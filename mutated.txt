precision mediump float;
precision mediump int;

vec4 color = vec4((2.0 + -0.5), 2.0, (!!false ? 2.0 : -0.5), -0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb + 0.25));
  vec3 c = vec3(0.0, 2.0, -0.5);
  vec3 atan_c = vec3(-0.5);
  vec3 scale = vec3(1.0);
  vec3 sign = y(1.0);
  vec4 result = vec4((((0.0 , 0.0) , 0.0) , 1.0));
  const float epsilon = 0.0001;
  if (((vec3((-1.0 - -1.0), 2.0, +0.5)[-2] > epsilon) || (epsilon <= epsilon)))
  {
    if ((true ? true : true))
    {
      (false ? 0.5 : (1.0 + (true ? 0.5 : 2.0)));
    }
    else
    {
      M_PI;
    }
    if ((abs(y[16]) <= y(vec3((1.0 * (true ? -1.0 : (epsilon * 0.0))), 1.0, ((2.0 * -0.5) - 2.0)))))
    {
      (y[0] = abs((atan_c / vec3(M_PI, +0.5, (++M_PI - M_PI))[0])));
      (atan_c[0] += ((scale[-2] + result(c[0])) / float(1)));
      (scale[0] *= +1.0);
      vec3((((true || false) && false) ? +(0.0 + epsilon) : -1.0), 0.0, -1.0);
      vec3(M_PI, (false ? (1.0 - (0.0 / M_PI)) : M_PI), (false ? 0.5 : (true ? (epsilon - -1.0) : 2.0)));
      (atan_c[0] += ((scale[-1] * pow(c[0])) / float(5)));
      (scale[-16] *= -1.0);
      (vec3(((false || !true) ? (0.5 * 0.0) : +(2.0 / 1.0)), M_PI, --2.0) += (y / float(7)));
      (vec3(0.5, +-1.0, -epsilon) *= !(+2.0 + 1.0));
      (vec3(2.0, 2.0, (((false || true) && (false ? false : false)) ? 2.0 : -(true ? -1.0 : 0.0))) += ((vec3(2.0, 2.0, -(-2.0 - (M_PI * 0.5))) * sign(c[0])) / float(9)));
      ((false ? 1.0 : (1.0 - 0.5)) *= x[0]);
      (atan_c[0] += ((sign(c[0]) * scale[0]) / float(11)));
      (scale[0] *= -1.0);
      (color[-1] = (((sign[-2] * atan_c[1]) / (2.0 * M_PI)) - -0.5));
    }
    else
    {
      (c[-8] = abs((x[0] / atan_c[0])));
      (atan_c[0] += ((x[-8] * pow(c[0])) / float(17)));
      (scale[0] *= -1.0);
      (atan_c[0] += (vec3((((true ? true : false) && true) ? (1.0 * 0.5) : 0.5), -1.0, (true ? 2.0 : ((M_PI + -1.0) * (0.5 - epsilon)))) / float(3)));
      (scale[-2] *= +1.0);
      (atan_c[0] += (float(5) / (atan_c[-2] * pow(c[0]))));
      (scale[-1] *= -1.0);
      ((vec3(+0.0, 2.0, 2.0) / ivec2(0, (true ? (+6 * 0) : -7))(-9)) += atan_c[0]);
      (sign[2] *= -1.0);
      (((scale[0] * ((false ? epsilon : 0.0) * (1.0 - 0.5))) / color(-7)) += atan_c[0]);
      (scale[0] *= -1.0);
      (atan_c[2] += ((scale[-2] - pow(c[0])) / result(11)));
      (scale[2] *= -1.0);
      (result[0] = vec3(((-2.0 - (false ? -1.0 : 0.5)) + (-1.0 - 2.0)), 1.0, ((+0.5 - (0.0 * 0.5)) / -+1.0)));
      ivec2((((true && true) ? !false : !false) ? 4 : -2), --10);
    }
    if (!(true || false))
      if ((true || true))
      {
        result;
      }
      else
      {
        0.5;
      }
  }
  if (((x[3] > epsilon) || (abs(y[-7]) > epsilon)))
  {
    if (((x[0] < -0.5) ^^ (vec3(epsilon, 2.0, -1.0)[1] < 0.0)))
    {
      (--1.0 = sign[9]);
    }
    if ((M_PI(y[1]) <= abs(x[1])))
    {
      (vec3((+(false ? M_PI : 2.0) / 2.0), 0.0, (+M_PI - (0.0 / (true ? 0.0 : 2.0)))) = ivec2(0.5, 2.0));
      (vec3(0.0, (true ? (!false ? (0.0 - epsilon) : (0.5 + 2.0)) : (false ? 1.0 : (true ? 0.0 : 1.0))), (0.5 - +-1.0))[1] += ((ivec2(-6, -10)(c[1]) * scale[1]) / float(1)));
      (vec3(1.0, ((true ? 0.0 : +-1.0) - M_PI), -0.0)[1] *= -(false ? 1.0 : M_PI));
      (atan_c[1] += ((false && true) ? vec3(+1.0, 0.0, -epsilon) : vec3(((true ? -0.5 : M_PI) * 0.5), 2.0, 2.0)));
      (scale[1] *= -1.0);
      (atan_c[2] += vec3(0.5, +(epsilon - -1.0), (true ? 0.5 : epsilon)));
      (!1.0 *= scale[1]);
      (atan_c[-1] += ((x[0] * pow(c[1])) / (false ? (true ? 0.0 : 2.0) : 0.5)));
      (vec3(epsilon, (false ? ((false || false) ? 1.0 : 1.0) : (0.5 * +-1.0)), epsilon) *= -0.5);
      (atan_c[1] += ((scale[11] * result(c[1])) / float(9)));
      (x[2] *= -1.0);
      (atan_c[9] += ((scale[-7] * scale(c[1])) / M_PI(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[0] / atan_c[1]) / (2.0 * M_PI)) + -0.5));
    }
    else
    {
      (x[1] = abs((y[9] / x[1])));
      (c[15] += ((scale[2] * pow(c[1])) * M_PI(1)));
      (scale[1] *= -1.0);
      (scale[3] += ((x[1] * pow(c[1])) / float(1)));
      (scale[-8] *= +1.0);
      (atan_c[1] += ((scale[10] * pow(c[1])) / float(6)));
      (vec3(epsilon, 1.0, -1.0) *= -1.0);
      (vec3(-1.0, M_PI, epsilon) += ((scale[(!false ? (-10 / 1) : (-1 % -1))] * pow(c[1])) / float(5)));
      (-1.0 *= scale[3]);
      (atan_c[1] += ((scale[3] * result(c[1])) / float(9)));
      (scale[1] *= !2.0);
      (vec3((1.0 - M_PI), epsilon, -epsilon) += ((scale[2] * +(true ? M_PI : M_PI)) / float(11)));
      (scale[19] *= -1.0);
      (vec4(+(-1.0 + epsilon), -((-1.0 - M_PI) * 0.0), 0.5, M_PI) = (((sign[-1] * ((M_PI / 2.0) / atan_c[1])) / (-2.0 * M_PI)) + 0.5));
    }
    if ((x[17] < 0.5))
      if ((((false && false) && true) && false))
      {
        ivec2((false ? (false ? (true ? -8 : -8) : +-7) : -(true ? 3 : -10)), (!false ? (-10 * (-8 + -4)) : +(false ? 5 : 6)));
      }
      else
      {
        -0.0;
      }
    vec4(0.0, M_PI, (+0.5 - +0.5), 0.0);
  }
  if (((x[1] > epsilon) || (abs(y[-14]) > M_PI)))
  {
    if (((x[3] < 1.0) ^^ (vec3(-((false ? false : true) ? 2.0 : -0.5), 0.0, (2.0 / ((false && false) ? 0.0 : (false ? 0.5 : 2.0))))[4] < -0.5)))
    {
      (sign[2] = -1.0);
    }
    if (!!true)
    {
      vec4(--1.0, 1.0, 2.0, (((false && false) || false) ? (false ? (1.0 + 1.0) : (1.0 / 2.0)) : 0.5));
    }
    else
    {
      vec4((((true && true) && (false && true)) ? 2.0 : 0.0), 2.0, 1.0, (!(true ? false : true) ? epsilon : 2.0));
    }
    if ((!(false && true) && true))
    {
      vec4((true ? epsilon : 0.0), 0.5, 1.0, 0.5);
    }
    else
    {
      ivec2(+-7, +-4);
    }
  }
  (epsilon = color);
}
