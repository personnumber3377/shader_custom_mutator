Mutations attempted: 0
Valid mutations:     0
Success rate:        0.00%
Processing this: /home/oof/webgl_cleaned/mat4_empty_out_mat4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(out mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_zeros) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(out mat4 par[2])
{
	set_all(par, mat_zeros);
	return mat_ones;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(out mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_zeros) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(out mat4 par[2])\n{\n\tset_all(par, mat_zeros);\n\treturn mat_ones;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = (gtf_Color.rg + 0.01) / 1.01;
	color = vec4(log(c) / -4.61, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (gtf_Color.rg + 0.01) / 1.01;\n\tcolor = vec4(log(c) / -4.61, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((-1.0 - 2.0), 2.0, ((true || !false) ? +(false ? 0.5 : 0.5) : -1.0), +1.0);

void main()
{
  vec2 c = ((gtf_Color.rg + 0.01) / 1.01);
  (color = vec4((log(c) / -4.61) , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
100.0
Processing this: /home/oof/webgl_cleaned/4b_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform bvec4 color;
varying vec4 col;
void main ()
{
	col = vec4(color);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform bvec4 color;\nvarying vec4 col;\nvoid main ()\n{\n\tcol = vec4(color);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform bvec4 color = bvec4(((1.0 * -1.0) * 1.0), -1.0, ++(0.5 - -1.0), 0.5);

vec4 col;

void main()
{
  (col = vec4(color));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '++' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform bvec4 color = bvec4(((1.0 * -1.0) * 1.0), -1.0, ++(0.5 - -1.0), 0.5);

vec4 col;

void main()
{
  (col = vec4(color));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/reflect_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  (v1.x = (cos(theta) * sin(phi)));
  (v1.y = (sin(theta) * sin(phi)));
  (v1.z = cos(phi));
  (color = vec4(((reflect(v1 , v2) + 1.0) / 2.0)));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  (v1.x = (cos(theta) * sin(phi)));
  (v1.y = (sin(theta) * sin(phi)));
  (v1.z = cos(phi));
  (color = vec4(((reflect(v1 , v2) + 1.0) / 2.0)));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
33.33333333333333
Processing this: /home/oof/webgl_cleaned/vec3_ps_t_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	float k = m.t;
	vec2 n = m.ps;
	vec4 a = vec4(n.t, k, n.s, al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tfloat k = m.t;\n\tvec2 n = m.ps;\n\tvec4 a = vec4(n.t, k, n.s, al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  float k = m.t;
  vec2 n = m.ps;
  vec4 a = vec4(n.t , k , n.s , al.q);
  (gl_FragColor = a);
}


As vertex? : False
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(1.0 / pow(vec2(2.0), 5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(1.0 / pow(vec2(2.0), 5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = color.rg;
  (vec4((1.0 / pow(vec2(2.0) , (5.0 * c))) , 0.0) = gl_FragColor);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = color.rg;
  (vec4((1.0 / pow(vec2(2.0) , (5.0 * c))) , 0.0) = gl_FragColor);
}


==============================
40.0
Processing this: /home/oof/webgl_cleaned/abs_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	if((c[0] < 0.0)) c[0] *= -1.0;
	if((c[1] < 0.0)) c[1] *= -1.0;
	if((c[2] < 0.0)) c[2] *= -1.0;
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tif((c[0] < 0.0)) c[0] *= -1.0;\n\tif((c[1] < 0.0)) c[1] *= -1.0;\n\tif((c[2] < 0.0)) c[2] *= -1.0;\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((1.0 - 2.0), -(0.0 + -1.0), -(-1.0 + -2.0), 0.0);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  if ((c[2] < 0.0))
    (c[2] *= -1.0);
  (gl_FragColor = vec4(c , 1.0));
}


As vertex? : False
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/refract_vec2_frag_ivarynconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	vec2 result;
	float eta = 0.5;
	float k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));
	if(k < 0.0)
		result = vec2(0.0);
	else
		result = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;
	gl_FragColor = vec4((result + 1.0) / 2.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tvec2 result;\n\tfloat eta = 0.5;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));\n\tif(k < 0.0)\n\t\tresult = vec2(0.0);\n\telse\n\t\tresult = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;\n\tgl_FragColor = vec4((result + 1.0) / 2.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  (v1.x = (cos(theta) * sin(phi)));
  (v1.y = (sin(theta) * sin(phi)));
  vec2 result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    (result = vec2(0.0));
  else
    (result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2)));
  (gl_FragColor = vec4(((result + 1.0) / 2.0) , 0.0 , 1.0));
  ivec2(((1 - 6) * (+0 + 6)), 3);
}


As vertex? : False
SUCCESS!
57.14285714285714
Processing this: /home/oof/webgl_cleaned/fract_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);
	c = abs((c - floor(c)) - 0.5) * 2.0;
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tc = abs((c - floor(c)) - 0.5) * 2.0;\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = ((true || (true || false)) ? vec4(-1.0, +((true ? false : true) ? 2.0 : (2.0 + 2.0)), +((true ? true : true) ? 2.0 : 0.5), +(--1.0 + (true ? -1.0 : 0.5))) : vec4(0.0, -1.0, -1.0, +2.0));

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  (c = (abs(((c - floor(c)) - 0.5)) * 2.0));
  (color = vec4(c , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = ((true || (true || false)) ? vec4(-1.0, +((true ? false : true) ? 2.0 : (2.0 + 2.0)), +((true ? true : true) ? 2.0 : 0.5), +(--1.0 + (true ? -1.0 : 0.5))) : vec4(0.0, -1.0, -1.0, +2.0));

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  (c = (abs(((c - floor(c)) - 0.5)) * 2.0));
  (color = vec4(c , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/not_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 _not(in bvec3 a)
{
	bvec3 result;
	if(a[0]) result[0] = false;
	else result[0] = true;
	if(a[1]) result[1] = false;
	else result[1] = true;
	if(a[2]) result[2] = false;
	else result[2] = true;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	gl_FragColor = vec4(vec3(_not(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 _not(in bvec3 a)\n{\n\tbvec3 result;\n\tif(a[0]) result[0] = false;\n\telse result[0] = true;\n\tif(a[1]) result[1] = false;\n\telse result[1] = true;\n\tif(a[2]) result[2] = false;\n\telse result[2] = true;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tgl_FragColor = vec4(vec3(_not(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, ((true || (true ? false : true)) ? 2.0 : 0.5), -1.0, 0.0);

bvec3 _not(in bvec3 a)
{
  bvec3 result;
  if (a[0])
    (result[0] = false);
  else
    (result[0] = true);
  if (a[1])
    (result[1] = false);
  else
    (result[1] = true);
  if (a[2])
    (result[2] = false);
  else
    (result[2] = true);
  return result;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  (gl_FragColor = vec4(vec3(_not(bvec3(c))) , 1.0));
}


As vertex? : False
SUCCESS!
55.55555555555556
Mutations attempted: 9
Valid mutations:     5
Success rate:        55.56%
Processing this: /home/oof/webgl_cleaned/log2_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 31.0 * color.r + 1.0;
	gl_FragColor = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 31.0 * color.r + 1.0;\n\tgl_FragColor = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct30486 {
  uint f_2202;
  int f_4681[3];
  mat3 f_6002[4];
  float f_5992;
};

vec4 color;

void main()
{
  float c = ((31.0 * color.r) + 1.0);
  (gl_FragColor = vec4(ivec2(+3, 5)));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:5: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct30486 {
  uint f_2202;
  int f_4681[3];
  mat3 f_6002[4];
  float f_5992;
};

vec4 color;

void main()
{
  float c = ((31.0 * color.r) + 1.0);
  (gl_FragColor = vec4(ivec2(+3, 5)));
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/fwidth_frag_ref_dx.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY = vec2((true ? 0.5 : ++0.0), -(!false ? +0.0 : (1.0 / -1.0)));

void main()
{
  (vertXY = gtf_Vertex.xy);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY = vec2((true ? 0.5 : ++0.0), -(!false ? +0.0 : (1.0 / -1.0)));

void main()
{
  (vertXY = gtf_Vertex.xy);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
45.45454545454545
Processing this: /home/oof/webgl_cleaned/buffer_objects_pointSize.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  (2.0 * +1.0);
}


As vertex? : False
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg * 99.0) + 1.0;
	gl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg * 99.0) + 1.0;\n\tgl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((+(false ? 0.0 : 2.0) / (true ? 0.0 : +-1.0)), ((!false ? (false ? 0.5 : 1.0) : 0.5) - (false ? +2.0 : 1.0)), (-1.0 - (0.0 * (1.0 * -1.0))), 2.0);

void main()
{
  vec2 c = ((color.rg * 99.0) + 1.0);
  (gl_FragColor = vec4((1.0 / sqrt(c)) , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
53.84615384615385
Processing this: /home/oof/webgl_cleaned/vec4_barg_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.barg;
	vec4 a = vec4(m.b, m.a, m.r, m.g);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.barg;\n\tvec4 a = vec4(m.b, m.a, m.r, m.g);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((false && (false || false)) ? (true ? --1.0 : (false ? 1.0 : 0.0)) : -1.0), 0.0, 2.0, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.barg;
  vec4 a = vec4(m.b , m.a , m.r , m.g);
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * a));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((false && (false || false)) ? (true ? --1.0 : (false ? 1.0 : 0.0)) : -1.0), 0.0, 2.0, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.barg;
  vec4 a = vec4(m.b , m.a , m.r , m.g);
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * a));
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/fract_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct34163 {
  ivec2 f_826[4];
  int f_9960;
  float f_6082;
  bvec3 f_6254;
};

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 0.5));
  (c = (abs((fract(c) - 0.5)) * 2.0));
  (gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
53.333333333333336
Processing this: /home/oof/webgl_cleaned/any_bvec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	color = vec4(vec3(any(bvec3(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tcolor = vec4(vec3(any(bvec3(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(1.0, 0.0, 0.5, 0.0);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  (color = vec4(vec3(any(bvec3(c))) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
56.25
Processing this: /home/oof/webgl_cleaned/vec3array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
uniform vec3 lightPosition[2];
void main()
{
    vec3 v[2];
    v[1] = vec3(gtf_Color.r, gtf_Color.g, gtf_Color.b);
    v[0] = lightPosition[1];
    color =  vec4(v[1] + v[1], 0.0)/2.0;
    gl_Position     = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nuniform vec3 lightPosition[2];\nvoid main()\n{\n    vec3 v[2];\n    v[1] = vec3(gtf_Color.r, gtf_Color.g, gtf_Color.b);\n    v[0] = lightPosition[1];\n    color =  vec4(v[1] + v[1], 0.0)/2.0;\n    gl_Position     = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 0.0, (((false ? 0.0 : 2.0) + 1.0) / +-1.0), (((true && true) ? 2.0 : -1.0) + -1.0));

uniform vec3 lightPosition[2];

void main()
{
  vec3 v[2];
  (v[1] = vec3(gtf_Color.r , gtf_Color.g , gtf_Color.b));
  (v[0] = lightPosition[1]);
  (color = (vec4((v[1] + v[1]) , 0.0) / 2.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
58.82352941176471
Processing this: /home/oof/webgl_cleaned/relational_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool lessthan  = (m<k);
	bool greaterthan = (m>k);
	bool lessthanorequalto = (m <= 102);
	bool greaterthanorequalto = (k >=12);
	float gray;
	if( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool lessthan  = (m<k);\n\tbool greaterthan = (m>k);\n\tbool lessthanorequalto = (m <= 102);\n\tbool greaterthanorequalto = (k >=12);\n\tfloat gray;\n\tif( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (k >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    (gray = 1.0);
  else
    (gray = 0.0);
  (color = vec4(gray , gray , gray , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
  vec4(0.0, -+0.0, 0.5, 0.0);
}


As vertex? : True
SUCCESS!
61.111111111111114
Processing this: /home/oof/webgl_cleaned/max_vec3_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 max_c = vec3(0.5, 0.5, 0.5);
	vec3 c = color.rgb;
	if(c[0] < max_c[0]) c[0] = max_c[0];
	if(c[1] < max_c[1]) c[1] = max_c[1];
	if(c[2] < max_c[2]) c[2] = max_c[2];
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 max_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = color.rgb;\n\tif(c[0] < max_c[0]) c[0] = max_c[0];\n\tif(c[1] < max_c[1]) c[1] = max_c[1];\n\tif(c[2] < max_c[2]) c[2] = max_c[2];\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 max_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = color.rgb;
  if ((c[0] < max_c[0]))
    (c[0] = max_c[0]);
  if ((c[1] < max_c[1]))
    (c[1] = max_c[1]);
  if ((c[2] < max_c[2]))
    (c[2] = max_c[2]);
  (gl_FragColor = vec4(c , 1.0));
}


As vertex? : False
SUCCESS!
63.1578947368421
Mutations attempted: 19
Valid mutations:     12
Success rate:        63.16%
Processing this: /home/oof/webgl_cleaned/vec2_2float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 a = vec2(13.0,53.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 a = vec2(13.0,53.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(+((0.0 - 2.0) * (true ? -1.0 : 1.0)), 0.5, 2.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 a = vec2(13.0 , 53.0);
  float gray;
  if (((a[0] == 13.0) && (a[1] == 53.0)))
    (gray = 1.0);
  else
    (gray = 0.0);
  (color = vec4(gray , gray , gray , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
65.0
Processing this: /home/oof/webgl_cleaned/sign_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(c * sign(c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(c * sign(c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = (2.0 * (color.r - 0.5));
  (gl_FragColor = vec4((c * sign(c)) , 0.0 , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/structnest_vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	vec4 b;
};
struct nesta
{
	vec4 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec4(11, 13, 17, 31), nestb(vec4(12, 19, 29, 69) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.a[3] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2] + s.nest_a.nest_b.b[3]) / 201.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tvec4 b;\n};\nstruct nesta\n{\n\tvec4 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec4(11, 13, 17, 31), nestb(vec4(12, 19, 29, 69) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.a[3] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2] + s.nest_a.nest_b.b[3]) / 201.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  vec4 b;
};

struct nesta {
  vec4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec4(11 , 13 , 17 , 31) , nestb(vec4(12 , 19 , 29 , 69))));
  (color = vec4(vec3(((((((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.a[2]) + s.nest_a.a[3]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) + s.nest_a.nest_b.b[2]) + s.nest_a.nest_b.b[3]) / 201.0)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
68.18181818181817
Processing this: /home/oof/webgl_cleaned/sign_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 2.0 * (gtf_Color.r - 0.5);
	color = vec4(c * sign(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(c * sign(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, -(!false ? +1.0 : (1.0 * 1.0)), ((false || true) ? ((true ? true : true) ? 2.0 : 0.5) : ((true && true) ? (2.0 / 0.0) : (false ? 2.0 : 0.0))), ((false ? 0.5 : -1.0) * (+1.0 / (false ? 0.5 : -1.0))));

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  (color = vec4((c * sign(c)) , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
69.56521739130434
Processing this: /home/oof/webgl_cleaned/structcopy_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	sabcd s2 = sabcd(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0 ) );
	s2 = s;
	gl_FragColor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.a[3] + s2.b[0] + s2.b[1] + s2.b[2] + s2.b[3]) / 250.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tsabcd s2 = sabcd(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0 ) );\n\ts2 = s;\n\tgl_FragColor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.a[3] + s2.b[0] + s2.b[1] + s2.b[2] + s2.b[3]) / 250.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, +0.5, -1.0, -(0.0 + -1.0));

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  sabcd s2 = sabcd(vec4(0.0 , 0.0 , 0.0 , 0.0) , vec4(0.0 , 0.0 , 0.0 , 0.0));
  (s2 = s);
  (gl_FragColor = vec4(vec3(((((((((s2.a[0] + s2.a[1]) + s2.a[2]) + s2.a[3]) + s2.b[0]) + s2.b[1]) + s2.b[2]) + s2.b[3]) / 250.0)) , 1.0));
}


As vertex? : False
SUCCESS!
70.83333333333334
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(min(c, min_c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(min(c, min_c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, -1.0, -0.5, ((true ? +0.0 : 0.5) / +(-1.0 * 2.0)));

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  (gl_FragColor = vec4(min(c , min_c) , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
72.0
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	gl_FragColor = vec4(mix(color.rg, y, a), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tgl_FragColor = vec4(mix(color.rg, y, a), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -1.0, -0.5, -1.0);

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  (gl_FragColor = vec4(mix(color.rg , y , a) , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
73.07692307692307
Processing this: /home/oof/webgl_cleaned/struct_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
 mat4 a;
};
void main ()
{
	sabcd s = sabcd(mat4(12.0, 29.0, 13.0, 26.0,
			     71.0, 63.0, 90.0, 118.0,
			     128.0, 44.0, 57.0, 143.0,
			     151.0, 14.0, 15.0, 21.0 ) );
	float sum=0.0;
	int i,j;
	sum = sum + s.a[0][0];
	sum = sum + s.a[0][1];
	sum = sum + s.a[0][2];
	sum = sum + s.a[0][3];
	sum = sum + s.a[1][0];
	sum = sum + s.a[1][1];
	sum = sum + s.a[1][2];
	sum = sum + s.a[1][3];
	sum = sum + s.a[2][0];
	sum = sum + s.a[2][1];
	sum = sum + s.a[2][2];
	sum = sum + s.a[2][3];
	sum = sum + s.a[3][0];
	sum = sum + s.a[3][1];
	sum = sum + s.a[3][2];
	sum = sum + s.a[3][3];
	gl_FragColor =  vec4( vec3(  sum / 995.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n mat4 a;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(mat4(12.0, 29.0, 13.0, 26.0,\n\t\t\t     71.0, 63.0, 90.0, 118.0,\n\t\t\t     128.0, 44.0, 57.0, 143.0,\n\t\t\t     151.0, 14.0, 15.0, 21.0 ) );\n\tfloat sum=0.0;\n\tint i,j;\n\tsum = sum + s.a[0][0];\n\tsum = sum + s.a[0][1];\n\tsum = sum + s.a[0][2];\n\tsum = sum + s.a[0][3];\n\tsum = sum + s.a[1][0];\n\tsum = sum + s.a[1][1];\n\tsum = sum + s.a[1][2];\n\tsum = sum + s.a[1][3];\n\tsum = sum + s.a[2][0];\n\tsum = sum + s.a[2][1];\n\tsum = sum + s.a[2][2];\n\tsum = sum + s.a[2][3];\n\tsum = sum + s.a[3][0];\n\tsum = sum + s.a[3][1];\n\tsum = sum + s.a[3][2];\n\tsum = sum + s.a[3][3];\n\tgl_FragColor =  vec4( vec3(  sum / 995.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

struct sabcd {
  mat4 a;
};

void main()
{
  sabcd s = sabcd(mat4(12.0 , 29.0 , 13.0 , 26.0 , 71.0 , 63.0 , 90.0 , 118.0 , 128.0 , 44.0 , 57.0 , 143.0 , 151.0 , 14.0 , 15.0 , 21.0));
  float sum = 0.0;
  int i, j;
  (sum = (sum + s.a[0][0]));
  (sum = (sum + s.a[0][1]));
  (sum = (sum + s.a[0][2]));
  (sum = (sum + s.a[0][3]));
  (sum = (sum + s.a[1][0]));
  (sum = (sum + s.a[1][1]));
  (sum = (sum + s.a[1][2]));
  (sum = (sum + s.a[1][3]));
  (sum = (sum + s.a[2][0]));
  (sum = (sum + s.a[2][1]));
  (sum = (sum + s.a[2][2]));
  (sum = (sum + s.a[2][3]));
  (sum = (sum + s.a[3][0]));
  (sum = (sum + s.a[3][1]));
  (sum = (sum + s.a[3][2]));
  (sum = (sum + s.a[3][3]));
  (gl_FragColor = vec4(vec3((sum / 995.0)) , 1.0));
}


As vertex? : False
SUCCESS!
74.07407407407408
Processing this: /home/oof/webgl_cleaned/tan_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	float o;
	if(abs(c) < 0.5)
		o = 0.5 * (sin(c) / cos(c)) + 0.5;
	else
		o = 0.5 * (cos(c) / sin(c)) + 0.5;
	color = vec4(o, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tfloat o;\n\tif(abs(c) < 0.5)\n\t\to = 0.5 * (sin(c) / cos(c)) + 0.5;\n\telse\n\t\to = 0.5 * (cos(c) / sin(c)) + 0.5;\n\tcolor = vec4(o, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  if ((abs(c) < 0.5))
    (o = ((0.5 * (sin(c) / cos(c))) + 0.5));
  else
    (o = ((0.5 * (cos(c) / sin(c))) + 0.5));
  (gl_Position = (gtf_Vertex - gtf_ModelViewProjectionMatrix));
  float o;
  float c = (((0.5 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  (color = vec4(o , 0.0 , 0.0 , 1.0));
  const float M_PI = 3.141592653589793;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'c' : undeclared identifier
ERROR: 0:15: 'o' : undeclared identifier
ERROR: 0:15: 'c' : undeclared identifier
ERROR: 0:15: 'c' : undeclared identifier
ERROR: 0:15: 'assign' : l-value required (can't modify a const)
ERROR: 0:17: 'o' : undeclared identifier
ERROR: 0:17: 'c' : undeclared identifier
ERROR: 0:17: 'c' : undeclared identifier
WARNING: 0:17: '/' : Divide by zero during constant folding
ERROR: 0:17: 'assign' : l-value required (can't modify a const)
ERROR: 0:18: '-' : wrong operand types - no operation '-' exists that takes a left-hand operand of type 'mediump 4-component vector of float' and a right operand of type 'uniform mediump 4X4 matrix of float' (or there is no acceptable conversion)
ERROR: 0:20: 'M_PI' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  if ((abs(c) < 0.5))
    (o = ((0.5 * (sin(c) / cos(c))) + 0.5));
  else
    (o = ((0.5 * (cos(c) / sin(c))) + 0.5));
  (gl_Position = (gtf_Vertex - gtf_ModelViewProjectionMatrix));
  float o;
  float c = (((0.5 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  (color = vec4(o , 0.0 , 0.0 , 1.0));
  const float M_PI = 3.141592653589793;
}


==============================
71.42857142857143
Processing this: /home/oof/webgl_cleaned/log_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 31.0 * color.rg + 1.0;
	gl_FragColor = vec4(log(c) / 3.466, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 31.0 * color.rg + 1.0;\n\tgl_FragColor = vec4(log(c) / 3.466, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = ((31.0 * color.rg) + 1.0);
  (0.5 = vec4(2.0, (false ? 0.5 : (+0.5 * 0.0)), ((true && false) ? +-0.0 : -1.0), 1.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = ((31.0 * color.rg) + 1.0);
  (0.5 = vec4(2.0, (false ? 0.5 : (+0.5 * 0.0)), ((true && false) ? +-0.0 : -1.0), 1.0));
}


==============================
68.96551724137932
Mutations attempted: 29
Valid mutations:     20
Success rate:        68.97%
Processing this: /home/oof/webgl_cleaned/equal_ivec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(equal(ivec3(c), ivec3(0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(equal(ivec3(c), ivec3(0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(1.0, (((true ? true : false) ? true : true) ? (!true ? (false ? 1.0 : 1.0) : 0.5) : -1.0), -1.0, (1.0 / 0.5));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(equal(ivec3(c) , ivec3(0)));
  (color = vec4(result , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
70.0
Processing this: /home/oof/webgl_cleaned/sin_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * gtf_Color.rgb;
	float sign = 1.0;
	vec3 sin_c = vec3(0.0);
	float fact;
	float fact_of;
	for(int i = 0; i < 12; i++)
	{
		fact = 1.0;
		for(int j = 2; j <= 23; j++)
			if (j <= 2 * i + 1)
				fact *= float(j);
		sin_c += sign * pow(c, vec3(2.0 * float(i) + 1.0)) / fact;
		sign *= -1.0;
	}
	color = vec4(0.5 * sin_c + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * gtf_Color.rgb;\n\tfloat sign = 1.0;\n\tvec3 sin_c = vec3(0.0);\n\tfloat fact;\n\tfloat fact_of;\n\tfor(int i = 0; i < 12; i++)\n\t{\n\t\tfact = 1.0;\n\t\tfor(int j = 2; j <= 23; j++)\n\t\t\tif (j <= 2 * i + 1)\n\t\t\t\tfact *= float(j);\n\t\tsin_c += sign * pow(c, vec3(2.0 * float(i) + 1.0)) / fact;\n\t\tsign *= -1.0;\n\t}\n\tcolor = vec4(0.5 * sin_c + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, ((true ? (true || true) : (false ? false : true)) ? (false ? (-1.0 + 1.0) : -2.0) : lerp(1.0, +0.5, -1.0)), +0.5, (((true || true) ? -1.0 : (0.0 - 0.0)) / +(1.0 - 2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  (sinValues[0] = 0.0);
  (sinValues[1] = 0.382683);
  (sinValues[2] = 0.707107);
  (sinValues[3] = 0.92388);
  (sinValues[4] = 1.0);
  (sinValues[5] = 0.92388);
  (sinValues[6] = 0.707107);
  (sinValues[7] = 0.382683);
  (sinValues[8] = 0.0);
  (sinValues[9] = -0.382683);
  (sinValues[10] = -0.707107);
  (sinValues[11] = -0.92388);
  (sinValues[12] = -1.0);
  (sinValues[13] = -0.923879);
  (sinValues[14] = -0.707107);
  (sinValues[15] = -0.382683);
  (sinValues[16] = 0.0);
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * gtf_Color.rgb);
  float sign = 1.0;
  vec3 sin_c = vec3(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    (fact = 1.0);
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec3(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  (color = vec4(((0.5 * sin_c) + 0.5) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'lerp' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, ((true ? (true || true) : (false ? false : true)) ? (false ? (-1.0 + 1.0) : -2.0) : lerp(1.0, +0.5, -1.0)), +0.5, (((true || true) ? -1.0 : (0.0 - 0.0)) / +(1.0 - 2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  (sinValues[0] = 0.0);
  (sinValues[1] = 0.382683);
  (sinValues[2] = 0.707107);
  (sinValues[3] = 0.92388);
  (sinValues[4] = 1.0);
  (sinValues[5] = 0.92388);
  (sinValues[6] = 0.707107);
  (sinValues[7] = 0.382683);
  (sinValues[8] = 0.0);
  (sinValues[9] = -0.382683);
  (sinValues[10] = -0.707107);
  (sinValues[11] = -0.92388);
  (sinValues[12] = -1.0);
  (sinValues[13] = -0.923879);
  (sinValues[14] = -0.707107);
  (sinValues[15] = -0.382683);
  (sinValues[16] = 0.0);
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * gtf_Color.rgb);
  float sign = 1.0;
  vec3 sin_c = vec3(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    (fact = 1.0);
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec3(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  (color = vec4(((0.5 * sin_c) + 0.5) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
67.74193548387096
Processing this: /home/oof/webgl_cleaned/buffer_objects_pointSize.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute float gtf_PointSize;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
	gl_PointSize = gtf_PointSize;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute float gtf_PointSize;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n\tgl_PointSize = gtf_PointSize;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(+gtf_PointSize, (-(true ? 1.0 : 1.0) + 0.5), (((false ? true : false) ? 1.0 : (1.0 * -1.0)) + ((true && false) ? (-1.0 - 0.0) : -2.0)), (2.0 + ((true ? 1.0 : 2.0) * 2.0)));

float gtf_PointSize;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
  (gl_PointSize = gtf_PointSize);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_PointSize' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(+gtf_PointSize, (-(true ? 1.0 : 1.0) + 0.5), (((false ? true : false) ? 1.0 : (1.0 * -1.0)) + ((true && false) ? (-1.0 - 0.0) : -2.0)), (2.0 + ((true ? 1.0 : 2.0) * 2.0)));

float gtf_PointSize;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
  (gl_PointSize = gtf_PointSize);
}


==============================
65.625
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 4.0 * (gtf_Color.r);
	color = vec4(c * c / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 4.0 * (gtf_Color.r);\n\tcolor = vec4(c * c / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, 0.0, -1.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (4.0 * gtf_Color.r);
  (color = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/gl_FragCoord_z_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
	gl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n\tgl_FragColor = vec4(vec3(gl_FragCoord.z), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  (gl_FragColor = vec4(vec3(gl_FragCoord.z)));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  (gl_FragColor = vec4(vec3(gl_FragCoord.z)));
}


==============================
64.70588235294117
Processing this: /home/oof/webgl_cleaned/bool_empty_inout_bool_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(inout bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(!par && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(inout bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(inout bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(!par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(inout bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
64.70588235294117
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
64.70588235294117
Processing this: /home/oof/webgl_cleaned/vec3_grb_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec3 t = m.grb;
	vec4 a = vec4(t.g, t.r, t.b, lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec3 t = m.grb;\n\tvec4 a = vec4(t.g, t.r, t.b, lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec3 t = m.grb;
  vec4 a = vec4(t.g , t.r , t.b , lightloc.a);
  (color = gtf_Color);
  (ivec2((!(false ? true : true) ? 9 : (!true ? (true ? 7 : 9) : 9)), -5) = (mat4(-1.0, (1.0 / 1.0), -0.0, ((!true ? 2.0 : (true ? 0.5 : 1.0)) - -1.0), ++(false ? 1.0 : 0.0), -1.0, (-+-1.0 * (false ? 0.5 : (2.0 * 2.0))), -0.5, ((!false ? -2.0 : 1.0) / +1.0), 2.0, 0.0, 0.0, ((false ? 0.5 : 2.0) + (false ? (-1.0 + 0.0) : (false ? 0.0 : 0.0))), 1.0, ((false ? (false && true) : (false ? false : false)) ? (true ? 2.0 : 1.0) : -1.0), -1.0) * a));
  ivec2(1, +((true && false) ? +0 : +9));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:19: '++' : l-value required (can't modify a const)
ERROR: 0:19: 'assign' : l-value required (can't modify a const)
ERROR: 0:19: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const 2-component vector of int'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec3 t = m.grb;
  vec4 a = vec4(t.g , t.r , t.b , lightloc.a);
  (color = gtf_Color);
  (ivec2((!(false ? true : true) ? 9 : (!true ? (true ? 7 : 9) : 9)), -5) = (mat4(-1.0, (1.0 / 1.0), -0.0, ((!true ? 2.0 : (true ? 0.5 : 1.0)) - -1.0), ++(false ? 1.0 : 0.0), -1.0, (-+-1.0 * (false ? 0.5 : (2.0 * 2.0))), -0.5, ((!false ? -2.0 : 1.0) / +1.0), 2.0, 0.0, 0.0, ((false ? 0.5 : 2.0) + (false ? (-1.0 + 0.0) : (false ? 0.0 : 0.0))), 1.0, ((false ? (false && true) : (false ? false : false)) ? (true ? 2.0 : 1.0) : -1.0), -1.0) * a));
  ivec2(1, +((true && false) ? +0 : +9));
}


==============================
62.857142857142854
Processing this: /home/oof/webgl_cleaned/CorrectConstFolding2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    struct s5 {
    float k;
    };
    const struct s {
        int i;
    	float j;
      s5 s55;
    } ss = s(4,1.0, s5(1.0));
   const struct s2 {
       int i;
       vec3 v3;
       bvec4 bv4;
   } s22  = s2(8, vec3(9, 10, 11), bvec4(true, false, true, false));
  struct s4 {
          int ii;
          vec4 v4;
      };
   const struct s1 {
      s2 ss;
      int i;
      float f;
      mat4 m;
      s4 s44;
     } s11 = s1(s22, 2, 4.0, mat4(5), s4(6, vec4(7, 8, 9, 10))) ;
   const struct s7 {
       int i;
       mat3 m3;
   } s77 = s7(12, mat3(15));
  vec2       v21 = vec2(1);
  const vec2 v22 = vec2(11);
  const vec4 v41 = vec4(2);
  const vec4 v43 = vec4(4,4,4,4);
  const vec4 v44 = vec4(5.0, 5.0, 5.0, 5.0);
  const vec4 v45 = vec4(v22, v22);
  const vec4 v46 = vec4(vec2(20, 21), vec2(22, 23));
  const vec3 v31 = vec3(s22.v3);
  const vec3 v32 = vec3(s77.m3);
  const vec3 v33 = vec3(s77.m3[2]);
  const vec3 v34 = vec3(s77.m3[2][0]);
  const mat4 m41 = mat4(1);
  const mat4 m42 = mat4(v44, v44, v44, v44);
  const mat4 m43 = mat4( v43.x);
  const vec4 v47 = vec4(m41[0][0]);
  const mat4 m45 = mat4(s22.v3, v44, v45, v32, 50, 52);
  const vec4 v48 = vec4(v31[0], v22[1], v41[0], v43[3]);
  const vec4 v49 = vec4(s22.v3.xy, s22.v3.zx);
  const vec4 v410 = vec4(v44.xy, v43.zx);
  const vec4 v411 = vec4(m42[3]);
  const vec4 v412 = vec4(m43[2]);
  const vec2 v23 = vec2(m41);
  const vec2 v24 = vec2(33, s11.i);
  const vec4 v413 = vec4(vec2(1.0,2.0),ivec2(3.0,4.0));
  const ivec4 i41 = ivec4(1.0, 2.0, 3.0, 4.0);
  const ivec4 i42 = ivec4(6);
  const ivec4 i43 = ivec4(v45);
  const ivec4 i44 = ivec4(v44[0]);
  const ivec4 i45 = ivec4(vec2(20, 21), vec2(22, 23));
  const vec4 v414 = vec4(ivec2(29, 30), ivec2(31, 32));
  const ivec4 i46 = ivec4(ivec2(2.0,3.0), ivec3(4.0,5.0,6.0));
  const ivec4 i47 = ivec4(i46);
  const ivec4 i48 = ivec4(v414.x);
  const ivec4 i49 = ivec4(vec4(1));
  const ivec4 i414 = ivec4(mat4(14));
  const ivec4 i410 = ivec4(m43);
  const ivec4 i411 = ivec4(m43[1]);
  const ivec4 i412 = ivec4(s77.i);
  const ivec4 i416 = ivec4(s22.v3.zyx, 12);
  const vec4 v415 = vec4(ivec2(35), ivec2(36));
  const bvec4 b41 = bvec4(1.0, 2.0, 3.0, 4.0);
  const bvec4 b42 = bvec4(6);
  const bvec4 b43 = bvec4(v45);
  const bvec4 b44 = bvec4(v44[0]);
  const bvec4 b45 = bvec4(vec2(0, 21), vec2(0, 1));
  const bvec4 b46 = bvec4(ivec2(0.0,3.0), ivec3(0,5.0,6.0));
  const bvec4 b47 = bvec4(i46);
  const bvec4 b48 = bvec4(v414.x);
  const bvec4 b49 = bvec4(vec4(0));
  const bvec4 b414 = bvec4(mat4(14));
  const bvec4 b410 = bvec4(m43);
  const bvec4 b411 = bvec4(m43[1]);
  const bvec4 b412 = bvec4(s77.i) ;
  const vec3 v35 = vec3(s11.s44.v4);
  struct s10 {
     int k;
  };
  struct s9 {
       float f;
      s10 s101;
   };
  const struct s8 {
      int i;
      s9 s99;
  } s88 = s8(1, s9(2.0, s10(5)));
   struct st4 {
       int m;
       vec3 v3;
   };
   struct st3 {
      int k;
      int l;
      st4 st44;
     };
   struct st2 {
       float f;
       st3 st33;
  };
  const struct st1 {
      int i;
      st2 st22;
  } st11 = st1(1, st2(2.0, st3(5, 6, st4(7, v35))));
  const vec4 v416 = vec4(s88.s99.s101.k);
  const vec4 v417 = vec4(st11.st22.st33.st44.v3, s88.s99.s101.k);
  const vec3 v36 = vec3(s11.ss.v3);
  vec4 v418 = v416;
  const float f1 = v416[0];
  vec4 v419;
  v419.xyz = st11.st22.st33.st44.v3;
  mat4 m47;
  struct struct2 {
      int k;
  } struct22 = struct2(4);
  const struct struct1 {
       struct2 sst2;
  } struct11 = struct1(struct2(2));
  const vec4 v420 = v417;
  vec4 v421 = vec4(s11.m);
  vec4 v422 = v420;
  vec4 v423 = s11.s44.v4;
  int int1 = ss.i * ss.i;
  int int2 = ss.i * 2;
  const vec4 v425 = v420 * v420;
  const vec4 v426 = s11.m * s11.s44.v4;
  const vec4 v427 = s11.s44.v4 * s11.m;
  float ff = 2.0;
  const float ffConst = 2.0;
  vec4 v428 = ff + v425;
  vec3 v39 = vec3(5);
  vec3 v310 = s22.v3 + v39;
  const vec4 v429 = v420 + v420;
  const vec4 v430 = v420 + ffConst;
  const vec4 v432 =  v429 + s11.f;
  const vec4 v433 = vec4(s11.f + s11.f);
  const vec4 v434 = v432 + vec4(3);
  const mat4 m48 = s11.m + ffConst;
  const mat4 m49 = mat4(ffConst + s11.f);
  const mat4 m410 = m48 + s11.f;
  const mat4 m413 = m48 + m48 ;
  const mat4 m414 = m413 + ffConst ;
  const vec4 v435 = ffConst + v420;
  const vec4 v436 =  s11.f + v429;
  const mat4 m415 = ffConst + s11.m;
  const mat4 m416 = s11.f + m48 ;
  const mat4 m417 = ffConst + m413 ;
  const vec4 v437 = v420 - v420;
  const vec4 v438 = v420 - ffConst;
  const vec4 v440 =  v429 - s11.f;
  const vec4 v441 = vec4(s11.f - s11.f);
  const vec4 v442 = v432 - vec4(3);
  const mat4 m418 = s11.m - ffConst;
  const mat4 m419 = mat4(ffConst - s11.f);
  const mat4 m420 = m48 - s11.f;
  const mat4 m423 = m48 - m48 ;
  const mat4 m424 = m413 - ffConst ;
  const vec4 v443 = ffConst - v420;
  const vec4 v444 =  s11.f - v429;
  const mat4 m425 = ffConst - s11.m;
  const mat4 m426 = s11.f - m48 ;
  const mat4 m427 = ffConst - m413 ;
  const vec4 v445 = v420 * v420;
  const vec4 v446 = v420 * ffConst;
  const vec4 v448 =  v429 * s11.f;
  const vec4 v449 = vec4(s11.f * s11.f);
  const vec4 v450 = v432 * vec4(3);
  const mat4 m428 = s11.m * ffConst;
  const mat4 m429 = mat4(ffConst * s11.f);
  const mat4 m430 = m48 * s11.f;
  const mat4 m433 = m48 * m48 ;
  const mat4 m434 = m413 * ffConst ;
  const vec4 v451 = ffConst * v420;
  const vec4 v452 =  s11.f * v429;
  const mat4 m435 = ffConst * s11.m;
  const mat4 m436 = s11.f * m48 ;
  const mat4 m437 = ffConst * m413 ;
  const vec4 v453 = v420 / v420;
  const vec4 v454 = v420 / ffConst;
  const vec4 v457 = vec4(s11.f / s11.f);
  const vec4 v458 = v432 / vec4(3);
  const mat4 m438 = s11.m / ffConst;
  const mat4 m439 = mat4(ffConst / s11.f);
  const mat4 m440 = m48 / s11.f;
  const mat4 m443 = m48 / m48 ;
  const mat4 m444 = m413 / ffConst ;
  const vec4 v459 = ffConst / v420;
  const vec4 v460 =  s11.f / v429;
  const mat4 m446 = s11.f / m48 ;
  const mat4 m447 = ffConst / m413 ;
  const vec4 v461 = v453 * m428;
  const vec4 v462 = v453 * m437;
  const vec4 v463 = m428 * v451;
  const vec4 v464 = m437 * v451;
  int ii = 2;
  const int iiConst = 2;
  const ivec4 i420 = ivec4( 7,8,9,5);
  const ivec4 i429 = i420 + i420;
  const ivec4 i430 = i420 + iiConst;
  const ivec4 i432 =  i429 + ss.i;
  const ivec4 i433 = ivec4(ss.i + ss.i);
  const ivec4 i435 = iiConst + i420;
  const ivec4 i436 =  ss.i + i429;
  const ivec4 i437 = i420 - i420;
  const ivec4 i438 = i420 - iiConst;
  const ivec4 i440 =  i429 - ss.i;
  const ivec4 i441 = ivec4(ss.i - ss.i);
  const ivec4 i443 = iiConst - i420;
  const ivec4 i444 =  ss.i - i429;
  const ivec4 i445 = i420 * i420;
  const ivec4 i446 = i420 * iiConst;
  const ivec4 i448 =  i429 * ss.i;
  const ivec4 i449 = ivec4(ss.i * ss.i);
  const ivec4 i451 = iiConst * i420;
  const ivec4 i452 =  ss.i * i429;
  const ivec4 i453 = i420 / i420;
  const ivec4 i454 = i420 / iiConst;
  const ivec4 i456 =  i429 / ss.i;
  const ivec4 i457 = ivec4(ss.i / ss.i);
  const ivec4 i459 = iiConst / i420;
  const ivec4 i460 =  ss.i / i429;
  const bvec4 b424 = bvec4(s22.bv4);
  const bool b1 = s22.bv4 == b424;
  const bool b2 = i420 == i420;
  const bool b3 = i420 == i445;
  const bool b4 = v420 == v420;
  const bool b5 = m430 == m434;
  const vec4 v465 = -v420;
  const mat4 m448 = -m447 ;
  const ivec4 i465 = -i456 ;
  const bool b7 = s22 == s22;
  const vec4 v466 = v432 + vec4(3,4,5,6);
  const vec4 v467 = v432 + vec4(vec2(3,4),5,6);
  const vec4 v468 = v432 + vec4(3, vec2(4, 5),vec2(6,7));
  const vec4 v469 = vec4(v468) + vec4(3) + v468 + vec4(s77.m3[2][0]);
  const bool b8 = ss == ss;
  struct st6 {
       vec3 v;
  };
  struct st5 {
      int i;
      float f;
      st6  st66;
  } st55;
  const st5 st551 = st5(2, 4.0, st6(vec3(7)));
  const st5 st552 = st5(2, 4.0, st6(vec3(7)));
  const bool b10 = st551 == st552;
  const bool b11 = st551.st66 == st552.st66;
  const st5 st553 = st5(2, 4.0, st6(vec3(8)));
  const bool b12 = st551.st66 == st553.st66;
  const bool b13 = st551 == st553;
  const bool b14 = st551 != st552;
  const bool b15 = st551.st66 != st552.st66;
  const bool b16 = st551.st66 != st553.st66;
  const bool b17 = st551 != st553;
  const bool b18 = s22.bv4 != b424;
  const bool b19 = i420 != i420;
  const bool b20 = i420 != i445;
  const bool b21 = v420 != v420;
  const bool b22 = m430 != m434;
  const int int10 = i420.xy.y;
  const int int13 = -ss.i;
  const vec4 v474 = -vec4(0.5);
  int int14 = ii++;
  int array[3];
  array[2];
  const vec4 v478 = v466 * 2.0;
  const vec4 v479 = iiConst > 1 ? v466 : v478;
  const struct st7 {
       int i;
       bool b;
  } st77 = st7(ss.i, true);
  const vec4 v481 = vec4(st77.i);
  const struct st8 {
      int i;
  } ;
  const struct st9 {
      s2 ss;
  } st99 = st9(s22);
  const vec3 v312 = st99.ss.v3;
  const vec4 v482 = mat4(1)[0];
  const mat4 m450 = mat4(ss.i);
  const mat4 m451 = mat4(b20);
  const mat4 m452 = mat4(st77.b);
  const vec4 v483 = vec4(vec4(3).x);
  const mat4 m453 = mat4(vec4(5).x);
  const vec4 v484 = vec4(mat4(6)[1]);
  const mat4 m454 = mat4(mat4(6)[1][1]);
  const vec4 v485 = vec4(st7(8, true).b);
  const vec4 v487 = vec4(vec4(12, 13, 14, 15).ab, 12, 14);
  int i20 = ss.i;
  const vec4 v489 = -vec4(7,8,9,5);
  gl_Position = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    struct s5 {\n    float k;\n    };\n    const struct s {\n        int i;\n    \tfloat j;\n      s5 s55;\n    } ss = s(4,1.0, s5(1.0));\n   const struct s2 {\n       int i;\n       vec3 v3;\n       bvec4 bv4;\n   } s22  = s2(8, vec3(9, 10, 11), bvec4(true, false, true, false));\n  struct s4 {\n          int ii;\n          vec4 v4;\n      };\n   const struct s1 {\n      s2 ss;\n      int i;\n      float f;\n      mat4 m;\n      s4 s44;\n     } s11 = s1(s22, 2, 4.0, mat4(5), s4(6, vec4(7, 8, 9, 10))) ;\n   const struct s7 {\n       int i;\n       mat3 m3;\n   } s77 = s7(12, mat3(15));\n  vec2       v21 = vec2(1);\n  const vec2 v22 = vec2(11);\n  const vec4 v41 = vec4(2);\n  const vec4 v43 = vec4(4,4,4,4);\n  const vec4 v44 = vec4(5.0, 5.0, 5.0, 5.0);\n  const vec4 v45 = vec4(v22, v22);\n  const vec4 v46 = vec4(vec2(20, 21), vec2(22, 23));\n  const vec3 v31 = vec3(s22.v3);\n  const vec3 v32 = vec3(s77.m3);\n  const vec3 v33 = vec3(s77.m3[2]);\n  const vec3 v34 = vec3(s77.m3[2][0]);\n  const mat4 m41 = mat4(1);\n  const mat4 m42 = mat4(v44, v44, v44, v44);\n  const mat4 m43 = mat4( v43.x);\n  const vec4 v47 = vec4(m41[0][0]);\n  const mat4 m45 = mat4(s22.v3, v44, v45, v32, 50, 52);\n  const vec4 v48 = vec4(v31[0], v22[1], v41[0], v43[3]);\n  const vec4 v49 = vec4(s22.v3.xy, s22.v3.zx);\n  const vec4 v410 = vec4(v44.xy, v43.zx);\n  const vec4 v411 = vec4(m42[3]);\n  const vec4 v412 = vec4(m43[2]);\n  const vec2 v23 = vec2(m41);\n  const vec2 v24 = vec2(33, s11.i);\n  const vec4 v413 = vec4(vec2(1.0,2.0),ivec2(3.0,4.0));\n  const ivec4 i41 = ivec4(1.0, 2.0, 3.0, 4.0);\n  const ivec4 i42 = ivec4(6);\n  const ivec4 i43 = ivec4(v45);\n  const ivec4 i44 = ivec4(v44[0]);\n  const ivec4 i45 = ivec4(vec2(20, 21), vec2(22, 23));\n  const vec4 v414 = vec4(ivec2(29, 30), ivec2(31, 32));\n  const ivec4 i46 = ivec4(ivec2(2.0,3.0), ivec3(4.0,5.0,6.0));\n  const ivec4 i47 = ivec4(i46);\n  const ivec4 i48 = ivec4(v414.x);\n  const ivec4 i49 = ivec4(vec4(1));\n  const ivec4 i414 = ivec4(mat4(14));\n  const ivec4 i410 = ivec4(m43);\n  const ivec4 i411 = ivec4(m43[1]);\n  const ivec4 i412 = ivec4(s77.i);\n  const ivec4 i416 = ivec4(s22.v3.zyx, 12);\n  const vec4 v415 = vec4(ivec2(35), ivec2(36));\n  const bvec4 b41 = bvec4(1.0, 2.0, 3.0, 4.0);\n  const bvec4 b42 = bvec4(6);\n  const bvec4 b43 = bvec4(v45);\n  const bvec4 b44 = bvec4(v44[0]);\n  const bvec4 b45 = bvec4(vec2(0, 21), vec2(0, 1));\n  const bvec4 b46 = bvec4(ivec2(0.0,3.0), ivec3(0,5.0,6.0));\n  const bvec4 b47 = bvec4(i46);\n  const bvec4 b48 = bvec4(v414.x);\n  const bvec4 b49 = bvec4(vec4(0));\n  const bvec4 b414 = bvec4(mat4(14));\n  const bvec4 b410 = bvec4(m43);\n  const bvec4 b411 = bvec4(m43[1]);\n  const bvec4 b412 = bvec4(s77.i) ;\n  const vec3 v35 = vec3(s11.s44.v4);\n  struct s10 {\n     int k;\n  };\n  struct s9 {\n       float f;\n      s10 s101;\n   };\n  const struct s8 {\n      int i;\n      s9 s99;\n  } s88 = s8(1, s9(2.0, s10(5)));\n   struct st4 {\n       int m;\n       vec3 v3;\n   };\n   struct st3 {\n      int k;\n      int l;\n      st4 st44;\n     };\n   struct st2 {\n       float f;\n       st3 st33;\n  };\n  const struct st1 {\n      int i;\n      st2 st22;\n  } st11 = st1(1, st2(2.0, st3(5, 6, st4(7, v35))));\n  const vec4 v416 = vec4(s88.s99.s101.k);\n  const vec4 v417 = vec4(st11.st22.st33.st44.v3, s88.s99.s101.k);\n  const vec3 v36 = vec3(s11.ss.v3);\n  vec4 v418 = v416;\n  const float f1 = v416[0];\n  vec4 v419;\n  v419.xyz = st11.st22.st33.st44.v3;\n  mat4 m47;\n  struct struct2 {\n      int k;\n  } struct22 = struct2(4);\n  const struct struct1 {\n       struct2 sst2;\n  } struct11 = struct1(struct2(2));\n  const vec4 v420 = v417;\n  vec4 v421 = vec4(s11.m);\n  vec4 v422 = v420;\n  vec4 v423 = s11.s44.v4;\n  int int1 = ss.i * ss.i;\n  int int2 = ss.i * 2;\n  const vec4 v425 = v420 * v420;\n  const vec4 v426 = s11.m * s11.s44.v4;\n  const vec4 v427 = s11.s44.v4 * s11.m;\n  float ff = 2.0;\n  const float ffConst = 2.0;\n  vec4 v428 = ff + v425;\n  vec3 v39 = vec3(5);\n  vec3 v310 = s22.v3 + v39;\n  const vec4 v429 = v420 + v420;\n  const vec4 v430 = v420 + ffConst;\n  const vec4 v432 =  v429 + s11.f;\n  const vec4 v433 = vec4(s11.f + s11.f);\n  const vec4 v434 = v432 + vec4(3);\n  const mat4 m48 = s11.m + ffConst;\n  const mat4 m49 = mat4(ffConst + s11.f);\n  const mat4 m410 = m48 + s11.f;\n  const mat4 m413 = m48 + m48 ;\n  const mat4 m414 = m413 + ffConst ;\n  const vec4 v435 = ffConst + v420;\n  const vec4 v436 =  s11.f + v429;\n  const mat4 m415 = ffConst + s11.m;\n  const mat4 m416 = s11.f + m48 ;\n  const mat4 m417 = ffConst + m413 ;\n  const vec4 v437 = v420 - v420;\n  const vec4 v438 = v420 - ffConst;\n  const vec4 v440 =  v429 - s11.f;\n  const vec4 v441 = vec4(s11.f - s11.f);\n  const vec4 v442 = v432 - vec4(3);\n  const mat4 m418 = s11.m - ffConst;\n  const mat4 m419 = mat4(ffConst - s11.f);\n  const mat4 m420 = m48 - s11.f;\n  const mat4 m423 = m48 - m48 ;\n  const mat4 m424 = m413 - ffConst ;\n  const vec4 v443 = ffConst - v420;\n  const vec4 v444 =  s11.f - v429;\n  const mat4 m425 = ffConst - s11.m;\n  const mat4 m426 = s11.f - m48 ;\n  const mat4 m427 = ffConst - m413 ;\n  const vec4 v445 = v420 * v420;\n  const vec4 v446 = v420 * ffConst;\n  const vec4 v448 =  v429 * s11.f;\n  const vec4 v449 = vec4(s11.f * s11.f);\n  const vec4 v450 = v432 * vec4(3);\n  const mat4 m428 = s11.m * ffConst;\n  const mat4 m429 = mat4(ffConst * s11.f);\n  const mat4 m430 = m48 * s11.f;\n  const mat4 m433 = m48 * m48 ;\n  const mat4 m434 = m413 * ffConst ;\n  const vec4 v451 = ffConst * v420;\n  const vec4 v452 =  s11.f * v429;\n  const mat4 m435 = ffConst * s11.m;\n  const mat4 m436 = s11.f * m48 ;\n  const mat4 m437 = ffConst * m413 ;\n  const vec4 v453 = v420 / v420;\n  const vec4 v454 = v420 / ffConst;\n  const vec4 v457 = vec4(s11.f / s11.f);\n  const vec4 v458 = v432 / vec4(3);\n  const mat4 m438 = s11.m / ffConst;\n  const mat4 m439 = mat4(ffConst / s11.f);\n  const mat4 m440 = m48 / s11.f;\n  const mat4 m443 = m48 / m48 ;\n  const mat4 m444 = m413 / ffConst ;\n  const vec4 v459 = ffConst / v420;\n  const vec4 v460 =  s11.f / v429;\n  const mat4 m446 = s11.f / m48 ;\n  const mat4 m447 = ffConst / m413 ;\n  const vec4 v461 = v453 * m428;\n  const vec4 v462 = v453 * m437;\n  const vec4 v463 = m428 * v451;\n  const vec4 v464 = m437 * v451;\n  int ii = 2;\n  const int iiConst = 2;\n  const ivec4 i420 = ivec4( 7,8,9,5);\n  const ivec4 i429 = i420 + i420;\n  const ivec4 i430 = i420 + iiConst;\n  const ivec4 i432 =  i429 + ss.i;\n  const ivec4 i433 = ivec4(ss.i + ss.i);\n  const ivec4 i435 = iiConst + i420;\n  const ivec4 i436 =  ss.i + i429;\n  const ivec4 i437 = i420 - i420;\n  const ivec4 i438 = i420 - iiConst;\n  const ivec4 i440 =  i429 - ss.i;\n  const ivec4 i441 = ivec4(ss.i - ss.i);\n  const ivec4 i443 = iiConst - i420;\n  const ivec4 i444 =  ss.i - i429;\n  const ivec4 i445 = i420 * i420;\n  const ivec4 i446 = i420 * iiConst;\n  const ivec4 i448 =  i429 * ss.i;\n  const ivec4 i449 = ivec4(ss.i * ss.i);\n  const ivec4 i451 = iiConst * i420;\n  const ivec4 i452 =  ss.i * i429;\n  const ivec4 i453 = i420 / i420;\n  const ivec4 i454 = i420 / iiConst;\n  const ivec4 i456 =  i429 / ss.i;\n  const ivec4 i457 = ivec4(ss.i / ss.i);\n  const ivec4 i459 = iiConst / i420;\n  const ivec4 i460 =  ss.i / i429;\n  const bvec4 b424 = bvec4(s22.bv4);\n  const bool b1 = s22.bv4 == b424;\n  const bool b2 = i420 == i420;\n  const bool b3 = i420 == i445;\n  const bool b4 = v420 == v420;\n  const bool b5 = m430 == m434;\n  const vec4 v465 = -v420;\n  const mat4 m448 = -m447 ;\n  const ivec4 i465 = -i456 ;\n  const bool b7 = s22 == s22;\n  const vec4 v466 = v432 + vec4(3,4,5,6);\n  const vec4 v467 = v432 + vec4(vec2(3,4),5,6);\n  const vec4 v468 = v432 + vec4(3, vec2(4, 5),vec2(6,7));\n  const vec4 v469 = vec4(v468) + vec4(3) + v468 + vec4(s77.m3[2][0]);\n  const bool b8 = ss == ss;\n  struct st6 {\n       vec3 v;\n  };\n  struct st5 {\n      int i;\n      float f;\n      st6  st66;\n  } st55;\n  const st5 st551 = st5(2, 4.0, st6(vec3(7)));\n  const st5 st552 = st5(2, 4.0, st6(vec3(7)));\n  const bool b10 = st551 == st552;\n  const bool b11 = st551.st66 == st552.st66;\n  const st5 st553 = st5(2, 4.0, st6(vec3(8)));\n  const bool b12 = st551.st66 == st553.st66;\n  const bool b13 = st551 == st553;\n  const bool b14 = st551 != st552;\n  const bool b15 = st551.st66 != st552.st66;\n  const bool b16 = st551.st66 != st553.st66;\n  const bool b17 = st551 != st553;\n  const bool b18 = s22.bv4 != b424;\n  const bool b19 = i420 != i420;\n  const bool b20 = i420 != i445;\n  const bool b21 = v420 != v420;\n  const bool b22 = m430 != m434;\n  const int int10 = i420.xy.y;\n  const int int13 = -ss.i;\n  const vec4 v474 = -vec4(0.5);\n  int int14 = ii++;\n  int array[3];\n  array[2];\n  const vec4 v478 = v466 * 2.0;\n  const vec4 v479 = iiConst > 1 ? v466 : v478;\n  const struct st7 {\n       int i;\n       bool b;\n  } st77 = st7(ss.i, true);\n  const vec4 v481 = vec4(st77.i);\n  const struct st8 {\n      int i;\n  } ;\n  const struct st9 {\n      s2 ss;\n  } st99 = st9(s22);\n  const vec3 v312 = st99.ss.v3;\n  const vec4 v482 = mat4(1)[0];\n  const mat4 m450 = mat4(ss.i);\n  const mat4 m451 = mat4(b20);\n  const mat4 m452 = mat4(st77.b);\n  const vec4 v483 = vec4(vec4(3).x);\n  const mat4 m453 = mat4(vec4(5).x);\n  const vec4 v484 = vec4(mat4(6)[1]);\n  const mat4 m454 = mat4(mat4(6)[1][1]);\n  const vec4 v485 = vec4(st7(8, true).b);\n  const vec4 v487 = vec4(vec4(12, 13, 14, 15).ab, 12, 14);\n  int i20 = ss.i;\n  const vec4 v489 = -vec4(7,8,9,5);\n  gl_Position = vec4(1);\n}\n\x00')
62.857142857142854
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = (gtf_Color.rgb * 99.0) + 1.0;
	color = vec4(1.0 / sqrt(c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (gtf_Color.rgb * 99.0) + 1.0;\n\tcolor = vec4(1.0 / sqrt(c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.0, 0.0, (2.0 / (0.0 - --1.0)), 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb * 99.0) + 1.0);
  (color = vec4((1.0 / sqrt(c)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.0, 0.0, (2.0 / (0.0 - --1.0)), 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb * 99.0) + 1.0);
  (color = vec4((1.0 / sqrt(c)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
61.111111111111114
Mutations attempted: 36
Valid mutations:     22
Success rate:        61.11%
Processing this: /home/oof/webgl_cleaned/webgl_variable.vert
Original source code: 
precision mediump float;
precision mediump int;

void main() {
  vec4 webgl_foo;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main() {\n  vec4 webgl_foo;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  vec4 webgl_foo[1] = (!true ? vec4(+-1.0, (((true && true) ? (0.5 / -1.0) : 0.5) / 1.0), 0.0, -1.0) : vec4(0.5, -1.0, +(false ? (0.5 / 1.0) : (true ? 0.5 : 2.0)), ((true || true) ? 0.5 : (false ? -1.0 : -1.0))));
  main();
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[1] of 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  vec4 webgl_foo[1] = (!true ? vec4(+-1.0, (((true && true) ? (0.5 / -1.0) : 0.5) / 1.0), 0.0, -1.0) : vec4(0.5, -1.0, +(false ? (0.5 / 1.0) : (true ? 0.5 : 2.0)), ((true || true) ? 0.5 : (false ? -1.0 : -1.0))));
  main();
}


==============================
59.45945945945946
Processing this: /home/oof/webgl_cleaned/bool_empty_out_bool_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(out bool par[3]);
bool is_all(const in bool array[3], const in bool value);
void set_all(out bool array[3], const in bool value);
void main ()
{
	bool par[3];
	bool ret = false;
	float gray = 0.0;
	set_all(par, true);
	ret = function(par);
	if(is_all(par, false) && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(out bool par[3])
{
	set_all(par, false);
	return true;
}
bool is_all(const in bool array[3], const in bool value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bool array[3], const in bool value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(out bool par[3]);\nbool is_all(const in bool array[3], const in bool value);\nvoid set_all(out bool array[3], const in bool value);\nvoid main ()\n{\n\tbool par[3];\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tset_all(par, true);\n\tret = function(par);\n\tif(is_all(par, false) && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(out bool par[3])\n{\n\tset_all(par, false);\n\treturn true;\n}\nbool is_all(const in bool array[3], const in bool value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bool array[3], const in bool value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.45945945945946
Processing this: /home/oof/webgl_cleaned/distance_vec2_vert_xvaryyhalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(distance(gtf_Color.rg, vec2(0.5))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(distance(gtf_Color.rg, vec2(0.5))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 0.0, 0.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  (color = vec4(vec3(distance(gtf_Color.rg , vec2(0.5))) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
60.526315789473685
Processing this: /home/oof/webgl_cleaned/greaterThan_vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThan(c, vec3(0.0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(greaterThan(c, vec3(0.0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((true ? (-1.0 / 0.0) : 1.0) * ((true ? 0.5 : 2.0) * -2.0)), 2.0, 0.0, -1.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(c , vec3(0.0)));
  (gl_FragColor = vec4(result , 1.0));
}


As vertex? : False
SUCCESS!
61.53846153846154
Processing this: /home/oof/webgl_cleaned/extension3_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
61.53846153846154
Processing this: /home/oof/webgl_cleaned/atan_vec2_vert_xvaryyvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 x = 2.0 * (gtf_Color.gg - 0.5);
	vec2 y = 2.0 * (gtf_Color.bb - 0.5);
	vec2 c;
	vec2 atan_c = vec2(0.0);
	vec2 scale = vec2(1.0);
	vec2 sign = vec2(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		if(x[0] < 0.0 ^^ y[0] < 0.0)
		{
			sign[0] = -1.0;
		}
		if(abs(y[0]) <= abs(x[0]))
		{
			c[0] = abs(y[0] / x[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[0] = abs(x[0] / y[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;
		}
		if(x[0] < 0.0)
			if(y[0] < 0.0) result[0] -= 0.5;
			else if(y[0] > 0.0) result[0] += 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		if(x[1] < 0.0 ^^ y[1] < 0.0)
		{
			sign[1] = -1.0;
		}
		if(abs(y[1]) <= abs(x[1]))
		{
			c[1] = abs(y[1] / x[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[1] = abs(x[1] / y[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;
		}
		if(x[1] < 0.0)
			if(y[1] < 0.0) result[1] -= 0.5;
			else if(y[1] > 0.0) result[1] += 0.5;
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 x = 2.0 * (gtf_Color.gg - 0.5);\n\tvec2 y = 2.0 * (gtf_Color.bb - 0.5);\n\tvec2 c;\n\tvec2 atan_c = vec2(0.0);\n\tvec2 scale = vec2(1.0);\n\tvec2 sign = vec2(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tif(x[0] < 0.0 ^^ y[0] < 0.0)\n\t\t{\n\t\t\tsign[0] = -1.0;\n\t\t}\n\t\tif(abs(y[0]) <= abs(x[0]))\n\t\t{\n\t\t\tc[0] = abs(y[0] / x[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[0] = abs(x[0] / y[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[0] < 0.0)\n\t\t\tif(y[0] < 0.0) result[0] -= 0.5;\n\t\t\telse if(y[0] > 0.0) result[0] += 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tif(x[1] < 0.0 ^^ y[1] < 0.0)\n\t\t{\n\t\t\tsign[1] = -1.0;\n\t\t}\n\t\tif(abs(y[1]) <= abs(x[1]))\n\t\t{\n\t\t\tc[1] = abs(y[1] / x[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[1] = abs(x[1] / y[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[1] < 0.0)\n\t\t\tif(y[1] < 0.0) result[1] -= 0.5;\n\t\t\telse if(y[1] > 0.0) result[1] += 0.5;\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, -0.5, 1.0, 0.5, 0.0, -0.5, 0.0, -0.5, -1.0, 1.0, 1.0, 1.0, 2.0, -0.5, -0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 x = (2.0 * (gtf_Color.gg - 0.5));
  vec2 y = (2.0 * (gtf_Color.bb - 0.5));
  vec2 c;
  vec2 atan_c = vec2(0.0);
  vec2 scale = vec2(1.0);
  vec2 sign = vec2(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      (sign[0] = -1.0);
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      (c[0] = abs((y[0] / x[0])));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      (result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5));
    }
    else
    {
      (c[0] = abs((x[0] / y[0])));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      (result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5));
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      (sign[1] = -1.0);
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      (c[1] = abs((y[1] / x[1])));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5));
    }
    else
    {
      (c[1] = abs((x[1] / y[1])));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5));
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  (color = result);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, -0.5, 1.0, 0.5, 0.0, -0.5, 0.0, -0.5, -1.0, 1.0, 1.0, 1.0, 2.0, -0.5, -0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 x = (2.0 * (gtf_Color.gg - 0.5));
  vec2 y = (2.0 * (gtf_Color.bb - 0.5));
  vec2 c;
  vec2 atan_c = vec2(0.0);
  vec2 scale = vec2(1.0);
  vec2 sign = vec2(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      (sign[0] = -1.0);
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      (c[0] = abs((y[0] / x[0])));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      (result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5));
    }
    else
    {
      (c[0] = abs((x[0] / y[0])));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      (result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5));
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      (sign[1] = -1.0);
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      (c[1] = abs((y[1] / x[1])));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5));
    }
    else
    {
      (c[1] = abs((x[1] / y[1])));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5));
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  (color = result);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/greaterThan_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 gt(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] > b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(gt(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 gt(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] > b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(gt(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 gt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] > b[0]))
    (result[0] = true);
  else
    (result[0] = false);
  if ((a[1] > b[1]))
    (result[1] = true);
  else
    (result[1] = false);
  if ((a[3] > vec3(0.5, (true ? 0.0 : ((0.5 + 2.0) / (1.0 * 1.0))), 0.5)[-14]))
    (vec4((2.0 * 1.0), 0.5, -1.0, 0.0) = false);
  else
    (result[2] = true);
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  (color = vec4(result , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:23: '[]' : vector field selection out of range
ERROR: 0:23: '[]' : index expression is negative
ERROR: 0:24: 'assign' : l-value required (can't modify a const)
ERROR: 0:24: 'assign' : cannot convert from 'const bool' to 'const 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 gt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] > b[0]))
    (result[0] = true);
  else
    (result[0] = false);
  if ((a[1] > b[1]))
    (result[1] = true);
  else
    (result[1] = false);
  if ((a[3] > vec3(0.5, (true ? 0.0 : ((0.5 + 2.0) / (1.0 * 1.0))), 0.5)[-14]))
    (vec4((2.0 * 1.0), 0.5, -1.0, 0.0) = false);
  else
    (result[2] = true);
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  (color = vec4(result , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
58.536585365853654
Processing this: /home/oof/webgl_cleaned/log2_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const float ln2 = 0.69314718055994530941723212145818;
void main ()
{
	float x = 31.0 * gtf_Color.r + 1.0;
	float y = 0.0;
	float z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0 / ln2;
	color = vec4(y / 5.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst float ln2 = 0.69314718055994530941723212145818;\nvoid main ()\n{\n\tfloat x = 31.0 * gtf_Color.r + 1.0;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0 / ln2;\n\tcolor = vec4(y / 5.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const float ln2 = 0.6931471805599453;

void main()
{
  float x = ((31.0 * gtf_Color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  (z = ((x - 1.0) / (x + 1.0)));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (2.0 / ln2));
  (color = vec4((y / 5.0) , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
59.523809523809526
Processing this: /home/oof/webgl_cleaned/fract_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  (c = (color((fract(color) - 0.5)) * 2.0));
  (gl_FragColor = vec4(c , 1.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'const mediump float' to 'mediump 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  (c = (color((fract(color) - 0.5)) * 2.0));
  (gl_FragColor = vec4(c , 1.0));
}


==============================
58.139534883720934
Processing this: /home/oof/webgl_cleaned/acos_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(acos(c) / M_PI, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(acos(c) / M_PI, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  (gl_FragColor = vec4((acos(c) / M_PI) , 1.0));
  vec4((1.0 * -0.0), ((true ? 0.0 : (-1.0 - 0.5)) - -1.0), (true ? 1.0 : (!true ? (false ? 1.0 : 0.0) : --1.0)), 2.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  (gl_FragColor = vec4((acos(c) / M_PI) , 1.0));
  vec4((1.0 * -0.0), ((true ? 0.0 : (-1.0 - 0.5)) - -1.0), (true ? 1.0 : (!true ? (false ? 1.0 : 0.0) : --1.0)), 2.0);
}


==============================
56.81818181818182
Mutations attempted: 44
Valid mutations:     25
Success rate:        56.82%
Processing this: /home/oof/webgl_cleaned/lessThanEqual_ivec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 lte(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lte(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 lte(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lte(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = ((false ? true : true) ? vec4(+0.5, 0.5, 0.0, 0.5) : vec4((-1.0 / 1.0), ++0.5, (((false ? false : true) && true) ? -1.0 : (!true ? -0.5 : (-1.0 + 2.0))), -0.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 lte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    (result[0] = true);
  else
    (result[0] = false);
  if ((a[1] <= b[1]))
    (result[1] = true);
  else
    (result[1] = false);
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lte(ivec2(c) , ivec2(0)));
  (color = vec4(result , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '++' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = ((false ? true : true) ? vec4(+0.5, 0.5, 0.0, 0.5) : vec4((-1.0 / 1.0), ++0.5, (((false ? false : true) && true) ? -1.0 : (!true ? -0.5 : (-1.0 + 2.0))), -0.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 lte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    (result[0] = true);
  else
    (result[0] = false);
  if ((a[1] <= b[1]))
    (result[1] = true);
  else
    (result[1] = false);
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lte(ivec2(c) , ivec2(0)));
  (color = vec4(result , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
55.55555555555556
Processing this: /home/oof/webgl_cleaned/bvec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform bool vuni1;
uniform bvec2 vuni2;
uniform bvec3 vuni3;
uniform bvec4 vuni4;
varying vec4 color;
void main ()
{
	if(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])
	color = vec4(1.0, 0.0, 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform bool vuni1;\nuniform bvec2 vuni2;\nuniform bvec3 vuni3;\nuniform bvec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tif(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])\n\tcolor = vec4(1.0, 0.0, 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bvec3 vuni3;

uniform bool vuni1;

vec4 gtf_Vertex = vec4(1.0, (vuni1 ? +2.0 : ((true ? 2.0 : -1.0) * (vuni1 ? -1.0 : -1.0))), ((true ? (vuni1 ? -1.0 : 2.0) : (0.0 / 1.0)) + 2.0), (true ? +0.5 : ((0.0 + 1.0) / 0.0)));

void main()
{
  if (((vuni1 || ((((vuni2[0] && vuni2[1]) && vuni3[0]) && vuni3[1]) && vuni3[2])) || (((vuni4[0] && vuni4[1]) && vuni4[2]) && vuni4[3])))
    (color = vec4(1.0 , 0.0 , 0.5 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}

uniform bvec2 vuni2;

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform bvec4 vuni4;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '=' : global variable initializers must be constant expressions
ERROR: 0:12: 'vuni2' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: 'vuni2' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const highp float' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:12: 'vuni4' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: 'vuni4' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const highp float' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:12: 'vuni4' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:12: 'vuni4' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:13: 'color' : undeclared identifier
ERROR: 0:13: 'assign' : l-value required (can't modify a const)
ERROR: 0:13: '=' : dimension mismatch
ERROR: 0:13: 'assign' : cannot convert from 'const 4-component vector of float' to 'const highp float'
ERROR: 0:14: 'gtf_ModelViewProjectionMatrix' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bvec3 vuni3;

uniform bool vuni1;

vec4 gtf_Vertex = vec4(1.0, (vuni1 ? +2.0 : ((true ? 2.0 : -1.0) * (vuni1 ? -1.0 : -1.0))), ((true ? (vuni1 ? -1.0 : 2.0) : (0.0 / 1.0)) + 2.0), (true ? +0.5 : ((0.0 + 1.0) / 0.0)));

void main()
{
  if (((vuni1 || ((((vuni2[0] && vuni2[1]) && vuni3[0]) && vuni3[1]) && vuni3[2])) || (((vuni4[0] && vuni4[1]) && vuni4[2]) && vuni4[3])))
    (color = vec4(1.0 , 0.0 , 0.5 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}

uniform bvec2 vuni2;

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform bvec4 vuni4;


==============================
54.347826086956516
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * gtf_Color.rg;
	color = vec4(c / 100.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * gtf_Color.rg;\n\tcolor = vec4(c / 100.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-+0.5, -(0.5 / (false ? 2.0 : 0.5)), 1.0, (((true || false) && (true || true)) ? (false ? 2.0 : (false ? 0.0 : 0.0)) : 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (100.0 * gtf_Color.rg);
  (color = vec4((c / 100.0) , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
55.319148936170215
Processing this: /home/oof/webgl_cleaned/asin_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (gtf_Color.r - 0.5);
	float asin_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	if(c < 0.0)
	{
		sign = -1.0;
		c *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		asin_c += scale * pow(c, float(i)) / float(i);
		scale *= float(i) / float(i + 1);
	}
	color = vec4(sign * asin_c / M_PI + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tfloat asin_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tif(c < 0.0)\n\t{\n\t\tsign = -1.0;\n\t\tc *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tasin_c += scale * pow(c, float(i)) / float(i);\n\t\tscale *= float(i) / float(i + 1);\n\t}\n\tcolor = vec4(sign * asin_c / M_PI + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4((false ? 0.5 : 1.0), (!(true ? true : false) ? ((true ? -1.0 : 0.5) + --1.0) : +2.0), -0.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  float asin_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  if ((c < 0.0))
  {
    (sign = -1.0);
    (c *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c += ((scale * pow(c , float(i))) / float(i)));
    (scale *= (float(i) / float((i + 1))));
  }
  (color = vec4((((sign * asin_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4((false ? 0.5 : 1.0), (!(true ? true : false) ? ((true ? -1.0 : 0.5) + --1.0) : +2.0), -0.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  float asin_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  if ((c < 0.0))
  {
    (sign = -1.0);
    (c *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c += ((scale * pow(c , float(i))) / float(i)));
    (scale *= (float(i) / float((i + 1))));
  }
  (color = vec4((((sign * asin_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
54.166666666666664
Processing this: /home/oof/webgl_cleaned/const_mat3_copy_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0, 2.0, 3.0,
	                     4.0, 5.0, 6.0,
	                     7.0, 8.0, 9.0);
	mat3 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[0][2] != 3.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 5.0) elms = false;
	if(b[1][2] != 6.0) elms = false;
	if(b[2][0] != 7.0) elms = false;
	if(b[2][1] != 8.0) elms = false;
	if(b[2][2] != 9.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0];
	if( x < 12.0-0.1 || x > 12.0+0.1 ) rows = false;
	x = b[0][1] + b[1][1] + b[2][1];
	if(x < 15.0-0.1 || x > 15.0+0.1 ) rows = false;
	x = b[0][2] + b[1][2] + b[2][2];
	if(x < 18.0-0.1 || x > 18.0+0.1 ) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2];
	if( x < 6.0-0.1 || x > 6.0+0.1 ) cols = false;
	x = b[1][0] + b[1][1] + b[1][2];
	if(x < 15.0-0.1 || x > 15.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2];
	if(x < 24.0-0.1 || x > 24.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0, 2.0, 3.0,\n\t                     4.0, 5.0, 6.0,\n\t                     7.0, 8.0, 9.0);\n\tmat3 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[0][2] != 3.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 5.0) elms = false;\n\tif(b[1][2] != 6.0) elms = false;\n\tif(b[2][0] != 7.0) elms = false;\n\tif(b[2][1] != 8.0) elms = false;\n\tif(b[2][2] != 9.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tif( x < 12.0-0.1 || x > 12.0+0.1 ) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1];\n\tif(x < 15.0-0.1 || x > 15.0+0.1 ) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2];\n\tif(x < 18.0-0.1 || x > 18.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2];\n\tif( x < 6.0-0.1 || x > 6.0+0.1 ) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2];\n\tif(x < 15.0-0.1 || x > 15.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2];\n\tif(x < 24.0-0.1 || x > 24.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0);
  mat3 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    (elms = false);
  if ((b[0][1] != 2.0))
    (elms = false);
  if ((b[0][2] != 3.0))
    (elms = false);
  if ((b[1][0] != 4.0))
    (elms = false);
  if ((b[1][1] != 5.0))
    (elms = false);
  if ((b[1][2] != 6.0))
    (elms = false);
  if ((b[2][0] != 7.0))
    (elms = false);
  if ((b[2][1] != 8.0))
    (elms = false);
  if ((b[2][2] != 9.0))
    (elms = false);
  bool rows = true;
  (x = ((b[0][0] + b[1][0]) + b[2][0]));
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    (rows = false);
  (x = ((b[0][1] + b[1][1]) + b[2][1]));
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    (rows = false);
  (x = ((b[0][2] + b[1][2]) + b[2][2]));
  if ((((2.0 - 0.1) < x) || (x > ((true ? (1.0 - 1.0) : (false ? 2.0 : 2.0)) + 0.6))))
    (rows = false);
  bool cols = true;
  (x = ((b[0][0] + b[0][1]) + b[0][2]));
  if (((x < (6.0 - 0.1)) || (x > (6.0 + 0.1))))
    (cols = false);
  (x = ((b[1][0] + b[1][1]) + b[1][2]));
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    (cols = false);
  (x = ((b[2][0] + b[2][1]) + b[2][2]));
  if (((x < (24.0 - 0.1)) || (x > (24.0 + 0.1))))
    (cols = false);
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  (gl_FragColor = vec4(gray , gray , gray , 1.0));
}


As vertex? : False
SUCCESS!
55.10204081632652
Processing this: /home/oof/webgl_cleaned/noopUniformShader.frag
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  (0.0 = vec4(0.0 , 0.0 , 0.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'constructor' : not enough data provided for construction
ERROR: 0:6: 'assign' : l-value required (can't modify a const)
ERROR: 0:6: '=' : dimension mismatch
ERROR: 0:6: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  (0.0 = vec4(0.0 , 0.0 , 0.0));
}


==============================
54.0
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	float s = lightloc.s;
	float t = lightloc.t;
	float p = lightloc.p;
	float q = lightloc.q;
	vec4 m = vec4(s, t, p, q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tfloat s = lightloc.s;\n\tfloat t = lightloc.t;\n\tfloat p = lightloc.p;\n\tfloat q = lightloc.q;\n\tvec4 m = vec4(s, t, p, q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((0.5 / +0.5) / 0.5), (true ? 2.0 : -1.0), +0.5, -1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  float s = lightloc.s;
  float t = lightloc.t;
  float p = lightloc.p;
  float q = lightloc.q;
  vec4 m = vec4(s , t , p , q);
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * m));
}


As vertex? : True
SUCCESS!
54.90196078431373
Processing this: /home/oof/webgl_cleaned/exp_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec3 c = color.rgb;
	gl_FragColor = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.0, 0.0, 1.0);

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec3 c = color.rgb;
  (gl_FragColor = vec4((pow(vec3(exp1) , (3.0 * c)) / exp3) , 1.0));
}


As vertex? : False
SUCCESS!
55.769230769230774
Processing this: /home/oof/webgl_cleaned/atan_vec3_vert_xvaryyvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (gtf_Color.ggg - 0.5);
	vec3 y = 2.0 * (gtf_Color.bbb - 0.5);
	vec3 c;
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		if(x[0] < 0.0 ^^ y[0] < 0.0)
		{
			sign[0] = -1.0;
		}
		if(abs(y[0]) <= abs(x[0]))
		{
			c[0] = abs(y[0] / x[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[0] = abs(x[0] / y[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;
		}
		if(x[0] < 0.0)
			if(y[0] < 0.0) result[0] -= 0.5;
			else if(y[0] > 0.0) result[0] += 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		if(x[1] < 0.0 ^^ y[1] < 0.0)
		{
			sign[1] = -1.0;
		}
		if(abs(y[1]) <= abs(x[1]))
		{
			c[1] = abs(y[1] / x[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[1] = abs(x[1] / y[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;
		}
		if(x[1] < 0.0)
			if(y[1] < 0.0) result[1] -= 0.5;
			else if(y[1] > 0.0) result[1] += 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		if(x[2] < 0.0 ^^ y[2] < 0.0)
		{
			sign[2] = -1.0;
		}
		if(abs(y[2]) <= abs(x[2]))
		{
			c[2] = abs(y[2] / x[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[2] = abs(x[2] / y[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;
		}
		if(x[2] < 0.0)
			if(y[2] < 0.0) result[2] -= 0.5;
			else if(y[2] > 0.0) result[2] += 0.5;
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 x = 2.0 * (gtf_Color.ggg - 0.5);\n\tvec3 y = 2.0 * (gtf_Color.bbb - 0.5);\n\tvec3 c;\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tif(x[0] < 0.0 ^^ y[0] < 0.0)\n\t\t{\n\t\t\tsign[0] = -1.0;\n\t\t}\n\t\tif(abs(y[0]) <= abs(x[0]))\n\t\t{\n\t\t\tc[0] = abs(y[0] / x[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[0] = abs(x[0] / y[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[0] < 0.0)\n\t\t\tif(y[0] < 0.0) result[0] -= 0.5;\n\t\t\telse if(y[0] > 0.0) result[0] += 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tif(x[1] < 0.0 ^^ y[1] < 0.0)\n\t\t{\n\t\t\tsign[1] = -1.0;\n\t\t}\n\t\tif(abs(y[1]) <= abs(x[1]))\n\t\t{\n\t\t\tc[1] = abs(y[1] / x[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[1] = abs(x[1] / y[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[1] < 0.0)\n\t\t\tif(y[1] < 0.0) result[1] -= 0.5;\n\t\t\telse if(y[1] > 0.0) result[1] += 0.5;\n\t}\n\tif(x[2] > epsilon || abs(y[2]) > epsilon)\n\t{\n\t\tif(x[2] < 0.0 ^^ y[2] < 0.0)\n\t\t{\n\t\t\tsign[2] = -1.0;\n\t\t}\n\t\tif(abs(y[2]) <= abs(x[2]))\n\t\t{\n\t\t\tc[2] = abs(y[2] / x[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[2] = abs(x[2] / y[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[2] < 0.0)\n\t\t\tif(y[2] < 0.0) result[2] -= 0.5;\n\t\t\telse if(y[2] > 0.0) result[2] += 0.5;\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4(2.0, -((1.0 - -1.0) + (false ? 0.0 : -1.0)), (false ? (-0.0 / 0.5) : ((false ? 0.0 : -1.0) / (true ? 1.0 : -1.0))), 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (gtf_Color.ggg - 0.5));
  vec3 y = (2.0 * (gtf_Color.bbb - 0.5));
  vec3 c;
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      (sign[0] = -1.0);
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      (c[0] = abs((y[0] / x[0])));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      (result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5));
    }
    else
    {
      (c[0] = abs((x[0] / y[0])));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      (result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5));
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      (sign[1] = -1.0);
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      (c[1] = abs((y[1] / x[1])));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5));
    }
    else
    {
      (c[1] = abs((x[1] / y[1])));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5));
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  if (((x[2] > epsilon) || (abs(y[2]) > epsilon)))
  {
    if (((x[2] < 0.0) ^^ (y[2] < 0.0)))
    {
      (sign[2] = -1.0);
    }
    if ((abs(y[2]) <= abs(x[2])))
    {
      (c[2] = abs((y[2] / x[2])));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      (result[2] = (((sign[2] * atan_c[2]) / (2.0 * M_PI)) + 0.5));
    }
    else
    {
      (c[2] = abs((x[2] / y[2])));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      (result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / (2.0 * M_PI)) + 0.5));
    }
    if ((x[2] < 0.0))
      if ((y[2] < 0.0))
        (result[2] -= 0.5);
      else
        if ((y[2] > 0.0))
          (result[2] += 0.5);
  }
  (color = result);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
56.60377358490566
Processing this: /home/oof/webgl_cleaned/buffer_objects.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec3 gtf_Normal;
attribute vec4 gtf_MultiTexCoord0;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat3 gtf_NormalMatrix;
varying vec4 gtf_TexCoord[1];
varying vec4 color;
vec4 Ambient;
vec4 Diffuse;
vec4 Specular;
const vec3 lightPosition = vec3(0.0, 0.0, 1.0);
const vec3 spotDirection = vec3(0.0, 0.0, -1.0);
const float spotCutoff = 180.0;
const float spotExponent = 0.0;
const float lightAttenuationConstant = 1.0;
const float lightAttenuationLinear = 0.0;
const float lightAttenuationQuadratic = 0.0;
const vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 0.0);
vec4 lightDiffuse = vec4(1.0, 1.0, 1.0, 1.0);
vec4 lightSpecular = vec4(1.0, 1.0, 1.0, 1.0);
const float materialShininess = 0.0;
const vec4 sceneColor = vec4(0.0, 0.0, 0.0, 0.0);
void spotLight(in int i,
               in vec3 normal,
               in vec3 eye,
               in vec3 ecPosition3
               )
{
    float nDotVP;
    float nDotHV;
    float pf;
    float spotDot;
    float spotAttenuation;
    float attenuation;
    float d;
    vec3 VP;
    vec3 halfVector;
    VP = lightPosition - ecPosition3;
    d = length(VP);
    VP = normalize(VP);
    attenuation = 1.0 / (lightAttenuationConstant +
                         lightAttenuationLinear * d +
                         lightAttenuationQuadratic * d * d);
    spotDot = dot(-VP, normalize(spotDirection));
    if (spotDot < cos(radians(spotCutoff)))
        spotAttenuation = 0.0;
    else
        spotAttenuation = pow(spotDot, spotExponent);
    attenuation *= spotAttenuation;
    halfVector = normalize(VP + eye);
    nDotVP = max(0.0, dot(normal, VP));
    nDotHV = max(0.0, dot(normal, halfVector));
    if (nDotVP == 0.0)
        pf = 0.0;
    else
        pf = pow(nDotHV, materialShininess);
    Ambient  += lightAmbient * attenuation;
    Diffuse  += lightDiffuse * nDotVP * attenuation;
    Specular += lightSpecular * pf * attenuation;
}
vec3 fnormal()
{
    vec3 normal = gtf_NormalMatrix * gtf_Normal;
    normal = normalize(normal);
	return normal;
}
void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
    vec3 ecPosition3;
    vec3 eye;
    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;
    eye = vec3 (0.0, 0.0, 1.0);
    Ambient  = vec4 (0.0);
    Diffuse  = vec4 (0.0);
    Specular = vec4 (0.0);
    spotLight(0, normal, eye, ecPosition3);
    color = sceneColor +
      Ambient  * gtf_Color +
      Diffuse  * gtf_Color;
    color += Specular * gtf_Color;
    color = clamp( color, 0.0, 1.0 );
    color.a *= alphaFade;
}
void main ()
{
	vec3  transformedNormal;
    float alphaFade = 1.0;
	vec4 ecPosition = gtf_Vertex;
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
	transformedNormal = fnormal();
    flight(transformedNormal, ecPosition, alphaFade);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec3 gtf_Normal;\nattribute vec4 gtf_MultiTexCoord0;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat3 gtf_NormalMatrix;\nvarying vec4 gtf_TexCoord[1];\nvarying vec4 color;\nvec4 Ambient;\nvec4 Diffuse;\nvec4 Specular;\nconst vec3 lightPosition = vec3(0.0, 0.0, 1.0);\nconst vec3 spotDirection = vec3(0.0, 0.0, -1.0);\nconst float spotCutoff = 180.0;\nconst float spotExponent = 0.0;\nconst float lightAttenuationConstant = 1.0;\nconst float lightAttenuationLinear = 0.0;\nconst float lightAttenuationQuadratic = 0.0;\nconst vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 lightDiffuse = vec4(1.0, 1.0, 1.0, 1.0);\nvec4 lightSpecular = vec4(1.0, 1.0, 1.0, 1.0);\nconst float materialShininess = 0.0;\nconst vec4 sceneColor = vec4(0.0, 0.0, 0.0, 0.0);\nvoid spotLight(in int i,\n               in vec3 normal,\n               in vec3 eye,\n               in vec3 ecPosition3\n               )\n{\n    float nDotVP;\n    float nDotHV;\n    float pf;\n    float spotDot;\n    float spotAttenuation;\n    float attenuation;\n    float d;\n    vec3 VP;\n    vec3 halfVector;\n    VP = lightPosition - ecPosition3;\n    d = length(VP);\n    VP = normalize(VP);\n    attenuation = 1.0 / (lightAttenuationConstant +\n                         lightAttenuationLinear * d +\n                         lightAttenuationQuadratic * d * d);\n    spotDot = dot(-VP, normalize(spotDirection));\n    if (spotDot < cos(radians(spotCutoff)))\n        spotAttenuation = 0.0;\n    else\n        spotAttenuation = pow(spotDot, spotExponent);\n    attenuation *= spotAttenuation;\n    halfVector = normalize(VP + eye);\n    nDotVP = max(0.0, dot(normal, VP));\n    nDotHV = max(0.0, dot(normal, halfVector));\n    if (nDotVP == 0.0)\n        pf = 0.0;\n    else\n        pf = pow(nDotHV, materialShininess);\n    Ambient  += lightAmbient * attenuation;\n    Diffuse  += lightDiffuse * nDotVP * attenuation;\n    Specular += lightSpecular * pf * attenuation;\n}\nvec3 fnormal()\n{\n    vec3 normal = gtf_NormalMatrix * gtf_Normal;\n    normal = normalize(normal);\n\treturn normal;\n}\nvoid flight(in vec3 normal, in vec4 ecPosition, float alphaFade)\n{\n    vec3 ecPosition3;\n    vec3 eye;\n    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;\n    eye = vec3 (0.0, 0.0, 1.0);\n    Ambient  = vec4 (0.0);\n    Diffuse  = vec4 (0.0);\n    Specular = vec4 (0.0);\n    spotLight(0, normal, eye, ecPosition3);\n    color = sceneColor +\n      Ambient  * gtf_Color +\n      Diffuse  * gtf_Color;\n    color += Specular * gtf_Color;\n    color = clamp( color, 0.0, 1.0 );\n    color.a *= alphaFade;\n}\nvoid main ()\n{\n\tvec3  transformedNormal;\n    float alphaFade = 1.0;\n\tvec4 ecPosition = gtf_Vertex;\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n\ttransformedNormal = fnormal();\n    flight(transformedNormal, ecPosition, alphaFade);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec3 gtf_Normal;

vec4 gtf_MultiTexCoord0;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat3 gtf_NormalMatrix;

vec4 gtf_TexCoord[1];

vec4 color;

vec4 Ambient;

vec4 Diffuse;

vec4 Specular;

const vec3 lightPosition = vec3(0.0 , 0.0 , 1.0);

const vec3 spotDirection = vec3(0.0 , 0.0 , -1.0);

const float spotCutoff = 180.0;

const float spotExponent = 0.0;

const float lightAttenuationConstant = 1.0;

const float lightAttenuationLinear = 0.0;

const float lightAttenuationQuadratic = 0.0;

const vec4 lightAmbient = vec4(0.0 , 0.0 , 0.0 , 0.0);

vec4 lightDiffuse = vec4(1.0 , 1.0 , 1.0 , 1.0);

vec4 lightSpecular = vec4(1.0 , 1.0 , 1.0 , 1.0);

const float materialShininess = 0.0;

const vec4 sceneColor = vec4(0.0 , 0.0 , 0.0 , 0.0);

void spotLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
  float nDotVP;
  float nDotHV;
  float pf;
  float spotDot;
  float spotAttenuation;
  float attenuation;
  float d;
  vec3 VP;
  vec3 halfVector;
  (VP = (lightPosition - ecPosition3));
  (d = length(VP));
  (VP = normalize(VP));
  (attenuation = (1.0 / ((lightAttenuationConstant + (lightAttenuationLinear * d)) + ((lightAttenuationQuadratic * d) * d))));
  (spotDot = dot(-VP , normalize(spotDirection)));
  if ((spotDot < cos(radians(spotCutoff))))
    (spotAttenuation = 0.0);
  else
    (spotAttenuation = pow(spotDot , spotExponent));
  (attenuation *= spotAttenuation);
  (halfVector = normalize((VP + eye)));
  (nDotVP = max(0.0 , dot(normal , VP)));
  (nDotHV = max(0.0 , dot(normal , halfVector)));
  if ((nDotVP == 0.0))
    (pf = 0.0);
  else
    (pf = pow(nDotHV , materialShininess));
  (Ambient += (lightAmbient * attenuation));
  (Diffuse += ((lightDiffuse * nDotVP) * attenuation));
  (Specular += ((lightSpecular * pf) * attenuation));
}

vec3 fnormal()
{
  vec3 normal = (gtf_NormalMatrix * gtf_Normal);
  (normal = normalize(normal));
  return normal;
}

void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
  vec3 ecPosition3;
  vec3 eye;
  (ecPosition3 = (vec3(ecPosition) / ecPosition.w));
  (eye = vec3(0.0 , 0.0 , 1.0));
  (Ambient = vec4(0.0));
  (Diffuse = vec4(0.0));
  (Specular = vec4(0.0));
  spotLight(0 , normal , eye , ecPosition3);
  (color = ((sceneColor + (Ambient * gtf_Color)) + (Diffuse * gtf_Color)));
  (color += (Specular * gtf_Color));
  (color = clamp(color , 0.0 , 1.0));
  (color.a *= alphaFade);
}

void main()
{
  vec3 transformedNormal;
  float alphaFade = 1.0;
  vec4 ecPosition = gtf_Vertex;
  (color = gtf_Color);
  (gtf_TexCoord[0] = gtf_MultiTexCoord0);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
  (transformedNormal = fnormal());
  flight(transformedNormal , ecPosition , alphaFade);
}


As vertex? : True
SUCCESS!
57.407407407407405
Mutations attempted: 54
Valid mutations:     31
Success rate:        57.41%
Processing this: /home/oof/webgl_cleaned/simple.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute float gtf_Color;
varying vec4 tc;
void main ()
{
	tc = vec4(gtf_Color, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute float gtf_Color;\nvarying vec4 tc;\nvoid main ()\n{\n\ttc = vec4(gtf_Color, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-1.0, (2.0 * (false ? gtf_Color : (gtf_Color * 2.0))), gtf_Color, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

float gtf_Color;

vec4 tc;

void main()
{
  (tc = vec4(gtf_Color , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'gtf_Color' : undeclared identifier
ERROR: 0:4: 'gtf_Color' : undeclared identifier
ERROR: 0:4: 'gtf_Color' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-1.0, (2.0 * (false ? gtf_Color : (gtf_Color * 2.0))), gtf_Color, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

float gtf_Color;

vec4 tc;

void main()
{
  (tc = vec4(gtf_Color , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
56.36363636363636
Processing this: /home/oof/webgl_cleaned/asin_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(asin(c) / M_PI + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(asin(c) / M_PI + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((!false ? false : !false) ? -1.0 : -(true ? 0.0 : 2.0)), +-(true ? 0.0 : 0.0), +1.0, 2.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  (color = vec4(((asin(c) / M_PI) + 0.5) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
57.14285714285714
Processing this: /home/oof/webgl_cleaned/samplerUniformShader.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform sampler2D s2D;
uniform samplerCube sCube;
void main()
{
    gl_FragColor = texture2D(s2D, vec2(0.5, 0.5)) +
                   textureCube(sCube, vec3(0.5, 0.5, 0.5));
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform sampler2D s2D;\nuniform samplerCube sCube;\nvoid main()\n{\n    gl_FragColor = texture2D(s2D, vec2(0.5, 0.5)) +\n                   textureCube(sCube, vec3(0.5, 0.5, 0.5));\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform sampler2D s2D;

uniform samplerCube sCube;

void main()
{
  (gl_FragColor = 0.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gl_FragColor' : undeclared identifier
ERROR: 0:10: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform sampler2D s2D;

uniform samplerCube sCube;

void main()
{
  (gl_FragColor = 0.5);
}


==============================
56.14035087719298
Processing this: /home/oof/webgl_cleaned/extension6_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
56.14035087719298
Processing this: /home/oof/webgl_cleaned/vec3_rg_b_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.rgb;
	float k = m.b;
	vec2 n = m.rg;
	vec4 a = vec4(n, k, al.a);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.rgb;\n\tfloat k = m.b;\n\tvec2 n = m.rg;\n\tvec4 a = vec4(n, k, al.a);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((true && false) ? 0.5 : +0.0) + 2.0), -1.0, -1.0, +0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.rgb;
  float k = m.b;
  vec2 n = m.rg;
  vec4 a = vec4(n , k , al.a);
  (gl_FragColor = a);
}


As vertex? : False
SUCCESS!
56.896551724137936
Processing this: /home/oof/webgl_cleaned/version2_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  (gl_FragColor = vec4(0));
  vec4(0.5, 0.0, ++2.0, ((+2.0 - 0.0) - 0.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:7: '++' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  (gl_FragColor = vec4(0));
  vec4(0.5, 0.0, ++2.0, ((+2.0 - 0.0) - 0.0));
}


==============================
55.932203389830505
Processing this: /home/oof/webgl_cleaned/mix_vec3_vert_xvary_yconsthalf_aconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 y = vec3(0.5, 0.5, 0.5);
	const vec3 a = vec3(0.5, 0.5, 0.5);
	color = vec4(mix(gtf_Color.rgb, y, a), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 y = vec3(0.5, 0.5, 0.5);\n\tconst vec3 a = vec3(0.5, 0.5, 0.5);\n\tcolor = vec4(mix(gtf_Color.rgb, y, a), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 y = vec3(0.5 , 0.5 , 0.5);
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  (color = vec4(mix(gtf_Color.rgb , y , a) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
56.666666666666664
Processing this: /home/oof/webgl_cleaned/acos_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	vec3 acos_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	if(c.r < 0.0)
	{
		sign.r = -1.0;
		c.r *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.r += scale.r * pow(c.r, float(i)) / float(i);
		scale.r *= float(i) / float(i + 1);
	}
	acos_c.r = M_PI / 2.0 - sign.r * acos_c.r;
	if(c.g < 0.0)
	{
		sign.g = -1.0;
		c.g *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.g += scale.g * pow(c.g, float(i)) / float(i);
		scale.g *= float(i) / float(i + 1);
	}
	acos_c.g = M_PI / 2.0 - sign.g * acos_c.g;
	if(c.b < 0.0)
	{
		sign.b = -1.0;
		c.b *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.b += scale.b * pow(c.b, float(i)) / float(i);
		scale.b *= float(i) / float(i + 1);
	}
	acos_c.b = M_PI / 2.0 - sign.b * acos_c.b;
	color = vec4(acos_c / M_PI, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 acos_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tif(c.r < 0.0)\n\t{\n\t\tsign.r = -1.0;\n\t\tc.r *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.r += scale.r * pow(c.r, float(i)) / float(i);\n\t\tscale.r *= float(i) / float(i + 1);\n\t}\n\tacos_c.r = M_PI / 2.0 - sign.r * acos_c.r;\n\tif(c.g < 0.0)\n\t{\n\t\tsign.g = -1.0;\n\t\tc.g *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.g += scale.g * pow(c.g, float(i)) / float(i);\n\t\tscale.g *= float(i) / float(i + 1);\n\t}\n\tacos_c.g = M_PI / 2.0 - sign.g * acos_c.g;\n\tif(c.b < 0.0)\n\t{\n\t\tsign.b = -1.0;\n\t\tc.b *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.b += scale.b * pow(c.b, float(i)) / float(i);\n\t\tscale.b *= float(i) / float(i + 1);\n\t}\n\tacos_c.b = M_PI / 2.0 - sign.b * acos_c.b;\n\tcolor = vec4(acos_c / M_PI, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(1.0, +2.0, 0.5, -1.0);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  vec3 acos_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  if ((c.r < 0.0))
  {
    (sign.r = -1.0);
    (c.r *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.r += ((scale.r * pow(c.r , float(i))) / float(i)));
    (scale.r *= (float(i) / float((i + 1))));
  }
  (acos_c.r = ((M_PI / 2.0) - (sign.r * acos_c.r)));
  if ((c.g < 0.0))
  {
    (sign.g = -1.0);
    (c.g *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.g += ((scale.g * pow(c.g , float(i))) / float(i)));
    (scale.g *= (float(i) / float((i + 1))));
  }
  (acos_c.g = ((M_PI / 2.0) - (sign.g * acos_c.g)));
  if ((c.b < 0.0))
  {
    (sign.b = -1.0);
    (c.b *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.b += ((scale.b * pow(c.b , float(i))) / float(i)));
    (scale.b *= (float(i) / float((i + 1))));
  }
  (acos_c.b = ((M_PI / 2.0) - (sign.b * acos_c.b)));
  (color = vec4((acos_c / M_PI) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
57.377049180327866
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 31.0 * gtf_Color.rg + 1.0;
	color = vec4(log(c) / 3.466, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 31.0 * gtf_Color.rg + 1.0;\n\tcolor = vec4(log(c) / 3.466, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((!(false || true) ? -1.0 : 0.0), (0.5 / (1.0 + -1.0)), 0.5, 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((31.0 * gtf_Color.rg) + 1.0);
  (color = vec4((log(c) / 3.466) , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
58.06451612903226
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(out vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(out vec4 par)
{
	set_all(par, 0.0);
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(out vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(out vec4 par)\n{\n\tset_all(par, 0.0);\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
58.06451612903226
Mutations attempted: 62
Valid mutations:     36
Success rate:        58.06%
Processing this: /home/oof/webgl_cleaned/const_mat4_copy_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	mat4 b = a;
	bool elms = true;
	if(b[0][0] !=  1.0) elms = false;
	if(b[0][1] !=  2.0) elms = false;
	if(b[0][2] !=  3.0) elms = false;
	if(b[0][3] !=  4.0) elms = false;
	if(b[1][0] !=  5.0) elms = false;
	if(b[1][1] !=  6.0) elms = false;
	if(b[1][2] !=  7.0) elms = false;
	if(b[1][3] !=  8.0) elms = false;
	if(b[2][0] !=  9.0) elms = false;
	if(b[2][1] != 10.0) elms = false;
	if(b[2][2] != 11.0) elms = false;
	if(b[2][3] != 12.0) elms = false;
	if(b[3][0] != 13.0) elms = false;
	if(b[3][1] != 14.0) elms = false;
	if(b[3][2] != 15.0) elms = false;
	if(b[3][3] != 16.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0] + b[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = b[0][1] + b[1][1] + b[2][1] + b[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = b[0][2] + b[1][2] + b[2][2] + b[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = b[0][3] + b[1][3] + b[2][3] + b[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2] + b[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = b[1][0] + b[1][1] + b[1][2] + b[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2] + b[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = b[3][0] + b[3][1] + b[3][2] + b[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tmat4 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=  1.0) elms = false;\n\tif(b[0][1] !=  2.0) elms = false;\n\tif(b[0][2] !=  3.0) elms = false;\n\tif(b[0][3] !=  4.0) elms = false;\n\tif(b[1][0] !=  5.0) elms = false;\n\tif(b[1][1] !=  6.0) elms = false;\n\tif(b[1][2] !=  7.0) elms = false;\n\tif(b[1][3] !=  8.0) elms = false;\n\tif(b[2][0] !=  9.0) elms = false;\n\tif(b[2][1] != 10.0) elms = false;\n\tif(b[2][2] != 11.0) elms = false;\n\tif(b[2][3] != 12.0) elms = false;\n\tif(b[3][0] != 13.0) elms = false;\n\tif(b[3][1] != 14.0) elms = false;\n\tif(b[3][2] != 15.0) elms = false;\n\tif(b[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0] + b[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1] + b[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2] + b[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = b[0][3] + b[1][3] + b[2][3] + b[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2] + b[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2] + b[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2] + b[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = b[3][0] + b[3][1] + b[3][2] + b[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    (elms = false);
  if ((b[0][1] != 2.0))
    (elms = false);
  if ((b[0][2] != 3.0))
    (elms = false);
  if ((b[0][3] != 4.0))
    (elms = false);
  if ((b[1][0] != 5.0))
    (elms = false);
  if ((b[1][1] != 6.0))
    (elms = false);
  if ((b[1][2] != 7.0))
    (elms = false);
  if ((b[1][3] != 8.0))
    (elms = false);
  if ((b[2][0] != 9.0))
    (elms = false);
  if ((b[2][1] != 10.0))
    (elms = false);
  if ((b[2][2] != 11.0))
    (elms = false);
  if ((b[2][3] != 12.0))
    (elms = false);
  if ((b[3][0] != 13.0))
    (elms = false);
  if ((b[3][1] != 14.0))
    (elms = false);
  if ((b[3][2] != 15.0))
    (elms = false);
  if ((b[3][3] != 16.0))
    (elms = false);
  bool rows = true;
  (x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]));
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    (rows = false);
  (x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]));
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    (rows = false);
  (x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]));
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    (rows = false);
  (x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]));
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    (rows = false);
  bool cols = true;
  (x = (((b[0][0] + b[0][1]) + b[0][2]) + b[0][3]));
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    (cols = false);
  (x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]));
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    (cols = false);
  (x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]));
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    (cols = false);
  (x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]));
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    (cols = false);
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  (gl_FragColor = vec4(gray , gray , gray , 1.0));
}


As vertex? : False
SUCCESS!
58.730158730158735
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = (gtf_Color.rgb * 99.0) + 1.0;
	color = vec4(1.0 / sqrt(c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (gtf_Color.rgb * 99.0) + 1.0;\n\tcolor = vec4(1.0 / sqrt(c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-1.0, (true ? 2.0 : ((true || true) ? 2.0 : 0.0)), (-1.0 / 0.0), 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb * 99.0) + 1.0);
  (color = vec4((1.0 / sqrt(c)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
59.375
Processing this: /home/oof/webgl_cleaned/4b_firstthree_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform bvec4 color;
void main ()
{
	gl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform bvec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bvec4 color = bvec4(0.5, 1.0, 0.0, 1.0);

void main()
{
  (gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]) , 1.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bvec4 color = bvec4(0.5, 1.0, 0.0, 1.0);

void main()
{
  (gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]) , 1.0));
}


==============================
58.46153846153847
Processing this: /home/oof/webgl_cleaned/vec3_float_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 b = vec2(53.0, 139.0);
	vec3 a = vec3(13.0, b);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 b = vec2(53.0, 139.0);\n\tvec3 a = vec3(13.0, b);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, (!false ? -1.0 : 0.0), (0.5 + -1.0), 1.0);

void main()
{
  vec2 b = vec2(53.0 , 139.0);
  vec3 a = vec3(13.0 , b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    (gray = 1.0);
  else
    (gray = 0.0);
  (gl_FragColor = vec4(gray , gray , gray , 1.0));
}


As vertex? : False
SUCCESS!
59.09090909090909
Processing this: /home/oof/webgl_cleaned/vec4_zx_wy_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.zx;
	vec2 n = lightloc.wy;
	vec4 a = vec4(m.y, n.y, m.x, n.x);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.zx;\n\tvec2 n = lightloc.wy;\n\tvec4 a = vec4(m.y, n.y, m.x, n.x);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.zx;
  vec2 n = lightloc.wy;
  vec4 a = vec4(m.y , n.y , m.x , n.x);
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * a));
}


As vertex? : True
SUCCESS!
59.70149253731343
Processing this: /home/oof/webgl_cleaned/int_empty_inout_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(inout int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(inout int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(inout int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(inout int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.70149253731343
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xconsthalf_yvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = -2.0 * (color.r - 0.5);
	gl_FragColor = vec4(exp2(2.0 * c) / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = -2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(exp2(2.0 * c) / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+((true ? 0.5 : 1.0) / 0.0), ((1.0 * 2.0) - 0.0), ((false || true) ? +(false ? 0.0 : 0.5) : ((true ? 0.5 : 0.0) + 1.0)), 1.0);

void main()
{
  float c = (-2.0 * (color.r - 0.5));
  (gl_FragColor = vec4((exp2((2.0 * c)) / 4.0) , 0.0 , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
60.29411764705882
Processing this: /home/oof/webgl_cleaned/sign_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(c * sign(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(c * sign(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  (gl_FragColor = vec4((c * sign(c)) , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
60.86956521739131
Processing this: /home/oof/webgl_cleaned/vec4_gr_ab_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.gr;
	vec2 n = lightloc.ab;
	vec4 a = vec4(m.g, m.r, n.g, n.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.gr;\n\tvec2 n = lightloc.ab;\n\tvec4 a = vec4(m.g, m.r, n.g, n.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.gr;
  vec2 n = lightloc.ab;
  vec4 a = vec4(m.g , m.r , n.g , n.r);
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * a));
}


As vertex? : True
SUCCESS!
61.42857142857143
Processing this: /home/oof/webgl_cleaned/faceforward_float_vert_nvaryiconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g * 2.0) - 1.0;
	float v2 = (gtf_Color.b * 2.0) - 1.0;
	color = vec4((faceforward(v1, v2, v1) + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g * 2.0) - 1.0;\n\tfloat v2 = (gtf_Color.b * 2.0) - 1.0;\n\tcolor = vec4((faceforward(v1, v2, v1) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, (-1.0 - ((true ? false : false) ? 0.5 : (false ? 0.0 : 0.0))), +2.0, -+(0.5 * 2.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g * 2.0) - 1.0);
  float v2 = ((gtf_Color.b * 2.0) - 1.0);
  (color = vec4(((faceforward(v1 , v2 , v1) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
61.97183098591549
Mutations attempted: 71
Valid mutations:     44
Success rate:        61.97%
Processing this: /home/oof/webgl_cleaned/log_float_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = (color.r + 0.01) / 1.01;
	gl_FragColor = vec4(log(c) / -4.61, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (color.r + 0.01) / 1.01;\n\tgl_FragColor = vec4(log(c) / -4.61, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, +0.5, (((false ? 0.0 : 0.5) * +1.0) / 0.5), 0.0);

void main()
{
  float c = ((color.r + 0.01) / 1.01);
  (gl_FragColor = vec4((log(c) / -4.61) , 0.0 , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
62.5
Processing this: /home/oof/webgl_cleaned/normalize_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, -1.0, -1.0, -0.5);

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  (gl_FragColor = vec4(normalize(tmp_Color.rg) , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
63.013698630136986
Processing this: /home/oof/webgl_cleaned/exp2_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = gtf_Color.rg;
	color = vec4(exp2(5.0 * c) / 32.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(exp2(5.0 * c) / 32.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((2.0 + 2.0), 0.5, -1.0, -0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  (color = vec4((exp2((5.0 * c)) / 32.0) , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
63.51351351351351
Processing this: /home/oof/webgl_cleaned/vec3_zx_y_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	float k = m.y;
	vec2 n = m.zx;
	vec4 a = vec4(n.y, k, n.x, al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tfloat k = m.y;\n\tvec2 n = m.zx;\n\tvec4 a = vec4(n.y, k, n.x, al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.0, -((1.0 - 1.0) * -1.0), (((true ? 1.0 : 1.0) * (true ? 0.5 : 0.5)) - (true ? -1.0 : 0.5)));

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  float k = m.y;
  vec2 n = m.zx;
  vec4 a = vec4(n.y , k , n.x , al.w);
  (gl_FragColor = a);
}


As vertex? : False
SUCCESS!
64.0
Processing this: /home/oof/webgl_cleaned/array_const_mat3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat3 a = mat3(1.0, 2.0, 3.0,
		            4.0, 5.0, 6.0,
			    7.0, 8.0, 9.0);
	const mat3 b = mat3(10.0, 11.0, 12.0,
		            13.0, 14.0, 15.0,
			    16.0, 17.0, 18.0);
	mat3 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat3 a = mat3(1.0, 2.0, 3.0,\n\t\t            4.0, 5.0, 6.0,\n\t\t\t    7.0, 8.0, 9.0);\n\tconst mat3 b = mat3(10.0, 11.0, 12.0,\n\t\t            13.0, 14.0, 15.0,\n\t\t\t    16.0, 17.0, 18.0);\n\tmat3 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = -14;

void main()
{
  const mat3 a = mat3(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0);
  const mat3 b = mat3(10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0 , 17.0 , 18.0);
  mat3 array[array_size];
  float gray;
  (array[0] = a);
  (array[1] = b);
  if (((array[0] == a) && (array[1] == b)))
    (gray = 1.0);
  else
    (gray = 0.0);
  (gl_FragColor = vec4(gray , gray , gray , 1.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: '' : array size must be non-negative
ERROR: 0:15: '[]' : array index out of range
ERROR: 0:16: '[]' : array index out of range

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = -14;

void main()
{
  const mat3 a = mat3(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0);
  const mat3 b = mat3(10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0 , 17.0 , 18.0);
  mat3 array[array_size];
  float gray;
  (array[0] = a);
  (array[1] = b);
  if (((array[0] == a) && (array[1] == b)))
    (gray = 1.0);
  else
    (gray = 0.0);
  (gl_FragColor = vec4(gray , gray , gray , 1.0));
}


==============================
63.1578947368421
Processing this: /home/oof/webgl_cleaned/max_float_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = gtf_Color.r;
	if(c < max_c) c = max_c;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = gtf_Color.r;\n\tif(c < max_c) c = max_c;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = gtf_Color.r;
  if ((c < max_c))
    (c = max_c);
  (color = vec4(c , 0.0 , 0.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = gtf_Color.r;
  if ((c < max_c))
    (c = max_c);
  (color = vec4(c , 0.0 , 0.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
62.33766233766234
Processing this: /home/oof/webgl_cleaned/abs_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(abs(c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(abs(c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 0.0, (true ? 0.0 : (0.5 - -1.0)), ((true ? false : !false) ? -1.0 : 0.5), 2.0, 0.0, 0.5, +((true ? true : true) ? -1.0 : (true ? 0.0 : -1.0)), ((false || false) ? 1.0 : (true ? (true ? 2.0 : 0.5) : -1.0)), 0.5, (!false ? 2.0 : -(-1.0 * 0.0)), 0.5, -1.0, +-(0.0 - 0.0), +-+0.5, (0.5 / 0.5));

vec4 color;

void main()
{
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  (color = vec4(abs(c) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 0.0, (true ? 0.0 : (0.5 - -1.0)), ((true ? false : !false) ? -1.0 : 0.5), 2.0, 0.0, 0.5, +((true ? true : true) ? -1.0 : (true ? 0.0 : -1.0)), ((false || false) ? 1.0 : (true ? (true ? 2.0 : 0.5) : -1.0)), 0.5, (!false ? 2.0 : -(-1.0 * 0.0)), 0.5, -1.0, +-(0.0 - 0.0), +-+0.5, (0.5 / 0.5));

vec4 color;

void main()
{
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  (color = vec4(abs(c) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
61.53846153846154
Processing this: /home/oof/webgl_cleaned/struct_bvec2bvec3bvec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	bvec2 a;
	bvec3 b;
	bvec4 c;
};
void main ()
{
	sabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );
	float gray = 0.0;
	if( (s.a[0]) && (s.a[1]) && (s.b[0]) && (!s.b[1]) && (s.b[2]) && (s.c[0]) && (s.c[1]) && (s.c[2]) )
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tbvec2 a;\n\tbvec3 b;\n\tbvec4 c;\n};\nvoid main ()\n{\n\tsabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );\n\tfloat gray = 0.0;\n\tif( (s.a[0]) && (s.a[1]) && (s.b[0]) && (!s.b[1]) && (s.b[2]) && (s.c[0]) && (s.c[1]) && (s.c[2]) )\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  bvec2 a;
  bvec3 b;
  bvec4 c;
};

void main()
{
  sabcd s = sabcd(bvec2(12 , 13) , bvec3(14.0 , 0.0 , 139.0) , bvec4(25.5 , 17.0 , 145 , 163));
  float gray = 0.0;
  if ((((((((s.a[0] && s.a[1]) && s.b[0]) && !s.b[1]) && s.b[2]) && s.c[0]) && s.c[1]) && s.c[2]))
    (gray = 1.0);
  else
    (gray = 0.0);
  (gl_FragColor = vec4(gray , gray , gray));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct sabcd {
  bvec2 a;
  bvec3 b;
  bvec4 c;
};

void main()
{
  sabcd s = sabcd(bvec2(12 , 13) , bvec3(14.0 , 0.0 , 139.0) , bvec4(25.5 , 17.0 , 145 , 163));
  float gray = 0.0;
  if ((((((((s.a[0] && s.a[1]) && s.b[0]) && !s.b[1]) && s.b[2]) && s.c[0]) && s.c[1]) && s.c[2]))
    (gray = 1.0);
  else
    (gray = 0.0);
  (gl_FragColor = vec4(gray , gray , gray));
}


==============================
60.75949367088608
Processing this: /home/oof/webgl_cleaned/24f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec4 color[2];
void main ()
{
	gl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2] + color[0][3],
						 color[1][0] + color[1][1] + color[1][2] + color[1][3],
						 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec4 color[2];\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2] + color[0][3],\n\t\t\t\t\t\t color[1][0] + color[1][1] + color[1][2] + color[1][3],\n\t\t\t\t\t\t 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec4 color[2];

void main()
{
  (gl_FragColor = vec4((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]) , (((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]) , 0.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec4 color[2];

void main()
{
  (gl_FragColor = vec4((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]) , (((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]) , 0.0));
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
60.0
Mutations attempted: 80
Valid mutations:     48
Success rate:        60.00%
Processing this: /home/oof/webgl_cleaned/step_float_frag_xvary_edgeconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float edge = 0.5;
	gl_FragColor = vec4(step(edge, color.r), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge = 0.5;\n\tgl_FragColor = vec4(step(edge, color.r), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float edge = 0.5;
  (1.0 = vec4(step(edge , color.r) , 0.0 , 0.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float edge = 0.5;
  (1.0 = vec4(step(edge , color.r) , 0.0 , 0.0));
}


==============================
59.25925925925925
Processing this: /home/oof/webgl_cleaned/vec4_x_y_z_w_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float x = al.x;
	float y = al.y;
	float z = al.z;
	float w = al.w;
	vec4 m = vec4(x,y,z,w);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat x = al.x;\n\tfloat y = al.y;\n\tfloat z = al.z;\n\tfloat w = al.w;\n\tvec4 m = vec4(x,y,z,w);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  float x = al.x;
  float y = al.y;
  float z = al.z;
  float w = al.w;
  vec4 m = vec4(x , y , z , w);
  (gl_FragColor = m);
  vec4(1.0, 0.0, -0.5, -1.0);
}


As vertex? : False
SUCCESS!
59.756097560975604
Processing this: /home/oof/webgl_cleaned/unary_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = +23;
	int k = -m;
	bool a = false;
	bool b = !a;
	float gray;
	if( (m==23) && (k==-23) && (b) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = +23;\n\tint k = -m;\n\tbool a = false;\n\tbool b = !a;\n\tfloat gray;\n\tif( (m==23) && (k==-23) && (b) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 2.0, ((false ? (true || true) : (false ? true : true)) ? (+1.0 / (1.0 + 0.0)) : -1.0), 2.0);

void main()
{
  int m = +23;
  int k = -m;
  bool a = false;
  bool b = !a;
  float gray;
  if ((((m == 23) && (k == -23)) && b))
    (gray = 1.0);
  else
    (gray = 0.0);
  (gl_FragColor = vec4(gray , gray , gray , 1.0));
}


As vertex? : False
SUCCESS!
60.24096385542169
Processing this: /home/oof/webgl_cleaned/asin_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(asin(c) / M_PI + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(asin(c) / M_PI + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((1.0 * 0.5) - -0.5) / +(0.5 - 2.0)), 0.0, 2.0, --(1.0 * 2.0), -1.0, (1.0 / 0.0), (0.0 - (!true ? (0.5 / -1.0) : (false ? 2.0 : 1.0))), -1.0, 0.5, (0.0 + +0.5), 0.0, 0.0, (0.5 * -1.0), 2.0, +((-1.0 / 2.0) - (true ? -1.0 : 0.5)), ((false || !true) ? (0.0 + +2.0) : 0.5));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  (color = vec4(((asin(c) / M_PI) + 0.5) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((1.0 * 0.5) - -0.5) / +(0.5 - 2.0)), 0.0, 2.0, --(1.0 * 2.0), -1.0, (1.0 / 0.0), (0.0 - (!true ? (0.5 / -1.0) : (false ? 2.0 : 1.0))), -1.0, 0.5, (0.0 + +0.5), 0.0, 0.0, (0.5 * -1.0), 2.0, +((-1.0 / 2.0) - (true ? -1.0 : 0.5)), ((false || !true) ? (0.0 + +2.0) : 0.5));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  (color = vec4(((asin(c) / M_PI) + 0.5) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
59.523809523809526
Processing this: /home/oof/webgl_cleaned/clamp_float_vert_xvary_yconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = gtf_Color.r;
	color = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((2.0 - ((true ? true : true) ? (0.5 / 0.0) : 2.0)), ((-1.0 / 0.0) * (0.0 / (2.0 * 1.0))), 1.0, (+0.5 / (0.0 / 2.0)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = gtf_Color.r;
  (color = vec4(clamp(c , min_c , max_c) , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/ivec4_empty_inout_ivec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(inout ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(inout ivec4 par)
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(inout ivec4 par);\nbool is_all(const in ivec4 par, const in int value);\nvoid set_all(out ivec4 par, const in int value);\nvoid main ()\n{\n\tivec4 par = ivec4(1, 1, 1, 1);\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(inout ivec4 par)\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 par, const in int value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
60.0
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = (gtf_Color.rg * 99.0) + 1.0;
	color = vec4(1.0 / sqrt(c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (gtf_Color.rg * 99.0) + 1.0;\n\tcolor = vec4(1.0 / sqrt(c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, 0.0, -(true ? (-1.0 - 0.5) : 0.0), (false ? --1.0 : -0.5), (((-1.0 - 0.0) * (true ? 2.0 : 1.0)) + (-1.0 + 0.5)), (true ? ((true ? true : false) ? 0.0 : (1.0 * 1.0)) : ((false || true) ? +1.0 : (2.0 + 2.0))), (0.0 + ((0.5 / 1.0) - -1.0)), (+0.5 + 2.0), +(false ? 0.0 : (2.0 / 2.0)), 2.0, ((false && true) ? (-1.0 - 1.0) : -1.0), -1.0, --1.0, (-1.0 - 2.0), ((false || true) ? (false ? -0.5 : 0.5) : (!false ? 0.0 : -1.0)), (((true ? 0.0 : 2.0) - 1.0) / -1.0));

vec4 color;

void main()
{
  vec2 c = ((gtf_Color.rg * 99.0) + 1.0);
  (color = vec4((1.0 / sqrt(c)) , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, 0.0, -(true ? (-1.0 - 0.5) : 0.0), (false ? --1.0 : -0.5), (((-1.0 - 0.0) * (true ? 2.0 : 1.0)) + (-1.0 + 0.5)), (true ? ((true ? true : false) ? 0.0 : (1.0 * 1.0)) : ((false || true) ? +1.0 : (2.0 + 2.0))), (0.0 + ((0.5 / 1.0) - -1.0)), (+0.5 + 2.0), +(false ? 0.0 : (2.0 / 2.0)), 2.0, ((false && true) ? (-1.0 - 1.0) : -1.0), -1.0, --1.0, (-1.0 - 2.0), ((false || true) ? (false ? -0.5 : 0.5) : (!false ? 0.0 : -1.0)), (((true ? 0.0 : 2.0) - 1.0) / -1.0));

vec4 color;

void main()
{
  vec2 c = ((gtf_Color.rg * 99.0) + 1.0);
  (color = vec4((1.0 / sqrt(c)) , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
59.30232558139535
Processing this: /home/oof/webgl_cleaned/2b_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform bvec2 color;
varying vec2 col;
void main ()
{
	col = vec2(color);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform bvec2 color;\nvarying vec2 col;\nvoid main ()\n{\n\tcol = vec2(color);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform bvec2 color;

vec2 col = vec2((true ? 0.5 : -1.0), 1.0);

void main()
{
  (col = vec2(color));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
59.77011494252874
Processing this: /home/oof/webgl_cleaned/lessThan_ivec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(lessThan(ivec3(c), ivec3(0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(lessThan(ivec3(c), ivec3(0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-1.0, ((false || true) ? 2.0 : 0.5), (((-1.0 / -1.0) / -1.0) * 0.0), 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(lessThan(ivec3(c) , ivec3(0)));
  (color = vec4(result , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
60.22727272727273
Processing this: /home/oof/webgl_cleaned/log_vec3_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = (color.rgb + 0.01) / 1.01;
	gl_FragColor = vec4(log(c) / -4.61, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (color.rgb + 0.01) / 1.01;\n\tgl_FragColor = vec4(log(c) / -4.61, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.0, -0.5, -0.5);

void main()
{
  vec3 c = ((color.rgb + 0.01) / 1.01);
  (gl_FragColor = vec4((log(c) / -4.61) , 1.0));
}


As vertex? : False
SUCCESS!
60.67415730337079
Mutations attempted: 89
Valid mutations:     54
Success rate:        60.67%
Processing this: /home/oof/webgl_cleaned/sign_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 2.0 * (gtf_Color.r - 0.5);
	if(c > 0.0) c = 1.0 * c;
	if(c < 0.0) c = -1.0 * c;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tif(c > 0.0) c = 1.0 * c;\n\tif(c < 0.0) c = -1.0 * c;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-0.5 + (0.5 / 2.0)), 2.0, ((2.0 * (false ? 0.5 : 2.0)) + 2.0), ((true ? 0.0 : +0.5) * -(false ? 0.0 : 0.0)), +(!false ? 2.0 : (false ? 2.0 : 0.0)), ((true ? -1.0 : -1.0) - +2.0), 0.5, (((true ? false : true) || !true) ? 1.0 : ((true && false) ? -1.0 : +2.0)), 0.5, 2.0, ((true ? false : false) ? ---1.0 : +(true ? 0.5 : 1.0)), 1.0, -1.0, -1.0, ((+1.0 + (1.0 - -1.0)) / 1.0), +-0.0);

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  if ((c > 0.0))
    (c = (1.0 * c));
  if ((c < 0.0))
    (c = (-1.0 * c));
  (color = vec4(c , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-0.5 + (0.5 / 2.0)), 2.0, ((2.0 * (false ? 0.5 : 2.0)) + 2.0), ((true ? 0.0 : +0.5) * -(false ? 0.0 : 0.0)), +(!false ? 2.0 : (false ? 2.0 : 0.0)), ((true ? -1.0 : -1.0) - +2.0), 0.5, (((true ? false : true) || !true) ? 1.0 : ((true && false) ? -1.0 : +2.0)), 0.5, 2.0, ((true ? false : false) ? ---1.0 : +(true ? 0.5 : 1.0)), 1.0, -1.0, -1.0, ((+1.0 + (1.0 - -1.0)) / 1.0), +-0.0);

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  if ((c > 0.0))
    (c = (1.0 * c));
  if ((c < 0.0))
    (c = (-1.0 * c));
  (color = vec4(c , 0.0 , 0.0 , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/length_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(sqrt(gtf_Color.r*gtf_Color.r + gtf_Color.g*gtf_Color.g + gtf_Color.b*gtf_Color.b) / 3.0), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(sqrt(gtf_Color.r*gtf_Color.r + gtf_Color.g*gtf_Color.g + gtf_Color.b*gtf_Color.b) / 3.0), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 0.5, ((false ? !false : !true) ? -1.0 : 0.0), 2.0);

void main()
{
  (color = vec4(vec3((sqrt((((gtf_Color.r * gtf_Color.r) + (gtf_Color.g * gtf_Color.g)) + (gtf_Color.b * gtf_Color.b))) / 3.0)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
60.43956043956044
Processing this: /home/oof/webgl_cleaned/default.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
	gl_PointSize = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n\tgl_PointSize = 1.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-(-1.0 * (-1.0 + 1.0)), -(1.0 * 0.5), 1.0, 0.5);

void main()
{
  (color = gtf_Color);
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
  (gl_PointSize = 1.0);
}


As vertex? : True
SUCCESS!
60.86956521739131
Processing this: /home/oof/webgl_cleaned/bvec4_empty_out_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(out bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(out bvec4 par[3])
{
	set_all(par, bvec4(false, false, false, false));
	return bvec4(true, true, true, true);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(out bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(out bvec4 par[3])\n{\n\tset_all(par, bvec4(false, false, false, false));\n\treturn bvec4(true, true, true, true);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.86956521739131
Processing this: /home/oof/webgl_cleaned/length_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(length(gtf_Color.rg) / 2.0), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(length(gtf_Color.rg) / 2.0), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-(!false ? 2.0 : 0.0), 2.0, -1.0, (false ? -(-1.0 * 0.5) : -1.0), 0.5, +0.0, -1.0, ((false ? false : true) ? 0.0 : 2.0), 1.0, 2.0, (0.0 * (1.0 / (false ? 1.0 : 1.0))), (0.0 + 1.0), 2.0, (((true ? false : false) ? !false : true) ? -2.0 : (false ? (true ? 0.5 : 2.0) : (true ? 1.0 : 2.0))), (2.0 / -1.0), (!true ? 0.5 : (false ? 0.0 : -1.0)));

vec4 color;

void main()
{
  (color = vec4(vec3((length(gtf_Color.rg) / 2.0)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-(!false ? 2.0 : 0.0), 2.0, -1.0, (false ? -(-1.0 * 0.5) : -1.0), 0.5, +0.0, -1.0, ((false ? false : true) ? 0.0 : 2.0), 1.0, 2.0, (0.0 * (1.0 / (false ? 1.0 : 1.0))), (0.0 + 1.0), 2.0, (((true ? false : false) ? !false : true) ? -2.0 : (false ? (true ? 0.5 : 2.0) : (true ? 1.0 : 2.0))), (2.0 / -1.0), (!true ? 0.5 : (false ? 0.0 : -1.0)));

vec4 color;

void main()
{
  (color = vec4(vec3((length(gtf_Color.rg) / 2.0)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
60.215053763440864
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(1.0 / pow(vec2(2.0), 5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(1.0 / pow(vec2(2.0), 5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = color.rg;
  (gl_FragColor = vec4((1.0 / pow(vec2(2.0) , (5.0 * c))) , 0.0 , 1.0));
}


As vertex? : False
SUCCESS!
60.63829787234043
Processing this: /home/oof/webgl_cleaned/lessThan_vec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 lt(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] < b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] < b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] < b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(lt(c, vec3(0.0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 lt(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] < b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] < b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] < b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(lt(c, vec3(0.0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 lt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[-2] < b[0]))
    (result[0] = false);
  else
    (vec4((-2.0 - 0.5), 1.0, -((-1.0 * 0.0) * (true ? 0.0 : 0.5)), 1.0) = false);
  if ((a[1] < b[1]))
    (result[1] = true);
  else
    (result[1] = false);
  if ((a[2] < b[2]))
    (result[2] = true);
  else
    (result[2] = false);
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(lt(c , vec3(0.0)));
  (gl_FragColor = vec4(result , 1.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: '[]' : index expression is negative
ERROR: 0:12: 'assign' : l-value required (can't modify a const)
ERROR: 0:12: 'assign' : cannot convert from 'const bool' to 'const 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec3 lt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[-2] < b[0]))
    (result[0] = false);
  else
    (vec4((-2.0 - 0.5), 1.0, -((-1.0 * 0.0) * (true ? 0.0 : 0.5)), 1.0) = false);
  if ((a[1] < b[1]))
    (result[1] = true);
  else
    (result[1] = false);
  if ((a[2] < b[2]))
    (result[2] = true);
  else
    (result[2] = false);
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(lt(c , vec3(0.0)));
  (gl_FragColor = vec4(result , 1.0));
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/1f_vert.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float col;
void main ()
{
	gl_FragColor = vec4 (col, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float col;\nvoid main ()\n{\n\tgl_FragColor = vec4 (col, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

float col;

void main()
{
  (col = col);
  vec4(0.0, 1.0, 2.0, 0.0);
}


As vertex? : False
SUCCESS!
60.416666666666664
Processing this: /home/oof/webgl_cleaned/normalize_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = gtf_Color + vec4(0.25);
	color = vec4(normalize(tmp_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = gtf_Color + vec4(0.25);\n\tcolor = vec4(normalize(tmp_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, (!!false ? 0.0 : ((false ? true : false) ? -1.0 : 1.0)), 0.5, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 tmp_Color = (gtf_Color + vec4(0.25));
  (color = vec4(normalize(tmp_Color.rgb) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


As vertex? : True
SUCCESS!
60.824742268041234
Processing this: /home/oof/webgl_cleaned/log_vec3_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = (color.rgb + 0.01) / 1.01;
	gl_FragColor = vec4(log(c) / -4.61, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (color.rgb + 0.01) / 1.01;\n\tgl_FragColor = vec4(log(c) / -4.61, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((color.rgb + 0.01) / 1.01);
  ivec2((false ? 8 : 9), 5);
}


As vertex? : False
SUCCESS!
61.224489795918366
Mutations attempted: 98
Valid mutations:     60
Success rate:        61.22%
Processing this: /home/oof/webgl_cleaned/reflect_float_vert_ivarynconst_ref.vert
