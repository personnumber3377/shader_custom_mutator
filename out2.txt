Using this seed: 46497
Mutations attempted: 0
Valid mutations:     0
Success rate:        0.00%
Processing this: /home/oof/webgl_cleaned/matrix2VSU.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat4 transforms;
uniform mat4 anotherMatrix;
varying vec4 color;
void main()
{
  color = gtf_Color;
   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat4 transforms;\nuniform mat4 anotherMatrix;\nvarying vec4 color;\nvoid main()\n{\n  color = gtf_Color;\n   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color = vec4(0.5, ((false ? true : (true && true)) ? (+1.0 - (-1.0 + 2.0)) : +-1.0), ++(true ? 0.5 : -1.0), 0.0);

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms) * anotherMatrix) * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: '++' : l-value required (can't modify a const)
ERROR: 0:14: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color = vec4(0.5, ((false ? true : (true && true)) ? (+1.0 - (-1.0 + 2.0)) : +-1.0), ++(true ? 0.5 : -1.0), 0.0);

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms) * anotherMatrix) * gtf_Vertex);
}


==============================
Processing this: /home/oof/webgl_cleaned/all_bvec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(4.0 * gtf_Color.rg);
	color = vec4(vec3(all(bvec2(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(4.0 * gtf_Color.rg);\n\tcolor = vec4(vec3(all(bvec2(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.5, -0.5, 0.5, 1.0);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor((4.0 * gtf_Color.rg));
  color = vec4(vec3(all(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/log_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 31.0 * color.rgb + 1.0;
	gl_FragColor = vec4(log(c) / 3.466, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 31.0 * color.rgb + 1.0;\n\tgl_FragColor = vec4(log(c) / 3.466, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((31.0 * color.rgb) + 1.0);
  gl_FragColor = color((log(c) / 3.466));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'gl_FragColor' : undeclared identifier
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((31.0 * color.rgb) + 1.0);
  gl_FragColor = color((log(c) / 3.466));
}


==============================
33.33333333333333
Processing this: /home/oof/webgl_cleaned/extension8_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
33.33333333333333
Processing this: /home/oof/webgl_cleaned/vec4_tsq_p_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.tsq;
	float p = al.p;
	vec4 a = vec4(m.t, m.s, p, m.p);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.tsq;\n\tfloat p = al.p;\n\tvec4 a = vec4(m.t, m.s, p, m.p);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.tsq;
  float p = al.p;
  vec4 a = vec4(m.t , m.s , p , m.p);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/float_empty_in_float_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(in float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(in float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(in float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(in float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((true ? -1.0 : +2.0) * 2.0), (false ? 1.0 : +0.5), (0.0 / 0.5), (false ? 0.0 : 0.5));


void main()
{
  float par = 1.0;
  float ret = 0.0;
  float gray = 0.0;
  ret = function(par);
  if (((par == 1.0) && (ret == 1.0)))
  {
    gray = 1.0;
  }
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}

float function(in float par)
{
  if ((par == 1.0))
  {
    par = 0.0;
    return 1.0;
  }
  else
    return 0.0;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'function' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((true ? -1.0 : +2.0) * 2.0), (false ? 1.0 : +0.5), (0.0 / 0.5), (false ? 0.0 : 0.5));


void main()
{
  float par = 1.0;
  float ret = 0.0;
  float gray = 0.0;
  ret = function(par);
  if (((par == 1.0) && (ret == 1.0)))
  {
    gray = 1.0;
  }
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}

float function(in float par)
{
  if ((par == 1.0))
  {
    par = 0.0;
    return 1.0;
  }
  else
    return 0.0;
}


==============================
40.0
Processing this: /home/oof/webgl_cleaned/relational_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool lessthan  = (m<k);
	bool greaterthan = (m>k);
	bool lessthanorequalto = (m <= 102);
	bool greaterthanorequalto = (k >=12);
	float gray;
	if( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool lessthan  = (m<k);\n\tbool greaterthan = (m>k);\n\tbool lessthanorequalto = (m <= 102);\n\tbool greaterthanorequalto = (k >=12);\n\tfloat gray;\n\tif( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (k >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  main();
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: Recursive function call in the following call chain:main) -> main)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (k >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  main();
}


==============================
33.33333333333333
Processing this: /home/oof/webgl_cleaned/sign_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(c * (sign(c)), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(c * (sign(c)), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 2.0, 0.5, -1.0);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4((c * sign(c)) , 1.0);
}


As vertex? : False
SUCCESS!
42.857142857142854
Processing this: /home/oof/webgl_cleaned/tan_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	float o;
	if(abs(c) < 0.5)
		o = 0.5 * (sin(c) / cos(c)) + 0.5;
	else
		o = 0.5 * (cos(c) / sin(c)) + 0.5;
	color = vec4(o, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tfloat o;\n\tif(abs(c) < 0.5)\n\t\to = 0.5 * (sin(c) / cos(c)) + 0.5;\n\telse\n\t\to = 0.5 * (cos(c) / sin(c)) + 0.5;\n\tcolor = vec4(o, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 1.0, ((true ? (true || false) : (true ? true : false)) ? -1.0 : 0.5), 2.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((0.5 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  float o;
  if ((abs(c) < 0.5))
    o = ((0.5 * (sin(c) / cos(c))) + 0.5);
  else
    o = ((0.5 * (cos(c) / sin(c))) + 0.5);
  color = vec4(o , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/dot_vec3_vert_xvaryythird_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(gtf_Color.r + gtf_Color.g + gtf_Color.b) * 0.3333, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(gtf_Color.r + gtf_Color.g + gtf_Color.b) * 0.3333, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(+2.0, ((true ? +0.0 : +1.0) + ((true ? 0.0 : 0.0) + (0.5 + 0.0))), ((false ? 0.5 : 0.0) - (true ? +0.0 : (false ? 0.5 : -1.0))), (((false ? -1.0 : -1.0) * (true ? 0.5 : 2.0)) + 0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4((vec3(((gtf_Color.r + gtf_Color.g) + gtf_Color.b)) * 0.3333) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
55.55555555555556
Mutations attempted: 9
Valid mutations:     5
Success rate:        55.56%
Processing this: /home/oof/webgl_cleaned/faceforward_vec2_frag_nvaryiconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	if(dot(v1, v2) >= 0.0) v1 *= -1.0;
	gl_FragColor = vec4((v1 + 1.0) / 2.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tif(dot(v1, v2) >= 0.0) v1 *= -1.0;\n\tgl_FragColor = vec4((v1 + 1.0) / 2.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-1.0 * (true ? -1.0 : (true ? 0.0 : 2.0))), 1.0, ((-1.0 * 2.0) + 0.0), 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  gl_FragColor = vec4(((v1 + 1.0) / 2.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((false ? 2.0 : -(false ? 1.0 : -1.0)), ((true ? false : (false || true)) ? ((0.0 + -1.0) / 2.0) : 0.0), (-0.0 - -1.0), (!true ? 2.0 : (false ? 2.0 : (2.0 + 1.0))));

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg * 99.0) + 1.0;
	gl_FragColor = vec4(inversesqrt(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg * 99.0) + 1.0;\n\tgl_FragColor = vec4(inversesqrt(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, 0.5, 0.0, (+(2.0 / 0.0) + ++0.5));

void main()
{
  vec2 c = ((color.rg * 99.0) + 1.0);
  gl_FragColor = vec4(inversesqrt(c) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:4: '/' : Divide by zero during constant folding
ERROR: 0:4: '++' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, 0.5, 0.0, (+(2.0 / 0.0) + ++0.5));

void main()
{
  vec2 c = ((color.rg * 99.0) + 1.0);
  gl_FragColor = vec4(inversesqrt(c) , 0.0 , 1.0);
}


==============================
58.333333333333336
Processing this: /home/oof/webgl_cleaned/gl_MaxCombinedTextureImageUnits_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(float(gl_MaxCombinedTextureImageUnits) / 8.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(float(gl_MaxCombinedTextureImageUnits) / 8.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4((8.0 / float(gl_MaxCombinedTextureImageUnits)));
}


As vertex? : False
SUCCESS!
61.53846153846154
Processing this: /home/oof/webgl_cleaned/1b_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform bool color;
void main ()
{
	gl_FragColor = vec4 (float(color), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform bool color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (float(color), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bool color;

void main()
{
  color = vec4(float(color) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a uniform "color")
ERROR: 0:8: 'assign' : cannot convert from 'const 4-component vector of float' to 'uniform bool'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bool color;

void main()
{
  color = vec4(float(color) , 0.0 , 0.0);
}


==============================
57.14285714285714
Processing this: /home/oof/webgl_cleaned/bvec4_empty_inout_bvec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(inout bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, false) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(inout bvec4 par)
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(inout bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, false) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(inout bvec4 par)\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;




void main()
{
  bvec4 par = bvec4(true , true , true , true);
  bvec4 ret = bvec4(false , false , false , false);
  float gray = 0.0;
  ret = function(par);
  if ((is_all(par , false) && is_all(ret , true)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

bvec4 function(inout bvec4 par)
{
  if (is_all(par , true))
  {
    set_all(par , false);
    return bvec4(true , true , true , true);
  }
  else
    return bvec4(false , false , false , false);
}

bool is_all(const in bvec4 par, const in bool value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}

void set_all(out bvec4 par, const in bool value)
{
  par[0] = value;
  par[1] = value;
  par[2] = value;
  par[3] = value;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'function' : no matching overloaded function found
ERROR: 0:18: 'assign' : cannot convert from 'const mediump float' to '4-component vector of bool'
ERROR: 0:19: 'is_all' : no matching overloaded function found
ERROR: 0:19: 'is_all' : no matching overloaded function found
ERROR: 0:19: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const mediump float' and a right operand of type 'const mediump float' (or there is no acceptable conversion)
ERROR: 0:29: 'is_all' : no matching overloaded function found
ERROR: 0:31: 'set_all' : no matching overloaded function found
ERROR: 0:29: '' : boolean expression expected

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;




void main()
{
  bvec4 par = bvec4(true , true , true , true);
  bvec4 ret = bvec4(false , false , false , false);
  float gray = 0.0;
  ret = function(par);
  if ((is_all(par , false) && is_all(ret , true)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

bvec4 function(inout bvec4 par)
{
  if (is_all(par , true))
  {
    set_all(par , false);
    return bvec4(true , true , true , true);
  }
  else
    return bvec4(false , false , false , false);
}

bool is_all(const in bvec4 par, const in bool value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}

void set_all(out bvec4 par, const in bool value)
{
  par[0] = value;
  par[1] = value;
  par[2] = value;
  par[3] = value;
}


==============================
53.333333333333336
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xconst2_yvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 2.0, (!false ? ((1.0 + 0.5) * 1.0) : 0.5), 1.0, -1.0, (true ? 0.5 : 1.0), +0.0, (true ? ---1.0 : 0.0), 0.5, 1.0, 0.0, ((2.0 / (true ? 1.0 : 0.5)) + (-1.0 - 0.0)), 0.5, +(0.5 - -0.5), ((true ? -1.0 : 0.0) + ((2.0 / 0.0) + (false ? -1.0 : 2.0))), 0.0);

vec4 color;

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((pow(vec2(2.0) , (2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 2.0, (!false ? ((1.0 + 0.5) * 1.0) : 0.5), 1.0, -1.0, (true ? 0.5 : 1.0), +0.0, (true ? ---1.0 : 0.0), 0.5, 1.0, 0.0, ((2.0 / (true ? 1.0 : 0.5)) + (-1.0 - 0.0)), 0.5, +(0.5 - -0.5), ((true ? -1.0 : 0.0) + ((2.0 / 0.0) + (false ? -1.0 : 2.0))), 0.0);

vec4 color;

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((pow(vec2(2.0) , (2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/CorrectExtension1_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
50.0
Processing this: /home/oof/webgl_cleaned/degrees_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.0, 1.0, +0.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
52.94117647058824
Processing this: /home/oof/webgl_cleaned/float_empty_empty_float_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;


void main()
{
  float par = 1.0;
  float ret = 0.0;
  float gray = 0.0;
  ret = function(par);
  if (((par == 1.0) && (ret == 1.0)))
  {
    gray = 1.0;
  }
  gl_FragColor = vec4(gray , gray , gray , 1.0);
  vec4((((false ? true : false) && !true) ? (!false ? function(1.0) : (false ? 1.0 : 0.5)) : 0.0), -0.0, function((1.0 - (2.0 - 1.0))), 1.0);
}

float function(float par)
{
  if ((par == 1.0))
  {
    par = 0.0;
    return 1.0;
  }
  else
    return 0.0;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'function' : no matching overloaded function found
ERROR: 0:18: 'function' : no matching overloaded function found
ERROR: 0:18: 'function' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;


void main()
{
  float par = 1.0;
  float ret = 0.0;
  float gray = 0.0;
  ret = function(par);
  if (((par == 1.0) && (ret == 1.0)))
  {
    gray = 1.0;
  }
  gl_FragColor = vec4(gray , gray , gray , 1.0);
  vec4((((false ? true : false) && !true) ? (!false ? function(1.0) : (false ? 1.0 : 0.5)) : 0.0), -0.0, function((1.0 - (2.0 - 1.0))), 1.0);
}

float function(float par)
{
  if ((par == 1.0))
  {
    par = 0.0;
    return 1.0;
  }
  else
    return 0.0;
}


==============================
50.0
Mutations attempted: 18
Valid mutations:     9
Success rate:        50.00%
Processing this: /home/oof/webgl_cleaned/sqrt_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 100.0 * color.rgb;
	gl_FragColor = vec4(c / 100.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 100.0 * color.rgb;\n\tgl_FragColor = vec4(c / 100.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((1.0 / -1.0) * color.rgb);
  gl_FragColor = vec4((c / 100.0) , 1.0);
}


As vertex? : False
SUCCESS!
52.63157894736842
Processing this: /home/oof/webgl_cleaned/exp2_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = color.r;
	gl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = color.r;\n\tgl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 2.0, +(+0.0 + 1.0), -0.0);

void main()
{
  float c = color.r;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
55.00000000000001
Processing this: /home/oof/webgl_cleaned/dot_float_frag_xvaryyone_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(color.r), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(color.r), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-((false ? 0.5 : -1.0) / (true ? 0.5 : -1.0)), 1.0, (true ? -1.0 : (!false ? 0.5 : 1.0)), (!(true ? true : true) ? -1.0 : (+2.0 / (0.5 * 0.5))));

void main()
{
  gl_FragColor = vec4(vec3(color.r) , 1.0);
}


As vertex? : False
SUCCESS!
57.14285714285714
Processing this: /home/oof/webgl_cleaned/smoothstep_vec2_vert_xvary_edgeconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 edge0 = vec2(0.25, 0.25);
	const vec2 edge1 = vec2(0.75, 0.75);
	vec2 c = clamp((gtf_Color.rg - edge0) / (edge1 - edge0), 0.0, 1.0);
	color = vec4(c * c * (3.0 - 2.0 * c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge0 = vec2(0.25, 0.25);\n\tconst vec2 edge1 = vec2(0.75, 0.75);\n\tvec2 c = clamp((gtf_Color.rg - edge0) / (edge1 - edge0), 0.0, 1.0);\n\tcolor = vec4(c * c * (3.0 - 2.0 * c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge0 = vec2(0.25 , 0.25);
  const vec2 edge1 = vec2(0.75 , 0.75);
  vec2 c = clamp(((gtf_Color.rg - edge0) / (edge1 - edge0)) , 0.0);
  color = vec4(((c * c) * (3.0 - (2.0 * c))) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'clamp' : no matching overloaded function found
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: '=' : cannot convert from 'const mediump float' to 'mediump 2-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge0 = vec2(0.25 , 0.25);
  const vec2 edge1 = vec2(0.75 , 0.75);
  vec2 c = clamp(((gtf_Color.rg - edge0) / (edge1 - edge0)) , 0.0);
  color = vec4(((c * c) * (3.0 - (2.0 * c))) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
54.54545454545454
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	float c = color.r;
	gl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (1.0 / 1.0), (((true ? -1.0 : 0.0) + (true ? 0.5 : -1.0)) + (!false ? -2.0 : 2.0)), -(false ? +0.5 : 1.0));

void main()
{
  const float exp3 = 20.0855;
  float c = color.r;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
56.52173913043478
Processing this: /home/oof/webgl_cleaned/inversesqrt_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r * 99.0) + 1.0;
	color = vec4(1.0 / sqrt(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r * 99.0) + 1.0;\n\tcolor = vec4(1.0 / sqrt(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((-1.0 / 0.5), 0.5, (2.0 - ((true ? false : false) ? (0.5 - 0.0) : 1.0)), (!true ? (!false ? +1.0 : -1.0) : (1.0 - 0.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4((1.0 / sqrt(c)) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.333333333333336
Processing this: /home/oof/webgl_cleaned/brick_mat2.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec3 gtf_Normal;
attribute mat2 myAttrib2m;
uniform mat3 gtf_NormalMatrix;
varying float lightIntensity;
varying vec3  Position;
uniform vec3  LightPosition;
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
const float specularContribution = 0.7;
const float diffuseContribution  = (1.0 - specularContribution);
void main() {
    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;
    Position        = vec3(gtf_Vertex);
    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);
    vec3 lightVec   = normalize(LightPosition - vec3(pos));
    vec3 reflectVec = reflect(lightVec, tnorm);
    vec3 viewVec    = normalize(vec3(pos));
	float f = myAttrib2m[0][0];
	float spec = clamp(dot(reflectVec, viewVec), f, 1.0);
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +
                     specularContribution * spec;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec3 gtf_Normal;\nattribute mat2 myAttrib2m;\nuniform mat3 gtf_NormalMatrix;\nvarying float lightIntensity;\nvarying vec3  Position;\nuniform vec3  LightPosition;\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nconst float specularContribution = 0.7;\nconst float diffuseContribution  = (1.0 - specularContribution);\nvoid main() {\n    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;\n    Position        = vec3(gtf_Vertex);\n    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);\n    vec3 lightVec   = normalize(LightPosition - vec3(pos));\n    vec3 reflectVec = reflect(lightVec, tnorm);\n    vec3 viewVec    = normalize(vec3(pos));\n\tfloat f = myAttrib2m[0][0];\n\tfloat spec = clamp(dot(reflectVec, viewVec), f, 1.0);\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +\n                     specularContribution * spec;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec3 gtf_Normal = vec3((true ? ((true ? -1.0 : -1.0) * (false ? 2.0 : 1.0)) : (-1.0 / 0.5)), -1.0, --1.0);

mat2 myAttrib2m;

uniform mat3 gtf_NormalMatrix;

float lightIntensity;

vec3 Position;

uniform vec3 LightPosition;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float f = myAttrib2m[0][0];
  float spec = clamp(dot(reflectVec , viewVec) , f , 1.0);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec3 gtf_Normal = vec3((true ? ((true ? -1.0 : -1.0) * (false ? 2.0 : 1.0)) : (-1.0 / 0.5)), -1.0, --1.0);

mat2 myAttrib2m;

uniform mat3 gtf_NormalMatrix;

float lightIntensity;

vec3 Position;

uniform vec3 LightPosition;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float f = myAttrib2m[0][0];
  float spec = clamp(dot(reflectVec , viewVec) , f , 1.0);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
56.00000000000001
Processing this: /home/oof/webgl_cleaned/max_float_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = color.r;
	gl_FragColor = vec4(max(c, max_c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(max(c, max_c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, (1.0 - 0.5), 1.0, 0.0);

void main()
{
  const float max_c = 0.5;
  float c = color.r;
  gl_FragColor = vec4(max(c , max_c) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
57.692307692307686
Processing this: /home/oof/webgl_cleaned/sign_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 2.0 * (gtf_Color.r - 0.5);
	color = vec4(c * sign(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(c * sign(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  color = vec4(0.5, 1.0, -1.0, +1.0)((c * sign(c)) , 0.0 , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  color = vec4(0.5, 1.0, -1.0, +1.0)((c * sign(c)) , 0.0 , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
55.55555555555556
Processing this: /home/oof/webgl_cleaned/equal_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 eq(in bvec3 a, in bvec3 b)
{
	bvec3 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] == b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	vec3 result = vec3(eq(bvec3(c), bvec3(true)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 eq(in bvec3 a, in bvec3 b)\n{\n\tbvec3 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] == b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tvec3 result = vec3(eq(bvec3(c), bvec3(true)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 eq(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  vec3 result = vec3(eq(bvec3(c) , bvec3(true)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
57.14285714285714
Mutations attempted: 28
Valid mutations:     16
Success rate:        57.14%
Processing this: /home/oof/webgl_cleaned/mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat2 a = mat2(1.0, 2.0,
	              4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat2 a = mat2(1.0, 2.0,\n\t              4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, (-1.0 + 0.0), -1.0, 0.5);

void main()
{
  float x;
  mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.620689655172406
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(ivec2(c) , ivec2(0)));
  gl_FragColor = color(result , 0.0);
  ivec2(8, +1);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gl_FragColor' : undeclared identifier
ERROR: 0:10: 'color' : function name expected
ERROR: 0:10: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(ivec2(c) , ivec2(0)));
  gl_FragColor = color(result , 0.0);
  ivec2(8, +1);
}


==============================
56.666666666666664
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 ne(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(ne(c, vec3(0.0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 ne(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(ne(c, vec3(0.0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? (-1.0 * 1.0) : 0.0), 0.5, 2.0, 2.0);

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
58.06451612903226
Processing this: /home/oof/webgl_cleaned/distance_vec2_frag_xvaryyhalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(distance(color.rg, vec2(0.5))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(distance(color.rg, vec2(0.5))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  2.0 = color(vec3(distance(color.rg , vec2(0.5))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'color' : function name expected
ERROR: 0:8: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  2.0 = color(vec3(distance(color.rg , vec2(0.5))));
}


==============================
56.25
Processing this: /home/oof/webgl_cleaned/log2_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 31.0 * color.r + 1.0;
	gl_FragColor = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 31.0 * color.r + 1.0;\n\tgl_FragColor = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = ((31.0 * color.r) + 1.0);
  gl_FragColor = vec4((log2(c) / 5.0) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = ((31.0 * color.r) + 1.0);
  gl_FragColor = vec4((log2(c) / 5.0) , 0.0 , 0.0);
}


==============================
54.54545454545454
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat2 m1 = mat2(gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.a);
	mat2 m2 = mat2(1.0, 0.5, 0.5, 1.0);
	mat2 m3 = mat2(0.0);
	m3 = matrixCompMult(m1, m2);
	color = vec4(m3[0][0], m3[1][0], m3[0][1], m3[1][1]);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m1 = mat2(gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.a);\n\tmat2 m2 = mat2(1.0, 0.5, 0.5, 1.0);\n\tmat2 m3 = mat2(0.0);\n\tm3 = matrixCompMult(m1, m2);\n\tcolor = vec4(m3[0][0], m3[1][0], m3[0][1], m3[1][1]);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, (0.0 + -1.0), -1.0, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat2 m1 = mat2(gtf_Color.r , gtf_Color.g , gtf_Color.b , gtf_Color.a);
  mat2 m2 = mat2(1.0 , 0.5 , 0.5 , 1.0);
  mat2 m3 = mat2(0.0);
  m3 = matrixCompMult(m1 , m2);
  color = vec4(m3[0][0] , m3[1][0] , m3[0][1] , m3[1][1]);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
55.88235294117647
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	vec2 c = gtf_Color.rg;
	color = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, -0.5, 0.0, 0.5, 1.0, -1.0, 2.0, -0.5, 0.5, 1.0, 0.5, -0.5, 1.0, 2.0, -1.0, 2.0);

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, -0.5, 0.0, 0.5, 1.0, -1.0, 2.0, -0.5, 0.5, 1.0, 0.5, -0.5, 1.0, 2.0, -1.0, 2.0);

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
54.285714285714285
Processing this: /home/oof/webgl_cleaned/refract_float_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 2.0, -1.0, +((false ? 0.0 : 1.0) / 0.0));

void main()
{
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
55.55555555555556
Processing this: /home/oof/webgl_cleaned/max_float_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = color.r;
	gl_FragColor = vec4(max(c, max_c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(max(c, max_c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = color.r;
  gl_FragColor = vec4(max(c , max_c) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
56.75675675675676
Processing this: /home/oof/webgl_cleaned/const_mat4_copy_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	mat4 b = a;
	bool elms = true;
	if(b[0][0] !=  1.0) elms = false;
	if(b[0][1] !=  2.0) elms = false;
	if(b[0][2] !=  3.0) elms = false;
	if(b[0][3] !=  4.0) elms = false;
	if(b[1][0] !=  5.0) elms = false;
	if(b[1][1] !=  6.0) elms = false;
	if(b[1][2] !=  7.0) elms = false;
	if(b[1][3] !=  8.0) elms = false;
	if(b[2][0] !=  9.0) elms = false;
	if(b[2][1] != 10.0) elms = false;
	if(b[2][2] != 11.0) elms = false;
	if(b[2][3] != 12.0) elms = false;
	if(b[3][0] != 13.0) elms = false;
	if(b[3][1] != 14.0) elms = false;
	if(b[3][2] != 15.0) elms = false;
	if(b[3][3] != 16.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0] + b[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = b[0][1] + b[1][1] + b[2][1] + b[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = b[0][2] + b[1][2] + b[2][2] + b[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = b[0][3] + b[1][3] + b[2][3] + b[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2] + b[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = b[1][0] + b[1][1] + b[1][2] + b[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2] + b[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = b[3][0] + b[3][1] + b[3][2] + b[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tmat4 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=  1.0) elms = false;\n\tif(b[0][1] !=  2.0) elms = false;\n\tif(b[0][2] !=  3.0) elms = false;\n\tif(b[0][3] !=  4.0) elms = false;\n\tif(b[1][0] !=  5.0) elms = false;\n\tif(b[1][1] !=  6.0) elms = false;\n\tif(b[1][2] !=  7.0) elms = false;\n\tif(b[1][3] !=  8.0) elms = false;\n\tif(b[2][0] !=  9.0) elms = false;\n\tif(b[2][1] != 10.0) elms = false;\n\tif(b[2][2] != 11.0) elms = false;\n\tif(b[2][3] != 12.0) elms = false;\n\tif(b[3][0] != 13.0) elms = false;\n\tif(b[3][1] != 14.0) elms = false;\n\tif(b[3][2] != 15.0) elms = false;\n\tif(b[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0] + b[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1] + b[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2] + b[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = b[0][3] + b[1][3] + b[2][3] + b[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2] + b[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2] + b[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2] + b[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = b[3][0] + b[3][1] + b[3][2] + b[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 3.0))
    elms = false;
  if ((b[0][3] != 4.0))
    elms = false;
  if ((b[1][0] != 5.0))
    elms = false;
  if ((b[1][1] != 6.0))
    elms = false;
  if ((b[1][2] != 7.0))
    elms = false;
  if ((b[1][3] != 8.0))
    elms = false;
  if ((b[2][0] != 9.0))
    elms = false;
  if ((b[2][1] != 10.0))
    elms = false;
  if ((b[2][2] != 11.0))
    elms = false;
  if ((b[2][3] != 12.0))
    elms = false;
  if ((b[3][0] != 13.0))
    elms = false;
  if ((b[3][1] != 14.0))
    elms = false;
  if ((b[3][2] != 15.0))
    elms = false;
  if ((b[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  vec4(0.0, -0.5, -0.5, 0.0) = (((b[0][0] + b[0][1]) + b[16][2]) + b[-2][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:56: '[]' : matrix field selection out of range
ERROR: 0:56: '[]' : index expression is negative
ERROR: 0:56: 'assign' : l-value required (can't modify a const)
ERROR: 0:56: '=' : dimension mismatch
ERROR: 0:56: 'assign' : cannot convert from 'mediump float' to 'const 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 3.0))
    elms = false;
  if ((b[0][3] != 4.0))
    elms = false;
  if ((b[1][0] != 5.0))
    elms = false;
  if ((b[1][1] != 6.0))
    elms = false;
  if ((b[1][2] != 7.0))
    elms = false;
  if ((b[1][3] != 8.0))
    elms = false;
  if ((b[2][0] != 9.0))
    elms = false;
  if ((b[2][1] != 10.0))
    elms = false;
  if ((b[2][2] != 11.0))
    elms = false;
  if ((b[2][3] != 12.0))
    elms = false;
  if ((b[3][0] != 13.0))
    elms = false;
  if ((b[3][1] != 14.0))
    elms = false;
  if ((b[3][2] != 15.0))
    elms = false;
  if ((b[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  vec4(0.0, -0.5, -0.5, 0.0) = (((b[0][0] + b[0][1]) + b[16][2]) + b[-2][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
55.26315789473685
Mutations attempted: 38
Valid mutations:     21
Success rate:        55.26%
Processing this: /home/oof/webgl_cleaned/exp2_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = color.rgb;
	gl_FragColor = vec4(exp2(5.0 * c) / 32.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(exp2(5.0 * c) / 32.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0) , 1.0);
}


As vertex? : False
SUCCESS!
56.41025641025641
Processing this: /home/oof/webgl_cleaned/const_mat3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0,   2.0,   4.0,
	                     8.0,  16.0,  32.0,
	                    64.0, 128.0, 256.0);
	bool elms = true;
	if(a[0][0] !=   1.0) elms = false;
	if(a[0][1] !=   2.0) elms = false;
	if(a[0][2] !=   4.0) elms = false;
	if(a[1][0] !=   8.0) elms = false;
	if(a[1][1] !=  16.0) elms = false;
	if(a[1][2] !=  32.0) elms = false;
	if(a[2][0] !=  64.0) elms = false;
	if(a[2][1] != 128.0) elms = false;
	if(a[2][2] != 256.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0];
	if( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;
	x = a[0][1] + a[1][1] + a[2][1];
	if(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;
	x = a[0][2] + a[1][2] + a[2][2];
	if(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2];
	if( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;
	x = a[1][0] + a[1][1] + a[1][2];
	if(x < 56.0-0.1 || x > 56.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2];
	if(x < 448.0-0.1 || x > 448.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0,   2.0,   4.0,\n\t                     8.0,  16.0,  32.0,\n\t                    64.0, 128.0, 256.0);\n\tbool elms = true;\n\tif(a[0][0] !=   1.0) elms = false;\n\tif(a[0][1] !=   2.0) elms = false;\n\tif(a[0][2] !=   4.0) elms = false;\n\tif(a[1][0] !=   8.0) elms = false;\n\tif(a[1][1] !=  16.0) elms = false;\n\tif(a[1][2] !=  32.0) elms = false;\n\tif(a[2][0] !=  64.0) elms = false;\n\tif(a[2][1] != 128.0) elms = false;\n\tif(a[2][2] != 256.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0];\n\tif( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1];\n\tif(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2];\n\tif(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2];\n\tif( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2];\n\tif(x < 56.0-0.1 || x > 56.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2];\n\tif(x < 448.0-0.1 || x > 448.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, ((true ? true : false) ? (false ? 2.0 : -1.0) : 0.0), -((false && true) ? -1.0 : 1.0), (((true && true) ? !true : true) ? (2.0 * (false ? 0.0 : 0.5)) : 1.0), ((false ? (0.5 * 2.0) : 2.0) / 1.0), ++(0.5 - 0.0), (!!true ? (2.0 / (true ? -1.0 : 0.0)) : +2.0), (false ? 0.0 : (+2.0 - +0.0)), -1.0, 0.0, (false ? (true ? -1.0 : 2.0) : +(0.5 + 2.0)), 1.0, 1.0, (!(true ? true : false) ? 0.0 : 0.0), ++-1.0, 2.0);

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 4.0))
    elms = false;
  if ((a[1][0] != 8.0))
    elms = false;
  if ((a[1][1] != 16.0))
    elms = false;
  if ((a[1][2] != 32.0))
    elms = false;
  if ((a[2][0] != 64.0))
    elms = false;
  if ((a[2][1] != 128.0))
    elms = false;
  if ((a[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((a[0][0] + a[1][0]) + a[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((a[0][1] + a[1][1]) + a[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((a[0][2] + a[1][2]) + a[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((a[0][0] + a[0][1]) + a[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((a[1][0] + a[1][1]) + a[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((a[2][0] + a[2][1]) + a[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '++' : l-value required (can't modify a const)
ERROR: 0:6: '++' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, ((true ? true : false) ? (false ? 2.0 : -1.0) : 0.0), -((false && true) ? -1.0 : 1.0), (((true && true) ? !true : true) ? (2.0 * (false ? 0.0 : 0.5)) : 1.0), ((false ? (0.5 * 2.0) : 2.0) / 1.0), ++(0.5 - 0.0), (!!true ? (2.0 / (true ? -1.0 : 0.0)) : +2.0), (false ? 0.0 : (+2.0 - +0.0)), -1.0, 0.0, (false ? (true ? -1.0 : 2.0) : +(0.5 + 2.0)), 1.0, 1.0, (!(true ? true : false) ? 0.0 : 0.0), ++-1.0, 2.0);

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 4.0))
    elms = false;
  if ((a[1][0] != 8.0))
    elms = false;
  if ((a[1][1] != 16.0))
    elms = false;
  if ((a[1][2] != 32.0))
    elms = false;
  if ((a[2][0] != 64.0))
    elms = false;
  if ((a[2][1] != 128.0))
    elms = false;
  if ((a[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((a[0][0] + a[1][0]) + a[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((a[0][1] + a[1][1]) + a[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((a[0][2] + a[1][2]) + a[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((a[0][0] + a[0][1]) + a[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((a[1][0] + a[1][1]) + a[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((a[2][0] + a[2][1]) + a[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
55.00000000000001
Processing this: /home/oof/webgl_cleaned/matrixVSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, -1.0, 1.0, 2.0);

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
56.09756097560976
Processing this: /home/oof/webgl_cleaned/4i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec4 color;
void main ()
{
	gl_FragColor = vec4 (color[0], color[1], color[2], color[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0], color[1], color[2], color[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec4 color;

void main()
{
  gl_FragColor = 2.0(color[0] , color[1] , color[2]);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'gl_FragColor' : undeclared identifier
ERROR: 0:8: 'assign' : l-value required (can't modify a const)
ERROR: 0:8: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform ivec4 color;

void main()
{
  gl_FragColor = 2.0(color[0] , color[1] , color[2]);
}


==============================
54.761904761904766
Processing this: /home/oof/webgl_cleaned/ivec4_empty_inout_ivec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(inout ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(inout ivec4 par)
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(inout ivec4 par);\nbool is_all(const in ivec4 par, const in int value);\nvoid set_all(out ivec4 par, const in int value);\nvoid main ()\n{\n\tivec4 par = ivec4(1, 1, 1, 1);\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(inout ivec4 par)\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 par, const in int value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 1.0, -0.0, (0.0 / ++0.5), +((true ? 0.5 : 0.0) - -1.0), 0.0, 2.0, (-1.0 + -+2.0), 0.0, (-1.0 - 0.5), 0.0, +((false ? 2.0 : -1.0) * 1.0), (2.0 / (-1.0 - 1.0)), 2.0, 2.0, 0.0);

vec4 color;




void main()
{
  ivec4 par = ivec4(1 , 1 , 1 , 1);
  ivec4 ret = ivec4(0 , 0 , 0 , 0);
  float gray = 0.0;
  ret = function(par);
  if ((is_all(par , 0) && is_all(ret , 1)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

ivec4 function(inout ivec4 par)
{
  if (is_all(par , 1))
  {
    set_all(par , 0);
    return ivec4(1 , 1 , 1 , 1);
  }
  else
    return ivec4(0 , 0 , 0 , 0);
}

bool is_all(const in ivec4 par, const in int value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}

void set_all(out ivec4 par, const in int value)
{
  par[0] = value;
  par[1] = value;
  par[2] = value;
  par[3] = value;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '++' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions
ERROR: 0:18: 'function' : no matching overloaded function found
ERROR: 0:18: 'assign' : cannot convert from 'const mediump float' to 'mediump 4-component vector of int'
ERROR: 0:19: 'is_all' : no matching overloaded function found
ERROR: 0:19: 'is_all' : no matching overloaded function found
ERROR: 0:19: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const mediump float' and a right operand of type 'const mediump float' (or there is no acceptable conversion)
ERROR: 0:29: 'is_all' : no matching overloaded function found
ERROR: 0:31: 'set_all' : no matching overloaded function found
ERROR: 0:29: '' : boolean expression expected

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 1.0, -0.0, (0.0 / ++0.5), +((true ? 0.5 : 0.0) - -1.0), 0.0, 2.0, (-1.0 + -+2.0), 0.0, (-1.0 - 0.5), 0.0, +((false ? 2.0 : -1.0) * 1.0), (2.0 / (-1.0 - 1.0)), 2.0, 2.0, 0.0);

vec4 color;




void main()
{
  ivec4 par = ivec4(1 , 1 , 1 , 1);
  ivec4 ret = ivec4(0 , 0 , 0 , 0);
  float gray = 0.0;
  ret = function(par);
  if ((is_all(par , 0) && is_all(ret , 1)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

ivec4 function(inout ivec4 par)
{
  if (is_all(par , 1))
  {
    set_all(par , 0);
    return ivec4(1 , 1 , 1 , 1);
  }
  else
    return ivec4(0 , 0 , 0 , 0);
}

bool is_all(const in ivec4 par, const in int value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}

void set_all(out ivec4 par, const in int value)
{
  par[0] = value;
  par[1] = value;
  par[2] = value;
  par[3] = value;
}


==============================
53.48837209302325
Processing this: /home/oof/webgl_cleaned/non-ascii-comments.vert
Original source code: 
precision mediump float;
precision mediump int;

void main() {
  gl_Position = vec4(1,1,1,1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main() {\n  gl_Position = vec4(1,1,1,1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  vec4(1 , 1 , 1) = gl_Position;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'constructor' : not enough data provided for construction
ERROR: 0:6: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  vec4(1 , 1 , 1) = gl_Position;
}


==============================
52.27272727272727
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvaryyvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (color.ggg - 0.5);
	vec3 y = 2.0 * (color.bbb - 0.5);
	vec3 c;
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		if(x[0] < 0.0 ^^ y[0] < 0.0)
		{
			sign[0] = -1.0;
		}
		if(abs(y[0]) <= abs(x[0]))
		{
			c[0] = abs(y[0] / x[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[0] = abs(x[0] / y[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;
		}
		if(x[0] < 0.0)
			if(y[0] < 0.0) result[0] -= 0.5;
			else if(y[0] > 0.0) result[0] += 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		if(x[1] < 0.0 ^^ y[1] < 0.0)
		{
			sign[1] = -1.0;
		}
		if(abs(y[1]) <= abs(x[1]))
		{
			c[1] = abs(y[1] / x[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[1] = abs(x[1] / y[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;
		}
		if(x[1] < 0.0)
			if(y[1] < 0.0) result[1] -= 0.5;
			else if(y[1] > 0.0) result[1] += 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		if(x[2] < 0.0 ^^ y[2] < 0.0)
		{
			sign[2] = -1.0;
		}
		if(abs(y[2]) <= abs(x[2]))
		{
			c[2] = abs(y[2] / x[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[2] = abs(x[2] / y[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;
		}
		if(x[2] < 0.0)
			if(y[2] < 0.0) result[2] -= 0.5;
			else if(y[2] > 0.0) result[2] += 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 x = 2.0 * (color.ggg - 0.5);\n\tvec3 y = 2.0 * (color.bbb - 0.5);\n\tvec3 c;\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tif(x[0] < 0.0 ^^ y[0] < 0.0)\n\t\t{\n\t\t\tsign[0] = -1.0;\n\t\t}\n\t\tif(abs(y[0]) <= abs(x[0]))\n\t\t{\n\t\t\tc[0] = abs(y[0] / x[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[0] = abs(x[0] / y[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[0] < 0.0)\n\t\t\tif(y[0] < 0.0) result[0] -= 0.5;\n\t\t\telse if(y[0] > 0.0) result[0] += 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tif(x[1] < 0.0 ^^ y[1] < 0.0)\n\t\t{\n\t\t\tsign[1] = -1.0;\n\t\t}\n\t\tif(abs(y[1]) <= abs(x[1]))\n\t\t{\n\t\t\tc[1] = abs(y[1] / x[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[1] = abs(x[1] / y[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[1] < 0.0)\n\t\t\tif(y[1] < 0.0) result[1] -= 0.5;\n\t\t\telse if(y[1] > 0.0) result[1] += 0.5;\n\t}\n\tif(x[2] > epsilon || abs(y[2]) > epsilon)\n\t{\n\t\tif(x[2] < 0.0 ^^ y[2] < 0.0)\n\t\t{\n\t\t\tsign[2] = -1.0;\n\t\t}\n\t\tif(abs(y[2]) <= abs(x[2]))\n\t\t{\n\t\t\tc[2] = abs(y[2] / x[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[2] = abs(x[2] / y[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[2] < 0.0)\n\t\t\tif(y[2] < 0.0) result[2] -= 0.5;\n\t\t\telse if(y[2] > 0.0) result[2] += 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb - 0.5));
  vec3 c;
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      sign[0] = -1.0;
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      c[0] = abs((y[0] / x[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[0] = abs((x[0] / y[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      sign[1] = -1.0;
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      c[1] = abs((y[1] / x[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[1] = abs((x[1] / y[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  if (((x[2] > epsilon) || (abs(y[2]) > epsilon)))
  {
    if (((x[2] < 0.0) ^^ (y[2] < 0.0)))
    {
      sign[2] = -1.0;
    }
    if ((abs(y[2]) <= abs(x[2])))
    {
      c[2] = abs((y[2] / x[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * atan_c[2]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[2] = abs((x[2] / y[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[2] < 0.0))
      if ((y[2] < 0.0))
        (result[2] -= 0.5);
      else
        if ((y[2] > 0.0))
          (result[2] += 0.5);
  }
  gl_FragColor = result;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb - 0.5));
  vec3 c;
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      sign[0] = -1.0;
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      c[0] = abs((y[0] / x[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[0] = abs((x[0] / y[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      sign[1] = -1.0;
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      c[1] = abs((y[1] / x[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[1] = abs((x[1] / y[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  if (((x[2] > epsilon) || (abs(y[2]) > epsilon)))
  {
    if (((x[2] < 0.0) ^^ (y[2] < 0.0)))
    {
      sign[2] = -1.0;
    }
    if ((abs(y[2]) <= abs(x[2])))
    {
      c[2] = abs((y[2] / x[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * atan_c[2]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[2] = abs((x[2] / y[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[2] < 0.0))
      if ((y[2] < 0.0))
        (result[2] -= 0.5);
      else
        if ((y[2] > 0.0))
          (result[2] += 0.5);
  }
  gl_FragColor = result;
}


==============================
51.11111111111111
Processing this: /home/oof/webgl_cleaned/equal_bvec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(equal(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(equal(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+-1.0, ((false ? (false ? -1.0 : 2.0) : -0.0) * 1.0), (false ? 0.5 : ((false ? 0.0 : 0.5) - 1.0)), 0.5);

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(equal(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
52.17391304347826
Processing this: /home/oof/webgl_cleaned/bvec4_empty_empty_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;





void main()
{
  bvec4 par[3];
  bvec4 ret = bvec4(false , false , false , false);
  float gray = 0.0;
  set_all(par , bvec4(true , true , true , true));
  ret = function(par);
  if ((is_all(par , bvec4(true , true , true , true)) && is_all(ret , true)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

bvec4 function(bvec4 par[3])
{
  if (is_all(par , bvec4(true , true , true , true)))
  {
    set_all(par , bvec4(false , false , false , false));
    return bvec4(true , true , true , true);
  }
  else
    return bvec4(false , false , false , false);
}

bool is_all(const in bvec4 par, const in bool value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}

bool is_all(const in bvec4 array[3], const in bvec4 value)
{
  bool ret = true;
  if ((array[0] != value))
    ret = false;
  if ((array[1] != value))
    ret = false;
  if ((array[2] != value))
    ret = false;
  return ret;
}

void set_all(out bvec4 array[3], const in bvec4 value)
{
  array[0] = value;
  array[1] = value;
  array[2] = value;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:19: 'set_all' : no matching overloaded function found
ERROR: 0:20: 'function' : no matching overloaded function found
ERROR: 0:20: 'assign' : cannot convert from 'const mediump float' to '4-component vector of bool'
ERROR: 0:21: 'is_all' : no matching overloaded function found
ERROR: 0:21: 'is_all' : no matching overloaded function found
ERROR: 0:21: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const mediump float' and a right operand of type 'const mediump float' (or there is no acceptable conversion)
ERROR: 0:31: 'is_all' : no matching overloaded function found
ERROR: 0:33: 'set_all' : no matching overloaded function found
ERROR: 0:31: '' : boolean expression expected

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;





void main()
{
  bvec4 par[3];
  bvec4 ret = bvec4(false , false , false , false);
  float gray = 0.0;
  set_all(par , bvec4(true , true , true , true));
  ret = function(par);
  if ((is_all(par , bvec4(true , true , true , true)) && is_all(ret , true)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

bvec4 function(bvec4 par[3])
{
  if (is_all(par , bvec4(true , true , true , true)))
  {
    set_all(par , bvec4(false , false , false , false));
    return bvec4(true , true , true , true);
  }
  else
    return bvec4(false , false , false , false);
}

bool is_all(const in bvec4 par, const in bool value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}

bool is_all(const in bvec4 array[3], const in bvec4 value)
{
  bool ret = true;
  if ((array[0] != value))
    ret = false;
  if ((array[1] != value))
    ret = false;
  if ((array[2] != value))
    ret = false;
  return ret;
}

void set_all(out bvec4 array[3], const in bvec4 value)
{
  array[0] = value;
  array[1] = value;
  array[2] = value;
}


==============================
51.06382978723404
Processing this: /home/oof/webgl_cleaned/ivec4_empty_empty_ivec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(ivec4 par)
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(ivec4 par);\nbool is_all(const in ivec4 par, const in int value);\nvoid set_all(out ivec4 par, const in int value);\nvoid main ()\n{\n\tivec4 par = ivec4(1, 1, 1, 1);\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(ivec4 par)\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 par, const in int value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

ivec4 function(ivec4 par)
{
  if (is_all(par , 1))
  {
    set_all(par , 0);
    return ivec4(1 , 1 , 1 , 1);
  }
  else
    return ivec4(0 , 0 , 0 , 0);
}

void main()
{
  ivec4 par = ivec4(1 , 1 , 1 , 1);
  ivec4 ret = ivec4(0 , 0 , 0 , 0);
  float gray = 0.0;
  ret = function(par);
  if ((is_all(par , 1) && is_all(ret , 1)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

bool is_all(const in ivec4 par, const in int value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}


void set_all(out ivec4 par, const in int value)
{
  par[0] = value;
  par[1] = value;
  par[2] = value;
  par[3] = value;
}


uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;


vec4 gtf_Vertex;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'is_all' : no matching overloaded function found
ERROR: 0:8: 'set_all' : no matching overloaded function found
ERROR: 0:6: '' : boolean expression expected
ERROR: 0:21: 'is_all' : no matching overloaded function found
ERROR: 0:21: 'is_all' : no matching overloaded function found
ERROR: 0:21: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const mediump float' and a right operand of type 'const mediump float' (or there is no acceptable conversion)
ERROR: 0:25: 'color' : undeclared identifier
ERROR: 0:25: 'assign' : l-value required (can't modify a const)
ERROR: 0:25: '=' : dimension mismatch
ERROR: 0:25: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const highp float'
ERROR: 0:26: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:26: 'gtf_Vertex' : undeclared identifier
ERROR: 0:26: '=' : dimension mismatch
ERROR: 0:26: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

ivec4 function(ivec4 par)
{
  if (is_all(par , 1))
  {
    set_all(par , 0);
    return ivec4(1 , 1 , 1 , 1);
  }
  else
    return ivec4(0 , 0 , 0 , 0);
}

void main()
{
  ivec4 par = ivec4(1 , 1 , 1 , 1);
  ivec4 ret = ivec4(0 , 0 , 0 , 0);
  float gray = 0.0;
  ret = function(par);
  if ((is_all(par , 1) && is_all(ret , 1)))
  {
    gray = 1.0;
  }
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

bool is_all(const in ivec4 par, const in int value)
{
  bool ret = true;
  if ((par[0] != value))
    ret = false;
  if ((par[1] != value))
    ret = false;
  if ((par[2] != value))
    ret = false;
  if ((par[3] != value))
    ret = false;
  return ret;
}


void set_all(out ivec4 par, const in int value)
{
  par[0] = value;
  par[1] = value;
  par[2] = value;
  par[3] = value;
}


uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;


vec4 gtf_Vertex;


==============================
50.0
Mutations attempted: 48
Valid mutations:     24
Success rate:        50.00%
Processing this: /home/oof/webgl_cleaned/notEqual_ivec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 ne(in ivec3 a, in ivec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(ne(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 ne(in ivec3 a, in ivec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(ne(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 ne(in ivec3 a, in ivec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[2] != b[0]))
    result[3] = true;
  else
    b[-(1 % 4)] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(ne(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: '[]' : vector field selection out of range
ERROR: 0:16: '%' : integer modulus operator supported in GLSL ES 3.00 and above only
ERROR: 0:16: '[]' : index expression is negative
ERROR: 0:16: 'assign' : cannot convert from 'const bool' to 'mediump int'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec3 ne(in ivec3 a, in ivec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[2] != b[0]))
    result[3] = true;
  else
    b[-(1 % 4)] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(ne(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


==============================
48.97959183673469
Processing this: /home/oof/webgl_cleaned/min_float_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.5;
	float c = gtf_Color.r;
	if(c > min_c) c = min_c;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.5;\n\tfloat c = gtf_Color.r;\n\tif(c > min_c) c = min_c;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-0.5, 1.0, 0.0, 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float min_c = 0.5;
  float c = gtf_Color.r;
  if ((c > min_c))
    c = min_c;
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/struct_bool_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	bool a;
	bool b;
	bool c;
	bool d;
};
void main ()
{
	sabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));
	float gray = 0.0;
	if( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tbool a;\n\tbool b;\n\tbool c;\n\tbool d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));\n\tfloat gray = 0.0;\n\tif( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
50.98039215686274
Processing this: /home/oof/webgl_cleaned/atan_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 4.0 * 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(atan(c) / M_PI + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 4.0 * 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(atan(c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? 0.5 : 2.0), -1.0, 0.5, --1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (color.r - 0.5));
  gl_FragColor = vec4(((atan(c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? 0.5 : 2.0), -1.0, 0.5, --1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (color.r - 0.5));
  gl_FragColor = vec4(((atan(c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconst2_yvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.0, (-1.0 + --0.0), 2.0);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4((pow(vec3(2.0) , (2.0 * c)) / 4.0) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.0, (-1.0 + --0.0), 2.0);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4((pow(vec3(2.0) , (2.0 * c)) / 4.0) , 1.0);
}


==============================
49.056603773584904
Processing this: /home/oof/webgl_cleaned/extension2_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
49.056603773584904
Processing this: /home/oof/webgl_cleaned/exp_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	vec2 c = color.rg;
	gl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = color.rg;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  ivec2(-0.5, 0.0);
}


As vertex? : False
SUCCESS!
50.0
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 lte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lte(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 lte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lte(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  return result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
50.90909090909091
Processing this: /home/oof/webgl_cleaned/ceil_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((true && (false || false)) ? +0.0 : 1.0), 0.0, (false ? ++1.0 : 0.0), +((true ? 2.0 : 2.0) * 1.0));

void main()
{
  vec2 c = ((10.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 1.0);
}


As vertex? : False
