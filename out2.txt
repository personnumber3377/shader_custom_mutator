Using this seed: 10137
Mutations attempted: 0
Valid mutations:     0
Success rate:        0.00%
Processing this: /home/oof/webgl_cleaned/bvec4_empty_inout_bvec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec4 function(inout bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, false) && is_all(ret, true))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bvec4 function(inout bvec4 par)
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec4 function(inout bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, false) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbvec4 function(inout bvec4 par)\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
Processing this: /home/oof/webgl_cleaned/inversesqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r * 99.0) + 1.0;
	color = vec4(inversesqrt(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r * 99.0) + 1.0;\n\tcolor = vec4(inversesqrt(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((false ? +2.0 : -1.0), 2.0, 0.5, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4(inversesqrt(c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
100.0
Processing this: /home/oof/webgl_cleaned/bvec4_empty_in_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(in bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(in bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(in bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(in bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
100.0
Processing this: /home/oof/webgl_cleaned/dot_vec3_frag_xvaryythird.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(dot(color.rgb, vec3(0.3333))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(dot(color.rgb, vec3(0.3333))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(dot(color.rgb , vec3(0.3333))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(dot(color.rgb , vec3(0.3333))));
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/ivec4_empty_inout_ivec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(inout ivec4 par[3]);
bool is_all(const in ivec4 par, const in int value);
bool is_all(const in ivec4 array[3], const in ivec4 value);
void set_all(out ivec4 array[3], const in ivec4 value);
void main ()
{
	ivec4 par[3];
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	set_all(par, ivec4(1, 1, 1, 1));
	ret = function(par);
	if(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(inout ivec4 par[3])
{
	if(is_all(par, ivec4(1, 1, 1, 1)))
	{
		set_all(par, ivec4(0, 0, 0, 0));
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in ivec4 array[3], const in ivec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 array[3], const in ivec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(inout ivec4 par[3]);\nbool is_all(const in ivec4 par, const in int value);\nbool is_all(const in ivec4 array[3], const in ivec4 value);\nvoid set_all(out ivec4 array[3], const in ivec4 value);\nvoid main ()\n{\n\tivec4 par[3];\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tset_all(par, ivec4(1, 1, 1, 1));\n\tret = function(par);\n\tif(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(inout ivec4 par[3])\n{\n\tif(is_all(par, ivec4(1, 1, 1, 1)))\n\t{\n\t\tset_all(par, ivec4(0, 0, 0, 0));\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in ivec4 array[3], const in ivec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 array[3], const in ivec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
50.0
Processing this: /home/oof/webgl_cleaned/mat4_empty_out_mat4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
mat4 function(out mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(out mat4 par)
{
	set_all(par, 0.0);
	return mat4(1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nmat4 function(out mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(out mat4 par)\n{\n\tset_all(par, 0.0);\n\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
50.0
Processing this: /home/oof/webgl_cleaned/acos_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	vec3 acos_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	if(c.r < 0.0)
	{
		sign.r = -1.0;
		c.r *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.r += scale.r * pow(c.r, float(i)) / float(i);
		scale.r *= float(i) / float(i + 1);
	}
	acos_c.r = M_PI / 2.0 - sign.r * acos_c.r;
	if(c.g < 0.0)
	{
		sign.g = -1.0;
		c.g *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.g += scale.g * pow(c.g, float(i)) / float(i);
		scale.g *= float(i) / float(i + 1);
	}
	acos_c.g = M_PI / 2.0 - sign.g * acos_c.g;
	if(c.b < 0.0)
	{
		sign.b = -1.0;
		c.b *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.b += scale.b * pow(c.b, float(i)) / float(i);
		scale.b *= float(i) / float(i + 1);
	}
	acos_c.b = M_PI / 2.0 - sign.b * acos_c.b;
	color = vec4(acos_c / M_PI, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 acos_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tif(c.r < 0.0)\n\t{\n\t\tsign.r = -1.0;\n\t\tc.r *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.r += scale.r * pow(c.r, float(i)) / float(i);\n\t\tscale.r *= float(i) / float(i + 1);\n\t}\n\tacos_c.r = M_PI / 2.0 - sign.r * acos_c.r;\n\tif(c.g < 0.0)\n\t{\n\t\tsign.g = -1.0;\n\t\tc.g *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.g += scale.g * pow(c.g, float(i)) / float(i);\n\t\tscale.g *= float(i) / float(i + 1);\n\t}\n\tacos_c.g = M_PI / 2.0 - sign.g * acos_c.g;\n\tif(c.b < 0.0)\n\t{\n\t\tsign.b = -1.0;\n\t\tc.b *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.b += scale.b * pow(c.b, float(i)) / float(i);\n\t\tscale.b *= float(i) / float(i + 1);\n\t}\n\tacos_c.b = M_PI / 2.0 - sign.b * acos_c.b;\n\tcolor = vec4(acos_c / M_PI, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-+0.5, ((true ? false : (true ? false : false)) ? (0.5 / (-1.0 * 0.0)) : 0.0), -1.0, (-1.0 * (false ? (2.0 + 0.5) : -1.0)));

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  vec3 acos_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  if ((c.r < 0.0))
  {
    sign.r = -1.0;
    (c.r *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.r += ((scale.r * pow(c.r , float(i))) / float(i)));
    (scale.r *= (float(i) / float((i + 1))));
  }
  acos_c.r = ((M_PI / 2.0) - (sign.r * acos_c.r));
  if ((c.g < 0.0))
  {
    sign.g = -1.0;
    (c.g *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.g += ((scale.g * pow(c.g , float(i))) / float(i)));
    (scale.g *= (float(i) / float((i + 1))));
  }
  acos_c.g = ((M_PI / 2.0) - (sign.g * acos_c.g));
  if ((c.b < 0.0))
  {
    sign.b = -1.0;
    (c.b *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.b += ((scale.b * pow(c.b , float(i))) / float(i)));
    (scale.b *= (float(i) / float((i + 1))));
  }
  acos_c.b = ((M_PI / 2.0) - (sign.b * acos_c.b));
  color = vec4((acos_c / M_PI) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/lessThanEqual_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((1.0 / 0.5), 2.0, 0.0, 0.0);

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
75.0
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	float c = color.r;
	gl_FragColor = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, 1.0, 0.5, -0.5);

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  float c = color.r;
  gl_FragColor = vec4((pow(exp1 , (3.0 * c)) / exp3) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
80.0
Processing this: /home/oof/webgl_cleaned/mix_float_vert_xvary_yconsthalf_aconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float y = 0.5;
	const float a = 0.5;
	float c = gtf_Color.r;
	color = vec4(mix(c, y, a), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float y = 0.5;\n\tconst float a = 0.5;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(mix(c, y, a), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = (!(false ? false : true) ? vec4(((2.0 + 1.0) - ((true && true) ? 0.0 : (1.0 - 1.0))), (-1.0 + 0.0), 0.0, (0.0 - ((true ? true : false) ? (true ? -1.0 : 0.0) : 2.0))) : vec4(-1.0, -1.0, (((true && true) ? (0.5 / 2.0) : (0.5 * -1.0)) + +-0.0), --1.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float y = 0.5;
  const float a = 0.5;
  float c = gtf_Color.r;
  color = vec4(mix(c , y , a) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = (!(false ? false : true) ? vec4(((2.0 + 1.0) - ((true && true) ? 0.0 : (1.0 - 1.0))), (-1.0 + 0.0), 0.0, (0.0 - ((true ? true : false) ? (true ? -1.0 : 0.0) : 2.0))) : vec4(-1.0, -1.0, (((true && true) ? (0.5 / 2.0) : (0.5 * -1.0)) + +-0.0), --1.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float y = 0.5;
  const float a = 0.5;
  float c = gtf_Color.r;
  color = vec4(mix(c , y , a) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
66.66666666666666
Mutations attempted: 6
Valid mutations:     4
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/atan_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 4.0 * 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(atan(c) / M_PI + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 4.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(atan(c) / M_PI + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-1.0, ((0.5 + 1.0) / ((false || true) ? (0.0 + 1.0) : 0.5)), 0.0, 2.0);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((atan(c) / M_PI) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
71.42857142857143
Processing this: /home/oof/webgl_cleaned/reflect_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (-1.0 / (0.5 / -1.0)), 0.0, +--1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (-1.0 / (0.5 / -1.0)), 0.0, +--1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Processing this: /home/oof/webgl_cleaned/vertexOnly2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    gl_Position = vec4(4.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    gl_Position = vec4(4.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(4.0);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/4i_vert.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 col;
void main ()
{
	gl_FragColor = vec4 (col[0], col[1], col[2], col[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 col;\nvoid main ()\n{\n\tgl_FragColor = vec4 (col[0], col[1], col[2], col[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 col = vec4(1.0, ((false ? (false ? 2.0 : -1.0) : 0.0) * 0.5), (+(1.0 * 0.5) + +0.0), 0.5);

void main()
{
  gl_FragColor = vec4(col[0] , col[1] , col[2] , col[3]);
}


As vertex? : False
SUCCESS!
70.0
Processing this: /home/oof/webgl_cleaned/vec3_vec2_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 b = vec2(13.0, 53.0);
	vec3 a = vec3(b, 139.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 b = vec2(13.0, 53.0);\n\tvec3 a = vec3(b, 139.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 b = vec2(13.0 , 53.0);
  vec3 a = vec3(b , 139.0);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 b = vec2(13.0 , 53.0);
  vec3 a = vec3(b , 139.0);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray);
}


==============================
63.63636363636363
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par[3])
{
	set_all(par, 0);
	return 1;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par[3])\n{\n\tset_all(par, 0);\n\treturn 1;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.63636363636363
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat2 m1 = mat2(color.rg, color.ba);
	mat2 m2 = mat2(1.0, 0.5, 0.5, 1.0);
	mat2 m3 = mat2(0.0);
	m3[0][0] = m1[0][0] * m2[0][0];
	m3[0][1] = m1[0][1] * m2[0][1];
	m3[1][0] = m1[1][0] * m2[1][0];
	m3[1][1] = m1[1][1] * m2[1][1];
	gl_FragColor = vec4(m3[0][0], m3[1][0], m3[0][1], m3[1][1]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m1 = mat2(color.rg, color.ba);\n\tmat2 m2 = mat2(1.0, 0.5, 0.5, 1.0);\n\tmat2 m3 = mat2(0.0);\n\tm3[0][0] = m1[0][0] * m2[0][0];\n\tm3[0][1] = m1[0][1] * m2[0][1];\n\tm3[1][0] = m1[1][0] * m2[1][0];\n\tm3[1][1] = m1[1][1] * m2[1][1];\n\tgl_FragColor = vec4(m3[0][0], m3[1][0], m3[0][1], m3[1][1]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 2.0, +(false ? (0.0 * 1.0) : (-1.0 / -1.0)), -1.0);

void main()
{
  mat2 m1 = mat2(color.rg , color.ba);
  mat2 m2 = mat2(1.0 , 0.5 , 0.5 , 1.0);
  mat2 m3 = mat2(0.0);
  m3[0][0] = (m1[0][0] * m2[0][0]);
  m3[0][1] = (m1[0][1] * m2[0][1]);
  m3[1][0] = (m1[1][0] * m2[1][0]);
  m3[1][1] = (m1[1][1] * m2[1][1]);
  gl_FragColor = vec4(m3[0][0] , m3[1][0] , m3[0][1] , m3[1][1]);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/cos_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * ( fract(abs(color.r)) - 0.5 );
	float sign =  1.0;
	float cos_c = -1.0;
	float fact_even = 1.0;
	float fact_odd  = 1.0;
	float sum;
	for(int i = 2; i <= 10; i += 2)
	{
		fact_even *= float(i);
		fact_odd  *= float(i-1);
		sum = sign * pow(abs(c), float(i/2))/fact_even;
		cos_c += pow(abs(c), float(i/2))*(sum/fact_odd);
		sign = -sign;
	}
	gl_FragColor = vec4(0.5 * cos_c + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * ( fract(abs(color.r)) - 0.5 );\n\tfloat sign =  1.0;\n\tfloat cos_c = -1.0;\n\tfloat fact_even = 1.0;\n\tfloat fact_odd  = 1.0;\n\tfloat sum;\n\tfor(int i = 2; i <= 10; i += 2)\n\t{\n\t\tfact_even *= float(i);\n\t\tfact_odd  *= float(i-1);\n\t\tsum = sign * pow(abs(c), float(i/2))/fact_even;\n\t\tcos_c += pow(abs(c), float(i/2))*(sum/fact_odd);\n\t\tsign = -sign;\n\t}\n\tgl_FragColor = vec4(0.5 * cos_c + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (-1.0 + (2.0 * (0.5 - 0.5))), 0.0, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * (fract(abs(color.r)) - 0.5));
  float sign = 1.0;
  float cos_c = -1.0;
  float fact_even = 1.0;
  float fact_odd = 1.0;
  float sum;
  for (int i = 2; (i <= 10); (i += 2))
  {
    (fact_even *= float(i));
    (fact_odd *= float((i - 1)));
    sum = ((sign * pow(abs(c) , float((i / 2)))) / fact_even);
    (cos_c += (pow(abs(c) , float((i / 2))) * (sum / fact_odd)));
    sign = -sign;
  }
  gl_FragColor = vec4(((0.5 * cos_c) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
69.23076923076923
Processing this: /home/oof/webgl_cleaned/emit1.glsl
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform sampler2D GLGE_EMIT;
varying vec2 texCoord;
float blurSize=0.007;
void main(){
	vec4 color=vec4(0.0,0.0,0.0,0.0);
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - 4.0*blurSize, texCoord.y)) * 0.05;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - 3.0*blurSize, texCoord.y)) * 0.09;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - 2.0*blurSize, texCoord.y)) * 0.12;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - blurSize, texCoord.y)) * 0.15;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x, texCoord.y)) * 0.16;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + blurSize, texCoord.y)) * 0.15;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + 2.0*blurSize, texCoord.y)) * 0.12;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + 3.0*blurSize, texCoord.y)) * 0.09;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + 4.0*blurSize, texCoord.y)) * 0.05;
    gl_FragColor = vec4(color.rgb,1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform sampler2D GLGE_EMIT;\nvarying vec2 texCoord;\nfloat blurSize=0.007;\nvoid main(){\n\tvec4 color=vec4(0.0,0.0,0.0,0.0);\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - 4.0*blurSize, texCoord.y)) * 0.05;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - 3.0*blurSize, texCoord.y)) * 0.09;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - 2.0*blurSize, texCoord.y)) * 0.12;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - blurSize, texCoord.y)) * 0.15;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x, texCoord.y)) * 0.16;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + blurSize, texCoord.y)) * 0.15;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + 2.0*blurSize, texCoord.y)) * 0.12;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + 3.0*blurSize, texCoord.y)) * 0.09;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + 4.0*blurSize, texCoord.y)) * 0.05;\n    gl_FragColor = vec4(color.rgb,1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform sampler2D GLGE_EMIT = GLGE_EMIT;

vec2 texCoord;

float blurSize = 0.007;

void main()
{
  vec4 color = vec4(0.0 , 0.0 , 0.0 , 0.0);
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (4.0 * blurSize)) , texCoord.y)) * 0.05));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2(texCoord.x , texCoord.y)) * 0.16));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (4.0 * blurSize)) , texCoord.y)) * 0.05));
  gl_FragColor = vec4(color.rgb , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'GLGE_EMIT' : undeclared identifier
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform sampler2D GLGE_EMIT = GLGE_EMIT;

vec2 texCoord;

float blurSize = 0.007;

void main()
{
  vec4 color = vec4(0.0 , 0.0 , 0.0 , 0.0);
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (4.0 * blurSize)) , texCoord.y)) * 0.05));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2(texCoord.x , texCoord.y)) * 0.16));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (4.0 * blurSize)) , texCoord.y)) * 0.05));
  gl_FragColor = vec4(color.rgb , 1.0);
}


==============================
64.28571428571429
Processing this: /home/oof/webgl_cleaned/DuplicateVersion1_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1);
}


As vertex? : False
SUCCESS!
66.66666666666666
Mutations attempted: 15
Valid mutations:     10
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/vec4_r_g_b_a_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float r = al.r;
	float g = al.g;
	float b = al.b;
	float a = al.a;
	vec4 m = vec4(r,g,b,a);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat r = al.r;\n\tfloat g = al.g;\n\tfloat b = al.b;\n\tfloat a = al.a;\n\tvec4 m = vec4(r,g,b,a);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((1.0 / ((false || false) ? -2.0 : -2.0)), +(+-1.0 * -1.0), ((false ? (false ? false : false) : !false) ? 1.0 : +2.0), 0.0);

void main()
{
  vec4 al = color;
  float r = al.r;
  float g = al.g;
  float b = al.b;
  float a = al.a;
  vec4 m = vec4(r , g , b , a);
  gl_FragColor = m;
}


As vertex? : False
SUCCESS!
68.75
Processing this: /home/oof/webgl_cleaned/bvec4_2int_2float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	bvec4 a = bvec4(0, 23, 0.0, 23.0);
	float gray;
	if( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tbvec4 a = bvec4(0, 23, 0.0, 23.0);\n\tfloat gray;\n\tif( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+((2.0 + 0.5) + 2.0), -0.0, (true ? (false ? (false ? 0.0 : 0.0) : (2.0 + -1.0)) : ((false ? 2.0 : 2.0) - +-1.0)), +(-0.0 + -1.0));

void main()
{
  bvec4 a = bvec4(0 , 23 , 0.0 , 23.0);
  float gray;
  if (((((a[0] == false) && (a[1] == true)) && (a[2] == false)) && (a[3] == true)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
70.58823529411765
Processing this: /home/oof/webgl_cleaned/sin_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  ivec2(((true ? true : true) ? ((3 / 9) * 1) : 0), 3);
}


As vertex? : False
SUCCESS!
72.22222222222221
Processing this: /home/oof/webgl_cleaned/compressed_paletted_texture.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 gtf_TexCoord[1];
attribute vec4 gtf_MultiTexCoord0;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 gtf_TexCoord[1];\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(((!true || (true ? true : false)) ? +2.0 : ((2.0 * 2.0) + (true ? -1.0 : -1.0))), ++(false ? 2.0 : 2.0), 1.0, 1.0);

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: '++' : l-value required (can't modify a const)
ERROR: 0:12: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(((!true || (true ? true : false)) ? +2.0 : ((2.0 * 2.0) + (true ? -1.0 : -1.0))), ++(false ? 2.0 : 2.0), 1.0, 1.0);

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
68.42105263157895
Processing this: /home/oof/webgl_cleaned/CorrectSwizzle1_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Normal;
uniform mat4 gtf_NormalMatrix;
void main()
{
   vec4 v = vec4(1,2,3,4);
   vec3 v3 = vec3(5,6,7);
   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);
   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Normal;\nuniform mat4 gtf_NormalMatrix;\nvoid main()\n{\n   vec4 v = vec4(1,2,3,4);\n   vec3 v3 = vec3(5,6,7);\n   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);\n   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Normal;

uniform mat4 gtf_NormalMatrix = mat4((!!false ? ((true || true) ? 0.0 : 2.0) : -1.0), 0.0, (0.5 + -2.0), 0.5, 0.0, 1.0, (true ? +2.0 : ((false ? true : false) ? (1.0 * 0.0) : (2.0 + 1.0))), (!!false ? --1.0 : 0.0), (((false ? -1.0 : 0.0) + (0.5 - -1.0)) * (+2.0 - -1.0)), -1.0, --1.0, 0.0, 2.0, 2.0, (false ? 1.0 : 0.5), (0.5 - +-2.0));

void main()
{
  vec4 v = vec4(1 , 2 , 3 , 4);
  vec3 v3 = vec3(5 , 6 , 7);
  vec4 v4 = vec4(normalize(v3.yzy).xyz.zyx , 1.0);
  gl_Position = (v4 + vec4(normalize((gtf_NormalMatrix * gtf_Normal)).xyz.zyx , v4.y));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Normal;

uniform mat4 gtf_NormalMatrix = mat4((!!false ? ((true || true) ? 0.0 : 2.0) : -1.0), 0.0, (0.5 + -2.0), 0.5, 0.0, 1.0, (true ? +2.0 : ((false ? true : false) ? (1.0 * 0.0) : (2.0 + 1.0))), (!!false ? --1.0 : 0.0), (((false ? -1.0 : 0.0) + (0.5 - -1.0)) * (+2.0 - -1.0)), -1.0, --1.0, 0.0, 2.0, 2.0, (false ? 1.0 : 0.5), (0.5 - +-2.0));

void main()
{
  vec4 v = vec4(1 , 2 , 3 , 4);
  vec3 v3 = vec3(5 , 6 , 7);
  vec4 v4 = vec4(normalize(v3.yzy).xyz.zyx , 1.0);
  gl_Position = (v4 + vec4(normalize((gtf_NormalMatrix * gtf_Normal)).xyz.zyx , v4.y));
}


==============================
65.0
Processing this: /home/oof/webgl_cleaned/acos_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	vec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 asin_c = vec2(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	gl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tvec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tvec2 weight = arrVal - floor(arrVal);\n\tvec2 asin_c = vec2(0.0);\n\tif (arr0x == 0)\n\t\tasin_c.x = lerp(asinValues[0], asinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tasin_c.x = lerp(asinValues[1], asinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tasin_c.x = lerp(asinValues[2], asinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tasin_c.x = lerp(asinValues[3], asinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tasin_c.x = lerp(asinValues[4], asinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tasin_c.x = lerp(asinValues[5], asinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tasin_c.x = lerp(asinValues[6], asinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tasin_c.x = lerp(asinValues[7], asinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tasin_c.x = lerp(asinValues[8], asinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tasin_c.x = lerp(asinValues[9], asinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tasin_c.x = lerp(asinValues[10], asinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tasin_c.x = lerp(asinValues[11], asinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tasin_c.x = lerp(asinValues[12], asinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tasin_c.x = lerp(asinValues[13], asinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tasin_c.x = lerp(asinValues[14], asinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tasin_c.x = lerp(asinValues[15], asinValues[16], weight.x);\n        else if (arr0x == 16)\n                asin_c.x = asinValues[16];\n\tif (arr0y == 0)\n\t\tasin_c.y = lerp(asinValues[0], asinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tasin_c.y = lerp(asinValues[1], asinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tasin_c.y = lerp(asinValues[2], asinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tasin_c.y = lerp(asinValues[3], asinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tasin_c.y = lerp(asinValues[4], asinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tasin_c.y = lerp(asinValues[5], asinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tasin_c.y = lerp(asinValues[6], asinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tasin_c.y = lerp(asinValues[7], asinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tasin_c.y = lerp(asinValues[8], asinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tasin_c.y = lerp(asinValues[9], asinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tasin_c.y = lerp(asinValues[10], asinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tasin_c.y = lerp(asinValues[11], asinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tasin_c.y = lerp(asinValues[12], asinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tasin_c.y = lerp(asinValues[13], asinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tasin_c.y = lerp(asinValues[14], asinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tasin_c.y = lerp(asinValues[15], asinValues[16], weight.y);\n        else if (arr0y == 16)\n                asin_c.y = asinValues[16];\n\tgl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 1.348062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/vec4_qspt_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.qspt;
	vec4 a = vec4(m.t, m.q, m.p, m.s);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.qspt;\n\tvec4 a = vec4(m.t, m.q, m.p, m.s);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.qspt;
  vec4 a = vec4(m.t , m.q , m.p , m.s);
  gl_FragColor = a;
  ivec2(((false || !true) ? (false ? 8 : +2) : 3), +((5 * 1) / (6 + 3)));
}


As vertex? : False
SUCCESS!
68.18181818181817
Processing this: /home/oof/webgl_cleaned/vec4_xyz_w_1vec3_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	float w = lightloc.w;
	vec4 a = vec4(m, w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tfloat w = lightloc.w;\n\tvec4 a = vec4(m, w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-2.0, (false ? (true ? 2.0 : (true ? 0.0 : 0.5)) : -1.0), 2.0, 1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  float w = lightloc.w;
  vec4 a = vec4(m , w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
69.56521739130434
Processing this: /home/oof/webgl_cleaned/ceil_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((ceil(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 0.0, 0.0, 2.0, 0.5, -1.0, -0.5, 0.0, 2.0, -0.5, 1.0, 2.0, 0.0, 0.0, -0.5);

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 0.0, 0.0, 2.0, 0.5, -1.0, -0.5, 0.0, 2.0, -0.5, 1.0, 2.0, 0.0, 0.0, -0.5);

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
66.66666666666666
Processing this: /home/oof/webgl_cleaned/length_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(length(color.r)), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(length(color.r)), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = ivec2(1.0, -0.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'assign' : cannot convert from 'const 2-component vector of int' to 'FragColor mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = ivec2(1.0, -0.5);
}


==============================
64.0
Mutations attempted: 25
Valid mutations:     16
Success rate:        64.00%
Processing this: /home/oof/webgl_cleaned/mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	               5.0,  6.0,  7.0,  8.0,
	               9.0, 10.0, 11.0, 12.0,
	              13.0, 14.0, 15.0, 16.0);
	bool elms = true;
	if(a[0][0] !=  1.0) elms = false;
	if(a[0][1] !=  2.0) elms = false;
	if(a[0][2] !=  3.0) elms = false;
	if(a[0][3] !=  4.0) elms = false;
	if(a[1][0] !=  5.0) elms = false;
	if(a[1][1] !=  6.0) elms = false;
	if(a[1][2] !=  7.0) elms = false;
	if(a[1][3] !=  8.0) elms = false;
	if(a[2][0] !=  9.0) elms = false;
	if(a[2][1] != 10.0) elms = false;
	if(a[2][2] != 11.0) elms = false;
	if(a[2][3] != 12.0) elms = false;
	if(a[3][0] != 13.0) elms = false;
	if(a[3][1] != 14.0) elms = false;
	if(a[3][2] != 15.0) elms = false;
	if(a[3][3] != 16.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tmat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t               5.0,  6.0,  7.0,  8.0,\n\t               9.0, 10.0, 11.0, 12.0,\n\t              13.0, 14.0, 15.0, 16.0);\n\tbool elms = true;\n\tif(a[0][0] !=  1.0) elms = false;\n\tif(a[0][1] !=  2.0) elms = false;\n\tif(a[0][2] !=  3.0) elms = false;\n\tif(a[0][3] !=  4.0) elms = false;\n\tif(a[1][0] !=  5.0) elms = false;\n\tif(a[1][1] !=  6.0) elms = false;\n\tif(a[1][2] !=  7.0) elms = false;\n\tif(a[1][3] !=  8.0) elms = false;\n\tif(a[2][0] !=  9.0) elms = false;\n\tif(a[2][1] != 10.0) elms = false;\n\tif(a[2][2] != 11.0) elms = false;\n\tif(a[2][3] != 12.0) elms = false;\n\tif(a[3][0] != 13.0) elms = false;\n\tif(a[3][1] != 14.0) elms = false;\n\tif(a[3][2] != 15.0) elms = false;\n\tif(a[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 * -0.9)) || (x > (!true ? -1.0 : (false ? 0.5 : -1.0)))))
    -(0.0 * 1.0);
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
65.38461538461539
Processing this: /home/oof/webgl_cleaned/exp_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec3 c = gtf_Color.rgb;
	color = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec3 c = gtf_Color.rgb;
  color = vec4((pow(vec3(exp1) , (3.0 * c)) / exp3) , 1.0);
  gtf_ModelViewProjectionMatrix = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  vec4(+0.0, 0.5, +1.0, (true ? 0.0 : (-1.0 + (1.0 - -1.0))));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'assign' : l-value required (can't modify a uniform "gtf_ModelViewProjectionMatrix")
ERROR: 0:18: '=' : dimension mismatch
ERROR: 0:18: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'uniform mediump 4X4 matrix of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec3 c = gtf_Color.rgb;
  color = vec4((pow(vec3(exp1) , (3.0 * c)) / exp3) , 1.0);
  gtf_ModelViewProjectionMatrix = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  vec4(+0.0, 0.5, +1.0, (true ? 0.0 : (-1.0 + (1.0 - -1.0))));
}


==============================
62.96296296296296
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 16.0 * gtf_Color.r;
	color = vec4(pow(c, 0.5) / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 16.0 * gtf_Color.r;\n\tcolor = vec4(pow(c, 0.5) / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex = vec4(-1.0, 0.5, 0.5, +(+0.5 / 1.0));

void main()
{
  float c = (16.0 * gtf_Color.r);
  color = vec4((pow(c , 0.5) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.28571428571429
Processing this: /home/oof/webgl_cleaned/mod_vec3_frag_xvary_yconst1.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(mod(c, 1.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(mod(c, 1.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -0.5, 0.5, 0.5);

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(mod(c , 1.0) , 1.0);
}


As vertex? : False
SUCCESS!
65.51724137931035
Processing this: /home/oof/webgl_cleaned/extension9_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
65.51724137931035
Processing this: /home/oof/webgl_cleaned/vec4_empty_empty_vec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
65.51724137931035
Processing this: /home/oof/webgl_cleaned/version2_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/clamp_vec2_vert_xvary_yconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec2 c = gtf_Color.rg;
	if(c[0] > max_c) c[0] = max_c;
	if(c[0] < min_c) c[0] = min_c;
	if(c[1] > max_c) c[1] = max_c;
	if(c[1] < min_c) c[1] = min_c;
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tvec2 c = gtf_Color.rg;\n\tif(c[0] > max_c) c[0] = max_c;\n\tif(c[0] < min_c) c[0] = min_c;\n\tif(c[1] > max_c) c[1] = max_c;\n\tif(c[1] < min_c) c[1] = min_c;\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  if ((c[0] > max_c))
    c[0] = max_c;
  if ((c[0] < min_c))
    c[0] = min_c;
  if ((c[1] > max_c))
    c[1] = max_c;
  if ((gtf_Color[0] < min_c))
    min_c = c[1];
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  if ((c[0] > max_c))
    c[0] = max_c;
  if ((c[0] < min_c))
    c[0] = min_c;
  if ((c[1] > max_c))
    c[1] = max_c;
  if ((gtf_Color[0] < min_c))
    min_c = c[1];
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
64.51612903225806
Processing this: /home/oof/webgl_cleaned/vec2_2float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 a = vec2(13.0,53.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 a = vec2(13.0,53.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-0.5, 1.0, -1.0, -0.5);

void main()
{
  vec2 a = vec2(13.0 , 53.0);
  float gray;
  if (((a[0] == 13.0) && (a[1] == 53.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
65.625
Processing this: /home/oof/webgl_cleaned/relational_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool lessthan  = (m<k);
	bool greaterthan = (m>k);
	bool lessthanorequalto = (m <= 102);
	bool greaterthanorequalto = (k >=12);
	float gray;
	if( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool lessthan  = (m<k);\n\tbool greaterthan = (m>k);\n\tbool lessthanorequalto = (m <= 102);\n\tbool greaterthanorequalto = (k >=12);\n\tfloat gray;\n\tif( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (k >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.66666666666666
Mutations attempted: 33
Valid mutations:     22
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * color.rg;
	gl_FragColor = vec4(c / 100.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * color.rg;\n\tgl_FragColor = vec4(c / 100.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = (100.0 * color.rg);
  gl_FragColor = color((c / 100.0) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'gl_FragColor' : undeclared identifier
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = (100.0 * color.rg);
  gl_FragColor = color((c / 100.0) , 0.0);
}


==============================
64.70588235294117
Processing this: /home/oof/webgl_cleaned/for_nested_continue_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int count1 = 0, count2 = 0;
	int val1 = 0, val2 = 0;
    	for(int i=0;i<10;i++)
	{
	  	count1++;
		count2 = 0;
		for(int j=0;j<10;j++)
		{
			count2++;
			if(count2 == 5)
				continue;
			else
				val2 += count2;
		}
	  	if(count1 == 5)
            		continue;
	  	else
	    		val1 += count1;
	}
	float gray;
	if( (val1 == 50) && (val2 == 500) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint count1 = 0, count2 = 0;\n\tint val1 = 0, val2 = 0;\n    \tfor(int i=0;i<10;i++)\n\t{\n\t  \tcount1++;\n\t\tcount2 = 0;\n\t\tfor(int j=0;j<10;j++)\n\t\t{\n\t\t\tcount2++;\n\t\t\tif(count2 == 5)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tval2 += count2;\n\t\t}\n\t  \tif(count1 == 5)\n            \t\tcontinue;\n\t  \telse\n\t    \t\tval1 += count1;\n\t}\n\tfloat gray;\n\tif( (val1 == 50) && (val2 == 500) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int count1 = 0 , count2 = 0;
  int val1 = 0 , val2 = 0;
  for (int i = 0; (i < 10); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 10); j++)
    {
      count2++;
      if ((count2 == 5))
        continue;
      else
        (val2 += count2);
    }
    if ((count1 == 5))
      continue;
    else
      (val1 += count1);
  }
  float gray;
  if (((+0.5 == 50) && (main() == 500)))
    gtf_ModelViewProjectionMatrix = 1.0;
  else
    gray = ((true || true) ? (false ? 0.5 : 0.0) : (0.0 + 2.0));
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:32: '==' : wrong operand types - no operation '==' exists that takes a left-hand operand of type 'const float' and a right operand of type 'const int' (or there is no acceptable conversion)
ERROR: 0:32: '==' : operation with void operands
ERROR: 0:32: '==' : wrong operand types - no operation '==' exists that takes a left-hand operand of type 'void' and a right operand of type 'const int' (or there is no acceptable conversion)
ERROR: 0:33: 'assign' : l-value required (can't modify a uniform "gtf_ModelViewProjectionMatrix")
ERROR: 0:33: '=' : dimension mismatch
ERROR: 0:33: 'assign' : cannot convert from 'const float' to 'uniform mediump 4X4 matrix of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int count1 = 0 , count2 = 0;
  int val1 = 0 , val2 = 0;
  for (int i = 0; (i < 10); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 10); j++)
    {
      count2++;
      if ((count2 == 5))
        continue;
      else
        (val2 += count2);
    }
    if ((count1 == 5))
      continue;
    else
      (val1 += count1);
  }
  float gray;
  if (((+0.5 == 50) && (main() == 500)))
    gtf_ModelViewProjectionMatrix = 1.0;
  else
    gray = ((true || true) ? (false ? 0.5 : 0.0) : (0.0 + 2.0));
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.857142857142854
Processing this: /home/oof/webgl_cleaned/tan_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);
	vec2 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * tan(c.r) + 0.5;
	else
		o.r = 0.5 / tan(c.r) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * tan(c.g) + 0.5;
	else
		o.g = 0.5 / tan(c.g) + 0.5;
	gl_FragColor = vec4(o, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);\n\tvec2 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * tan(c.r) + 0.5;\n\telse\n\t\to.r = 0.5 / tan(c.r) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * tan(c.g) + 0.5;\n\telse\n\t\to.g = 0.5 / tan(c.g) + 0.5;\n\tgl_FragColor = vec4(o, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((0.5 * M_PI) * 2.0) * (color.rg - 0.5));
  vec2 o = vec2(++0.5, +2.0);
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '++' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((0.5 * M_PI) * 2.0) * (color.rg - 0.5));
  vec2 o = vec2(++0.5, +2.0);
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 1.0);
}


==============================
61.111111111111114
Processing this: /home/oof/webgl_cleaned/smoothstep_vec2_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 edge0 = vec2(0.25, 0.25);
	const vec2 edge1 = vec2(0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rg), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge0 = vec2(0.25, 0.25);\n\tconst vec2 edge1 = vec2(0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rg), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-1.0, 2.0, (((true || false) ? 0.0 : 0.5) - 1.0), 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge0 = vec2(0.25 , 0.25);
  const vec2 edge1 = vec2(0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rg) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.16216216216216
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 31.0 * gtf_Color.r + 1.0;
	color = vec4(log(c) / 3.466, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 31.0 * gtf_Color.r + 1.0;\n\tcolor = vec4(log(c) / 3.466, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-(false ? 1.0 : (true ? 1.0 : -1.0)), ((1.0 - (0.0 + 2.0)) * ((true ? 0.0 : -1.0) * 2.0)), -1.0, --(1.0 / 1.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((31.0 * gtf_Color.r) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-(false ? 1.0 : (true ? 1.0 : -1.0)), ((1.0 - (0.0 + 2.0)) * ((true ? 0.0 : -1.0) * 2.0)), -1.0, --(1.0 / 1.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((31.0 * gtf_Color.r) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.526315789473685
Processing this: /home/oof/webgl_cleaned/length_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && true) ? (!true ? 2.0 : 0.0) : (-1.0 / 0.0)), ((true || !true) ? 1.0 : -0.0), 0.0, 2.0);

void main()
{
  gl_FragColor = vec4(vec3((sqrt(((color.r * color.r) + (color.g * color.g))) / 2.0)) , 1.0);
}


As vertex? : False
SUCCESS!
61.53846153846154
Processing this: /home/oof/webgl_cleaned/vec4_ar_bg_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.ar;
	vec2 n = lightloc.bg;
	vec4 a = vec4(m.g, n.g, n.r, m.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.ar;\n\tvec2 n = lightloc.bg;\n\tvec4 a = vec4(m.g, n.g, n.r, m.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((((false && true) ? false : false) ? ((true && true) ? 0.0 : 2.0) : 1.0), 0.5, -1.0, 1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.ar;
  vec2 n = lightloc.bg;
  vec4 a = vec4(m.g , n.g , n.r , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
62.5
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconsthalf_yvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = -2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((!true ? !false : true) ? 0.0 : +(false ? 2.0 : 0.0)), -1.0, 1.0, 0.0);

void main()
{
  vec3 c = (-2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4((exp2((2.0 * c)) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
63.41463414634146
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(in mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_ones) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(in mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(in mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_ones) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(in mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
63.41463414634146
Processing this: /home/oof/webgl_cleaned/any_bvec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	gl_FragColor = vec4(vec3(any(bvec2(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tgl_FragColor = vec4(vec3(any(bvec2(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+-(0.5 - 0.5), 0.0, 1.0, 0.5);

void main()
{
  vec2 c = floor((1.5 * color.rg));
  gl_FragColor = vec4(vec3(any(bvec2(c))) , 1.0);
}


As vertex? : False
SUCCESS!
64.28571428571429
Mutations attempted: 42
Valid mutations:     27
Success rate:        64.29%
Processing this: /home/oof/webgl_cleaned/struct_bool_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	bool a;
	bool b;
	bool c;
	bool d;
};
void main ()
{
	sabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));
	float gray = 0.0;
	if( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))
	  gray=1.0;
	else
          gray =0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tbool a;\n\tbool b;\n\tbool c;\n\tbool d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));\n\tfloat gray = 0.0;\n\tif( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix / gtf_Vertex);
  sabcd((false ? false : !(true ? true : false)), (!!true ? false : false), !true, true);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:26: '/' : wrong operand types - no operation '/' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:26: '=' : dimension mismatch
ERROR: 0:26: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix / gtf_Vertex);
  sabcd((false ? false : !(true ? true : false)), (!!true ? false : false), !true, true);
}


==============================
62.7906976744186
Processing this: /home/oof/webgl_cleaned/fract_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/matrix2VSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-1.0 - -(1.0 - 2.0)), ((false ? -2.0 : 0.5) / -1.0), 2.0, -+-1.0);

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
64.44444444444444
Processing this: /home/oof/webgl_cleaned/vec4_xyzw_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.xyzw;
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.xyzw;\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, -1.0, 0.0, 1.0, -1.0, 2.0, (+(2.0 / 0.5) + -1.0), -1.0, -2.0, ((false ? (true ? false : true) : (false && true)) ? 0.0 : (2.0 + +1.0)), ---1.0, 0.5, 2.0, 0.0, 1.0, (2.0 + 0.5));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.xyzw;
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, -1.0, 0.0, 1.0, -1.0, 2.0, (+(2.0 / 0.5) + -1.0), -1.0, -2.0, ((false ? (true ? false : true) : (false && true)) ? 0.0 : (2.0 + +1.0)), ---1.0, 0.5, 2.0, 0.0, 1.0, (2.0 + 0.5));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.xyzw;
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


==============================
63.04347826086957
Processing this: /home/oof/webgl_cleaned/vec3_yxz_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec3 t = m.yxz;
	vec4 a = vec4(t.y, t.x, t.z, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec3 t = m.yxz;\n\tvec4 a = vec4(t.y, t.x, t.z, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, (true ? -(true ? 2.0 : -1.0) : (true ? -1.0 : (1.0 + -1.0))), -1.0, (+(-1.0 / 2.0) + +0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec3 t = m.yxz;
  vec4 a = vec4(t.y , t.x , t.z , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
63.829787234042556
Processing this: /home/oof/webgl_cleaned/bvec4_empty_in_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(in bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(in bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(in bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(in bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.829787234042556
Processing this: /home/oof/webgl_cleaned/mat3_9float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat3 m = mat3(gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if(m[0][0] != gtf_Color.r) result = black;
	if(m[0][1] != gtf_Color.g) result = black;
	if(m[0][2] != gtf_Color.b) result = black;
	if(m[1][0] != gtf_Color.r) result = black;
	if(m[1][1] != gtf_Color.g) result = black;
	if(m[1][2] != gtf_Color.b) result = black;
	if(m[2][0] != gtf_Color.r) result = black;
	if(m[2][1] != gtf_Color.g) result = black;
	if(m[2][2] != gtf_Color.b) result = black;
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m = mat3(gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif(m[0][0] != gtf_Color.r) result = black;\n\tif(m[0][1] != gtf_Color.g) result = black;\n\tif(m[0][2] != gtf_Color.b) result = black;\n\tif(m[1][0] != gtf_Color.r) result = black;\n\tif(m[1][1] != gtf_Color.g) result = black;\n\tif(m[1][2] != gtf_Color.b) result = black;\n\tif(m[2][0] != gtf_Color.r) result = black;\n\tif(m[2][1] != gtf_Color.g) result = black;\n\tif(m[2][2] != gtf_Color.b) result = black;\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 1.0, 1.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat3 m = mat3(gtf_Color.r , gtf_Color.g , gtf_Color.b , gtf_Color.r , gtf_Color.g , gtf_Color.b , gtf_Color.r , gtf_Color.g , gtf_Color.b);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != gtf_Color.r))
    result = black;
  if ((m[0][1] != gtf_Color.g))
    result = black;
  if ((m[0][2] != gtf_Color.b))
    result = black;
  if ((m[1][0] != gtf_Color.r))
    result = black;
  if ((m[1][1] != gtf_Color.g))
    result = black;
  if ((m[1][2] != gtf_Color.b))
    result = black;
  if ((m[2][0] != gtf_Color.r))
    result = black;
  if ((m[2][1] != gtf_Color.g))
    result = black;
  if ((m[2][2] != gtf_Color.b))
    result = black;
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.58333333333334
Processing this: /home/oof/webgl_cleaned/length_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 1.0, 0.0, --1.0);

void main()
{
  gl_FragColor = vec4(vec3((sqrt(((color.r * color.r) + (color.g * color.g))) / 2.0)) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 1.0, 0.0, --1.0);

void main()
{
  gl_FragColor = vec4(vec3((sqrt(((color.r * color.r) + (color.g * color.g))) / 2.0)) , 1.0);
}


==============================
63.26530612244898
Processing this: /home/oof/webgl_cleaned/length_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(gtf_Color.r), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(gtf_Color.r), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4(vec3(gtf_Color.r) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.0
Processing this: /home/oof/webgl_cleaned/mat2_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat2 m = mat2(0.5);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if((m[0][0] != 0.5))
		result = black;
	if((m[0][1] != 0.0))
		result = black;
	if((m[1][0] != 0.0))
		result = black;
	if((m[1][1] != 0.5))
		result = black;
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m = mat2(0.5);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif((m[0][0] != 0.5))\n\t\tresult = black;\n\tif((m[0][1] != 0.0))\n\t\tresult = black;\n\tif((m[1][0] != 0.0))\n\t\tresult = black;\n\tif((m[1][1] != 0.5))\n\t\tresult = black;\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  mat2 m = mat2(0.5);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != 0.5))
    result = black;
  if ((m[0][1] != 0.0))
    result = black;
  if ((m[1][0] != 0.0))
    result = black;
  if ((m[1][1] != 0.5))
    result = black;
  gl_FragColor = result;
}


As vertex? : False
SUCCESS!
64.70588235294117
Mutations attempted: 51
Valid mutations:     33
Success rate:        64.71%
Processing this: /home/oof/webgl_cleaned/clamp_float_vert_xvary_yconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = gtf_Color.r;
	if(c > max_c) c = max_c;
	if(c < min_c) c = min_c;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = gtf_Color.r;\n\tif(c > max_c) c = max_c;\n\tif(c < min_c) c = min_c;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(+((0.5 / 0.0) / (1.0 / 0.5)), (0.0 + 2.0), 0.0, 2.0);

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = gtf_Color.r;
  if ((c > max_c))
    c = max_c;
  if ((c < min_c))
    c = min_c;
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
65.38461538461539
Processing this: /home/oof/webgl_cleaned/matrix2VSU.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat4 transforms;
uniform mat4 anotherMatrix;
varying vec4 color;
void main()
{
  color = gtf_Color;
   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat4 transforms;\nuniform mat4 anotherMatrix;\nvarying vec4 color;\nvoid main()\n{\n  color = gtf_Color;\n   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, --1.0, (false ? 0.5 : 0.0), -1.0, -1.0, 2.0, 2.0, 2.0, 0.5, (false ? +2.0 : ((true || false) ? 2.0 : (true ? 0.0 : 2.0))), (0.5 * (-1.0 / 1.0)), 0.0, (!true ? 2.0 : (true ? 2.0 : 2.0)), +((true ? false : true) ? +1.0 : +2.0), (0.5 / (-0.0 * 1.0)), 0.0);

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms) * anotherMatrix) * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, --1.0, (false ? 0.5 : 0.0), -1.0, -1.0, 2.0, 2.0, 2.0, 0.5, (false ? +2.0 : ((true || false) ? 2.0 : (true ? 0.0 : 2.0))), (0.5 * (-1.0 / 1.0)), 0.0, (!true ? 2.0 : (true ? 2.0 : 2.0)), +((true ? false : true) ? +1.0 : +2.0), (0.5 / (-0.0 * 1.0)), 0.0);

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms) * anotherMatrix) * gtf_Vertex);
}


==============================
64.15094339622641
Processing this: /home/oof/webgl_cleaned/max_float_vert_xvary_yconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = gtf_Color.r;
	color = vec4(max(c, max_c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(max(c, max_c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((true ? 2.0 : 2.0) * 2.0) + -1.0), (1.0 / (false ? (true ? 0.5 : 0.0) : 2.0)), 2.0, -2.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = gtf_Color.r;
  color = vec4(max(c , max_c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.81481481481481
Processing this: /home/oof/webgl_cleaned/mix_vec2_vert_xvary_yconsthalf_aconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = gtf_Color.rg;
	color = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = gtf_Color.rg;
  color = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  vec4(0.5, 2.0, (2.0 * 2.0), (false ? ((false ? 2.0 : 2.0) + (true ? 0.5 : 0.0)) : ((true && false) ? 0.5 : -1.0)));
}


As vertex? : True
SUCCESS!
65.45454545454545
Processing this: /home/oof/webgl_cleaned/vec3_zx_y_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	float k = m.y;
	vec2 n = m.zx;
	vec4 a = vec4(n.y, k, n.x, al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tfloat k = m.y;\n\tvec2 n = m.zx;\n\tvec4 a = vec4(n.y, k, n.x, al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 0.5, -0.5, 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  float k = m.y;
  vec2 n = m.zx;
  vec4 a = vec4(n.y , k , n.x , al.w);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
66.07142857142857
Processing this: /home/oof/webgl_cleaned/varying1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float foo;
void main()
{
    foo = 5.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float foo;\nvoid main()\n{\n    foo = 5.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

float foo;

void main()
{
  foo = 5.0;
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
66.66666666666666
Processing this: /home/oof/webgl_cleaned/vec3_yz_x_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec2 t = m.yz;
	float k = m.x;
	vec4 a = vec4(k, t.x, t.y,  lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec2 t = m.yz;\n\tfloat k = m.x;\n\tvec4 a = vec4(k, t.x, t.y,  lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((!false ? -1.0 : -1.0), +0.0, 1.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec2 t = m.yz;
  float k = m.x;
  vec4 a = vec4(k , t.x , t.y , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
67.24137931034483
Processing this: /home/oof/webgl_cleaned/normalize_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((+(2.0 * 0.5) * (-1.0 * (-1.0 / -1.0))), 1.0, (((-1.0 + 1.0) * (0.0 / 0.5)) * -1.0), 0.0);

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  gl_FragColor = vec4(normalize(tmp_Color.rg) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
67.79661016949152
Processing this: /home/oof/webgl_cleaned/mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	               5.0,  6.0,  7.0,  8.0,
	               9.0, 10.0, 11.0, 12.0,
	              13.0, 14.0, 15.0, 16.0);
	bool elms = true;
	if(a[0][0] !=  1.0) elms = false;
	if(a[0][1] !=  2.0) elms = false;
	if(a[0][2] !=  3.0) elms = false;
	if(a[0][3] !=  4.0) elms = false;
	if(a[1][0] !=  5.0) elms = false;
	if(a[1][1] !=  6.0) elms = false;
	if(a[1][2] !=  7.0) elms = false;
	if(a[1][3] !=  8.0) elms = false;
	if(a[2][0] !=  9.0) elms = false;
	if(a[2][1] != 10.0) elms = false;
	if(a[2][2] != 11.0) elms = false;
	if(a[2][3] != 12.0) elms = false;
	if(a[3][0] != 13.0) elms = false;
	if(a[3][1] != 14.0) elms = false;
	if(a[3][2] != 15.0) elms = false;
	if(a[3][3] != 16.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tmat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t               5.0,  6.0,  7.0,  8.0,\n\t               9.0, 10.0, 11.0, 12.0,\n\t              13.0, 14.0, 15.0, 16.0);\n\tbool elms = true;\n\tif(a[0][0] !=  1.0) elms = false;\n\tif(a[0][1] !=  2.0) elms = false;\n\tif(a[0][2] !=  3.0) elms = false;\n\tif(a[0][3] !=  4.0) elms = false;\n\tif(a[1][0] !=  5.0) elms = false;\n\tif(a[1][1] !=  6.0) elms = false;\n\tif(a[1][2] !=  7.0) elms = false;\n\tif(a[1][3] !=  8.0) elms = false;\n\tif(a[2][0] !=  9.0) elms = false;\n\tif(a[2][1] != 10.0) elms = false;\n\tif(a[2][2] != 11.0) elms = false;\n\tif(a[2][3] != 12.0) elms = false;\n\tif(a[3][0] != 13.0) elms = false;\n\tif(a[3][1] != 14.0) elms = false;\n\tif(a[3][2] != 15.0) elms = false;\n\tif(a[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  (((a[0][(false ? (true ? 2 : 3) : 2)] + a[1][1]) + a[4][1]) + vec4(1.0, (((false || true) || false) ? -1.0 : 2.0), 2.0, 1.0)) = +--1.0;
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:45: '[]' : matrix field selection out of range
ERROR: 0:45: '--' : l-value required (can't modify a const)
ERROR: 0:45: 'assign' :  l-value required
ERROR: 0:45: '=' : dimension mismatch
ERROR: 0:45: 'assign' : cannot convert from 'const float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  (((a[0][(false ? (true ? 2 : 3) : 2)] + a[1][1]) + a[4][1]) + vec4(1.0, (((false || true) || false) ? -1.0 : 2.0), 2.0, 1.0)) = +--1.0;
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
66.66666666666666
Mutations attempted: 60
Valid mutations:     40
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/vertexOnly2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    gl_Position = vec4(4.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    gl_Position = vec4(4.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(((true ? 2.0 : 0.5) + (0.0 + 0.5)), (((false || true) ? (true && true) : !true) ? (false ? 1.0 : 1.0) : (-1.0 * 0.5)), (0.0 / -(0.5 + 2.0)), (true ? (--1.0 * (1.0 + 0.0)) : (true ? 0.0 : +1.0)))(3.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(((true ? 2.0 : 0.5) + (0.0 + 0.5)), (((false || true) ? (true && true) : !true) ? (false ? 1.0 : 1.0) : (-1.0 * 0.5)), (0.0 / -(0.5 + 2.0)), (true ? (--1.0 * (1.0 + 0.0)) : (true ? 0.0 : +1.0)))(3.5);
}


==============================
65.57377049180327
Processing this: /home/oof/webgl_cleaned/atan_vec2_frag_xvaryyvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 x = 2.0 * (color.gg - 0.5);
	vec2 y = 2.0 * (color.bb - 0.5);
	const float epsilon = 1.0e-4;
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		gl_FragColor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		gl_FragColor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;
	}
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 x = 2.0 * (color.gg - 0.5);\n\tvec2 y = 2.0 * (color.bb - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tgl_FragColor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tgl_FragColor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;\n\t}\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 x = (2.0 * (color.gg - 0.5));
  vec2 y = (2.0 * (color.bb - 0.5));
  const float epsilon = 0.0001;
  gl_FragColor = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    gl_FragColor[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    gl_FragColor[1] = ((atan(y[1] , x[1]) / (2.0 * M_PI)) + 0.5);
  }
}


As vertex? : False
SUCCESS!
66.12903225806451
Processing this: /home/oof/webgl_cleaned/inversesqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r * 99.0) + 1.0;
	color = vec4(inversesqrt(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r * 99.0) + 1.0;\n\tcolor = vec4(inversesqrt(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, -0.5, 0.5, -1.0);

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4(inversesqrt(c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/step_float_frag_xvary_edgeconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float edge = 0.5;
	gl_FragColor = vec4(step(edge, color.r), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge = 0.5;\n\tgl_FragColor = vec4(step(edge, color.r), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.0, (((false ? true : false) ? !false : false) ? 0.5 : 2.0), 0.0);

void main()
{
  const float edge = 0.5;
  gl_FragColor = vec4(step(edge , color.r) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
67.1875
Processing this: /home/oof/webgl_cleaned/postfixdecrement_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 23;
	int k = m--;
	float gray;
	if( ( k == 23 ) && ( m == 22 ) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 23;\n\tint k = m--;\n\tfloat gray;\n\tif( ( k == 23 ) && ( m == 22 ) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((-1.0 - 0.0) / -0.0), 2.0, 1.0, 0.0);

void main()
{
  int m = 23;
  int k = m--;
  float gray;
  if (((k == 23) && (m == 22)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
67.6923076923077
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 lte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lte(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 lte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lte(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
68.18181818181817
Processing this: /home/oof/webgl_cleaned/radians_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 360.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 360.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, -0.5, 0.0, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((360.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((radians(c) / (4.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
68.65671641791045
Processing this: /home/oof/webgl_cleaned/floor_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, 2.0, 0.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
69.11764705882352
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconst2_yvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((0.5 - color.rgb) * -2.0);
  gl_FragColor = vec4((pow(vec3(2.0) , (2.0 * c)) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
69.56521739130434
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
69.56521739130434
Mutations attempted: 69
Valid mutations:     48
Success rate:        69.57%
Processing this: /home/oof/webgl_cleaned/exp2_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 0.5, 0.0, +-1.0, 2.0, --0.5, -1.0, 0.5, 2.0, (1.0 * 0.5), +--1.0, -1.0, (true ? (0.5 + 0.5) : ((true && true) ? 2.0 : 0.0)), 0.0, 0.5, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 0.5, 0.0, +-1.0, 2.0, --0.5, -1.0, 0.5, 2.0, (1.0 * 0.5), +--1.0, -1.0, (true ? (0.5 + 0.5) : ((true && true) ? 2.0 : 0.0)), 0.0, 0.5, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
68.57142857142857
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!false ? +0.0 : 1.0), 1.0, 0.0, 1.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(greaterThanEqual(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
69.01408450704226
Processing this: /home/oof/webgl_cleaned/tan_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 0.5 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);
	vec3 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * tan(c.r) + 0.5;
	else
		o.r = 0.5 / tan(c.r) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * tan(c.g) + 0.5;
	else
		o.g = 0.5 / tan(c.g) + 0.5;
	if(abs(c.b) < 0.5)
		o.b = 0.5 * tan(c.b) + 0.5;
	else
		o.b = 0.5 / tan(c.b) + 0.5;
	color = vec4(o, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 0.5 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * tan(c.r) + 0.5;\n\telse\n\t\to.r = 0.5 / tan(c.r) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * tan(c.g) + 0.5;\n\telse\n\t\to.g = 0.5 / tan(c.g) + 0.5;\n\tif(abs(c.b) < 0.5)\n\t\to.b = 0.5 * tan(c.b) + 0.5;\n\telse\n\t\to.b = 0.5 / tan(c.b) + 0.5;\n\tcolor = vec4(o, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 1.0, 1.0, -0.5, 1.0, 1.0, 0.0, 0.0, -0.5, -1.0, 1.0, 1.0, 0.0, -0.5, -0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (gtf_Color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * tan(c.b)) + 0.5);
  else
    o.b = ((0.5 / tan(c.b)) + 0.5);
  color = vec4(o , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 1.0, 1.0, -0.5, 1.0, 1.0, 0.0, 0.0, -0.5, -1.0, 1.0, 1.0, 0.0, -0.5, -0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (gtf_Color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * tan(c.b)) + 0.5);
  else
    o.b = ((0.5 / tan(c.b)) + 0.5);
  color = vec4(o , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
68.05555555555556
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
68.05555555555556
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	gl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tgl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  gl_FragColor = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
}


As vertex? : False
SUCCESS!
68.4931506849315
Processing this: /home/oof/webgl_cleaned/Low_Level_Assembly_Reserved_Words_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform float MIN;
uniform float R0;
uniform float FOGC;
uniform float CUBE;
uniform float f;
uniform float o;
uniform float p;
uniform float w;
uniform float x;
uniform float y;
uniform float z;
void main()
{
	gl_FragColor = vec4(f, o, p, w);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform float MIN;\nuniform float R0;\nuniform float FOGC;\nuniform float CUBE;\nuniform float f;\nuniform float o;\nuniform float p;\nuniform float w;\nuniform float x;\nuniform float y;\nuniform float z;\nvoid main()\n{\n\tgl_FragColor = vec4(f, o, p, w);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w;

uniform float x;

uniform float y = ((false ? (2.0 * 0.0) : (0.0 + 1.0)) / -1.0);

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w;

uniform float x;

uniform float y = ((false ? (2.0 * 0.0) : (0.0 + 1.0)) / -1.0);

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


==============================
67.56756756756756
Processing this: /home/oof/webgl_cleaned/int_empty_inout_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(inout int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(inout int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(inout int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(inout int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
67.56756756756756
Processing this: /home/oof/webgl_cleaned/2b_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform bvec2 color;
varying vec2 col;
void main ()
{
	col = vec2(color);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform bvec2 color;\nvarying vec2 col;\nvoid main ()\n{\n\tcol = vec2(color);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.5, 0.0, 2.0, -1.0, 0.5, 2.0, 0.5, 0.5, 0.0, 0.0, 0.0, -0.5, -0.5, 0.5, 0.0);

vec4 gtf_Color;

uniform bvec2 color;

vec2 col;

void main()
{
  col = vec2(color);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.5, 0.0, 2.0, -1.0, 0.5, 2.0, 0.5, 0.5, 0.0, 0.0, 0.0, -0.5, -0.5, 0.5, 0.0);

vec4 gtf_Color;

uniform bvec2 color;

vec2 col;

void main()
{
  col = vec2(color);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
66.66666666666666
Processing this: /home/oof/webgl_cleaned/acos_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	vec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 asin_c = vec2(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	gl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tvec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tvec2 weight = arrVal - floor(arrVal);\n\tvec2 asin_c = vec2(0.0);\n\tif (arr0x == 0)\n\t\tasin_c.x = lerp(asinValues[0], asinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tasin_c.x = lerp(asinValues[1], asinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tasin_c.x = lerp(asinValues[2], asinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tasin_c.x = lerp(asinValues[3], asinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tasin_c.x = lerp(asinValues[4], asinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tasin_c.x = lerp(asinValues[5], asinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tasin_c.x = lerp(asinValues[6], asinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tasin_c.x = lerp(asinValues[7], asinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tasin_c.x = lerp(asinValues[8], asinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tasin_c.x = lerp(asinValues[9], asinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tasin_c.x = lerp(asinValues[10], asinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tasin_c.x = lerp(asinValues[11], asinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tasin_c.x = lerp(asinValues[12], asinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tasin_c.x = lerp(asinValues[13], asinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tasin_c.x = lerp(asinValues[14], asinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tasin_c.x = lerp(asinValues[15], asinValues[16], weight.x);\n        else if (arr0x == 16)\n                asin_c.x = asinValues[16];\n\tif (arr0y == 0)\n\t\tasin_c.y = lerp(asinValues[0], asinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tasin_c.y = lerp(asinValues[1], asinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tasin_c.y = lerp(asinValues[2], asinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tasin_c.y = lerp(asinValues[3], asinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tasin_c.y = lerp(asinValues[4], asinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tasin_c.y = lerp(asinValues[5], asinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tasin_c.y = lerp(asinValues[6], asinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tasin_c.y = lerp(asinValues[7], asinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tasin_c.y = lerp(asinValues[8], asinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tasin_c.y = lerp(asinValues[9], asinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tasin_c.y = lerp(asinValues[10], asinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tasin_c.y = lerp(asinValues[11], asinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tasin_c.y = lerp(asinValues[12], asinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tasin_c.y = lerp(asinValues[13], asinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tasin_c.y = lerp(asinValues[14], asinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tasin_c.y = lerp(asinValues[15], asinValues[16], weight.y);\n        else if (arr0y == 16)\n                asin_c.y = asinValues[16];\n\tgl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? (true ? 0.0 : (false ? 0.0 : 1.0)) : ((1.0 * -1.0) - (0.5 * 2.0))), 0.5, lerp(((false ? -1.0 : -1.0) + (2.0 + 0.5)), +(false ? -1.0 : 1.0), (false ? 1.0 : lerp(0.0, 0.0, 0.0))), (true ? 0.0 : lerp((1.0 / -1.0), (-1.0 + 2.0), 0.0)));

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'lerp' : no matching overloaded function found
ERROR: 0:4: 'lerp' : no matching overloaded function found
ERROR: 0:4: 'lerp' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? (true ? 0.0 : (false ? 0.0 : 1.0)) : ((1.0 * -1.0) - (0.5 * 2.0))), 0.5, lerp(((false ? -1.0 : -1.0) + (2.0 + 0.5)), +(false ? -1.0 : 1.0), (false ? 1.0 : lerp(0.0, 0.0, 0.0))), (true ? 0.0 : lerp((1.0 / -1.0), (-1.0 + 2.0), 0.0)));

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 0.0 , 1.0);
}


==============================
65.78947368421053
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 1.0, 1.0, 1.0);

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.23376623376623
Mutations attempted: 77
Valid mutations:     51
Success rate:        66.23%
Processing this: /home/oof/webgl_cleaned/reflect_float_frag_ivarynconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (color.g + 1.0) / 2.0;
	float v2 = (color.b + 1.0) / 2.0;
	gl_FragColor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (color.g + 1.0) / 2.0;\n\tfloat v2 = (color.b + 1.0) / 2.0;\n\tgl_FragColor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g + 1.0) / 2.0);
  float v2 = ((color.b + 1.0) / 2.0);
  gl_FragColor = vec4((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/const_mat2_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	mat2 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 8.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = b[0][1] + b[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = b[1][0] + b[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tmat2 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((main() < (10.0 - 0.1)) || (x > (10.0 + -0.1))))
    gtf_Vertex = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:29: '<' : operation with void operands
ERROR: 0:29: '<' : wrong operand types - no operation '<' exists that takes a left-hand operand of type 'void' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:30: 'assign' : cannot convert from 'const bool' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((main() < (10.0 - 0.1)) || (x > (10.0 + -0.1))))
    gtf_Vertex = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
65.82278481012658
Processing this: /home/oof/webgl_cleaned/max_float_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = gtf_Color.r;
	if(c < max_c) c = max_c;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = gtf_Color.r;\n\tif(c < max_c) c = max_c;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-1.0, 1.0, 2.0, (2.0 / (-1.0 - -1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = gtf_Color.r;
  if ((c < max_c))
    c = max_c;
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.25
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
66.25
Processing this: /home/oof/webgl_cleaned/exp2_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((!true ? -1.0 : 0.0), 2.0, ((0.5 / 1.0) * 0.0), (((false ? true : false) && true) ? 2.0 : 0.0), (0.0 * 0.5), (false ? 0.5 : ((false ? 0.5 : 2.0) - 1.0)), -(0.0 + (2.0 + 1.0)), ((false ? 0.5 : +2.0) + 0.5), -1.0, 2.0, ++(0.0 / -1.0), 0.0, (1.0 + 0.0), +((true ? -1.0 : 2.0) + -1.0), 2.0, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((!true ? -1.0 : 0.0), 2.0, ((0.5 / 1.0) * 0.0), (((false ? true : false) && true) ? 2.0 : 0.0), (0.0 * 0.5), (false ? 0.5 : ((false ? 0.5 : 2.0) - 1.0)), -(0.0 + (2.0 + 1.0)), ((false ? 0.5 : +2.0) + 0.5), -1.0, 2.0, ++(0.0 / -1.0), 0.0, (1.0 + 0.0), +((true ? -1.0 : 2.0) + -1.0), 2.0, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
65.4320987654321
Processing this: /home/oof/webgl_cleaned/length_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(length(color.rgb) / 3.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(length(color.rgb) / 3.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, -1.0, -0.5, 0.0);

void main()
{
  gl_FragColor = vec4(vec3((length(color.rgb) / 3.0)) , 1.0);
}


As vertex? : False
SUCCESS!
65.85365853658537
Processing this: /home/oof/webgl_cleaned/ivec4_empty_empty_ivec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
ivec4 function(ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
ivec4 function(ivec4 par)
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nivec4 function(ivec4 par);\nbool is_all(const in ivec4 par, const in int value);\nvoid set_all(out ivec4 par, const in int value);\nvoid main ()\n{\n\tivec4 par = ivec4(1, 1, 1, 1);\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nivec4 function(ivec4 par)\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 par, const in int value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
65.85365853658537
Processing this: /home/oof/webgl_cleaned/sqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = sqrt(100.0 * gtf_Color.r);
	color = vec4(c * c / 100.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = sqrt(100.0 * gtf_Color.r);\n\tcolor = vec4(c * c / 100.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 1.0, (((false || false) || true) ? 2.0 : 2.0), (true ? 0.0 : (true ? (2.0 + -1.0) : -0.5)));

void main()
{
  float c = sqrt((100.0 * gtf_Color.r));
  color = vec4(((c * c) / 100.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.26506024096386
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	vec2 c = gtf_Color.rg;
	color = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, (0.5 * 0.0), 2.0, (true ? 0.5 : (-1.0 + (1.0 / 1.0))), -2.0, -1.0, 0.0, -0.5, (+0.5 * 0.0), (1.0 - -1.0), -2.0, 2.0, ((false || false) ? -1.0 : -1.0), +1.0, +-1.0, (1.0 - 0.0));

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, (0.5 * 0.0), 2.0, (true ? 0.5 : (-1.0 + (1.0 / 1.0))), -2.0, -1.0, 0.0, -0.5, (+0.5 * 0.0), (1.0 - -1.0), -2.0, 2.0, ((false || false) ? -1.0 : -1.0), +1.0, +-1.0, (1.0 - 0.0));

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
65.47619047619048
Processing this: /home/oof/webgl_cleaned/structnest_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct nestb
{
	mat2 b;
};
struct nesta
{
	mat2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );
	gl_FragColor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct nestb\n{\n\tmat2 b;\n};\nstruct nesta\n{\n\tmat2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );\n\tgl_FragColor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nestb {
  mat2 b;
};

struct nesta {
  mat2 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat2(11 , 13 , 29 , 33) , nestb(mat2(12 , 19 , 79 , 81))));
  gl_FragColor = vec4(vec3(((((((((s.nest_a.a[0][0] + s.nest_a.a[0][1]) + s.nest_a.a[1][0]) + s.nest_a.a[1][1]) + s.nest_a.nest_b.b[0][0]) + s.nest_a.nest_b.b[0][1]) + s.nest_a.nest_b.b[1][0]) + s.nest_a.nest_b.b[1][1]) / 277.0)) , 1.0);
}


As vertex? : False
SUCCESS!
65.88235294117646
Mutations attempted: 85
Valid mutations:     56
Success rate:        65.88%
Processing this: /home/oof/webgl_cleaned/Low_Level_Assembly_Reserved_Words_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform float MIN;
uniform float R0;
uniform float FOGC;
uniform float CUBE;
uniform float f;
uniform float o;
uniform float p;
uniform float w;
uniform float x;
uniform float y;
uniform float z;
void main()
{
	gl_FragColor = vec4(f, o, p, w);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform float MIN;\nuniform float R0;\nuniform float FOGC;\nuniform float CUBE;\nuniform float f;\nuniform float o;\nuniform float p;\nuniform float w;\nuniform float x;\nuniform float y;\nuniform float z;\nvoid main()\n{\n\tgl_FragColor = vec4(f, o, p, w);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w = 2.0;

uniform float x;

uniform float y;

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w = 2.0;

uniform float x;

uniform float y;

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


==============================
65.11627906976744
Processing this: /home/oof/webgl_cleaned/clamp_float_frag_xvary_yconstquarter_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = color.r;
	if(c > max_c) c = max_c;
	if(c < min_c) c = min_c;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = color.r;\n\tif(c > max_c) c = max_c;\n\tif(c < min_c) c = min_c;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = color.r;
  if ((c > max_c))
    c = max_c;
  if ((c < min_c))
    c = min_c;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
65.51724137931035
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x = (gtf_Color.r + 0.01) / 1.01;
	float y = 0.0;
	float z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	color = vec4(y / -4.61, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = (gtf_Color.r + 0.01) / 1.01;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tcolor = vec4(y / -4.61, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, 0.0, ((+1.0 + 1.0) * (2.0 / (false ? 0.5 : 0.5))), (2.0 + 0.5));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x = ((gtf_Color.r + 0.01) / 1.01);
  float y = 0.0;
  float z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  color = vec4((y / -4.61) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
65.9090909090909
Processing this: /home/oof/webgl_cleaned/lessThanEqual_ivec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec2 lte(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lte(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec2 lte(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lte(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


==============================
65.1685393258427
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 16.0 * color.r;
	gl_FragColor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 16.0 * color.r;\n\tgl_FragColor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((-1.0 - 0.5) - 1.0), 1.0, --(true ? 1.0 : 2.0), 0.5);

void main()
{
  float c = (16.0 * color.r);
  gl_FragColor = vec4((sqrt(c) / 4.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((-1.0 - 0.5) - 1.0), 1.0, --(true ? 1.0 : 2.0), 0.5);

void main()
{
  float c = (16.0 * color.r);
  gl_FragColor = vec4((sqrt(c) / 4.0) , 0.0 , 0.0 , 1.0);
}


==============================
64.44444444444444
Processing this: /home/oof/webgl_cleaned/exp2_float_vert_xvaryneg_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = gtf_Color.r;
	color = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((true ? false : false) ? !true : false) ? 0.5 : 0.5), +0.0, (((false ? true : false) ? (true ? 0.5 : 2.0) : -1.0) + 2.0), -1.0, (0.0 - (-1.0 + 0.5)), 1.0, 1.0, (+0.0 - -0.0), 0.0, ((true ? 0.0 : 1.0) + 2.0), (1.0 - 1.0), 1.0, 1.0, (0.5 / -1.0), (false ? +0.5 : 0.0), (true ? ((true ? false : true) ? (1.0 + -1.0) : 0.5) : ((true ? true : false) ? -0.0 : (true ? 0.5 : -1.0))));

vec4 color;

void main()
{
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(2.0 , (5.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((true ? false : false) ? !true : false) ? 0.5 : 0.5), +0.0, (((false ? true : false) ? (true ? 0.5 : 2.0) : -1.0) + 2.0), -1.0, (0.0 - (-1.0 + 0.5)), 1.0, 1.0, (+0.0 - -0.0), 0.0, ((true ? 0.0 : 1.0) + 2.0), (1.0 - 1.0), 1.0, 1.0, (0.5 / -1.0), (false ? +0.5 : 0.0), (true ? ((true ? false : true) ? (1.0 + -1.0) : 0.5) : ((true ? true : false) ? -0.0 : (true ? 0.5 : -1.0))));

vec4 color;

void main()
{
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(2.0 , (5.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.73626373626373
Processing this: /home/oof/webgl_cleaned/sign_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	if(c[0] > 0.0) c[0] = 1.0 * c[0];
	if(c[0] < 0.0) c[0] = -1.0 * c[0];
	if(c[1] > 0.0) c[1] = 1.0 * c[1];
	if(c[1] < 0.0) c[1] = -1.0 * c[1];
	if(c[2] > 0.0) c[2] = 1.0 * c[2];
	if(c[2] < 0.0) c[2] = -1.0 * c[2];
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tif(c[0] > 0.0) c[0] = 1.0 * c[0];\n\tif(c[0] < 0.0) c[0] = -1.0 * c[0];\n\tif(c[1] > 0.0) c[1] = 1.0 * c[1];\n\tif(c[1] < 0.0) c[1] = -1.0 * c[1];\n\tif(c[2] > 0.0) c[2] = 1.0 * c[2];\n\tif(c[2] < 0.0) c[2] = -1.0 * c[2];\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.5, 0.5, 0.5);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  if ((c[0] > 0.0))
    c[0] = (1.0 * c[0]);
  if ((c[0] < 0.0))
    c[0] = (-1.0 * c[0]);
  if ((c[1] > 0.0))
    c[1] = (1.0 * c[1]);
  if ((c[1] < 0.0))
    c[1] = (-1.0 * c[1]);
  if ((c[2] > 0.0))
    c[2] = (1.0 * c[2]);
  if ((c[2] < 0.0))
    c[2] = (-1.0 * c[2]);
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
SUCCESS!
64.13043478260869
Processing this: /home/oof/webgl_cleaned/structUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 a_vertex;
attribute vec3 a_normal;
uniform mat4 u_modelViewProjMatrix;
struct MyStruct
{
  int x;
  int y;
};
uniform MyStruct u_struct;
uniform float u_array[4];
varying vec3 v_normal;
void main()
{
    v_normal = a_normal;
    gl_Position = u_modelViewProjMatrix * a_vertex +
        vec4(u_struct.x, u_struct.y, 0, 1) +
        vec4(u_array[0], u_array[1], u_array[2], u_array[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 a_vertex;\nattribute vec3 a_normal;\nuniform mat4 u_modelViewProjMatrix;\nstruct MyStruct\n{\n  int x;\n  int y;\n};\nuniform MyStruct u_struct;\nuniform float u_array[4];\nvarying vec3 v_normal;\nvoid main()\n{\n    v_normal = a_normal;\n    gl_Position = u_modelViewProjMatrix * a_vertex +\n        vec4(u_struct.x, u_struct.y, 0, 1) +\n        vec4(u_array[0], u_array[1], u_array[2], u_array[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 a_vertex;

vec3 a_normal;

uniform mat4 u_modelViewProjMatrix;

struct MyStruct {
  int x;
  int y;
};

uniform MyStruct u_struct;

uniform float u_array[4];

vec3 v_normal;

void main()
{
  v_normal = a_normal;
  gl_Position = (((u_modelViewProjMatrix * a_vertex) + vec4(u_struct.x , u_struct.y , 0 , 1)) + vec4(u_array[0] , u_array[1] , u_array[2] , u_array[3]));
}


As vertex? : True
SUCCESS!
64.51612903225806
Processing this: /home/oof/webgl_cleaned/abs_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (color.rg - 0.5);
	if((c[0] < 0.0)) c[0] *= -1.0;
	if((c[1] < 0.0)) c[1] *= -1.0;
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tif((c[0] < 0.0)) c[0] *= -1.0;\n\tif((c[1] < 0.0)) c[1] *= -1.0;\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(--(-1.0 - -1.0), 0.5, 0.0, 0.0);

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(--(-1.0 - -1.0), 0.5, 0.0, 0.0);

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


==============================
63.829787234042556
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.829787234042556
Mutations attempted: 94
Valid mutations:     60
Success rate:        63.83%
Processing this: /home/oof/webgl_cleaned/cos_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * gtf_Color.rgb;
	float sign = -1.0;
	vec3 cos_c = vec3(1.0,1.0,1.0);
	float fact = 1.0;
	for(int i = 2; i <= 20; i += 2)
	{
		fact *= float(i)*float(i-1);
		cos_c += sign*pow(c, vec3(float(i),float(i),float(i)))/fact;
		sign = -sign;
	}
	color = vec4(0.5 * cos_c + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * gtf_Color.rgb;\n\tfloat sign = -1.0;\n\tvec3 cos_c = vec3(1.0,1.0,1.0);\n\tfloat fact = 1.0;\n\tfor(int i = 2; i <= 20; i += 2)\n\t{\n\t\tfact *= float(i)*float(i-1);\n\t\tcos_c += sign*pow(c, vec3(float(i),float(i),float(i)))/fact;\n\t\tsign = -sign;\n\t}\n\tcolor = vec4(0.5 * cos_c + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * gtf_Color.rgb);
  float sign = -1.0;
  vec3 cos_c = vec3(1.0 , 1.0 , 1.0);
  float fact = 1.0;
  for (int i = 2; (i <= 20); (i += 2))
  {
    (fact *= (float(i) * float((i - 1))));
    (cos_c += ((sign * pow(c , vec3(float(i) , float(i) , float(i)))) / fact));
    sign = -sign;
  }
  color = vec4(((0.5 * cos_c) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.21052631578948
Processing this: /home/oof/webgl_cleaned/fboShader0.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
varying vec4 texCoord[1];
varying vec4 color;
uniform mat4 gtf_ModelViewProjectionMatrix;
void main ()
{
    color = gtf_Color;
    texCoord[0] = gtf_MultiTexCoord0;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 texCoord[1];\nvarying vec4 color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid main ()\n{\n    color = gtf_Color;\n    texCoord[0] = gtf_MultiTexCoord0;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1] = vec4[1](vec4(2.0, 1.0, -0.5, -0.5));

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:10: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:10: '=' : Invalid operation for arrays
ERROR: 0:10: '=' : cannot convert from 'const array[1] of 4-component vector of float' to 'mediump array[1] of 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1] = vec4[1](vec4(2.0, 1.0, -0.5, -0.5));

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.541666666666664
Processing this: /home/oof/webgl_cleaned/vec4_tsqp_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.tsqp;
	vec4 a = vec4(m.t, m.s, m.q, m.p);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.tsqp;\n\tvec4 a = vec4(m.t, m.s, m.q, m.p);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!false ? 0.5 : --1.0), 0.0, -1.0, 0.5);

void main()
{
  vec4 al = color;
  vec4 m = al.tsqp;
  vec4 a = vec4(m.t , m.s , m.q , m.p);
  gl_FragColor = a;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4((!false ? 0.5 : --1.0), 0.0, -1.0, 0.5);

void main()
{
  vec4 al = color;
  vec4 m = al.tsqp;
  vec4 a = vec4(m.t , m.s , m.q , m.p);
  gl_FragColor = a;
}


==============================
62.88659793814433
Processing this: /home/oof/webgl_cleaned/sin_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((true ? -1.0 : 0.0) + (0.0 + 0.0)) / (1.0 * (1.0 / 0.0))), 0.5, 0.5, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.26530612244898
Processing this: /home/oof/webgl_cleaned/step_float_frag_xvary_edgeconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float edge = 0.5;
	float c = color.r;
	if(c >= edge) c = 1.0;
	else c = 0.0;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge = 0.5;\n\tfloat c = color.r;\n\tif(c >= edge) c = 1.0;\n\telse c = 0.0;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!(true && true) ? 1.0 : (!false ? (true ? 2.0 : 0.5) : 0.5)), (((false && true) ? false : (false && false)) ? ((false ? false : true) ? 0.0 : 0.5) : (true ? 2.0 : 0.0)), -((false && true) ? (0.5 * 1.0) : 0.5), -1.0);

void main()
{
  const float edge = 0.5;
  float c = color.r;
  if ((c >= edge))
    c = 1.0;
  else
    c = 0.0;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0);
}


==============================
63.0
Processing this: /home/oof/webgl_cleaned/bool_empty_inout_bool_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(inout bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(!par && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(inout bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(inout bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(!par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(inout bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
63.0
Processing this: /home/oof/webgl_cleaned/degrees_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +-1.0, (0.5 / -(0.0 * 1.0)), 1.0, -0.5, (false ? -1.0 : 1.0), 2.0, +0.0, 0.5, 0.5, 0.5, 0.5, 2.0, 1.0, 0.5, 2.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +-1.0, (0.5 / -(0.0 * 1.0)), 1.0, -0.5, (false ? -1.0 : 1.0), 2.0, +0.0, 0.5, 0.5, 0.5, 0.5, 2.0, 1.0, 0.5, 2.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.37623762376238
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg * 99.0) + 1.0;
	gl_FragColor = vec4(inversesqrt(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg * 99.0) + 1.0;\n\tgl_FragColor = vec4(inversesqrt(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = ((color.rg * 99.0) + 2.0);
  gl_FragColor = vec4(inversesqrt(c) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.745098039215684
Processing this: /home/oof/webgl_cleaned/gl_FrontFacing_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
	if(gl_FrontFacing)
		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
	else
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n\tif(gl_FrontFacing)\n\t\tgl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n\telse\n\t\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  if (gl_FrontFacing)
    gl_FragColor = vec4(0.0 , 1.0 , 0.0);
  else
    (-(false ? -1.0 : 2.0) / +0.5) = vec4(1.0 , 0.0 , 0.0);
  vec4(((false && (false ? true : false)) ? (0.5 + (0.0 + -1.0)) : 1.0), -1.0, 0.0, -1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:7: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  if (gl_FrontFacing)
    gl_FragColor = vec4(0.0 , 1.0 , 0.0);
  else
    (-(false ? -1.0 : 2.0) / +0.5) = vec4(1.0 , 0.0 , 0.0);
  vec4(((false && (false ? true : false)) ? (0.5 + (0.0 + -1.0)) : 1.0), -1.0, 0.0, -1.0);
}


==============================
62.13592233009708
Mutations attempted: 103
Valid mutations:     64
Success rate:        62.14%
Processing this: /home/oof/webgl_cleaned/exp_vec3_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	vec3 c = color.rgb;
	gl_FragColor = vec4(1.0 / pow(vec3(exp1), 3.0 * c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(1.0 / pow(vec3(exp1), 3.0 * c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  vec3 c = color.rgb;
  ((false ? 0.0 : 2.0) * +1.0) = vec4((1.0 / pow(vec3(exp1) , (3.0 * c))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction
ERROR: 0:10: 'assign' : l-value required (can't modify a const)
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  vec3 c = color.rgb;
  ((false ? 0.0 : 2.0) * +1.0) = vec4((1.0 / pow(vec3(exp1) , (3.0 * c))));
}


==============================
61.53846153846154
Processing this: /home/oof/webgl_cleaned/fragmentOnly3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    gl_FragColor = vec4(1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    gl_FragColor = vec4(1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1.0);
}


As vertex? : True
SUCCESS!
61.904761904761905
Processing this: /home/oof/webgl_cleaned/tan_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	float o;
	if(abs(c) < 0.5)
		o = 0.5 * tan(c) + 0.5;
	else
		o = 0.5 / tan(c) + 0.5;
	color = vec4(o, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tfloat o;\n\tif(abs(c) < 0.5)\n\t\to = 0.5 * tan(c) + 0.5;\n\telse\n\t\to = 0.5 / tan(c) + 0.5;\n\tcolor = vec4(o, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(2.0, ((true ? (true && false) : (false ? true : true)) ? ((false && true) ? (false ? -1.0 : 2.0) : -0.0) : 2.0), 0.0, 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((0.5 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  float o;
  if ((abs(c) < 0.5))
    o = ((0.5 * tan(c)) + 0.5);
  else
    o = ((0.5 / tan(c)) + 0.5);
  color = vec4(o , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.264150943396224
Processing this: /home/oof/webgl_cleaned/array_const_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
		             5.0,  6.0,  7.0,  8.0,
			     9.0, 10.0, 11.0, 12.0,
			    13.0, 14.0, 15.0, 16.0);
	const mat4 b = mat4(17.0, 18.0, 19.0, 20.0,
		            21.0, 22.0, 23.0, 24.0,
			    25.0, 26.0, 27.0, 28.0,
			    29.0, 30.0, 31.0, 32.0);
	mat4 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t\t             5.0,  6.0,  7.0,  8.0,\n\t\t\t     9.0, 10.0, 11.0, 12.0,\n\t\t\t    13.0, 14.0, 15.0, 16.0);\n\tconst mat4 b = mat4(17.0, 18.0, 19.0, 20.0,\n\t\t            21.0, 22.0, 23.0, 24.0,\n\t\t\t    25.0, 26.0, 27.0, 28.0,\n\t\t\t    29.0, 30.0, 31.0, 32.0);\n\tmat4 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.616822429906534
Processing this: /home/oof/webgl_cleaned/4b_firstthree_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform bvec4 color;
void main ()
{
	gl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform bvec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bvec4 color = bvec4((0.5 - (false ? (false ? -1.0 : 2.0) : -1.0)), (!true ? 1.0 : -1.0), (false ? -1.0 : 0.5), 2.0);

void main()
{
  gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bvec4 color = bvec4((0.5 - (false ? (false ? -1.0 : 2.0) : -1.0)), (!true ? 1.0 : -1.0), (false ? -1.0 : 0.5), 2.0);

void main()
{
  gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]) , 1.0);
}


==============================
62.03703703703704
Processing this: /home/oof/webgl_cleaned/vec4_empty_empty_vec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(vec4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(vec4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
62.03703703703704
Processing this: /home/oof/webgl_cleaned/mat2_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat2 m = mat2(0.5);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if((m[0][0] != 0.5))
		result = black;
	if((m[0][1] != 0.0))
		result = black;
	if((m[1][0] != 0.0))
		result = black;
	if((m[1][1] != 0.5))
		result = black;
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m = mat2(0.5);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif((m[0][0] != 0.5))\n\t\tresult = black;\n\tif((m[0][1] != 0.0))\n\t\tresult = black;\n\tif((m[1][0] != 0.0))\n\t\tresult = black;\n\tif((m[1][1] != 0.5))\n\t\tresult = black;\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.0, 0.0, -1.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat2 m = mat2(0.5);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != 0.5))
    result = black;
  if ((m[0][1] != 0.0))
    result = black;
  if ((m[1][0] != 0.0))
    result = black;
  if ((m[1][1] != 0.5))
    result = black;
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.38532110091744
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par)
{
	par = 0;
	return 1;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par)\n{\n\tpar = 0;\n\treturn 1;\n}\n\x00')
62.38532110091744
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.81818181818181
Processing this: /home/oof/webgl_cleaned/faceforward_float_vert_nvaryiconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g * 2.0) - 1.0;
	float v2 = (gtf_Color.b * 2.0) - 1.0;
	if(dot(v1, v2) >= 0.0) v1 *= -1.0;
	color = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g * 2.0) - 1.0;\n\tfloat v2 = (gtf_Color.b * 2.0) - 1.0;\n\tif(dot(v1, v2) >= 0.0) v1 *= -1.0;\n\tcolor = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g * 2.0) - 1.0);
  float v2 = ((gtf_Color.b * 2.0) - 1.0);
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  color = vec4(((v1 + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'color' : undeclared identifier
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g * 2.0) - 1.0);
  float v2 = ((gtf_Color.b * 2.0) - 1.0);
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  color = vec4(((v1 + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.261261261261254
Mutations attempted: 111
Valid mutations:     68
Success rate:        61.26%
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	vec3 c = clamp((gtf_Color.rgb - edge0) / (edge1 - edge0), 0.0, 1.0);
	color = vec4(c * c * (3.0 - 2.0 * c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tvec3 c = clamp((gtf_Color.rgb - edge0) / (edge1 - edge0), 0.0, 1.0);\n\tcolor = vec4(c * c * (3.0 - 2.0 * c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, 0.5, -0.5, 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  vec3 c = clamp(((gtf_Color.rgb - edge0) / (edge1 - edge0)) , 0.0 , 1.0);
  color = vec4(((c * c) * (3.0 - (2.0 * c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.60714285714286
Processing this: /home/oof/webgl_cleaned/vec4_gr_ab_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.gr;
	vec2 n = lightloc.ab;
	vec4 a = vec4(m.g, m.r, n.g, n.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.gr;\n\tvec2 n = lightloc.ab;\n\tvec4 a = vec4(m.g, m.r, n.g, n.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, --1.0, +(false ? (true ? 2.0 : 0.5) : 0.5), 2.0, 1.0, 0.0, +((0.0 / 1.0) / (-1.0 / 1.0)), 0.0, 1.0, 2.0, 1.0, 0.5, 2.0, 0.5, (2.0 + 1.0), 0.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.gr;
  vec2 n = lightloc.ab;
  vec4 a = vec4(m.g , m.r , n.g , n.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, --1.0, +(false ? (true ? 2.0 : 0.5) : 0.5), 2.0, 1.0, 0.0, +((0.0 / 1.0) / (-1.0 / 1.0)), 0.0, 1.0, 2.0, 1.0, 0.5, 2.0, 0.5, (2.0 + 1.0), 0.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.gr;
  vec2 n = lightloc.ab;
  vec4 a = vec4(m.g , m.r , n.g , n.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
61.06194690265486
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
61.06194690265486
Processing this: /home/oof/webgl_cleaned/max_float_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = color.r;
	if(c < max_c) c = max_c;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = color.r;\n\tif(c < max_c) c = max_c;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = color.r;
  if ((c < max_c))
    c = max_c;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.40350877192983
Processing this: /home/oof/webgl_cleaned/matrix2arrayVSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --1.0, (true ? +1.0 : ((2.0 / 0.5) * (2.0 + 1.0))), (2.0 * 0.0));

void main()
{
  gl_FragColor = color;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --1.0, (true ? +1.0 : ((2.0 / 0.5) * (2.0 + 1.0))), (2.0 * 0.0));

void main()
{
  gl_FragColor = color;
}


==============================
60.86956521739131
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-(true ? 1.0 : (1.0 * -1.0)), (-1.0 / +(-1.0 + 2.0)), -1.0, +1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.206896551724135
Processing this: /home/oof/webgl_cleaned/const_mat4_copy_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	mat4 b = a;
	bool elms = true;
	if(b[0][0] !=  1.0) elms = false;
	if(b[0][1] !=  2.0) elms = false;
	if(b[0][2] !=  3.0) elms = false;
	if(b[0][3] !=  4.0) elms = false;
	if(b[1][0] !=  5.0) elms = false;
	if(b[1][1] !=  6.0) elms = false;
	if(b[1][2] !=  7.0) elms = false;
	if(b[1][3] !=  8.0) elms = false;
	if(b[2][0] !=  9.0) elms = false;
	if(b[2][1] != 10.0) elms = false;
	if(b[2][2] != 11.0) elms = false;
	if(b[2][3] != 12.0) elms = false;
	if(b[3][0] != 13.0) elms = false;
	if(b[3][1] != 14.0) elms = false;
	if(b[3][2] != 15.0) elms = false;
	if(b[3][3] != 16.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0] + b[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = b[0][1] + b[1][1] + b[2][1] + b[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = b[0][2] + b[1][2] + b[2][2] + b[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = b[0][3] + b[1][3] + b[2][3] + b[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2] + b[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = b[1][0] + b[1][1] + b[1][2] + b[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2] + b[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = b[3][0] + b[3][1] + b[3][2] + b[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tmat4 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=  1.0) elms = false;\n\tif(b[0][1] !=  2.0) elms = false;\n\tif(b[0][2] !=  3.0) elms = false;\n\tif(b[0][3] !=  4.0) elms = false;\n\tif(b[1][0] !=  5.0) elms = false;\n\tif(b[1][1] !=  6.0) elms = false;\n\tif(b[1][2] !=  7.0) elms = false;\n\tif(b[1][3] !=  8.0) elms = false;\n\tif(b[2][0] !=  9.0) elms = false;\n\tif(b[2][1] != 10.0) elms = false;\n\tif(b[2][2] != 11.0) elms = false;\n\tif(b[2][3] != 12.0) elms = false;\n\tif(b[3][0] != 13.0) elms = false;\n\tif(b[3][1] != 14.0) elms = false;\n\tif(b[3][2] != 15.0) elms = false;\n\tif(b[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0] + b[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1] + b[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2] + b[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = b[0][3] + b[1][3] + b[2][3] + b[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2] + b[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2] + b[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2] + b[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = b[3][0] + b[3][1] + b[3][2] + b[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 3.0))
    elms = false;
  if ((b[0][3] != 4.0))
    elms = false;
  if ((b[1][0] != 5.0))
    elms = false;
  if ((b[1][1] != 6.0))
    elms = false;
  if ((b[1][2] != 7.0))
    elms = false;
  if ((b[1][3] != 8.0))
    elms = false;
  if ((b[2][0] != 9.0))
    elms = false;
  if ((b[2][1] != 10.0))
    elms = false;
  if ((b[2][2] != 11.0))
    elms = false;
  if ((b[2][3] != 12.0))
    elms = false;
  if ((b[3][0] != 13.0))
    elms = false;
  if ((b[3][1] != 14.0))
    elms = false;
  if ((b[3][2] != 15.0))
    elms = false;
  if ((b[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((b[0][0] + b[0][1]) + b[0][2]) + b[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
61.53846153846154
Processing this: /home/oof/webgl_cleaned/log_vec3_frag_xvary01_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 x = (color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	gl_FragColor = vec4(y / -4.61, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 x = (color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tgl_FragColor = vec4(y / -4.61, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 x = ((color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  gl_FragColor = vec4((y / -4.61) , 1.0);
}


As vertex? : False
SUCCESS!
61.86440677966102
Processing this: /home/oof/webgl_cleaned/degrees_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.18487394957983
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 x = 31.0 * gtf_Color.rg + 1.0;
	vec2 y = vec2(0.0);
	vec2 z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	vec2 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	color = vec4(y / 3.466, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 x = 31.0 * gtf_Color.rg + 1.0;\n\tvec2 y = vec2(0.0);\n\tvec2 z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tvec2 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tcolor = vec4(y / 3.466, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 2.0, 2.0, ((true ? !true : (false ? false : true)) ? -2.0 : +(0.0 / 0.0)));

void main()
{
  vec2 x = ((31.0 * gtf_Color.rg) + 1.0);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.5
Mutations attempted: 120
Valid mutations:     75
Success rate:        62.50%
Processing this: /home/oof/webgl_cleaned/sqrt_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 100.0 * color.rgb;
	gl_FragColor = vec4(c / 100.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 100.0 * color.rgb;\n\tgl_FragColor = vec4(c / 100.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, -1.0, 0.0, 2.0);

void main()
{
  vec3 c = (100.0 * color.rgb);
  gl_FragColor = vec4((c / 100.0) , 1.0);
}


As vertex? : False
SUCCESS!
62.8099173553719
Processing this: /home/oof/webgl_cleaned/normalize_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(tmp_Color.rg / length(tmp_Color.rg), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(tmp_Color.rg / length(tmp_Color.rg), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? 2.0 : (-1.0 * (false ? -1.0 : 2.0))), 0.5, 1.0, 1.0);

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  gl_FragColor = vec4((tmp_Color.rg / length(tmp_Color.rg)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.114754098360656
Processing this: /home/oof/webgl_cleaned/greaterThan_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 gt(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] > b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(gt(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 gt(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] > b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(gt(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((0.0 * -1.0), 1.0, (0.5 * ((true || false) ? (1.0 / 0.0) : 0.0)), (1.0 * 1.0));

bvec3 gt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] > b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.41463414634146
Processing this: /home/oof/webgl_cleaned/gl_MaxVertexUniformVectors_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(float(gl_MaxVertexUniformVectors) / 128.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(gl_MaxVertexUniformVectors) / 128.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((+0.5 * 0.5), (2.0 * (+0.0 - (false ? 0.5 : 0.5))), (true ? -1.0 : +(false ? 2.0 : 0.5)), 2.0);

void main()
{
  color = vec4((float(gl_MaxVertexUniformVectors) / 128.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.70967741935484
Processing this: /home/oof/webgl_cleaned/tan_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);
	vec2 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * tan(c.r) + 0.5;
	else
		o.r = 0.5 / tan(c.r) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * tan(c.g) + 0.5;
	else
		o.g = 0.5 / tan(c.g) + 0.5;
	gl_FragColor = vec4(o, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);\n\tvec2 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * tan(c.r) + 0.5;\n\telse\n\t\to.r = 0.5 / tan(c.r) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * tan(c.g) + 0.5;\n\telse\n\t\to.g = 0.5 / tan(c.g) + 0.5;\n\tgl_FragColor = vec4(o, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((0.5 * M_PI) * 2.0) * (color.rg - 0.5));
  vec2 o = vec2(2.0, 2.0);
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 1.0);
  ivec2((-3 - ((false || true) ? 6 : (3 / 6))), (true ? (false ? 3 : 7) : +6));
}


As vertex? : False
SUCCESS!
64.0
Processing this: /home/oof/webgl_cleaned/exp_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	vec3 c = color.rgb;
	gl_FragColor = vec4(exp(3.0 * c) / exp3, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(exp(3.0 * c) / exp3, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3));
}


==============================
63.49206349206349
Processing this: /home/oof/webgl_cleaned/cross_vec3_frag_xvaryyconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = vec3(1.0, 0.0, 0.0);
	vec3 v3;
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	v3.x = v1.y * v2.z - v2.y * v1.z;
	v3.y = v2.x * v1.z - v1.x * v2.z;
	v3.z = v1.x * v2.y - v2.x * v1.y;
	gl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = vec3(1.0, 0.0, 0.0);\n\tvec3 v3;\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tv3.x = v1.y * v2.z - v2.y * v1.z;\n\tv3.y = v2.x * v1.z - v1.x * v2.z;\n\tv3.z = v1.x * v2.y - v2.x * v1.y;\n\tgl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, ((1.0 - -1.0) + 1.0), 0.5, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = vec3(1.0 , 0.0 , 0.0);
  vec3 v3;
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  v3.x = ((v1.y * v2.z) - (v2.y * v1.z));
  v3.y = ((v2.x * v1.z) - (v1.x * v2.z));
  v3.z = ((v1.x * v2.y) - (v2.x * v1.y));
  gl_FragColor = vec4(((v3 + 1.0) / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
63.77952755905512
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 lte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lte(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 lte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lte(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = mat4((-2.0 - -2.0), --1.0, 2.0, 2.0, 0.0, ((true ? (false ? 0.5 : 2.0) : 2.0) + 0.0), 0.0, +(true ? -0.5 : (-1.0 / -1.0)), --1.0, ((0.5 - -2.0) / (2.0 - 0.5)), 1.0, 2.0, 0.0, 0.0, 0.5, 2.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:31: '--' : l-value required (can't modify a const)
ERROR: 0:31: '--' : l-value required (can't modify a const)
ERROR: 0:31: '=' : dimension mismatch
ERROR: 0:31: 'assign' : cannot convert from 'const 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = mat4((-2.0 - -2.0), --1.0, 2.0, 2.0, 0.0, ((true ? (false ? 0.5 : 2.0) : 2.0) + 0.0), 0.0, +(true ? -0.5 : (-1.0 / -1.0)), --1.0, ((0.5 - -2.0) / (2.0 - 0.5)), 1.0, 2.0, 0.0, 0.0, 0.5, 2.0);
}


==============================
63.28125
Processing this: /home/oof/webgl_cleaned/vec3_zyx_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	vec3 t = m.zyx;
	vec4 a = vec4(t.z, t.y, t.x ,al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tvec3 t = m.zyx;\n\tvec4 a = vec4(t.z, t.y, t.x ,al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  vec3 t = m.zyx;
  vec4 a = vec4(t.z , t.y , t.x , al.w);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
63.565891472868216
Processing this: /home/oof/webgl_cleaned/fboShader0.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
varying vec4 texCoord[1];
varying vec4 color;
uniform mat4 gtf_ModelViewProjectionMatrix;
void main ()
{
    color = gtf_Color;
    texCoord[0] = gtf_MultiTexCoord0;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 texCoord[1];\nvarying vec4 color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid main ()\n{\n    color = gtf_Color;\n    texCoord[0] = gtf_MultiTexCoord0;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0 = vec4(-(-1.0 * 0.5), (!(true ? false : true) ? 2.0 : (true ? (false ? 0.0 : 2.0) : -1.0)), (+--1.0 * -+-1.0), -(1.0 + 0.5));

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0 = vec4(-(-1.0 * 0.5), (!(true ? false : true) ? 2.0 : (true ? (false ? 0.0 : 2.0) : -1.0)), (+--1.0 * -+-1.0), -(1.0 + 0.5));

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.07692307692307
Mutations attempted: 130
Valid mutations:     82
Success rate:        63.08%
Processing this: /home/oof/webgl_cleaned/log2_vec3_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = (gtf_Color.rgb + 0.01) / 1.01;
	color = vec4(log2(c) / -8.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (gtf_Color.rgb + 0.01) / 1.01;\n\tcolor = vec4(log2(c) / -8.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, -1.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.5, -0.5, 1.0, 1.0, -1.0, 2.0, -1.0, 2.0, 1.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log2(c) / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, -1.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.5, -0.5, 1.0, 1.0, -1.0, 2.0, -1.0, 2.0, 1.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log2(c) / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.59541984732825
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = ((!true ? (true ? true : false) : (false ? false : false)) ? vec4((-1.0 + (0.5 + (1.0 * 0.0))), 1.0, 1.0, +2.0) : gtf_Vertex);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_Vertex' : undeclared identifier
ERROR: 0:6: '?:' : mismatching ternary operator operand types 'const 4-component vector of float and 'const highp float'
ERROR: 0:6: '=' : dimension mismatch
ERROR: 0:6: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = ((!true ? (true ? true : false) : (false ? false : false)) ? vec4((-1.0 + (0.5 + (1.0 * 0.0))), 1.0, 1.0, +2.0) : gtf_Vertex);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.121212121212125
Processing this: /home/oof/webgl_cleaned/degrees_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 / 0.0), (!true ? -(false ? -1.0 : 2.0) : -1.0), +1.0, 0.0, --1.0, (((true && true) ? (0.5 / 0.5) : 1.0) / ((-1.0 * 2.0) - (false ? -1.0 : 1.0))), -2.0, 0.0, 0.5, 1.0, +0.5, (-(false ? 0.5 : -1.0) + (false ? -2.0 : (true ? 1.0 : 2.0))), (-1.0 / -1.0), 1.0, -1.0, (!(true || false) ? ((-1.0 + 1.0) * (false ? -1.0 : 0.5)) : -0.5));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 / 0.0), (!true ? -(false ? -1.0 : 2.0) : -1.0), +1.0, 0.0, --1.0, (((true && true) ? (0.5 / 0.5) : 1.0) / ((-1.0 * 2.0) - (false ? -1.0 : 1.0))), -2.0, 0.0, 0.5, 1.0, +0.5, (-(false ? 0.5 : -1.0) + (false ? -2.0 : (true ? 1.0 : 2.0))), (-1.0 / -1.0), 1.0, -1.0, (!(true || false) ? ((-1.0 + 1.0) * (false ? -1.0 : 0.5)) : -0.5));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.65413533834586
Processing this: /home/oof/webgl_cleaned/bvec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform bool vuni1;
uniform bvec2 vuni2;
uniform bvec3 vuni3;
uniform bvec4 vuni4;
varying vec4 color;
void main ()
{
	if(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])
	color = vec4(1.0, 0.0, 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform bool vuni1;\nuniform bvec2 vuni2;\nuniform bvec3 vuni3;\nuniform bvec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tif(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])\n\tcolor = vec4(1.0, 0.0, 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((true ? (0.0 - -1.0) : 1.0), (false ? -1.0 : -1.0), 2.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform bool vuni1;

uniform bvec2 vuni2;

uniform bvec3 vuni3;

uniform bvec4 vuni4;

vec4 color;

void main()
{
  if (((vuni1 || ((((vuni2[0] && vuni2[1]) && vuni3[0]) && vuni3[1]) && vuni3[2])) || (((vuni4[0] && vuni4[1]) && vuni4[2]) && vuni4[3])))
    color = vec4(1.0 , 0.0 , 0.5 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.940298507462686
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 ne(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(ne(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 ne(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(ne(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(0.5 / 0.5), (1.0 - ((0.0 / -1.0) / --1.0)), -(1.0 - 0.5), +(0.5 + 0.0));

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(0.5 / 0.5), (1.0 - ((0.0 / -1.0) / --1.0)), -(1.0 - 0.5), +(0.5 + 0.0));

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.48148148148148
Processing this: /home/oof/webgl_cleaned/extension8_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
61.48148148148148
Processing this: /home/oof/webgl_cleaned/exp2_float_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = -gtf_Color.r;
	color = vec4(exp2(5.0 * c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = -gtf_Color.r;\n\tcolor = vec4(exp2(5.0 * c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (-0.5 + 2.0), -1.0, (0.0 - (false ? (true ? 2.0 : -1.0) : 1.0)));

void main()
{
  float c = -gtf_Color.r;
  color = vec4(exp2((5.0 * c)) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.76470588235294
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xvary_yconst2_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = color.rgb;
	gl_FragColor = vec4(c * c / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(c * c / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, -1.0, (((false ? 0.5 : 1.0) / 0.0) / (1.0 + (false ? 0.0 : 1.0))), ((false ? false : !true) ? 0.5 : (true ? (true ? 1.0 : 0.0) : (0.0 + 0.0))));

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4(((c * c) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
62.04379562043796
Processing this: /home/oof/webgl_cleaned/preprocess10_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  -2.0;
  vec4(+-1.0, 0.5, 1.0, 1.0);
}


As vertex? : False
SUCCESS!
62.31884057971014
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	float s = lightloc.s;
	float t = lightloc.t;
	float p = lightloc.p;
	float q = lightloc.q;
	vec4 m = vec4(s, t, p, q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tfloat s = lightloc.s;\n\tfloat t = lightloc.t;\n\tfloat p = lightloc.p;\n\tfloat q = lightloc.q;\n\tvec4 m = vec4(s, t, p, q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  float s = lightloc.s;
  float t = lightloc.t;
  float p = lightloc.p;
  float q = lightloc.q;
  vec4 m = vec4(s , t , p , q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
SUCCESS!
62.589928057553955
Mutations attempted: 139
Valid mutations:     87
Success rate:        62.59%
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gte(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 gte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(gte(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 gte(in vec2 a, in vec2 b)
{
  bvec2 result = bvec2(-1.0, 1.0);
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
  vec4(2.0, (((true ? -1.0 : 0.5) * 0.5) / (false ? 0.5 : 0.0)), 2.0, -1.0);
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(gte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.857142857142854
Processing this: /home/oof/webgl_cleaned/notEqual_bvec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 ne(in bvec2 a, in bvec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(ne(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 ne(in bvec2 a, in bvec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(ne(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 ne(in bvec2 a, in bvec2 b)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(ne(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.12056737588653
Processing this: /home/oof/webgl_cleaned/ceil_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0));
}


==============================
62.676056338028175
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float s = al.s;
	float t = al.t;
	float p = al.p;
	float q = al.q;
	vec4 m = vec4(s,t,p,q);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat s = al.s;\n\tfloat t = al.t;\n\tfloat p = al.p;\n\tfloat q = al.q;\n\tvec4 m = vec4(s,t,p,q);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, 0.0, (false ? (!true ? 1.0 : (-1.0 * 1.0)) : -1.0), 2.0);

void main()
{
  vec4 al = color;
  float s = al.s;
  float t = al.t;
  float p = al.p;
  float q = al.q;
  vec4 m = vec4(s , t , p , q);
  gl_FragColor = m;
}


As vertex? : False
SUCCESS!
62.93706293706294
Processing this: /home/oof/webgl_cleaned/dFdx_frag_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.19444444444444
Processing this: /home/oof/webgl_cleaned/const_mat3_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0,   2.0,   4.0,
	                     8.0,  16.0,  32.0,
	                    64.0, 128.0, 256.0);
	mat3 b = a;
	bool elms = true;
	if(b[0][0] !=   1.0) elms = false;
	if(b[0][1] !=   2.0) elms = false;
	if(b[0][2] !=   4.0) elms = false;
	if(b[1][0] !=   8.0) elms = false;
	if(b[1][1] !=  16.0) elms = false;
	if(b[1][2] !=  32.0) elms = false;
	if(b[2][0] !=  64.0) elms = false;
	if(b[2][1] != 128.0) elms = false;
	if(b[2][2] != 256.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0];
	x = b[0][0] + b[1][0] + b[2][0];
	if( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;
	x = b[0][1] + b[1][1] + b[2][1];
	if(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;
	x = b[0][2] + b[1][2] + b[2][2];
	if(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2];
	if( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;
	x = b[1][0] + b[1][1] + b[1][2];
	if(x < 56.0-0.1 || x > 56.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2];
	if(x < 448.0-0.1 || x > 448.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0,   2.0,   4.0,\n\t                     8.0,  16.0,  32.0,\n\t                    64.0, 128.0, 256.0);\n\tmat3 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=   1.0) elms = false;\n\tif(b[0][1] !=   2.0) elms = false;\n\tif(b[0][2] !=   4.0) elms = false;\n\tif(b[1][0] !=   8.0) elms = false;\n\tif(b[1][1] !=  16.0) elms = false;\n\tif(b[1][2] !=  32.0) elms = false;\n\tif(b[2][0] !=  64.0) elms = false;\n\tif(b[2][1] != 128.0) elms = false;\n\tif(b[2][2] != 256.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tif( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1];\n\tif(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2];\n\tif(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2];\n\tif( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2];\n\tif(x < 56.0-0.1 || x > 56.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2];\n\tif(x < 448.0-0.1 || x > 448.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 * (1.0 + 0.5)), -1.0, (true ? (!false ? +-1.0 : 2.0) : 2.0), (((false ? false : true) ? true : !true) ? (2.0 / -1.0) : 0.0), +2.0, +0.0, ((+1.0 - (true ? 2.0 : 0.5)) / 1.0), -0.0, ((false ? -2.0 : 0.5) * +(-1.0 - 1.0)), -(!false ? (true ? -1.0 : 0.5) : (false ? 0.0 : 2.0)), 0.5, 0.5, (1.0 + 0.5), (!false ? (true ? 0.5 : 1.0) : 0.5), -1.0, 0.5);

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  mat3 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[1][0] != 8.0))
    elms = false;
  if ((b[1][1] != 16.0))
    elms = false;
  if ((b[1][2] != 32.0))
    elms = false;
  if ((b[2][0] != 64.0))
    elms = false;
  if ((b[2][1] != 128.0))
    elms = false;
  if ((b[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((b[0][1] + b[1][1]) + b[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((b[0][2] + b[1][2]) + b[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((b[0][0] + b[0][1]) + b[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((b[1][0] + b[1][1]) + b[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((b[2][0] + b[2][1]) + b[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 * (1.0 + 0.5)), -1.0, (true ? (!false ? +-1.0 : 2.0) : 2.0), (((false ? false : true) ? true : !true) ? (2.0 / -1.0) : 0.0), +2.0, +0.0, ((+1.0 - (true ? 2.0 : 0.5)) / 1.0), -0.0, ((false ? -2.0 : 0.5) * +(-1.0 - 1.0)), -(!false ? (true ? -1.0 : 0.5) : (false ? 0.0 : 2.0)), 0.5, 0.5, (1.0 + 0.5), (!false ? (true ? 0.5 : 1.0) : 0.5), -1.0, 0.5);

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  mat3 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[1][0] != 8.0))
    elms = false;
  if ((b[1][1] != 16.0))
    elms = false;
  if ((b[1][2] != 32.0))
    elms = false;
  if ((b[2][0] != 64.0))
    elms = false;
  if ((b[2][1] != 128.0))
    elms = false;
  if ((b[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((b[0][1] + b[1][1]) + b[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((b[0][2] + b[1][2]) + b[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((b[0][0] + b[0][1]) + b[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((b[1][0] + b[1][1]) + b[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((b[2][0] + b[2][1]) + b[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.758620689655174
Processing this: /home/oof/webgl_cleaned/floor_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, (0.0 + -1.0), 2.0, 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.013698630136986
Processing this: /home/oof/webgl_cleaned/refract_float_vert_ivarynconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	float result;
	float eta = 0.5;
	float k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));
	if(k < 0.0)
		result = 0.0;
	else
		result = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;
	color = vec4((result + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tfloat result;\n\tfloat eta = 0.5;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));\n\tif(k < 0.0)\n\t\tresult = 0.0;\n\telse\n\t\tresult = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;\n\tcolor = vec4((result + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((-(true ? -1.0 : 1.0) + 0.0), --2.0, +(2.0 / 0.0), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  float result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = 0.0;
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  color = vec4(((result + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((-(true ? -1.0 : 1.0) + 0.0), --2.0, +(2.0 / 0.0), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  float result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = 0.0;
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  color = vec4(((result + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.585034013605444
Processing this: /home/oof/webgl_cleaned/vec3_xy_z_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec2 t = m.xy;
	float k = m.z;
	vec4 a = vec4(t, k, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec2 t = m.xy;\n\tfloat k = m.z;\n\tvec4 a = vec4(t, k, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, 2.0, -1.0, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec2 t = m.xy;
  float k = m.z;
  vec4 a = vec4(t , k , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
62.83783783783784
Processing this: /home/oof/webgl_cleaned/floor_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 2.0, -0.5, -1.0, -1.0, 1.0, 2.0, -1.0, 2.0, -1.0, 0.0, -1.0, 2.0, 2.0, 2.0, 0.0);

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 2.0, -0.5, -1.0, -1.0, 1.0, 2.0, -1.0, 2.0, -1.0, 0.0, -1.0, 2.0, 2.0, 2.0, 0.0);

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.41610738255034
Mutations attempted: 149
Valid mutations:     93
Success rate:        62.42%
Processing this: /home/oof/webgl_cleaned/asin_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(asin(c) / M_PI + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(asin(c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = color(((asin(c) / M_PI) + 0.5) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gl_FragColor' : undeclared identifier
ERROR: 0:10: 'color' : function name expected
ERROR: 0:10: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = color(((asin(c) / M_PI) + 0.5) , 0.0 , 0.0);
}


==============================
62.0
Processing this: /home/oof/webgl_cleaned/degrees_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.5, 1.0, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.251655629139066
Processing this: /home/oof/webgl_cleaned/dataType8_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float f;
void main()
{
    f = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float f;\nvoid main()\n{\n    f = 1.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

float f = (((-1.0 - f) / 0.5) * ++0.0);

void main()
{
  f = 1.0;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'f' : undeclared identifier
ERROR: 0:4: '++' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

float f = (((-1.0 - f) / 0.5) * ++0.0);

void main()
{
  f = 1.0;
}


==============================
61.8421052631579
Processing this: /home/oof/webgl_cleaned/bvec4_empty_out_bvec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec4 function(out bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bvec4 function(out bvec4 par[3])
{
	set_all(par, bvec4(false, false, false, false));
	return bvec4(true, true, true, true);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec4 function(out bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbvec4 function(out bvec4 par[3])\n{\n\tset_all(par, bvec4(false, false, false, false));\n\treturn bvec4(true, true, true, true);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
61.8421052631579
Processing this: /home/oof/webgl_cleaned/CorrectParse2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;
const bool BoolConst1 = true && true || false;
const bool BoolConst2 = false || !false && false;
void main ()
{
    float float1 = 4.0, float2 = floatConst2;
    int int_1 = int(FloatConst1);
    vec4 vec4_1;
    vec3 vec3_1 = vec3(1, 1, 1);
	vec3 vec3_2 = vec3(0, 0, 0);
    bool bool4, bool5;
    bool4 = bool5;
    bool4 = 4 > 5;
    bool4 = !(3.2 != 0.0);
    bool4 = bool(float1);
    bool4 = bool(int_1);
    float1 = float(bool4);
    float1 = float(int_1);
    int_1 = int(float1);
    int_1 = int(bool4);
    {
        int a, b, c;
        a = b;
        b = c;
        {
            int b, c, d;
            b = c;
            c = d;
            {
                int a, d, e;
                a = d;
                d = e;
            }
            {
                int a, b, c;
                a = b;
                b = c;
            }
        }
        a = b;
        b = c;
    }
    {
        float f1, f2;
        vec3 v31, v32;
        max(f1, f2);
        max(v31, v32);
        vec4 v4 = vec4(3.0);
        vec3 v3 = -vec3(2.0, 1.0, 3.0);
        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);
    }
    if (BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst1 || BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2 && BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (FloatConst1 != 0.0)
        --int_1;
    else
        ++int_1;
    if (0 != 0)
        ++int_1;
    else
        --int_1;
    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);
    float1 = 5 != 0 ? float1 : float(int_1);
    float1 = BoolConst1 ? float1 : float(int_1);
    if (float1 != float1)
        ++int_1;
    else
        --int_1;
    float1 = float1 != float1 ? float1 : float(int_1);
    --int_1;
    ++float1;
    (vec4_1.x)--;
    vec3_1++;
    if (vec3_1.x > vec3_2.x)
        float1 = 4.0 + 6.0;
    if (bool4 ^^ bool5)
        float1 *= 2.4;
    if (false ^^ false)
        float1 *= 2.5;
    if (true ^^ false)
        float1 *= 2.6;
    {
        int i;
    }
    if (bool4) {
        int i;
    } else {
        int i;
        i = 5;
    }
    mat4 m1;
    m1[2][1] = 4.0;
    gl_Position = vec4(float1+float1, float1, float1, float(int_1));
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nconst float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;\nconst bool BoolConst1 = true && true || false;\nconst bool BoolConst2 = false || !false && false;\nvoid main ()\n{\n    float float1 = 4.0, float2 = floatConst2;\n    int int_1 = int(FloatConst1);\n    vec4 vec4_1;\n    vec3 vec3_1 = vec3(1, 1, 1);\n\tvec3 vec3_2 = vec3(0, 0, 0);\n    bool bool4, bool5;\n    bool4 = bool5;\n    bool4 = 4 > 5;\n    bool4 = !(3.2 != 0.0);\n    bool4 = bool(float1);\n    bool4 = bool(int_1);\n    float1 = float(bool4);\n    float1 = float(int_1);\n    int_1 = int(float1);\n    int_1 = int(bool4);\n    {\n        int a, b, c;\n        a = b;\n        b = c;\n        {\n            int b, c, d;\n            b = c;\n            c = d;\n            {\n                int a, d, e;\n                a = d;\n                d = e;\n            }\n            {\n                int a, b, c;\n                a = b;\n                b = c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n    {\n        float f1, f2;\n        vec3 v31, v32;\n        max(f1, f2);\n        max(v31, v32);\n        vec4 v4 = vec4(3.0);\n        vec3 v3 = -vec3(2.0, 1.0, 3.0);\n        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);\n    }\n    if (BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst1 || BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2 && BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (FloatConst1 != 0.0)\n        --int_1;\n    else\n        ++int_1;\n    if (0 != 0)\n        ++int_1;\n    else\n        --int_1;\n    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);\n    float1 = 5 != 0 ? float1 : float(int_1);\n    float1 = BoolConst1 ? float1 : float(int_1);\n    if (float1 != float1)\n        ++int_1;\n    else\n        --int_1;\n    float1 = float1 != float1 ? float1 : float(int_1);\n    --int_1;\n    ++float1;\n    (vec4_1.x)--;\n    vec3_1++;\n    if (vec3_1.x > vec3_2.x)\n        float1 = 4.0 + 6.0;\n    if (bool4 ^^ bool5)\n        float1 *= 2.4;\n    if (false ^^ false)\n        float1 *= 2.5;\n    if (true ^^ false)\n        float1 *= 2.6;\n    {\n        int i;\n    }\n    if (bool4) {\n        int i;\n    } else {\n        int i;\n        i = 5;\n    }\n    mat4 m1;\n    m1[2][1] = 4.0;\n    gl_Position = vec4(float1+float1, float1, float1, float(int_1));\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = (3.0 * 8.0) , floatConst2 = 4.0;

const bool BoolConst1 = ((true && true) || false);

const bool BoolConst2 = (false || (!true && false));

void main()
{
  float float1 = 4.0 , float2 = floatConst2;
  int int_1 = int(FloatConst1);
  vec4 vec4_1;
  vec3 vec3_1 = vec3(1 , 1 , 1);
  vec3 vec3_2 = vec3(0 , 0 , 0);
  bool bool4, bool5;
  bool4 = bool5;
  bool4 = (4 > 5);
  bool4 = !(3.2 != 0.0);
  bool4 = bool(float1);
  bool4 = bool(int_1);
  float1 = float(bool4);
  float1 = float(int_1);
  int_1 = int(float1);
  int_1 = int(bool4);
  {
    int a, b, c;
    a = b;
    b = c;
    {
      int b, c, d;
      b = c;
      c = d;
      {
        int a, d, e;
        a = d;
        d = e;
      }
      {
        int a, b, c;
        a = b;
        b = c;
      }
    }
    a = b;
    b = c;
  }
  {
    float f1, f2;
    vec3 v31, v32;
    max(f1 , f2);
    max(v31 , v32);
    vec4 v4 = vec4(3.0);
    vec3 v3 = -vec3(2.0 , 1.0 , 3.0);
    mat2 m2 = mat2(3.0 , 4.0 , 6.0 , 3.0);
  }
  if (BoolConst1)
    ++vec3_1;
  else
    --vec3_1;
  if (BoolConst2)
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst1 || BoolConst2))
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst2 && BoolConst1))
    ++vec3_1;
  else
    --vec3_1;
  if ((FloatConst1 != 0.0))
    --int_1;
  else
    ++int_1;
  if ((0 != 0))
    ++int_1;
  else
    --int_1;
  bool4 = (((((BoolConst1 && !(int_1 != 0)) && !BoolConst1) && !(FloatConst1 != 0.0)) && (FloatConst1 != 0.0)) && (float1 != 0.0));
  (float1 = (5 != 0) ? float1 : float(int_1));
  (float1 = BoolConst1 ? float1 : float(int_1));
  if ((float1 != float1))
    ++int_1;
  else
    --int_1;
  (float1 = (float1 != float1) ? float1 : float(int_1));
  --int_1;
  ++float1;
  vec4_1.x--;
  vec3_1++;
  if ((vec3_1.x > vec3_2.x))
    float1 = (4.0 + 6.0);
  if ((bool4 ^^ bool5))
    (float1 *= 2.4);
  if ((false ^^ false))
    (float1 *= 2.5);
  if ((true ^^ false))
    (float1 *= 2.6);
  {
    int i;
  }
  if (bool4)
  {
    int i;
  }
  else
  {
    int i;
    i = 5;
  }
  mat4 m1;
  m1[2][1] = 4.0;
  gl_Position = vec4((float1 + float1) , float1 , float1 , float(int_1));
}


As vertex? : True
SUCCESS!
62.091503267973856
Processing this: /home/oof/webgl_cleaned/all_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool _all(in bvec3 a)
{
	bool temp = true;
	if(!a[0]) temp = false;
	if(!a[1]) temp = false;
	if(!a[2]) temp = false;
	return temp;
}
void main ()
{
	vec3 c = floor(4.0 * color.rgb);
	gl_FragColor = vec4(vec3(_all(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool _all(in bvec3 a)\n{\n\tbool temp = true;\n\tif(!a[0]) temp = false;\n\tif(!a[1]) temp = false;\n\tif(!a[2]) temp = false;\n\treturn temp;\n}\nvoid main ()\n{\n\tvec3 c = floor(4.0 * color.rgb);\n\tgl_FragColor = vec4(vec3(_all(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bool _all(in bvec3 a)
{
  bool temp = true;
  if (!a[0])
    temp = false;
  if (!a[1])
    temp = false;
  if (!a[2])
    temp = false;
  return temp;
}

void main()
{
  vec3 c = floor((4.0 * color.rgb));
  gl_FragColor = vec4(vec3(_all(bvec3(c))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:21: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bool _all(in bvec3 a)
{
  bool temp = true;
  if (!a[0])
    temp = false;
  if (!a[1])
    temp = false;
  if (!a[2])
    temp = false;
  return temp;
}

void main()
{
  vec3 c = floor((4.0 * color.rgb));
  gl_FragColor = vec4(vec3(_all(bvec3(c))));
}


==============================
61.68831168831169
Processing this: /home/oof/webgl_cleaned/vec3_zyx_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	vec3 t = m.zyx;
	vec4 a = vec4(t.z, t.y, t.x ,al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tvec3 t = m.zyx;\n\tvec4 a = vec4(t.z, t.y, t.x ,al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  vec3 t = m.zyx;
  vec4 a = vec4(t.z , t.y , t.x , al.w);
  gl_FragColor = a;
  vec4(-1.0, 2.0, +0.5, 2.0);
}


As vertex? : False
SUCCESS!
61.935483870967744
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 4.0 * (gtf_Color.rg);
	color = vec4(c * c / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 4.0 * (gtf_Color.rg);\n\tcolor = vec4(c * c / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 2.0, 1.0, 1.0);

void main()
{
  vec2 c = (4.0 * gtf_Color.rg);
  color = vec4(((c * c) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.17948717948718
Processing this: /home/oof/webgl_cleaned/bool_empty_empty_bool_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(par && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
62.17948717948718
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = color[17];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: '[]' : vector field selection out of range

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = color[17];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


==============================
61.78343949044586
Mutations attempted: 157
Valid mutations:     97
Success rate:        61.78%
Processing this: /home/oof/webgl_cleaned/equal_bvec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 eq(in bvec2 a, in bvec2 b)
{
	bvec2 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(eq(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 eq(in bvec2 a, in bvec2 b)\n{\n\tbvec2 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(eq(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? 2.0 : 2.0), +-0.0, ((-1.0 - 0.5) + +(false ? 1.0 : 0.0)), 0.5);

bvec2 eq(in bvec2 a, in bvec2 b)
{
  bvec2 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(eq(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.0253164556962
Processing this: /home/oof/webgl_cleaned/vec3_ps_t_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.stp;
	vec2 t = m.ps;
	float k = m.t;
	vec4 a = vec4(t.t, k, t.s, lightloc.q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.stp;\n\tvec2 t = m.ps;\n\tfloat k = m.t;\n\tvec4 a = vec4(t.t, k, t.s, lightloc.q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((false && false) ? false : true) ? 0.5 : -(false ? 1.0 : -1.0)), -1.0, 0.0, 1.0, 0.5, (((true && false) ? 0.5 : 2.0) * (true ? (false ? -1.0 : 0.0) : 0.0)), +(0.5 + -2.0), 1.0, (true ? -1.0 : 1.0), 2.0, -1.0, -1.0, ((!false ? false : true) ? 1.0 : -1.0), (!true ? 2.0 : --1.0), ((+0.5 / (2.0 + 2.0)) * ((true ? false : true) ? 1.0 : (0.5 / -1.0))), (-1.0 * ((true ? false : true) ? 0.0 : 0.5)));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.stp;
  vec2 t = m.ps;
  float k = m.t;
  vec4 a = vec4(t.t , k , t.s , lightloc.q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((false && false) ? false : true) ? 0.5 : -(false ? 1.0 : -1.0)), -1.0, 0.0, 1.0, 0.5, (((true && false) ? 0.5 : 2.0) * (true ? (false ? -1.0 : 0.0) : 0.0)), +(0.5 + -2.0), 1.0, (true ? -1.0 : 1.0), 2.0, -1.0, -1.0, ((!false ? false : true) ? 1.0 : -1.0), (!true ? 2.0 : --1.0), ((+0.5 / (2.0 + 2.0)) * ((true ? false : true) ? 1.0 : (0.5 / -1.0))), (-1.0 * ((true ? false : true) ? 0.0 : 0.5)));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.stp;
  vec2 t = m.ps;
  float k = m.t;
  vec4 a = vec4(t.t , k , t.s , lightloc.q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
61.63522012578616
Processing this: /home/oof/webgl_cleaned/vec4_bar_g_1vec3_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.bar;
	float g = lightloc.g;
	vec4 a = vec4(m.b, g, m.r, m.g);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.bar;\n\tfloat g = lightloc.g;\n\tvec4 a = vec4(m.b, g, m.r, m.g);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 0.5, -1.0, 2.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.bar;
  float g = lightloc.g;
  vec4 a = vec4(m.b , g , m.r , m.g);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
61.875
Processing this: /home/oof/webgl_cleaned/for_continue_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count=0;
	int val=0;
    	for(int i=0;i<10;i++)
	{
	  count++;
	  if(count == 5)
            continue;
	   else
	    val += count;
	}
	float gray;
	if( val == 50)
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint count=0;\n\tint val=0;\n    \tfor(int i=0;i<10;i++)\n\t{\n\t  count++;\n\t  if(count == 5)\n            continue;\n\t   else\n\t    val += count;\n\t}\n\tfloat gray;\n\tif( val == 50)\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, (true ? -0.5 : (2.0 + 1.0)), (0.0 * 0.5), -0.5);

void main()
{
  int count = 0;
  int val = 0;
  for (int i = 0; (i < 10); i++)
  {
    count++;
    if ((count == 5))
      continue;
    else
      (val += count);
  }
  float gray;
  if ((val == 50))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.11180124223602
Processing this: /home/oof/webgl_cleaned/struct_bool_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	bool a;
	bool b;
	bool c;
	bool d;
};
void main ()
{
	sabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));
	float gray = 0.0;
	if( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tbool a;\n\tbool b;\n\tbool c;\n\tbool d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));\n\tfloat gray = 0.0;\n\tif( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.34567901234568
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.57668711656442
Processing this: /home/oof/webgl_cleaned/bvec4_empty_empty_bvec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, true) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(bvec4 par)
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, true) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(bvec4 par)\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
62.57668711656442
Processing this: /home/oof/webgl_cleaned/vec3_grb_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.rgb;
	vec3 t = m.grb;
	vec4 a = vec4(t.g, t.r, t.b ,al.a);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.rgb;\n\tvec3 t = m.grb;\n\tvec4 a = vec4(t.g, t.r, t.b ,al.a);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, +1.0, -1.0, 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.rgb;
  vec3 t = m.grb;
  vec4 a = vec4(t.g , t.r , t.b , al.a);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
62.80487804878049
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	float c = color.r;
	gl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.5, 0.5, 0.5);

void main()
{
  const float exp1 = 2.7183;
  float c = color.r;
  gl_FragColor = vec4((1.0 / pow(exp1 , (3.0 * c))) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.030303030303024
Processing this: /home/oof/webgl_cleaned/fragmentOnly4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    discard;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    discard;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  discard;
}


As vertex? : True
SUCCESS!
63.25301204819277
Mutations attempted: 166
Valid mutations:     105
Success rate:        63.25%
Processing this: /home/oof/webgl_cleaned/vec3_vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 b = vec4(13.0, 53.0, 139.0, 217.0);
	vec3 a = vec3(b);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 b = vec4(13.0, 53.0, 139.0, 217.0);\n\tvec3 a = vec3(b);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --(0.0 - 2.0), 0.5, (false ? 2.0 : (true ? 0.0 : 0.5)));

void main()
{
  vec4 b = vec4(13.0 , 53.0 , 139.0 , 217.0);
  vec3 a = vec3(b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions
ERROR: 0:16: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:16: 'gtf_Vertex' : undeclared identifier
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --(0.0 - 2.0), 0.5, (false ? 2.0 : (true ? 0.0 : 0.5)));

void main()
{
  vec4 b = vec4(13.0 , 53.0 , 139.0 , 217.0);
  vec3 a = vec3(b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


==============================
62.874251497005986
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 ne(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(ne(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 ne(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(ne(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((true ? false : true) && false) ? -1.0 : ((false ? -1.0 : 2.0) / (false ? -1.0 : 2.0))), (-1.0 * ((-1.0 - 0.5) * -0.5)), (0.5 + --1.0), -0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((true ? false : true) && false) ? -1.0 : ((false ? -1.0 : 2.0) / (false ? -1.0 : 2.0))), (-1.0 * ((-1.0 - 0.5) * -0.5)), (0.5 + --1.0), -0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Processing this: /home/oof/webgl_cleaned/not_bvec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 _not(in bvec2 a)
{
	bvec2 result;
	if(a[0]) result[0] = false;
	else result[0] = true;
	if(a[1]) result[1] = false;
	else result[1] = true;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	color = vec4(vec2(_not(bvec2(c))), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 _not(in bvec2 a)\n{\n\tbvec2 result;\n\tif(a[0]) result[0] = false;\n\telse result[0] = true;\n\tif(a[1]) result[1] = false;\n\telse result[1] = true;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tcolor = vec4(vec2(_not(bvec2(c))), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((true ? (-1.0 - -2.0) : ((true ? false : false) ? -1.0 : (1.0 * -1.0))), 0.0, 0.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 _not(in bvec2 a)
{
  bvec2 result;
  if (a[0])
    result[0] = false;
  else
    result[0] = true;
  if (a[1])
    result[1] = false;
  else
    result[1] = true;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  color = vec4(vec2(_not(bvec2(c))) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.721893491124256
Processing this: /home/oof/webgl_cleaned/reflect_float_vert_ivarynconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	color = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tcolor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.5, (+0.0 / (1.0 - 1.0)), (true ? ++2.0 : -1.0), 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:6: '++' : l-value required (can't modify a const)
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : global variable initializers must be constant expressions
ERROR: 0:18: '*' : array / non-array mismatch
ERROR: 0:18: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[2] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:18: '=' : dimension mismatch
ERROR: 0:18: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.5, (+0.0 / (1.0 - 1.0)), (true ? ++2.0 : -1.0), 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.35294117647059
Processing this: /home/oof/webgl_cleaned/float_empty_empty_float_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(float par[3])
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return 1.0;
	}
	else
		return 0.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(float par[3])\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
62.35294117647059
Processing this: /home/oof/webgl_cleaned/degrees_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((((false && true) ? 0.0 : (2.0 * -1.0)) * (0.0 + 0.5)), 1.0, ((0.5 + 1.0) / (-1.0 - 0.5)), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((2.0 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.57309941520468
Processing this: /home/oof/webgl_cleaned/vec4_ar_bg_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.ar;
	vec2 n = lightloc.bg;
	vec4 a = vec4(m.g, n.g, n.r, m.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.ar;\n\tvec2 n = lightloc.bg;\n\tvec4 a = vec4(m.g, n.g, n.r, m.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-(2.0 + 1.0) * (0.5 - -1.0)), (false ? -1.0 : 0.0), 0.5, -0.0, 1.0, 2.0, -1.0, 1.0, 0.5, +(-1.0 / 0.5), 1.0, -1.0, +0.0, -1.0, 0.5, (-1.0 / 1.0));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.ar;
  vec2 n = lightloc.bg;
  vec4 a = vec4(m.g , n.g , n.r , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-(2.0 + 1.0) * (0.5 - -1.0)), (false ? -1.0 : 0.0), 0.5, -0.0, 1.0, 2.0, -1.0, 1.0, 0.5, +(-1.0 / 0.5), 1.0, -1.0, +0.0, -1.0, 0.5, (-1.0 / 1.0));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.ar;
  vec2 n = lightloc.bg;
  vec4 a = vec4(m.g , n.g , n.r , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
62.2093023255814
Processing this: /home/oof/webgl_cleaned/max_vec3_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 max_c = vec3(0.5, 0.5, 0.5);
	vec3 c = gtf_Color.rgb;
	if(c[0] < max_c[0]) c[0] = max_c[0];
	if(c[1] < max_c[1]) c[1] = max_c[1];
	if(c[2] < max_c[2]) c[2] = max_c[2];
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 max_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = gtf_Color.rgb;\n\tif(c[0] < max_c[0]) c[0] = max_c[0];\n\tif(c[1] < max_c[1]) c[1] = max_c[1];\n\tif(c[2] < max_c[2]) c[2] = max_c[2];\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 2.0, (((true ? false : true) || (false && false)) ? (+2.0 / (false ? 2.0 : 1.0)) : 0.0), (true ? 1.0 : -1.0));

void main()
{
  const vec3 max_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  if ((c[1] < max_c[1]))
    c[1] = max_c[1];
  if ((c[2] < max_c[2]))
    c[2] = max_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.42774566473989
Processing this: /home/oof/webgl_cleaned/floor_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	gl_FragColor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 0.0, 0.0, (true ? -1.0 : -1.0));

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 0.5));
  gl_FragColor = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.643678160919535
Processing this: /home/oof/webgl_cleaned/lessThanEqual_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, -0.5, 0.5, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.857142857142854
Mutations attempted: 175
Valid mutations:     110
Success rate:        62.86%
Processing this: /home/oof/webgl_cleaned/gl_MaxVertexUniformVectors_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(float(gl_MaxVertexUniformVectors) / 128.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(gl_MaxVertexUniformVectors) / 128.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (!false ? 2.0 : (-1.0 / 2.0)) : (false ? (true ? -1.0 : -1.0) : 2.0)), (!!true ? 2.0 : (false ? 2.0 : -1.0)), (1.0 * 1.0), 2.0, -1.0, 0.0, (0.5 / (0.5 / -0.0)), (((false ? true : true) ? 1.0 : (-1.0 - 2.0)) + 0.0), 0.5, +0.0, 1.0, (!true ? 2.0 : ((true ? false : false) ? (-1.0 * 2.0) : -1.0)), 0.5, +2.0, 2.0, 0.5);

vec4 color;

void main()
{
  color = vec4((float(gl_MaxVertexUniformVectors) / 128.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (!false ? 2.0 : (-1.0 / 2.0)) : (false ? (true ? -1.0 : -1.0) : 2.0)), (!!true ? 2.0 : (false ? 2.0 : -1.0)), (1.0 * 1.0), 2.0, -1.0, 0.0, (0.5 / (0.5 / -0.0)), (((false ? true : true) ? 1.0 : (-1.0 - 2.0)) + 0.0), 0.5, +0.0, 1.0, (!true ? 2.0 : ((true ? false : false) ? (-1.0 * 2.0) : -1.0)), 0.5, +2.0, 2.0, 0.5);

vec4 color;

void main()
{
  color = vec4((float(gl_MaxVertexUniformVectors) / 128.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Processing this: /home/oof/webgl_cleaned/cos_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((false ? (-1.0 / 0.0) : ((true ? 0.0 : 1.0) - 1.0)), +0.5, (+-1.0 / ++1.0), 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:10: '/' : Divide by zero during constant folding
ERROR: 0:10: '++' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((false ? (-1.0 / 0.0) : ((true ? 0.0 : 1.0) - 1.0)), +0.5, (+-1.0 / ++1.0), 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.14689265536724
Processing this: /home/oof/webgl_cleaned/vec4_wx_zy_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.wx;
	vec2 n = lightloc.zy;
	vec4 a = vec4(m.y, n.y, n.x, m.x);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.wx;\n\tvec2 n = lightloc.zy;\n\tvec4 a = vec4(m.y, n.y, n.x, m.x);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.wx;
  vec2 n = lightloc.zy;
  vec4 a = vec4(m.y , n.y , n.x , m.x);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
62.35955056179775
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	color = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tcolor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 1.0, (0.5 - ((-1.0 - 0.5) / (2.0 * 2.0))), -+(0.0 + -1.0));

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.56983240223464
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((false ? true : true) && (true ? true : true)) ? 0.0 : ((true ? true : true) ? -0.5 : 0.5)), 1.0, 0.5, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(exp1) , (3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.77777777777778
Processing this: /home/oof/webgl_cleaned/const_mat2_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	mat2 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 8.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = b[0][1] + b[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = b[1][0] + b[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tmat2 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.0, -0.0, -1.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.98342541436463
Processing this: /home/oof/webgl_cleaned/vec3_rgb_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec4 a = vec4(m.rgb,lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec4 a = vec4(m.rgb,lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, 0.0, ((false ? false : (false || false)) ? +(2.0 * 1.0) : (2.0 / 0.5)), ((-1.0 * 2.0) * (true ? 0.5 : 1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec4 a = vec4(m.rgb , lightloc.a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
63.18681318681318
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(inout mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_zeros) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(inout mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(inout mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_zeros) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(inout mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
63.18681318681318
Processing this: /home/oof/webgl_cleaned/bool_empty_inout_bool_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool function(inout bool par[3]);
bool is_all(const in bool array[3], const in bool value);
void set_all(out bool array[3], const in bool value);
void main ()
{
	bool par[3];
	bool ret = false;
	float gray = 0.0;
	set_all(par, true);
	ret = function(par);
	if(is_all(par, false) && ret)
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bool function(inout bool par[3])
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return true;
	}
	else
		return false;
}
bool is_all(const in bool array[3], const in bool value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bool array[3], const in bool value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool function(inout bool par[3]);\nbool is_all(const in bool array[3], const in bool value);\nvoid set_all(out bool array[3], const in bool value);\nvoid main ()\n{\n\tbool par[3];\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tset_all(par, true);\n\tret = function(par);\n\tif(is_all(par, false) && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbool function(inout bool par[3])\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\nbool is_all(const in bool array[3], const in bool value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bool array[3], const in bool value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.18681318681318
Processing this: /home/oof/webgl_cleaned/ceil_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (true ? -1.0 : -1.0), 0.5, -1.0);

void main()
{
  vec2 c = ((10.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.387978142076506
Mutations attempted: 183
Valid mutations:     116
Success rate:        63.39%
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x = (gtf_Color.r + 0.01) / 1.01;
	float y = 0.0;
	float z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	color = vec4(y / -4.61, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = (gtf_Color.r + 0.01) / 1.01;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tcolor = vec4(y / -4.61, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((1.0 / (!false ? (0.5 * 2.0) : -1.0)), -1.0, (true ? +(true ? -1.0 : -1.0) : (2.0 * 1.0)), 0.0);

void main()
{
  float x = ((gtf_Color.r + 0.01) / 1.01);
  float y = 0.0;
  float z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  color = vec4((y / -4.61) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.58695652173913
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, -1.0, -0.5, 0.0);

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.78378378378379
Processing this: /home/oof/webgl_cleaned/vec3_stp_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	vec4 a = vec4(m.stp,al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tvec4 a = vec4(m.stp,al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 m = al.stp;
  vec4 a = vec4(m.stp , al.q);
  vec4 al = color;
  vec4(2.0, 0.5, 0.5, (0.5 - 1.0));
  gl_FragColor = a;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'al' : undeclared identifier
ERROR: 0:8: 'stp' :  field selection requires structure or vector on left hand side
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: '=' : cannot convert from 'const highp float' to 'mediump 3-component vector of float'
ERROR: 0:9: 'al' : undeclared identifier
ERROR: 0:9: 'q' :  field selection requires structure or vector on left hand side

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 m = al.stp;
  vec4 a = vec4(m.stp , al.q);
  vec4 al = color;
  vec4(2.0, 0.5, 0.5, (0.5 - 1.0));
  gl_FragColor = a;
}


==============================
63.44086021505376
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.44086021505376
Processing this: /home/oof/webgl_cleaned/greaterThan_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gt(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gt(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 gt(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(gt(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 gt(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] > b[1]))
    result[0] = false;
  else
    result[0] = true;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(gt(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/structnest_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	vec3 b;
};
struct nesta
{
	vec3 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec3(11, 13, 17), nestb(vec3(12, 19, 29) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2]) / 101.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tvec3 b;\n};\nstruct nesta\n{\n\tvec3 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec3(11, 13, 17), nestb(vec3(12, 19, 29) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2]) / 101.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = (((true ? false : false) || false) ? mat4(-0.5, 0.0, +0.5, ((true ? 1.0 : 0.5) / (+0.5 * 0.0)), ((!false ? true : (true || true)) ? ((1.0 * 1.0) - +1.0) : 2.0), 1.0, +2.0, (true ? 0.0 : ((true ? 0.0 : 0.0) * (1.0 * 0.0))), +-(2.0 / 2.0), 0.5, (2.0 / (0.5 * 0.0)), (-1.0 - 2.0), (2.0 + (-2.0 + 0.5)), -((2.0 - 0.5) + 0.5), (false ? (!true ? 0.5 : +0.5) : 1.0), 2.0) : mat4(((!true || !true) ? (0.5 / -2.0) : (0.5 - 2.0)), (false ? (2.0 + 0.0) : ((false ? false : false) ? (-1.0 / 0.0) : -1.0)), (((1.0 * 0.0) + 0.0) - -(false ? 0.5 : 0.0)), +(+0.5 + (2.0 / -1.0)), 0.5, ((false ? !true : (false ? false : true)) ? 2.0 : -2.0), 0.0, --(0.5 * -1.0), +0.5, +-0.0, ((true ? 0.5 : -1.0) + 0.0), +(0.0 / (0.5 - 0.0)), 0.0, -1.0, 2.0, 2.0));

vec4 color;

struct nestb {
  vec3 b;
};

struct nesta {
  vec3 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec3(11 , 13 , 17) , nestb(vec3(12 , 19 , 29))));
  color = vec4(vec3(((((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.a[2]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) + s.nest_a.nest_b.b[2]) / 101.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Divide by zero during constant folding
WARNING: 0:6: '/' : Divide by zero during constant folding
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = (((true ? false : false) || false) ? mat4(-0.5, 0.0, +0.5, ((true ? 1.0 : 0.5) / (+0.5 * 0.0)), ((!false ? true : (true || true)) ? ((1.0 * 1.0) - +1.0) : 2.0), 1.0, +2.0, (true ? 0.0 : ((true ? 0.0 : 0.0) * (1.0 * 0.0))), +-(2.0 / 2.0), 0.5, (2.0 / (0.5 * 0.0)), (-1.0 - 2.0), (2.0 + (-2.0 + 0.5)), -((2.0 - 0.5) + 0.5), (false ? (!true ? 0.5 : +0.5) : 1.0), 2.0) : mat4(((!true || !true) ? (0.5 / -2.0) : (0.5 - 2.0)), (false ? (2.0 + 0.0) : ((false ? false : false) ? (-1.0 / 0.0) : -1.0)), (((1.0 * 0.0) + 0.0) - -(false ? 0.5 : 0.0)), +(+0.5 + (2.0 / -1.0)), 0.5, ((false ? !true : (false ? false : true)) ? 2.0 : -2.0), 0.0, --(0.5 * -1.0), +0.5, +-0.0, ((true ? 0.5 : -1.0) + 0.0), +(0.0 / (0.5 - 0.0)), 0.0, -1.0, 2.0, 2.0));

vec4 color;

struct nestb {
  vec3 b;
};

struct nesta {
  vec3 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec3(11 , 13 , 17) , nestb(vec3(12 , 19 , 29))));
  color = vec4(vec3(((((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.a[2]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) + s.nest_a.nest_b.b[2]) / 101.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.297872340425535
Processing this: /home/oof/webgl_cleaned/log2_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 31.0 * gtf_Color.r + 1.0;
	color = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 31.0 * gtf_Color.r + 1.0;\n\tcolor = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(+(0.5 - 2.0), -1.0, -0.5, (!true ? (false ? (false ? 2.0 : 0.0) : -2.0) : 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((31.0 * gtf_Color.r) + 1.0);
  color = vec4((log2(c) / 5.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.49206349206349
Processing this: /home/oof/webgl_cleaned/CorrectBuiltInOveride_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump int;
int radians(int f)
{
    return f;
}
void main()
{
    int f = 45;
    f = radians(f);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump int;\nint radians(int f)\n{\n    return f;\n}\nvoid main()\n{\n    int f = 45;\n    f = radians(f);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

int radians(int f)
{
  return f;
}

void main()
{
  int f = 45;
  f = radians(f);
}


As vertex? : False
SUCCESS!
63.68421052631579
Processing this: /home/oof/webgl_cleaned/matrix2VSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
63.87434554973822
Processing this: /home/oof/webgl_cleaned/log2_vec3_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const float ln2 = 0.69314718055994530941723212145818;
void main ()
{
	vec3 x = (gtf_Color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0 / ln2;
	color = vec4(y / -8.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst float ln2 = 0.69314718055994530941723212145818;\nvoid main ()\n{\n\tvec3 x = (gtf_Color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0 / ln2;\n\tcolor = vec4(y / -8.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(ln2 - -1.0), ln2, 0.5, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (-2.0 / ln2));
  color = vec4((y / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'ln2' : undeclared identifier
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: 'ln2' : undeclared identifier
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(ln2 - -1.0), ln2, 0.5, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (-2.0 / ln2));
  color = vec4((y / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.541666666666664
Mutations attempted: 192
Valid mutations:     122
Success rate:        63.54%
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, +0.5, --1.0, 1.0);

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, +0.5, --1.0, 1.0);

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


==============================
63.212435233160626
Processing this: /home/oof/webgl_cleaned/for_break_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int count = 0;
        for(int i=0;i<45;i++)
	{
	  count++;
	  if(count == 29)
            break;
	}
	float gray;
	if( count == 29)
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint count = 0;\n        for(int i=0;i<45;i++)\n\t{\n\t  count++;\n\t  if(count == 29)\n            break;\n\t}\n\tfloat gray;\n\tif( count == 29)\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(2.0, 0.0, -1.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int count = 0;
  for (int i = 0; (i < 45); i++)
  {
    count++;
    if ((count == 29))
      break;
  }
  float gray;
  if ((count == 29))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.4020618556701
Processing this: /home/oof/webgl_cleaned/any_bvec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	color = vec4(vec3(any(bvec2(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tcolor = vec4(vec3(any(bvec2(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct66964 {
  mat3 f_3967[8];
  ivec3 f_4289[3];
  int f_5192[8];
};

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+((true || true) ? -1.0 : 2.0), +(true ? (0.0 - 1.0) : 0.0), (true ? (-2.0 - 2.0) : (+1.0 + (0.0 / -1.0))), (0.0 * (0.5 / 0.0)), ((1.0 - (false ? 2.0 : 1.0)) + ((true || false) ? (false ? 1.0 : 0.5) : (false ? 2.0 : 2.0))), ((-1.0 - (2.0 + 1.0)) / -1.0), (true ? +0.5 : 0.0), -+-1.0, 1.0, (!(false && false) ? ((-1.0 / 0.0) / 0.5) : (true ? -0.0 : +2.0)), 0.5, ((true ? 0.0 : (true ? 2.0 : 2.0)) - (true ? (true ? 2.0 : 1.0) : 1.0)), (false ? 1.0 : (false ? 0.0 : 2.0)), +((false ? true : false) ? 1.0 : (1.0 / 2.0)), ((0.5 + 0.0) / (0.5 * 1.0)), 0.0);

vec4 color;

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  color = vec4(vec3(any(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:14: '/' : Divide by zero during constant folding
WARNING: 0:14: '*' : Constant folded undefined multiplication generated NaN
WARNING: 0:14: '/' : Divide by zero during constant folding
ERROR: 0:14: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct66964 {
  mat3 f_3967[8];
  ivec3 f_4289[3];
  int f_5192[8];
};

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+((true || true) ? -1.0 : 2.0), +(true ? (0.0 - 1.0) : 0.0), (true ? (-2.0 - 2.0) : (+1.0 + (0.0 / -1.0))), (0.0 * (0.5 / 0.0)), ((1.0 - (false ? 2.0 : 1.0)) + ((true || false) ? (false ? 1.0 : 0.5) : (false ? 2.0 : 2.0))), ((-1.0 - (2.0 + 1.0)) / -1.0), (true ? +0.5 : 0.0), -+-1.0, 1.0, (!(false && false) ? ((-1.0 / 0.0) / 0.5) : (true ? -0.0 : +2.0)), 0.5, ((true ? 0.0 : (true ? 2.0 : 2.0)) - (true ? (true ? 2.0 : 1.0) : 1.0)), (false ? 1.0 : (false ? 0.0 : 2.0)), +((false ? true : false) ? 1.0 : (1.0 / 2.0)), ((0.5 + 0.0) / (0.5 * 1.0)), 0.0);

vec4 color;

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  color = vec4(vec3(any(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.07692307692307
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? +(false ? 2.0 : 0.5) : 0.0), 0.0, -1.0, 1.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
63.26530612244898
Processing this: /home/oof/webgl_cleaned/preprocess10_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1);
}


As vertex? : False
SUCCESS!
63.45177664974619
Processing this: /home/oof/webgl_cleaned/struct_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	gl_FragColor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tgl_FragColor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -0.5, -0.5, 2.0);

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  gl_FragColor = vec4(vec3(((((((((s.a[0] + s.a[1]) + s.a[2]) + s.a[3]) + s.b[0]) + s.b[1]) + s.b[2]) + s.b[3]) / 250.0)) , 1.0);
}


As vertex? : False
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/22f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec2 color[2];
void main ()
{
	gl_FragColor = vec4 (color[0][0], color[0][1], color[1][0], color[1][1]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec2 color[2];\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0], color[0][1], color[1][0], color[1][1]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec2 color[2];

void main()
{
  color = vec4(color[0][0] , color[0][1] , color[1][0]);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a uniform "color")
ERROR: 0:8: '=' : array / non-array mismatch
ERROR: 0:8: 'assign' : cannot convert from 'const 4-component vector of float' to 'uniform mediump array[2] of 2-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec2 color[2];

void main()
{
  color = vec4(color[0][0] , color[0][1] , color[1][0]);
}


==============================
63.31658291457286
Processing this: /home/oof/webgl_cleaned/clamp_float_frag_xvary_yconstquarter.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = color.r;
	gl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = color.r;
  gl_FragColor = vec4(clamp(c , min_c , max_c) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.5
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(notEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(notEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct50000 {
  bool f_8550;
  bool f_5715;
  vec4 f_285;
  bool f_166[1];
  float f_5613;
  uint f_6037;
};

vec4 color = vec4(+-1.0, ((+0.5 - +0.0) / (true ? 0.5 : 0.0)), 1.0, 1.0);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct50000 {
  bool f_8550;
  bool f_5715;
  vec4 f_285;
  bool f_166[1];
  float f_5613;
  uint f_6037;
};

vec4 color = vec4(+-1.0, ((+0.5 - +0.0) / (true ? 0.5 : 0.0)), 1.0, 1.0);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


==============================
63.18407960199005
Processing this: /home/oof/webgl_cleaned/reflect_vec3_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	gl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tgl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = ivec2(0.0, -0.5)(color);
  gl_FragColor = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'assign' : cannot convert from 'const 2-component vector of int' to 'mediump float'
ERROR: 0:15: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = ivec2(0.0, -0.5)(color);
  gl_FragColor = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
}


==============================
62.87128712871287
Mutations attempted: 202
Valid mutations:     127
Success rate:        62.87%
Processing this: /home/oof/webgl_cleaned/gl_MaxCombinedTextureImageUnits_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(float(gl_MaxCombinedTextureImageUnits) / 8.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(float(gl_MaxCombinedTextureImageUnits) / 8.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, (2.0 + (!true ? (true ? 2.0 : 0.0) : 1.0)), 1.0, ((0.5 * (true ? 0.0 : 1.0)) - 0.5))((float(gl_MaxCombinedTextureImageUnits) / 8.5));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, (2.0 + (!true ? (true ? 2.0 : 0.0) : 1.0)), 1.0, ((0.5 * (true ? 0.0 : 1.0)) - 0.5))((float(gl_MaxCombinedTextureImageUnits) / 8.5));
}


==============================
62.5615763546798
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par[3])
{
	set_all(par, 0);
	return 1;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par[3])\n{\n\tset_all(par, 0);\n\treturn 1;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
62.5615763546798
Processing this: /home/oof/webgl_cleaned/refract_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.745098039215684
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
62.745098039215684
Processing this: /home/oof/webgl_cleaned/refract_vec2_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	gl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tgl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.0, 0.5, 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  gl_FragColor = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.926829268292686
Processing this: /home/oof/webgl_cleaned/refract_vec2_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-1.0, 0.5, (true ? -(2.0 / 0.5) : 0.0), 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.10679611650486
Processing this: /home/oof/webgl_cleaned/mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat4 a = mat4(   1.0,    2.0,     4.0,     8.0,
	                16.0,   32.0,    64.0,   128.0,
	               256.0,  512.0,  1024.0,  2048.0,
	              4096.0, 8192.0, 16384.0, 32768.0);
	bool elms = true;
	if(a[0][0] !=     1.0) elms = false;
	if(a[0][1] !=     2.0) elms = false;
	if(a[0][2] !=     4.0) elms = false;
	if(a[0][3] !=     8.0) elms = false;
	if(a[1][0] !=    16.0) elms = false;
	if(a[1][1] !=    32.0) elms = false;
	if(a[1][2] !=    64.0) elms = false;
	if(a[1][3] !=   128.0) elms = false;
	if(a[2][0] !=   256.0) elms = false;
	if(a[2][1] !=   512.0) elms = false;
	if(a[2][2] !=  1024.0) elms = false;
	if(a[2][3] !=  2048.0) elms = false;
	if(a[3][0] !=  4096.0) elms = false;
	if(a[3][1] !=  8192.0) elms = false;
	if(a[3][2] != 16384.0) elms = false;
	if(a[3][3] != 32768.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 4369.0-0.1 || x > 4369.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 8738.0-0.1 || x > 8738.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 17476.0-0.1 || x > 17476.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 34952.0-0.1 || x > 34952.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 15.0-0.1 || x > 15.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 240.0-0.1 || x > 240.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 3840.0-0.1 || x > 3840.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 61440.0-0.1 || x > 61440.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat4 a = mat4(   1.0,    2.0,     4.0,     8.0,\n\t                16.0,   32.0,    64.0,   128.0,\n\t               256.0,  512.0,  1024.0,  2048.0,\n\t              4096.0, 8192.0, 16384.0, 32768.0);\n\tbool elms = true;\n\tif(a[0][0] !=     1.0) elms = false;\n\tif(a[0][1] !=     2.0) elms = false;\n\tif(a[0][2] !=     4.0) elms = false;\n\tif(a[0][3] !=     8.0) elms = false;\n\tif(a[1][0] !=    16.0) elms = false;\n\tif(a[1][1] !=    32.0) elms = false;\n\tif(a[1][2] !=    64.0) elms = false;\n\tif(a[1][3] !=   128.0) elms = false;\n\tif(a[2][0] !=   256.0) elms = false;\n\tif(a[2][1] !=   512.0) elms = false;\n\tif(a[2][2] !=  1024.0) elms = false;\n\tif(a[2][3] !=  2048.0) elms = false;\n\tif(a[3][0] !=  4096.0) elms = false;\n\tif(a[3][1] !=  8192.0) elms = false;\n\tif(a[3][2] != 16384.0) elms = false;\n\tif(a[3][3] != 32768.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 4369.0-0.1 || x > 4369.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 8738.0-0.1 || x > 8738.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 17476.0-0.1 || x > 17476.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 34952.0-0.1 || x > 34952.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 15.0-0.1 || x > 15.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 240.0-0.1 || x > 240.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 3840.0-0.1 || x > 3840.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 61440.0-0.1 || x > 61440.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0 , 512.0 , 1024.0 , 2048.0 , 4096.0 , 8192.0 , 16384.0 , 32768.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 4.0))
    elms = false;
  if ((a[0][3] != 8.0))
    elms = false;
  if ((a[1][0] != 16.0))
    elms = false;
  if ((a[-15][1] != 32.0))
    elms = false;
  if ((a[1][2] != 64.0))
    elms = false;
  if ((a[1][3] != 128.0))
    elms = false;
  if ((a[2][0] != 256.0))
    elms = false;
  if ((a[2][1] != 512.0))
    elms = false;
  if ((a[2][2] != 1024.0))
    elms = false;
  if ((a[2][3] != 2048.0))
    elms = false;
  if ((a[3][0] != 4096.0))
    elms = false;
  if ((a[3][1] != 8192.0))
    elms = false;
  if ((a[3][2] != 16384.0))
    elms = false;
  if ((a[3][3] != 32768.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (4369.0 - 0.1)) || (x > (4369.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (8738.0 - 0.1)) || (x > (8738.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (17476.0 - 0.1)) || (x > (17476.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (34952.0 - 0.1)) || (x > (34952.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (240.0 - 0.1)) || (x > (240.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (3840.0 - 0.1)) || (x > (3840.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (61440.0 - 0.1)) || (x > (61440.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:25: '[]' : index expression is negative

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0 , 512.0 , 1024.0 , 2048.0 , 4096.0 , 8192.0 , 16384.0 , 32768.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 4.0))
    elms = false;
  if ((a[0][3] != 8.0))
    elms = false;
  if ((a[1][0] != 16.0))
    elms = false;
  if ((a[-15][1] != 32.0))
    elms = false;
  if ((a[1][2] != 64.0))
    elms = false;
  if ((a[1][3] != 128.0))
    elms = false;
  if ((a[2][0] != 256.0))
    elms = false;
  if ((a[2][1] != 512.0))
    elms = false;
  if ((a[2][2] != 1024.0))
    elms = false;
  if ((a[2][3] != 2048.0))
    elms = false;
  if ((a[3][0] != 4096.0))
    elms = false;
  if ((a[3][1] != 8192.0))
    elms = false;
  if ((a[3][2] != 16384.0))
    elms = false;
  if ((a[3][3] != 32768.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (4369.0 - 0.1)) || (x > (4369.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (8738.0 - 0.1)) || (x > (8738.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (17476.0 - 0.1)) || (x > (17476.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (34952.0 - 0.1)) || (x > (34952.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (240.0 - 0.1)) || (x > (240.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (3840.0 - 0.1)) || (x > (3840.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (61440.0 - 0.1)) || (x > (61440.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.80193236714976
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = color.rg;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.980769230769226
Processing this: /home/oof/webgl_cleaned/exp2_vec3_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = -gtf_Color.rgb;
	color = vec4(exp2(5.0 * c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -gtf_Color.rgb;\n\tcolor = vec4(exp2(5.0 * c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, 0.0, +-1.0, (((true && true) ? 1.0 : 1.0) + (false ? (0.0 - 1.0) : -1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = -gtf_Color.rgb;
  color = vec4(exp2((5.0 * c)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.1578947368421
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = (gtf_Color.rgb + 0.01) / 1.01;
	color = vec4(log(c) / -4.61, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (gtf_Color.rgb + 0.01) / 1.01;\n\tcolor = vec4(log(c) / -4.61, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (-1.0 + -0.5) : (0.0 / (0.0 + 0.5))), ((true ? (false ? 1.0 : 0.5) : (true ? 1.0 : 0.0)) + -1.0), 0.5, +0.5, (((false ? true : false) && (true ? false : true)) ? +0.0 : -1.0), (-1.0 - ((2.0 - 0.5) + 2.0)), -2.0, 2.0, -1.0, 1.0, (((1.0 * 2.0) + -2.0) / 0.5), 1.0, +((true ? 2.0 : 1.0) + 0.0), -(!true ? (true ? 1.0 : 1.0) : 2.0), -+2.0, 2.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (-1.0 + -0.5) : (0.0 / (0.0 + 0.5))), ((true ? (false ? 1.0 : 0.5) : (true ? 1.0 : 0.0)) + -1.0), 0.5, +0.5, (((false ? true : false) && (true ? false : true)) ? +0.0 : -1.0), (-1.0 - ((2.0 - 0.5) + 2.0)), -2.0, 2.0, -1.0, 1.0, (((1.0 * 2.0) + -2.0) / 0.5), 1.0, +((true ? 2.0 : 1.0) + 0.0), -(!true ? (true ? 1.0 : 1.0) : 2.0), -+2.0, 2.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.857142857142854
Mutations attempted: 210
Valid mutations:     132
Success rate:        62.86%
Processing this: /home/oof/webgl_cleaned/equal_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(equal(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(equal(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(equal(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.03317535545023
Processing this: /home/oof/webgl_cleaned/vec4_zwxy_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.zwxy;
	vec4 a = vec4(m.z, m.w, m.x, m.y);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.zwxy;\n\tvec4 a = vec4(m.z, m.w, m.x, m.y);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.zwxy;
  vec4 a = vec4(m.z , m.w , m.x , m.y);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
63.20754716981132
Processing this: /home/oof/webgl_cleaned/cross_vec3_frag_xvaryyconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = vec3(1.0, 0.0, 0.0);
	vec3 v3;
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	v3.x = v1.y * v2.z - v2.y * v1.z;
	v3.y = v2.x * v1.z - v1.x * v2.z;
	v3.z = v1.x * v2.y - v2.x * v1.y;
	gl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = vec3(1.0, 0.0, 0.0);\n\tvec3 v3;\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tv3.x = v1.y * v2.z - v2.y * v1.z;\n\tv3.y = v2.x * v1.z - v1.x * v2.z;\n\tv3.z = v1.x * v2.y - v2.x * v1.y;\n\tgl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1 = (!(true ? true : true) ? vec3(+2.0, -((true ? 0.5 : -1.0) / (true ? 0.5 : -1.0)), 2.0) : vec3((true ? (-1.0 + 0.5) : -(0.5 * 1.0)), ((true ? true : false) ? ((false || false) ? (false ? 0.5 : 0.5) : -1.0) : +(true ? -1.0 : 0.5)), 0.5));
  vec3 v2 = vec3(1.0 , 0.0 , 0.0);
  vec3 v3;
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  v3.x = ((v1.y * v2.z) - (v2.y * v1.z));
  v3.y = ((v2.x * v1.z) - (v1.x * v2.z));
  v3.z = ((v1.x * v2.y) - (v2.x * v1.y));
  gl_FragColor = vec4(((v3 + 1.0) / 2.0) , 1.0);
  ivec2(-6, 3);
}


As vertex? : False
SUCCESS!
63.38028169014085
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x = 31.0 * gtf_Color.r + 1.0;
	float y = 0.0;
	float z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	color = vec4(y / 3.466, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = 31.0 * gtf_Color.r + 1.0;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tcolor = vec4(y / 3.466, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 2.0, 0.0, 2.0);

void main()
{
  float x = ((31.0 * gtf_Color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.55140186915887
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 x = (gtf_Color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	color = vec4(y / -4.61, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 x = (gtf_Color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tcolor = vec4(y / -4.61, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 0.505);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  color = vec4((y / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.72093023255814
Processing this: /home/oof/webgl_cleaned/length_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(color.r), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(color.r), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(color.r));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(color.r));
}


==============================
63.42592592592593
Processing this: /home/oof/webgl_cleaned/const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.05)) || (vec4(((false ? 1.0 : 0.5) * 1.0), (0.5 - 0.0), (((true ? true : false) ? !true : (true && false)) ? 0.0 : 2.0), 1.0) > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: '>' : comparison operator only defined for scalars
ERROR: 0:22: '>' : wrong operand types - no operation '>' exists that takes a left-hand operand of type 'const 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.05)) || (vec4(((false ? 1.0 : 0.5) * 1.0), (0.5 - 0.0), (((true ? true : false) ? !true : (true && false)) ? 0.0 : 2.0), 1.0) > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
63.133640552995395
Processing this: /home/oof/webgl_cleaned/vec3_tsp_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	vec3 t = m.tsp;
	vec4 a = vec4(t.t, t.s, t.p ,al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tvec3 t = m.tsp;\n\tvec4 a = vec4(t.t, t.s, t.p ,al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -0.5, 1.0, 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  vec3 t = m.tsp;
  vec4 a = vec4(t.t , t.s , t.p , al.q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
63.30275229357798
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg * 99.0) + 1.0;
	gl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg * 99.0) + 1.0;\n\tgl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((0.5 - 0.5) / -1.0), (true ? (1.0 - 2.0) : 2.0), -(false ? +1.0 : (2.0 / 0.0)), 1.0);

void main()
{
  vec2 c = ((color.rg * 99.0) + 1.0);
  gl_FragColor = vec4((1.0 / sqrt(c)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.4703196347032
Processing this: /home/oof/webgl_cleaned/vec3_xy_z_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec2 t = m.xy;
	float k = m.z;
	vec4 a = vec4(t, k, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec2 t = m.xy;\n\tfloat k = m.z;\n\tvec4 a = vec4(t, k, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, 2.0, (+0.0 / (true ? 0.5 : -2.0)), (!(true ? false : false) ? 2.0 : (-1.0 - -2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec2 t = m.xy;
  float k = m.z;
  vec4 a = vec4(t , k , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
63.63636363636363
Mutations attempted: 220
Valid mutations:     140
Success rate:        63.64%
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvaryyvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (color.ggg - 0.5);
	vec3 y = 2.0 * (color.bbb - 0.5);
	vec3 c;
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		if(x[0] < 0.0 ^^ y[0] < 0.0)
		{
			sign[0] = -1.0;
		}
		if(abs(y[0]) <= abs(x[0]))
		{
			c[0] = abs(y[0] / x[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[0] = abs(x[0] / y[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;
		}
		if(x[0] < 0.0)
			if(y[0] < 0.0) result[0] -= 0.5;
			else if(y[0] > 0.0) result[0] += 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		if(x[1] < 0.0 ^^ y[1] < 0.0)
		{
			sign[1] = -1.0;
		}
		if(abs(y[1]) <= abs(x[1]))
		{
			c[1] = abs(y[1] / x[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[1] = abs(x[1] / y[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;
		}
		if(x[1] < 0.0)
			if(y[1] < 0.0) result[1] -= 0.5;
			else if(y[1] > 0.0) result[1] += 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		if(x[2] < 0.0 ^^ y[2] < 0.0)
		{
			sign[2] = -1.0;
		}
		if(abs(y[2]) <= abs(x[2]))
		{
			c[2] = abs(y[2] / x[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[2] = abs(x[2] / y[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;
		}
		if(x[2] < 0.0)
			if(y[2] < 0.0) result[2] -= 0.5;
			else if(y[2] > 0.0) result[2] += 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 x = 2.0 * (color.ggg - 0.5);\n\tvec3 y = 2.0 * (color.bbb - 0.5);\n\tvec3 c;\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tif(x[0] < 0.0 ^^ y[0] < 0.0)\n\t\t{\n\t\t\tsign[0] = -1.0;\n\t\t}\n\t\tif(abs(y[0]) <= abs(x[0]))\n\t\t{\n\t\t\tc[0] = abs(y[0] / x[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[0] = abs(x[0] / y[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[0] < 0.0)\n\t\t\tif(y[0] < 0.0) result[0] -= 0.5;\n\t\t\telse if(y[0] > 0.0) result[0] += 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tif(x[1] < 0.0 ^^ y[1] < 0.0)\n\t\t{\n\t\t\tsign[1] = -1.0;\n\t\t}\n\t\tif(abs(y[1]) <= abs(x[1]))\n\t\t{\n\t\t\tc[1] = abs(y[1] / x[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[1] = abs(x[1] / y[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[1] < 0.0)\n\t\t\tif(y[1] < 0.0) result[1] -= 0.5;\n\t\t\telse if(y[1] > 0.0) result[1] += 0.5;\n\t}\n\tif(x[2] > epsilon || abs(y[2]) > epsilon)\n\t{\n\t\tif(x[2] < 0.0 ^^ y[2] < 0.0)\n\t\t{\n\t\t\tsign[2] = -1.0;\n\t\t}\n\t\tif(abs(y[2]) <= abs(x[2]))\n\t\t{\n\t\t\tc[2] = abs(y[2] / x[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[2] = abs(x[2] / y[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[2] < 0.0)\n\t\t\tif(y[2] < 0.0) result[2] -= 0.5;\n\t\t\telse if(y[2] > 0.0) result[2] += 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb - 0.5));
  vec3 c;
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      sign[0] = -1.0;
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      c[0] = abs((y[0] / x[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[0] = abs((x[0] / y[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      sign[1] = -1.0;
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      c[1] = abs((y[1] / x[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[1] = abs((x[1] / y[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  if (((x[2] > epsilon) || (abs(y[2]) > epsilon)))
  {
    if (((x[2] < 0.0) ^^ (y[2] < 0.0)))
    {
      sign[2] = -1.0;
    }
    if ((abs(y[2]) <= abs(x[2])))
    {
      c[2] = abs((y[2] / x[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * atan_c[2]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[2] = abs((x[2] / y[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[2] < 0.0))
      if ((y[2] < 0.0))
        (result[2] -= 0.5);
      else
        if ((y[2] > 0.0))
          (result[2] += 0.5);
  }
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
63.80090497737556
Processing this: /home/oof/webgl_cleaned/simple.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute float gtf_Color;
varying vec4 tc;
void main ()
{
	tc = vec4(gtf_Color, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute float gtf_Color;\nvarying vec4 tc;\nvoid main ()\n{\n\ttc = vec4(gtf_Color, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

float gtf_Color;

vec4 tc = vec4(1.0, 2.0, (true ? (+1.0 / 2.0) : (!true ? 2.0 : -gtf_Color)), gtf_Color);

void main()
{
  tc = vec4(gtf_Color , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

float gtf_Color;

vec4 tc = vec4(1.0, 2.0, (true ? (+1.0 / 2.0) : (!true ? 2.0 : -gtf_Color)), gtf_Color);

void main()
{
  tc = vec4(gtf_Color , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.51351351351351
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat3 m1 = mat3(color.rgb, color.rgb, color.rgb);
	mat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);
	mat3 m3 = mat3(0.0);
	vec3 result = vec3(0.0, 0.0, 0.0);
	m3 = matrixCompMult(m1, m2);
	result[0] += m3[0][0];
	result[0] += m3[0][1];
	result[0] += m3[0][2];
	result[1] += m3[1][0];
	result[1] += m3[1][1];
	result[1] += m3[1][2];
	result[2] += m3[2][0];
	result[2] += m3[2][1];
	result[2] += m3[2][2];
	gl_FragColor = vec4(result / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m1 = mat3(color.rgb, color.rgb, color.rgb);\n\tmat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);\n\tmat3 m3 = mat3(0.0);\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tm3 = matrixCompMult(m1, m2);\n\tresult[0] += m3[0][0];\n\tresult[0] += m3[0][1];\n\tresult[0] += m3[0][2];\n\tresult[1] += m3[1][0];\n\tresult[1] += m3[1][1];\n\tresult[1] += m3[1][2];\n\tresult[2] += m3[2][0];\n\tresult[2] += m3[2][1];\n\tresult[2] += m3[2][2];\n\tgl_FragColor = vec4(result / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  mat3 m1 = mat3(color.rgb , color.rgb , color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3 = matrixCompMult(m1 , m2);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  gl_FragColor = vec4((result / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
63.67713004484305
Processing this: /home/oof/webgl_cleaned/step_vec3_frag_xvary_edgeconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 edge = vec3(0.5, 0.5, 0.5);
	gl_FragColor = vec4(step(edge, color.rgb), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge = vec3(0.5, 0.5, 0.5);\n\tgl_FragColor = vec4(step(edge, color.rgb), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, (true ? -1.0 : 0.5), 2.0, 2.0);

void main()
{
  const vec3 edge = vec3(0.5 , 0.5 , 0.5);
  gl_FragColor = vec4(step(edge , color.rgb) , 1.0);
}


As vertex? : False
SUCCESS!
63.83928571428571
Processing this: /home/oof/webgl_cleaned/fwidth_frag_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.0
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(notEqual(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(notEqual(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, -0.5, 0.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(notEqual(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.15929203539822
Processing this: /home/oof/webgl_cleaned/simple.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 tc;
void main ()
{
	gl_FragColor = tc;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 tc;\nvoid main ()\n{\n\tgl_FragColor = tc;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 tc = vec4(1.0, ((!true ? (true ? 1.0 : 1.0) : (true ? 0.0 : 2.0)) * -1.0), +--0.5, -2.0);

void main()
{
  gl_FragColor = tc;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 tc = vec4(1.0, ((!true ? (true ? 1.0 : 1.0) : (true ? 0.0 : 2.0)) * -1.0), +--0.5, -2.0);

void main()
{
  gl_FragColor = tc;
}


==============================
63.87665198237885
Processing this: /home/oof/webgl_cleaned/for_break_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count = 0;
        for(int i=0;i<5;i++)
	{
	  count++;
	  if(count == 3)
            break;
	}
	float gray;
	if( count == 3)
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint count = 0;\n        for(int i=0;i<5;i++)\n\t{\n\t  count++;\n\t  if(count == 3)\n            break;\n\t}\n\tfloat gray;\n\tif( count == 3)\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.5, 0.5, 0.0);

void main()
{
  int count = 0;
  for (int i = 0; (i < 5); i++)
  {
    count++;
    if ((count == 3))
      break;
  }
  float gray;
  if ((count == 3))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
64.03508771929825
Processing this: /home/oof/webgl_cleaned/exp2_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = color.rgb;
	gl_FragColor = vec4(exp2(5.0 * c) / 32.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(exp2(5.0 * c) / 32.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0));
}


==============================
63.75545851528385
Processing this: /home/oof/webgl_cleaned/qualifiers_struct_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,
sabcd e)
{
        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
        b = a;
        c.a += d.a;
        c.b += d.b;
        c.c += d.c;
        c.d += d.d;
        a.a += one.a;
        a.b += one.b;
        a.c += one.c;
        a.d += one.d;
        return e;
}
void main ()
{
	sabcd a = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd b = sabcd(2.0, 2.0, 2.0, 2.0);
	sabcd c = sabcd(3.0, 3.0, 3.0, 3.0);
	sabcd d = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd e = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd f = sabcd(0.0, 0.0, 0.0, 0.0);
	sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd four = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == one) q += 1.0;
	if(b == one) q += 2.0;
	if(c == seven) q += 4.0;
	if(d == four) q2 += 1.0;
	if(e == one) q2 += 2.0;
	if(f == one) q2 += 4.0;
	gl_FragColor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nsabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,\nsabcd e)\n{\n        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n        b = a;\n        c.a += d.a;\n        c.b += d.b;\n        c.c += d.c;\n        c.d += d.d;\n        a.a += one.a;\n        a.b += one.b;\n        a.c += one.c;\n        a.d += one.d;\n        return e;\n}\nvoid main ()\n{\n\tsabcd a = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd b = sabcd(2.0, 2.0, 2.0, 2.0);\n\tsabcd c = sabcd(3.0, 3.0, 3.0, 3.0);\n\tsabcd d = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd e = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd f = sabcd(0.0, 0.0, 0.0, 0.0);\n\tsabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd four = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == one) q += 1.0;\n\tif(b == one) q += 2.0;\n\tif(c == seven) q += 4.0;\n\tif(d == four) q2 += 1.0;\n\tif(e == one) q2 += 2.0;\n\tif(f == one) q2 += 4.0;\n\tgl_FragColor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d, sabcd e)
{
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  b = a;
  (c.a += d.a);
  (c.b += d.b);
  (c.c += d.c);
  (c.d += d.d);
  (a.a += one.a);
  (a.b += one.b);
  (a.c += one.c);
  (a.d += one.d);
  return e;
}

void main()
{
  sabcd a = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd b = sabcd(2.0 , 2.0 , 2.0 , 2.0);
  sabcd c = sabcd(3.0 , 3.0 , 3.0 , 3.0);
  sabcd d = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd e = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd f = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd four = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd seven = sabcd(7.0 , 7.0 , 7.0 , 7.0);
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == one))
    (q += 1.0);
  if ((b == one))
    (q += 2.0);
  if ((c == seven))
    (q += 4.0);
  if ((d == four))
    (q2 += 1.0);
  if ((e == one))
    (q2 += 2.0);
  if ((f == one))
    (q2 += 4.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.91304347826087
Mutations attempted: 230
Valid mutations:     147
Success rate:        63.91%
Processing this: /home/oof/webgl_cleaned/default.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
	gl_PointSize = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n\tgl_PointSize = 1.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((0.0 + +-1.0), 2.0, (1.0 + 0.5), (-1.0 * 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  gl_PointSize = 1.0;
}


As vertex? : True
SUCCESS!
64.06926406926407
Processing this: /home/oof/webgl_cleaned/3m_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform mat3 color;
void main ()
{
	gl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2],
						 color[1][0] + color[1][1] + color[1][2],
						 color[2][0] + color[2][1] + color[2][2],
						 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform mat3 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2],\n\t\t\t\t\t\t color[1][0] + color[1][1] + color[1][2],\n\t\t\t\t\t\t color[2][0] + color[2][1] + color[2][2],\n\t\t\t\t\t\t 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat3 color;

void main()
{
  color = vec4(((color[0][0] + color[0][1]) + color[0][2]) , ((color[1][0] + color[1][1]) + color[1][2]) , ((color[2][0] + color[2][1]) + color[2][2]));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a uniform "color")
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: 'assign' : cannot convert from 'const 4-component vector of float' to 'uniform mediump 3X3 matrix of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat3 color;

void main()
{
  color = vec4(((color[0][0] + color[0][1]) + color[0][2]) , ((color[1][0] + color[1][1]) + color[1][2]) , ((color[2][0] + color[2][1]) + color[2][2]));
}


==============================
63.793103448275865
Processing this: /home/oof/webgl_cleaned/notEqual_ivec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 ne(in ivec3 a, in ivec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(ne(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 ne(in ivec3 a, in ivec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(ne(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-1.0 * (0.5 * -1.0)), 0.5, 0.0, 1.0);

bvec3 ne(in ivec3 a, in ivec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(ne(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
63.94849785407726
Processing this: /home/oof/webgl_cleaned/min_vec3_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 min_c = vec3(0.5, 0.5, 0.5);
	vec3 c = color.rgb;
	gl_FragColor = vec4(min(c, min_c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 min_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(min(c, min_c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5);
  vec3 c = color.rgb;
  gl_FragColor = vec4(min(c , min_c) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5);
  vec3 c = color.rgb;
  gl_FragColor = vec4(min(c , min_c) , 1.0);
}


==============================
63.67521367521367
Processing this: /home/oof/webgl_cleaned/atan_float_frag_xvaryyvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float x = 2.0 * (color.g - 0.5);
	float y = 2.0 * (color.b - 0.5);
	const float epsilon = 1.0e-4;
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	if(x > epsilon || abs(y) > epsilon)
	{
		gl_FragColor = vec4(atan(y, x) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
	}
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat x = 2.0 * (color.g - 0.5);\n\tfloat y = 2.0 * (color.b - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x > epsilon || abs(y) > epsilon)\n\t{\n\t\tgl_FragColor = vec4(atan(y, x) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t}\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? -(true ? 1.0 : 0.5) : -1.0), 0.5, 0.0, (true ? (2.0 * (true ? 0.0 : 0.0)) : 1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  float x = (2.0 * (color.g - 0.5));
  float y = (2.0 * (color.b - 0.5));
  const float epsilon = 0.0001;
  gl_FragColor = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    gl_FragColor = vec4(((atan(y , x) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
  }
}


As vertex? : False
SUCCESS!
63.829787234042556
Processing this: /home/oof/webgl_cleaned/step_vec3_vert_xvary_edgeconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge = vec3(0.5, 0.5, 0.5);
	color = vec4(step(edge, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge = vec3(0.5, 0.5, 0.5);\n\tcolor = vec4(step(edge, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge = vec3(0.5 , 0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rgb) , 1.0);
  (gtf_ModelViewProjectionMatrix * gtf_Vertex) = gl_Position;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'assign' :  l-value required

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge = vec3(0.5 , 0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rgb) , 1.0);
  (gtf_ModelViewProjectionMatrix * gtf_Vertex) = gl_Position;
}


==============================
63.559322033898304
Processing this: /home/oof/webgl_cleaned/notEqual_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 ne(in bvec3 a, in bvec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	vec3 result = vec3(ne(bvec3(c), bvec3(true)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 ne(in bvec3 a, in bvec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tvec3 result = vec3(ne(bvec3(c), bvec3(true)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 ne(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = vec3(ne(bvec3(c)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:27: 'ne' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec3 ne(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = vec3(ne(bvec3(c)));
  gl_FragColor = vec4(result , 1.0);
}


==============================
63.29113924050633
Processing this: /home/oof/webgl_cleaned/array_const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat2 a = mat2(1.0, 2.0, 3.0, 4.0);
	const mat2 b = mat2(5.0, 6.0, 7.0, 8.0);
	mat2 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat2 a = mat2(1.0, 2.0, 3.0, 4.0);\n\tconst mat2 b = mat2(5.0, 6.0, 7.0, 8.0);\n\tmat2 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat2 a = mat2(1.0 , 2.0 , 3.0 , 4.0);
  const mat2 b = mat2(5.0 , 6.0 , 7.0 , 8.0);
  mat2 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[3] == b)))
    gray = 1.0;
  else
    ivec2((1 % 5), 2) = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: '[]' : array index out of range
ERROR: 0:19: '%' : integer modulus operator supported in GLSL ES 3.00 and above only
ERROR: 0:19: 'assign' : l-value required (can't modify a const)
ERROR: 0:19: 'assign' : cannot convert from 'const float' to 'const 2-component vector of int'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat2 a = mat2(1.0 , 2.0 , 3.0 , 4.0);
  const mat2 b = mat2(5.0 , 6.0 , 7.0 , 8.0);
  mat2 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[3] == b)))
    gray = 1.0;
  else
    ivec2((1 % 5), 2) = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
63.02521008403361
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 x = 31.0 * gtf_Color.rg + 1.0;
	vec2 y = vec2(0.0);
	vec2 z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	vec2 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	color = vec4(y / 3.466, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 x = 31.0 * gtf_Color.rg + 1.0;\n\tvec2 y = vec2(0.0);\n\tvec2 z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tvec2 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tcolor = vec4(y / 3.466, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+2.0, 1.0, 0.5, 0.0, (+0.0 / 0.0), -1.0, (((false && true) || false) ? (false ? 0.5 : 2.0) : (false ? -1.0 : (0.0 / -1.0))), 2.0, -1.0, -1.0, (false ? ((0.5 / 0.0) * (0.5 * 2.0)) : 2.0), (true ? (2.0 - 1.0) : (false ? 0.5 : (false ? -1.0 : 0.5))), 0.5, (2.0 + (+2.0 * (-1.0 / 2.0))), (true ? (-1.0 + (true ? 0.0 : 0.5)) : 0.0), 0.0);

vec4 color;

void main()
{
  vec2 x = ((31.0 * gtf_Color.rg) + 1.0);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Zero divided by zero during constant folding generated NaN
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+2.0, 1.0, 0.5, 0.0, (+0.0 / 0.0), -1.0, (((false && true) || false) ? (false ? 0.5 : 2.0) : (false ? -1.0 : (0.0 / -1.0))), 2.0, -1.0, -1.0, (false ? ((0.5 / 0.0) * (0.5 * 2.0)) : 2.0), (true ? (2.0 - 1.0) : (false ? 0.5 : (false ? -1.0 : 0.5))), 0.5, (2.0 + (+2.0 * (-1.0 / 2.0))), (true ? (-1.0 + (true ? 0.0 : 0.5)) : 0.0), 0.0);

vec4 color;

void main()
{
  vec2 x = ((31.0 * gtf_Color.rg) + 1.0);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.76150627615063
Processing this: /home/oof/webgl_cleaned/compressed_paletted_texture.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 gtf_TexCoord[1];
attribute vec4 gtf_MultiTexCoord0;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 gtf_TexCoord[1];\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(0.0, +0.5, 2.0, ((0.5 + 0.5) - --1.0));

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: '--' : l-value required (can't modify a const)
ERROR: 0:12: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(0.0, +0.5, 2.0, ((0.5 + 0.5) - --1.0));

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Mutations attempted: 240
Valid mutations:     150
Success rate:        62.50%
Processing this: /home/oof/webgl_cleaned/sin_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rgb) + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rgb) + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = (!false ? vec4(-1.0, --1.0, +(1.0 * 0.5), 0.5) : vec4(2.0, (-+1.0 + -(0.0 * 0.5)), (true ? +(true ? 0.0 : 1.0) : ((true ? 2.0 : -1.0) / (true ? 0.5 : 1.0))), -1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.rgb))) + 0.5) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = (!false ? vec4(-1.0, --1.0, +(1.0 * 0.5), 0.5) : vec4(2.0, (-+1.0 + -(0.0 * 0.5)), (true ? +(true ? 0.0 : 1.0) : ((true ? 2.0 : -1.0) / (true ? 0.5 : 1.0))), -1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.rgb))) + 0.5) , 1.0);
}


==============================
62.24066390041494
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gte(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 gte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(gte(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 gte(in vec2 a, in vec2 b)
{
  bvec2 result = bvec2(-1.0, 0.0);
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(gte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.396694214876035
Processing this: /home/oof/webgl_cleaned/normalize_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = gtf_Color + vec4(0.25);
	color = vec4(normalize(tmp_Color.r), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = gtf_Color + vec4(0.25);\n\tcolor = vec4(normalize(tmp_Color.r), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (!false ? (false ? -0.5 : 0.5) : (false ? -1.0 : 0.0)), (((2.0 - -1.0) / 0.0) * 1.0), -0.0);

void main()
{
  vec4 tmp_Color = (gtf_Color + vec4(0.25));
  color = vec4(normalize(tmp_Color.r) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.55144032921811
Processing this: /home/oof/webgl_cleaned/vec3_xyz_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec4 a = vec4(m.xyz,lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec4 a = vec4(m.xyz,lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((true ? ((2.0 - -1.0) * 2.0) : (true ? (-1.0 + 0.5) : (true ? 0.0 : -1.0))), 1.0, --2.0, --1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec4 a = vec4(m.xyz , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((true ? ((2.0 - -1.0) * 2.0) : (true ? (-1.0 + 0.5) : (true ? 0.0 : -1.0))), 1.0, --2.0, --1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec4 a = vec4(m.xyz , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
62.295081967213115
Processing this: /home/oof/webgl_cleaned/degrees_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.44897959183674
Processing this: /home/oof/webgl_cleaned/fract_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((true ? 0.0 : +(false ? 1.0 : -1.0)), ((true ? true : (true ? true : false)) ? 2.0 : -+1.0), -1.0, 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.601626016260155
Processing this: /home/oof/webgl_cleaned/degrees_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((2.0 * M_PI) * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((2.0 * M_PI) * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5));
}


==============================
62.34817813765182
Processing this: /home/oof/webgl_cleaned/log2_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const float ln2 = 0.69314718055994530941723212145818;
void main ()
{
	float x = 31.0 * color.r + 1.0;
	float y = 0.0;
	float z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0 / ln2;
	gl_FragColor = vec4(y / 5.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst float ln2 = 0.69314718055994530941723212145818;\nvoid main ()\n{\n\tfloat x = 31.0 * color.r + 1.0;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0 / ln2;\n\tgl_FragColor = vec4(y / 5.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? ((true && false) ? (true ? 0.0 : ln2) : ln2) : -1.0), (true ? ln2 : -1.0), 1.0, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  float x = ((31.0 * color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (2.0 / ln2));
  gl_FragColor = vec4((y / 5.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'ln2' : undeclared identifier
ERROR: 0:4: 'ln2' : undeclared identifier
ERROR: 0:4: 'ln2' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? ((true && false) ? (true ? 0.0 : ln2) : ln2) : -1.0), (true ? ln2 : -1.0), 1.0, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  float x = ((31.0 * color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (2.0 / ln2));
  gl_FragColor = vec4((y / 5.0) , 0.0 , 0.0 , 1.0);
}


==============================
62.096774193548384
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 4.0 * (gtf_Color.r);
	color = vec4(c * c / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 4.0 * (gtf_Color.r);\n\tcolor = vec4(c * c / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (4.0 * gtf_Color.r);
  color = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.24899598393574
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	gl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tgl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  gl_FragColor = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
}


As vertex? : False
SUCCESS!
62.4
Mutations attempted: 250
Valid mutations:     156
Success rate:        62.40%
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(out vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(out vec4 par)
{
	set_all(par, 0.0);
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(out vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(out vec4 par)\n{\n\tset_all(par, 0.0);\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
62.4
Processing this: /home/oof/webgl_cleaned/const_mat4_copy_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	mat4 b = a;
	bool elms = true;
	if(b[0][0] !=  1.0) elms = false;
	if(b[0][1] !=  2.0) elms = false;
	if(b[0][2] !=  3.0) elms = false;
	if(b[0][3] !=  4.0) elms = false;
	if(b[1][0] !=  5.0) elms = false;
	if(b[1][1] !=  6.0) elms = false;
	if(b[1][2] !=  7.0) elms = false;
	if(b[1][3] !=  8.0) elms = false;
	if(b[2][0] !=  9.0) elms = false;
	if(b[2][1] != 10.0) elms = false;
	if(b[2][2] != 11.0) elms = false;
	if(b[2][3] != 12.0) elms = false;
	if(b[3][0] != 13.0) elms = false;
	if(b[3][1] != 14.0) elms = false;
	if(b[3][2] != 15.0) elms = false;
	if(b[3][3] != 16.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0] + b[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = b[0][1] + b[1][1] + b[2][1] + b[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = b[0][2] + b[1][2] + b[2][2] + b[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = b[0][3] + b[1][3] + b[2][3] + b[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2] + b[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = b[1][0] + b[1][1] + b[1][2] + b[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2] + b[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = b[3][0] + b[3][1] + b[3][2] + b[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tmat4 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=  1.0) elms = false;\n\tif(b[0][1] !=  2.0) elms = false;\n\tif(b[0][2] !=  3.0) elms = false;\n\tif(b[0][3] !=  4.0) elms = false;\n\tif(b[1][0] !=  5.0) elms = false;\n\tif(b[1][1] !=  6.0) elms = false;\n\tif(b[1][2] !=  7.0) elms = false;\n\tif(b[1][3] !=  8.0) elms = false;\n\tif(b[2][0] !=  9.0) elms = false;\n\tif(b[2][1] != 10.0) elms = false;\n\tif(b[2][2] != 11.0) elms = false;\n\tif(b[2][3] != 12.0) elms = false;\n\tif(b[3][0] != 13.0) elms = false;\n\tif(b[3][1] != 14.0) elms = false;\n\tif(b[3][2] != 15.0) elms = false;\n\tif(b[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0] + b[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1] + b[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2] + b[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = b[0][3] + b[1][3] + b[2][3] + b[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2] + b[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2] + b[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2] + b[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = b[3][0] + b[3][1] + b[3][2] + b[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 3.0))
    elms = false;
  if ((b[0][3] != 4.0))
    elms = false;
  if ((b[1][0] != 5.0))
    elms = false;
  if ((b[1][1] != 6.0))
    elms = false;
  if ((b[1][2] != 7.0))
    elms = false;
  if ((b[1][3] != 8.0))
    elms = false;
  if ((b[2][0] != 9.0))
    elms = false;
  if ((b[2][1] != 10.0))
    elms = false;
  if ((b[2][2] != 11.0))
    elms = false;
  if ((b[2][3] != 12.0))
    elms = false;
  if ((b[3][0] != 13.0))
    elms = false;
  if ((b[3][1] != 14.0))
    elms = false;
  if ((b[3][2] != 15.0))
    elms = false;
  if ((b[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  vec4(+0.0, -(0.5 / (false ? -1.0 : 1.0)), ((false && (false ? true : true)) ? -1.0 : 2.0), +2.0);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.54980079681275
Processing this: /home/oof/webgl_cleaned/const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 0.5))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.698412698412696
Processing this: /home/oof/webgl_cleaned/notEqual_bvec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	vec2 result = vec2(notEqual(bvec2(c), bvec2(true)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tvec2 result = vec2(notEqual(bvec2(c), bvec2(true)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((false || (true && false)) ? 0.0 : (false ? +0.5 : +0.0)), (+2.0 + ((true && false) ? 1.0 : 1.0)), (((false ? false : true) ? false : true) ? -0.5 : 0.5), 0.5);

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  vec2 result = vec2(notEqual(bvec2(c) , bvec2(true)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex;

vec4 gtf_Color;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gtf_Color' : undeclared identifier
ERROR: 0:10: 'rg' :  field selection requires structure or vector on left hand side
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: '=' : cannot convert from 'const highp float' to 'mediump 2-component vector of float'
ERROR: 0:13: 'gtf_Vertex' : undeclared identifier
ERROR: 0:13: '=' : dimension mismatch
ERROR: 0:13: 'assign' : cannot convert from 'highp 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((false || (true && false)) ? 0.0 : (false ? +0.5 : +0.0)), (+2.0 + ((true && false) ? 1.0 : 1.0)), (((false ? false : true) ? false : true) ? -0.5 : 0.5), 0.5);

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  vec2 result = vec2(notEqual(bvec2(c) , bvec2(true)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex;

vec4 gtf_Color;


==============================
62.450592885375485
Processing this: /home/oof/webgl_cleaned/clamp_vec2_vert_xvary_yconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec2 c = gtf_Color.rg;
	color = vec4(clamp(c, min_c, max_c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(clamp(c, min_c, max_c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 2.0, (-(false ? -1.0 : 1.0) / (0.0 * 0.0)), -1.0, -1.0, (!false ? +(false ? 1.0 : 1.0) : (+2.0 + (0.5 / 0.5))), (1.0 * (-1.0 - (2.0 / 0.5))), ((!true ? (false ? false : true) : (true ? true : true)) ? 0.5 : (-0.0 / -2.0)), 1.0, 1.0, +(0.0 - (true ? 2.0 : 0.0)), (+0.5 - 2.0), ++0.0, 2.0, +0.0, 0.0);

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  color = vec4(clamp(c , min_c , max_c) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 2.0, (-(false ? -1.0 : 1.0) / (0.0 * 0.0)), -1.0, -1.0, (!false ? +(false ? 1.0 : 1.0) : (+2.0 + (0.5 / 0.5))), (1.0 * (-1.0 - (2.0 / 0.5))), ((!true ? (false ? false : true) : (true ? true : true)) ? 0.5 : (-0.0 / -2.0)), 1.0, 1.0, +(0.0 - (true ? 2.0 : 0.0)), (+0.5 - 2.0), ++0.0, 2.0, +0.0, 0.0);

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  color = vec4(clamp(c , min_c , max_c) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.20472440944882
Processing this: /home/oof/webgl_cleaned/CorrectExtension1_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
62.20472440944882
Processing this: /home/oof/webgl_cleaned/24f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec4 color[2];
void main ()
{
	gl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2] + color[0][3],
						 color[1][0] + color[1][1] + color[1][2] + color[1][3],
						 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec4 color[2];\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2] + color[0][3],\n\t\t\t\t\t\t color[1][0] + color[1][1] + color[1][2] + color[1][3],\n\t\t\t\t\t\t 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec4 color[2];

void main()
{
  gl_FragColor = vec4((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]) , (((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec4 color[2];

void main()
{
  gl_FragColor = vec4((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]) , (((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]) , 0.0);
}


==============================
61.96078431372549
Processing this: /home/oof/webgl_cleaned/CorrectParse2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;
const bool BoolConst1 = true && true || false;
const bool BoolConst2 = false || !false && false;
void main ()
{
    float float1 = 4.0, float2 = floatConst2;
    int int_1 = int(FloatConst1);
    vec4 vec4_1;
    vec3 vec3_1 = vec3(1, 1, 1);
	vec3 vec3_2 = vec3(0, 0, 0);
    bool bool4, bool5;
    bool4 = bool5;
    bool4 = 4 > 5;
    bool4 = !(3.2 != 0.0);
    bool4 = bool(float1);
    bool4 = bool(int_1);
    float1 = float(bool4);
    float1 = float(int_1);
    int_1 = int(float1);
    int_1 = int(bool4);
    {
        int a, b, c;
        a = b;
        b = c;
        {
            int b, c, d;
            b = c;
            c = d;
            {
                int a, d, e;
                a = d;
                d = e;
            }
            {
                int a, b, c;
                a = b;
                b = c;
            }
        }
        a = b;
        b = c;
    }
    {
        float f1, f2;
        vec3 v31, v32;
        max(f1, f2);
        max(v31, v32);
        vec4 v4 = vec4(3.0);
        vec3 v3 = -vec3(2.0, 1.0, 3.0);
        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);
    }
    if (BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst1 || BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2 && BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (FloatConst1 != 0.0)
        --int_1;
    else
        ++int_1;
    if (0 != 0)
        ++int_1;
    else
        --int_1;
    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);
    float1 = 5 != 0 ? float1 : float(int_1);
    float1 = BoolConst1 ? float1 : float(int_1);
    if (float1 != float1)
        ++int_1;
    else
        --int_1;
    float1 = float1 != float1 ? float1 : float(int_1);
    --int_1;
    ++float1;
    (vec4_1.x)--;
    vec3_1++;
    if (vec3_1.x > vec3_2.x)
        float1 = 4.0 + 6.0;
    if (bool4 ^^ bool5)
        float1 *= 2.4;
    if (false ^^ false)
        float1 *= 2.5;
    if (true ^^ false)
        float1 *= 2.6;
    {
        int i;
    }
    if (bool4) {
        int i;
    } else {
        int i;
        i = 5;
    }
    mat4 m1;
    m1[2][1] = 4.0;
    gl_Position = vec4(float1+float1, float1, float1, float(int_1));
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nconst float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;\nconst bool BoolConst1 = true && true || false;\nconst bool BoolConst2 = false || !false && false;\nvoid main ()\n{\n    float float1 = 4.0, float2 = floatConst2;\n    int int_1 = int(FloatConst1);\n    vec4 vec4_1;\n    vec3 vec3_1 = vec3(1, 1, 1);\n\tvec3 vec3_2 = vec3(0, 0, 0);\n    bool bool4, bool5;\n    bool4 = bool5;\n    bool4 = 4 > 5;\n    bool4 = !(3.2 != 0.0);\n    bool4 = bool(float1);\n    bool4 = bool(int_1);\n    float1 = float(bool4);\n    float1 = float(int_1);\n    int_1 = int(float1);\n    int_1 = int(bool4);\n    {\n        int a, b, c;\n        a = b;\n        b = c;\n        {\n            int b, c, d;\n            b = c;\n            c = d;\n            {\n                int a, d, e;\n                a = d;\n                d = e;\n            }\n            {\n                int a, b, c;\n                a = b;\n                b = c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n    {\n        float f1, f2;\n        vec3 v31, v32;\n        max(f1, f2);\n        max(v31, v32);\n        vec4 v4 = vec4(3.0);\n        vec3 v3 = -vec3(2.0, 1.0, 3.0);\n        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);\n    }\n    if (BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst1 || BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2 && BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (FloatConst1 != 0.0)\n        --int_1;\n    else\n        ++int_1;\n    if (0 != 0)\n        ++int_1;\n    else\n        --int_1;\n    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);\n    float1 = 5 != 0 ? float1 : float(int_1);\n    float1 = BoolConst1 ? float1 : float(int_1);\n    if (float1 != float1)\n        ++int_1;\n    else\n        --int_1;\n    float1 = float1 != float1 ? float1 : float(int_1);\n    --int_1;\n    ++float1;\n    (vec4_1.x)--;\n    vec3_1++;\n    if (vec3_1.x > vec3_2.x)\n        float1 = 4.0 + 6.0;\n    if (bool4 ^^ bool5)\n        float1 *= 2.4;\n    if (false ^^ false)\n        float1 *= 2.5;\n    if (true ^^ false)\n        float1 *= 2.6;\n    {\n        int i;\n    }\n    if (bool4) {\n        int i;\n    } else {\n        int i;\n        i = 5;\n    }\n    mat4 m1;\n    m1[2][1] = 4.0;\n    gl_Position = vec4(float1+float1, float1, float1, float(int_1));\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = (3.0 * 8.0);

const bool BoolConst1 = ((true && true) || false);

const bool BoolConst2 = (false || (!false && false));

void main()
{
  float float1 = 4.0 , float2 = floatConst2;
  int int_1 = int(FloatConst1);
  vec4 vec4_1;
  vec3 vec3_1 = vec3(1 , 1 , 1);
  vec3 vec3_2 = vec3(0 , 0 , 0);
  bool bool4, bool5;
  bool4 = bool5;
  bool4 = (4 > 5);
  bool4 = !(3.2 != 0.0);
  bool4 = bool(float1);
  bool4 = bool(int_1);
  float1 = float(bool4);
  float1 = float(int_1);
  int_1 = int(float1);
  int_1 = int(bool4);
  {
    int a, b, c;
    a = b;
    b = c;
    {
      int b, c, d;
      b = c;
      c = d;
      {
        int a, d, e;
        a = d;
        d = e;
      }
      {
        int a, b, c;
        a = b;
        b = c;
      }
    }
    a = b;
    b = c;
  }
  {
    float f1, f2;
    vec3 v31, v32;
    max(f1 , f2);
    max(v31 , v32);
    vec4 v4 = vec4(3.0);
    vec3 v3 = -vec3(2.0 , 1.0 , 3.0);
    mat2 m2 = mat2(3.0 , 4.0 , 6.0 , 3.0);
  }
  if (BoolConst1)
    ++vec3_1;
  else
    --vec3_1;
  if (BoolConst2)
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst1 || BoolConst2))
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst2 && BoolConst1))
    ++vec3_1;
  else
    --vec3_1;
  if ((FloatConst1 != 0.0))
    --int_1;
  else
    ++int_1;
  if ((0 != 0))
    ++int_1;
  else
    --int_1;
  bool4 = (((((BoolConst1 && !(int_1 != 0)) && !BoolConst1) && !(FloatConst1 != 0.0)) && (FloatConst1 != 0.0)) && (float1 != 0.0));
  (float1 = (5 != 0) ? float1 : float(int_1));
  (float1 = BoolConst1 ? float1 : float(int_1));
  if ((float1 != float1))
    ++int_1;
  else
    --int_1;
  (float1 = (float1 != float1) ? float1 : float(int_1));
  --int_1;
  ++float1;
  vec4_1.x--;
  vec3_1++;
  if ((vec3_1.x > vec3_2.x))
    float1 = (4.0 + 6.0);
  if ((bool4 ^^ bool5))
    (float1 *= 2.4);
  if ((false ^^ false))
    (float1 *= 2.5);
  if ((true ^^ false))
    (float1 *= 2.6);
  {
    int i;
  }
  if (bool4)
  {
    int i;
  }
  else
  {
    int i;
    i = 5;
  }
  mat4 m1;
  m1[2][1] = 4.0;
  gl_Position = vec4((float1 + float1) , float1 , float1 , float(int_1));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'floatConst2' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

const float FloatConst1 = (3.0 * 8.0);

const bool BoolConst1 = ((true && true) || false);

const bool BoolConst2 = (false || (!false && false));

void main()
{
  float float1 = 4.0 , float2 = floatConst2;
  int int_1 = int(FloatConst1);
  vec4 vec4_1;
  vec3 vec3_1 = vec3(1 , 1 , 1);
  vec3 vec3_2 = vec3(0 , 0 , 0);
  bool bool4, bool5;
  bool4 = bool5;
  bool4 = (4 > 5);
  bool4 = !(3.2 != 0.0);
  bool4 = bool(float1);
  bool4 = bool(int_1);
  float1 = float(bool4);
  float1 = float(int_1);
  int_1 = int(float1);
  int_1 = int(bool4);
  {
    int a, b, c;
    a = b;
    b = c;
    {
      int b, c, d;
      b = c;
      c = d;
      {
        int a, d, e;
        a = d;
        d = e;
      }
      {
        int a, b, c;
        a = b;
        b = c;
      }
    }
    a = b;
    b = c;
  }
  {
    float f1, f2;
    vec3 v31, v32;
    max(f1 , f2);
    max(v31 , v32);
    vec4 v4 = vec4(3.0);
    vec3 v3 = -vec3(2.0 , 1.0 , 3.0);
    mat2 m2 = mat2(3.0 , 4.0 , 6.0 , 3.0);
  }
  if (BoolConst1)
    ++vec3_1;
  else
    --vec3_1;
  if (BoolConst2)
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst1 || BoolConst2))
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst2 && BoolConst1))
    ++vec3_1;
  else
    --vec3_1;
  if ((FloatConst1 != 0.0))
    --int_1;
  else
    ++int_1;
  if ((0 != 0))
    ++int_1;
  else
    --int_1;
  bool4 = (((((BoolConst1 && !(int_1 != 0)) && !BoolConst1) && !(FloatConst1 != 0.0)) && (FloatConst1 != 0.0)) && (float1 != 0.0));
  (float1 = (5 != 0) ? float1 : float(int_1));
  (float1 = BoolConst1 ? float1 : float(int_1));
  if ((float1 != float1))
    ++int_1;
  else
    --int_1;
  (float1 = (float1 != float1) ? float1 : float(int_1));
  --int_1;
  ++float1;
  vec4_1.x--;
  vec3_1++;
  if ((vec3_1.x > vec3_2.x))
    float1 = (4.0 + 6.0);
  if ((bool4 ^^ bool5))
    (float1 *= 2.4);
  if ((false ^^ false))
    (float1 *= 2.5);
  if ((true ^^ false))
    (float1 *= 2.6);
  {
    int i;
  }
  if (bool4)
  {
    int i;
  }
  else
  {
    int i;
    i = 5;
  }
  mat4 m1;
  m1[2][1] = 4.0;
  gl_Position = vec4((float1 + float1) , float1 , float1 , float(int_1));
}


==============================
61.71875
Processing this: /home/oof/webgl_cleaned/boolUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform bool bval;
uniform bvec2 bval2;
uniform bvec3 bval3;
uniform bvec4 bval4;
void main()
{
    bool allSet = bval
            && bval2[0] && bval2[1]
            && bval3[0] && bval3[1] && bval3[2]
            && bval4[0] && bval4[1] && bval4[2] && bval4[3];
    gl_Position = vec4((allSet ? 1.0 : -1.0), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform bool bval;\nuniform bvec2 bval2;\nuniform bvec3 bval3;\nuniform bvec4 bval4;\nvoid main()\n{\n    bool allSet = bval\n            && bval2[0] && bval2[1]\n            && bval3[0] && bval3[1] && bval3[2]\n            && bval4[0] && bval4[1] && bval4[2] && bval4[3];\n    gl_Position = vec4((allSet ? 1.0 : -1.0), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bool bval;

uniform bvec2 bval2;

uniform bvec3 bval3 = bvec3((true ? ((true ? 1.0 : 2.0) * (true ? 0.5 : 1.0)) : -1.0), -1.0, -1.0);

uniform bvec4 bval4;

void main()
{
  bool allSet = (((((((((bval && bval2[0]) && bval2[1]) && bval3[0]) && bval3[1]) && bval3[2]) && bval4[0]) && bval4[1]) && bval4[2]) && bval4[3]);
  gl_Position = vec4((allSet ? 1.0 : -1.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bool bval;

uniform bvec2 bval2;

uniform bvec3 bval3 = bvec3((true ? ((true ? 1.0 : 2.0) * (true ? 0.5 : 1.0)) : -1.0), -1.0, -1.0);

uniform bvec4 bval4;

void main()
{
  bool allSet = (((((((((bval && bval2[0]) && bval2[1]) && bval3[0]) && bval3[1]) && bval3[2]) && bval4[0]) && bval4[1]) && bval4[2]) && bval4[3]);
  gl_Position = vec4((allSet ? 1.0 : -1.0) , 0.0 , 0.0 , 1.0);
}


==============================
61.478599221789885
Processing this: /home/oof/webgl_cleaned/structnest_mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	mat4 b;
};
struct nesta
{
	mat4 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat4(11, 13, 29, 33, 63, 13, 49, 57, 71, 47, 91, 101, 167, 21, 39, 41), nestb( mat4(12, 19, 79, 81, 35, 51, 73, 66, 23, 134, 121, 156, 76, 23, 24, 78) ) ) );
	float sum1=0.0,sum2=0.0;
	sum1 = sum1 + s.nest_a.a[0][0];
	sum2 = sum2 + s.nest_a.nest_b.b[0][0];
	sum1 = sum1 + s.nest_a.a[0][1];
	sum2 = sum2 + s.nest_a.nest_b.b[0][1];
	sum1 = sum1 + s.nest_a.a[0][2];
	sum2 = sum2 + s.nest_a.nest_b.b[0][2];
	sum1 = sum1 + s.nest_a.a[0][3];
	sum2 = sum2 + s.nest_a.nest_b.b[0][3];
	sum1 = sum1 + s.nest_a.a[1][0];
	sum2 = sum2 + s.nest_a.nest_b.b[1][0];
	sum1 = sum1 + s.nest_a.a[1][1];
	sum2 = sum2 + s.nest_a.nest_b.b[1][1];
	sum1 = sum1 + s.nest_a.a[1][2];
	sum2 = sum2 + s.nest_a.nest_b.b[1][2];
	sum1 = sum1 + s.nest_a.a[1][3];
	sum2 = sum2 + s.nest_a.nest_b.b[1][3];
	sum1 = sum1 + s.nest_a.a[2][0];
	sum2 = sum2 + s.nest_a.nest_b.b[2][0];
	sum1 = sum1 + s.nest_a.a[2][1];
	sum2 = sum2 + s.nest_a.nest_b.b[2][1];
	sum1 = sum1 + s.nest_a.a[2][2];
	sum2 = sum2 + s.nest_a.nest_b.b[2][2];
	sum1 = sum1 + s.nest_a.a[2][3];
	sum2 = sum2 + s.nest_a.nest_b.b[2][3];
	sum1 = sum1 + s.nest_a.a[3][0];
	sum2 = sum2 + s.nest_a.nest_b.b[3][0];
	sum1 = sum1 + s.nest_a.a[3][1];
	sum2 = sum2 + s.nest_a.nest_b.b[3][1];
	sum1 = sum1 + s.nest_a.a[3][2];
	sum2 = sum2 + s.nest_a.nest_b.b[3][2];
	sum1 = sum1 + s.nest_a.a[3][3];
	sum2 = sum2 + s.nest_a.nest_b.b[3][3];
	color = vec4( vec3( ( sum1 + sum2 )/ 1897.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tmat4 b;\n};\nstruct nesta\n{\n\tmat4 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat4(11, 13, 29, 33, 63, 13, 49, 57, 71, 47, 91, 101, 167, 21, 39, 41), nestb( mat4(12, 19, 79, 81, 35, 51, 73, 66, 23, 134, 121, 156, 76, 23, 24, 78) ) ) );\n\tfloat sum1=0.0,sum2=0.0;\n\tsum1 = sum1 + s.nest_a.a[0][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][0];\n\tsum1 = sum1 + s.nest_a.a[0][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][1];\n\tsum1 = sum1 + s.nest_a.a[0][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][2];\n\tsum1 = sum1 + s.nest_a.a[0][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][3];\n\tsum1 = sum1 + s.nest_a.a[1][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][0];\n\tsum1 = sum1 + s.nest_a.a[1][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][1];\n\tsum1 = sum1 + s.nest_a.a[1][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][2];\n\tsum1 = sum1 + s.nest_a.a[1][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][3];\n\tsum1 = sum1 + s.nest_a.a[2][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][0];\n\tsum1 = sum1 + s.nest_a.a[2][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][1];\n\tsum1 = sum1 + s.nest_a.a[2][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][2];\n\tsum1 = sum1 + s.nest_a.a[2][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][3];\n\tsum1 = sum1 + s.nest_a.a[3][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][0];\n\tsum1 = sum1 + s.nest_a.a[3][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][1];\n\tsum1 = sum1 + s.nest_a.a[3][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][2];\n\tsum1 = sum1 + s.nest_a.a[3][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][3];\n\tcolor = vec4( vec3( ( sum1 + sum2 )/ 1897.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  mat4 b;
};

struct nesta {
  mat4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat4(11 , 13 , 29 , 33 , 63 , 13 , 49 , 57 , 71 , 47 , 91 , 101 , 167 , 21 , 39 , 41) , nestb(mat4(12 , 19 , 79 , 81 , 35 , 51 , 73 , 66 , 23 , 134 , 121 , 156 , 76 , 23 , 24 , 78))));
  float sum1 = 0.0 , sum2 = 0.0;
  sum1 = (sum1 + s.nest_a.a[0][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][0]);
  sum1 = (sum1 + s.nest_a.a[0][1]);
  gtf_Vertex = (gtf_ModelViewProjectionMatrix + s.nest_a.nest_b.b[-4][1]);
  sum1 = (sum1 + s.nest_a.a[0][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][2]);
  sum1 = (sum1 + s.nest_a.a[0][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][3]);
  sum1 = (sum1 + s.nest_a.a[1][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][0]);
  sum1 = (sum1 + s.nest_a.a[1][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][1]);
  sum1 = (sum1 + s.nest_a.a[1][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][2]);
  sum1 = (sum1 + s.nest_a.a[1][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][3]);
  sum1 = (sum1 + s.nest_a.a[2][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][0]);
  sum1 = (sum1 + s.nest_a.a[2][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][1]);
  sum1 = (sum1 + s.nest_a.a[2][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][2]);
  sum1 = (sum1 + s.nest_a.a[2][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][3]);
  sum1 = (sum1 + s.nest_a.a[3][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][0]);
  sum1 = (sum1 + s.nest_a.a[3][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][1]);
  sum1 = (sum1 + s.nest_a.a[3][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][2]);
  sum1 = (sum1 + s.nest_a.a[3][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][3]);
  color = vec4(vec3(((sum1 + sum2) / 1897.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:30: '[]' : index expression is negative
ERROR: 0:30: '=' : dimension mismatch
ERROR: 0:30: 'assign' : cannot convert from 'mediump 4X4 matrix of float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  mat4 b;
};

struct nesta {
  mat4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat4(11 , 13 , 29 , 33 , 63 , 13 , 49 , 57 , 71 , 47 , 91 , 101 , 167 , 21 , 39 , 41) , nestb(mat4(12 , 19 , 79 , 81 , 35 , 51 , 73 , 66 , 23 , 134 , 121 , 156 , 76 , 23 , 24 , 78))));
  float sum1 = 0.0 , sum2 = 0.0;
  sum1 = (sum1 + s.nest_a.a[0][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][0]);
  sum1 = (sum1 + s.nest_a.a[0][1]);
  gtf_Vertex = (gtf_ModelViewProjectionMatrix + s.nest_a.nest_b.b[-4][1]);
  sum1 = (sum1 + s.nest_a.a[0][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][2]);
  sum1 = (sum1 + s.nest_a.a[0][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][3]);
  sum1 = (sum1 + s.nest_a.a[1][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][0]);
  sum1 = (sum1 + s.nest_a.a[1][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][1]);
  sum1 = (sum1 + s.nest_a.a[1][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][2]);
  sum1 = (sum1 + s.nest_a.a[1][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][3]);
  sum1 = (sum1 + s.nest_a.a[2][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][0]);
  sum1 = (sum1 + s.nest_a.a[2][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][1]);
  sum1 = (sum1 + s.nest_a.a[2][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][2]);
  sum1 = (sum1 + s.nest_a.a[2][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][3]);
  sum1 = (sum1 + s.nest_a.a[3][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][0]);
  sum1 = (sum1 + s.nest_a.a[3][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][1]);
  sum1 = (sum1 + s.nest_a.a[3][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][2]);
  sum1 = (sum1 + s.nest_a.a[3][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][3]);
  color = vec4(vec3(((sum1 + sum2) / 1897.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.240310077519375
Mutations attempted: 258
Valid mutations:     158
Success rate:        61.24%
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 4.0 * 2.0 * (color.rgb - 0.5);
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	if(c[0] < 0.0)
	{
		sign[0] = -1.0;
		c[0] *= -1.0;
	}
	if(c[0] <= 1.0)
	{
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * atan_c[0] / M_PI + 0.5;
	}
	else
	{
		c[0] = 1.0 / c[0];
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;
	}
	if(c[1] < 0.0)
	{
		sign[1] = -1.0;
		c[1] *= -1.0;
	}
	if(c[1] <= 1.0)
	{
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * atan_c[1] / M_PI + 0.5;
	}
	else
	{
		c[1] = 1.0 / c[1];
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;
	}
	if(c[2] < 0.0)
	{
		sign[2] = -1.0;
		c[2] *= -1.0;
	}
	if(c[2] <= 1.0)
	{
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * atan_c[2] / M_PI + 0.5;
	}
	else
	{
		c[2] = 1.0 / c[2];
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 4.0 * 2.0 * (color.rgb - 0.5);\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(c[0] < 0.0)\n\t{\n\t\tsign[0] = -1.0;\n\t\tc[0] *= -1.0;\n\t}\n\tif(c[0] <= 1.0)\n\t{\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * atan_c[0] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[0] = 1.0 / c[0];\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;\n\t}\n\tif(c[1] < 0.0)\n\t{\n\t\tsign[1] = -1.0;\n\t\tc[1] *= -1.0;\n\t}\n\tif(c[1] <= 1.0)\n\t{\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * atan_c[1] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[1] = 1.0 / c[1];\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;\n\t}\n\tif(c[2] < 0.0)\n\t{\n\t\tsign[2] = -1.0;\n\t\tc[2] *= -1.0;\n\t}\n\tif(c[2] <= 1.0)\n\t{\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * atan_c[2] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[2] = 1.0 / c[2];\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (--2.0 / ((true ? 2.0 : 0.5) * 0.0)), (1.0 * 0.5), +((false ? 1.0 : 2.0) + 0.5));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (--2.0 / ((true ? 2.0 : 0.5) * 0.0)), (1.0 * 0.5), +((false ? 1.0 : 2.0) + 0.5));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


==============================
61.003861003861005
Processing this: /home/oof/webgl_cleaned/all_bvec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool _all(in bvec2 a)
{
	bool temp = true;
	if(!a[0]) temp = false;
	if(!a[1]) temp = false;
	return temp;
}
void main ()
{
	vec2 c = floor(4.0 * gtf_Color.rg);
	color = vec4(vec3(_all(bvec2(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool _all(in bvec2 a)\n{\n\tbool temp = true;\n\tif(!a[0]) temp = false;\n\tif(!a[1]) temp = false;\n\treturn temp;\n}\nvoid main ()\n{\n\tvec2 c = floor(4.0 * gtf_Color.rg);\n\tcolor = vec4(vec3(_all(bvec2(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bool _all(in bvec2 a)
{
  bool temp = true;
  if (!a[-1])
    temp = false;
  if (!a[1])
    temp = false;
  return temp;
}

void main()
{
  vec2 c = floor((4.0 * gtf_Color.rg));
  color = vec4(vec3(_all(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: '[]' : index expression is negative

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bool _all(in bvec2 a)
{
  bool temp = true;
  if (!a[-1])
    temp = false;
  if (!a[1])
    temp = false;
  return temp;
}

void main()
{
  vec2 c = floor((4.0 * gtf_Color.rg));
  color = vec4(vec3(_all(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.76923076923077
Processing this: /home/oof/webgl_cleaned/brick.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec3 gtf_Normal;
attribute vec4 gtf_Vertex;
uniform mat3 gtf_NormalMatrix;
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying float lightIntensity;
varying vec3  Position;
uniform vec3  LightPosition;
uniform vec3  NotActiveOne;
attribute float myAttribute1;
attribute vec3 myAttribute2;
const float specularContribution = 0.7;
const float diffuseContribution  = (1.0 - specularContribution);
void main() {
    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;
    Position        = vec3(gtf_Vertex);
    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);
    vec3 lightVec   = normalize(LightPosition - vec3(pos));
    vec3 reflectVec = reflect(lightVec, tnorm);
    vec3 viewVec    = normalize(vec3(pos));
	float spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +
                     specularContribution * spec;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec3 gtf_Normal;\nattribute vec4 gtf_Vertex;\nuniform mat3 gtf_NormalMatrix;\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying float lightIntensity;\nvarying vec3  Position;\nuniform vec3  LightPosition;\nuniform vec3  NotActiveOne;\nattribute float myAttribute1;\nattribute vec3 myAttribute2;\nconst float specularContribution = 0.7;\nconst float diffuseContribution  = (1.0 - specularContribution);\nvoid main() {\n    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;\n    Position        = vec3(gtf_Vertex);\n    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);\n    vec3 lightVec   = normalize(LightPosition - vec3(pos));\n    vec3 reflectVec = reflect(lightVec, tnorm);\n    vec3 viewVec    = normalize(vec3(pos));\n\tfloat spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +\n                     specularContribution * spec;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity;

vec3 Position = vec3((true ? ((true || false) ? 2.0 : (diffuseContribution - 0.5)) : -myAttribute1), 2.0, 0.5);

uniform vec3 LightPosition;

uniform vec3 NotActiveOne;

float myAttribute1;

vec3 myAttribute2;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float spec = clamp(dot(reflectVec , viewVec) , myAttribute1 , myAttribute2[1]);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'diffuseContribution' : undeclared identifier
ERROR: 0:16: 'myAttribute1' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity;

vec3 Position = vec3((true ? ((true || false) ? 2.0 : (diffuseContribution - 0.5)) : -myAttribute1), 2.0, 0.5);

uniform vec3 LightPosition;

uniform vec3 NotActiveOne;

float myAttribute1;

vec3 myAttribute2;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float spec = clamp(dot(reflectVec , viewVec) , myAttribute1 , myAttribute2[1]);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.53639846743295
Processing this: /home/oof/webgl_cleaned/min_vec2_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = gtf_Color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = gtf_Color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = gtf_Color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  color = vec4(c , 0.0 , 1.0);
  gtf_Color = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.68702290076335
Processing this: /home/oof/webgl_cleaned/for_nested_break_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count1 = 0, count2 = 0;
        for(int i=0;i<4;i++)
	{
	  count1++;
	  count2 = 0;
	  for(int j=0;j<4;j++)
	  {
	     count2++;
	     if(count2 == 3)
		break;
	  }
	  if(count1 == 2)
            break;
	}
	float gray;
	if( (count1 == 2) && (count2 == 3))
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint count1 = 0, count2 = 0;\n        for(int i=0;i<4;i++)\n\t{\n\t  count1++;\n\t  count2 = 0;\n\t  for(int j=0;j<4;j++)\n\t  {\n\t     count2++;\n\t     if(count2 == 3)\n\t\tbreak;\n\t  }\n\t  if(count1 == 2)\n            break;\n\t}\n\tfloat gray;\n\tif( (count1 == 2) && (count2 == 3))\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? ((true ? false : false) ? (true ? 0.5 : -1.0) : (-1.0 - -1.0)) : 1.0), (false ? +(true ? 0.5 : 0.0) : (0.0 + -1.0)), -0.5, -1.0);

void main()
{
  int count1 = 0 , count2 = 0;
  for (int i = 0; (i < 4); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 4); j++)
    {
      count2++;
      if ((count2 == 3))
        break;
    }
    if ((count1 == 2))
      break;
  }
  float gray;
  if (((count1 == 2) && (count2 == 3)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.836501901140686
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec2 gte(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(gte(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec2 gte(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(gte(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 gte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(gte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec2 gte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(gte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


==============================
60.60606060606061
Processing this: /home/oof/webgl_cleaned/floatUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform float fval;
uniform vec2 fval2;
uniform vec3 fval3;
uniform vec4 fval4;
void main()
{
    float sum = fval
            + fval2[0] + fval2[1]
            + fval3[0] + fval3[1] + fval3[2]
            + fval4[0] + fval4[1] + fval4[2] + fval4[3];
    gl_Position = vec4(sum, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform float fval;\nuniform vec2 fval2;\nuniform vec3 fval3;\nuniform vec4 fval4;\nvoid main()\n{\n    float sum = fval\n            + fval2[0] + fval2[1]\n            + fval3[0] + fval3[1] + fval3[2]\n            + fval4[0] + fval4[1] + fval4[2] + fval4[3];\n    gl_Position = vec4(sum, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float fval;

uniform vec2 fval2;

uniform vec3 fval3 = vec3(-(-1.0 / (false ? 0.0 : 0.5)), 0.5, 0.5);

uniform vec4 fval4;

void main()
{
  float sum = (((((((((fval + fval2[0]) + fval2[1]) + fval3[0]) + fval3[1]) + fval3[2]) + fval4[0]) + fval4[1]) + fval4[2]) + fval4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float fval;

uniform vec2 fval2;

uniform vec3 fval3 = vec3(-(-1.0 / (false ? 0.0 : 0.5)), 0.5, 0.5);

uniform vec4 fval4;

void main()
{
  float sum = (((((((((fval + fval2[0]) + fval2[1]) + fval3[0]) + fval3[1]) + fval3[2]) + fval4[0]) + fval4[1]) + fval4[2]) + fval4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


==============================
60.37735849056604
Processing this: /home/oof/webgl_cleaned/bvec4_empty_in_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(in bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(in bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(in bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(in bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.37735849056604
Processing this: /home/oof/webgl_cleaned/step_vec2_vert_xvary_edgeconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 edge = vec2(0.5, 0.5);
	color = vec4(step(edge, gtf_Color.rg), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge = vec2(0.5, 0.5);\n\tcolor = vec4(step(edge, gtf_Color.rg), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge = vec2(0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rg) , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge = vec2(0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rg) , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.150375939849624
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
mat4 function(in mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(in mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nmat4 function(in mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(in mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.150375939849624
Mutations attempted: 266
Valid mutations:     160
Success rate:        60.15%
Processing this: /home/oof/webgl_cleaned/vec4_xy_zw_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.xy;
	vec2 n = lightloc.zw;
	vec4 a = vec4(m,n);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.xy;\n\tvec2 n = lightloc.zw;\n\tvec4 a = vec4(m,n);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, +0.0, 0.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.xy;
  vec2 n = lightloc.zw;
  vec4 a = vec4(m , n);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
60.2996254681648
Processing this: /home/oof/webgl_cleaned/buffer_objects_multitexturing.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
attribute vec4 gtf_MultiTexCoord1;
varying vec4 color;
varying vec4 gtf_TexCoord[2];
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gtf_TexCoord[1] = gtf_MultiTexCoord1;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nattribute vec4 gtf_MultiTexCoord1;\nvarying vec4 color;\nvarying vec4 gtf_TexCoord[2];\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgtf_TexCoord[1] = gtf_MultiTexCoord1;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color = vec4(-1.0, 0.5, (+(true ? 2.0 : -1.0) + 2.0), (2.0 * -2.0));

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 gtf_MultiTexCoord1;

vec4 color;

vec4 gtf_TexCoord[2];

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gtf_TexCoord[1] = gtf_MultiTexCoord1;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.447761194029844
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = (false ? -1.0 : 1.0)(greaterThan(ivec2(c)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: '=' : dimension mismatch
ERROR: 0:15: '=' : cannot convert from 'const float' to 'mediump 2-component vector of float'
ERROR: 0:15: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = (false ? -1.0 : 1.0)(greaterThan(ivec2(c)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.223048327137555
Processing this: /home/oof/webgl_cleaned/equal_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 eq(in bvec3 a, in bvec3 b)
{
	bvec3 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] == b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	vec3 result = vec3(eq(bvec3(c), bvec3(true)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 eq(in bvec3 a, in bvec3 b)\n{\n\tbvec3 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] == b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tvec3 result = vec3(eq(bvec3(c), bvec3(true)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 eq(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  vec3 result = vec3(eq(bvec3(c)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:33: 'eq' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 eq(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  vec3 result = vec3(eq(bvec3(c)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/vec2_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 b = vec3(13.0, 53.0, 139.0);
	vec2 a = vec2(b);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 b = vec3(13.0, 53.0, 139.0);\n\tvec2 a = vec2(b);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, (!true ? ((true ? false : false) ? (2.0 + 0.0) : 0.5) : 1.0), 0.5, 0.0);

void main()
{
  vec3 b = vec3(13.0 , 53.0 , 139.0);
  vec2 a = vec2(b);
  float gray;
  if (((a[0] == 13.0) && (a[1] == 53.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.147601476014756
Processing this: /home/oof/webgl_cleaned/bvec4_empty_out_bvec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(out bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, false) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(out bvec4 par)
{
	set_all(par, false);
	return bvec4(true, true, true, true);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(out bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, false) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(out bvec4 par)\n{\n\tset_all(par, false);\n\treturn bvec4(true, true, true, true);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
60.147601476014756
Processing this: /home/oof/webgl_cleaned/array_const_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
		             5.0,  6.0,  7.0,  8.0,
			     9.0, 10.0, 11.0, 12.0,
			    13.0, 14.0, 15.0, 16.0);
	const mat4 b = mat4(17.0, 18.0, 19.0, 20.0,
		            21.0, 22.0, 23.0, 24.0,
			    25.0, 26.0, 27.0, 28.0,
			    29.0, 30.0, 31.0, 32.0);
	mat4 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t\t             5.0,  6.0,  7.0,  8.0,\n\t\t\t     9.0, 10.0, 11.0, 12.0,\n\t\t\t    13.0, 14.0, 15.0, 16.0);\n\tconst mat4 b = mat4(17.0, 18.0, 19.0, 20.0,\n\t\t            21.0, 22.0, 23.0, 24.0,\n\t\t\t    25.0, 26.0, 27.0, 28.0,\n\t\t\t    29.0, 30.0, 31.0, 32.0);\n\tmat4 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.29411764705882
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * gtf_Color.rg;
	color = vec4(c / 100.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * gtf_Color.rg;\n\tcolor = vec4(c / 100.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, 1.0, -0.5, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (100.0 * gtf_Color.rg);
  color = vec4((c / 100.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.43956043956044
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lessThan(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lessThan(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 0.5, ((0.5 - 0.0) + (true ? 0.0 : (2.0 / 1.0))), 1.0);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lessThan(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.58394160583942
Processing this: /home/oof/webgl_cleaned/vec2_2float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 a = vec2(13.0,53.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 a = vec2(13.0,53.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false ? (1.0 - 2.0) : -1.0) - (-0.5 - -1.0)), (!(true || true) ? 0.0 : (false ? (false ? 0.5 : 1.0) : (0.0 - 1.0))), ((+-1.0 * -2.0) - (0.0 + -1.0)), 0.0);

void main()
{
  vec2 a = vec2(13.0 , 53.0);
  float gray;
  if (((a[0] == 13.0) && (a[1] == 53.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.72727272727273
Mutations attempted: 275
Valid mutations:     167
Success rate:        60.73%
Processing this: /home/oof/webgl_cleaned/cos_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * cos(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * cos(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((-1.0 - 0.5) * 0.5) + 1.0), 0.5, (((true && true) ? true : true) ? 0.0 : ((true && false) ? 0.5 : -0.5)), +0.0);

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * cos(((2.0 * M_PI) * color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.86956521739131
Processing this: /home/oof/webgl_cleaned/float_empty_out_float_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(out float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(out float par[3])
{
	set_all(par, 0.0);
	return 1.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(out float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(out float par[3])\n{\n\tset_all(par, 0.0);\n\treturn 1.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.86956521739131
Processing this: /home/oof/webgl_cleaned/structnest_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct nestb
{
	vec4 b;
};
struct nesta
{
	vec4 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec4(11, 13, 17, 31), nestb(vec4(12, 19, 29, 69) ) ) );
	gl_FragColor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.a[3] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2] + s.nest_a.nest_b.b[3]) / 201.0 ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct nestb\n{\n\tvec4 b;\n};\nstruct nesta\n{\n\tvec4 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec4(11, 13, 17, 31), nestb(vec4(12, 19, 29, 69) ) ) );\n\tgl_FragColor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.a[3] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2] + s.nest_a.nest_b.b[3]) / 201.0 ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nestb {
  vec4 b;
};

struct nesta {
  vec4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec4(11 , 13 , 17 , 31) , nestb(vec4(12 , 19 , 29 , 69))));
  gl_FragColor = vec4(vec3(((((((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.a[2]) + s.nest_a.a[3]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) + s.nest_a.nest_b.b[2]) + s.nest_a.nest_b.b[3]) / 201.0)) , 1.0);
}


As vertex? : False
SUCCESS!
61.01083032490975
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	color = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tcolor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.79136690647482
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.93189964157706
Processing this: /home/oof/webgl_cleaned/pow_vec3_vert_xconsthalf_yvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = -2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (gtf_Color.rgb - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (gtf_Color.rgb - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.71428571428571
Processing this: /home/oof/webgl_cleaned/float_empty_inout_float_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(inout float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(inout float par[3])
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return 1.0;
	}
	else
		return 0.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(inout float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(inout float par[3])\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.71428571428571
Processing this: /home/oof/webgl_cleaned/exp2_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = gtf_Color.rgb;
	color = vec4(pow(vec3(2.0), 5.0 * c) / 32.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(pow(vec3(2.0), 5.0 * c) / 32.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.5, -1.0, 0.5, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = gtf_Color.rgb;
  color = vec4((pow(vec3(2.0) , (5.0 * c)) / 32.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.854092526690394
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(out vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(out vec4 par[3])
{
	set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(out vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(out vec4 par[3])\n{\n\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.854092526690394
Processing this: /home/oof/webgl_cleaned/tan_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 0.5 * M_PI * 2.0 * (color.rgb - 0.5);
	vec3 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;
	else
		o.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;
	else
		o.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;
	if(abs(c.b) < 0.5)
		o.b = 0.5 * (sin(c.b) / cos(c.b)) + 0.5;
	else
		o.b = 0.5 * (cos(c.b) / sin(c.b)) + 0.5;
	gl_FragColor = vec4(o, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 0.5 * M_PI * 2.0 * (color.rgb - 0.5);\n\tvec3 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;\n\telse\n\t\to.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;\n\telse\n\t\to.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;\n\tif(abs(c.b) < 0.5)\n\t\to.b = 0.5 * (sin(c.b) / cos(c.b)) + 0.5;\n\telse\n\t\to.b = 0.5 * (cos(c.b) / sin(c.b)) + 0.5;\n\tgl_FragColor = vec4(o, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * (sin(c.r) / cos(c.r))) + 0.5);
  else
    o.r = ((0.5 * (cos(c.r) / sin(c.r))) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * (sin(c.g) / cos(c.g))) + 0.5);
  else
    o.g = ((0.5 * (cos(c.g) / sin(c.g))) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * (sin(c.b) / cos(c.b))) + 0.5);
  else
    o.b = ((0.5 * (cos(c.b) / sin(c.b))) + 0.5);
  gl_FragColor = vec4(o);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:23: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * (sin(c.r) / cos(c.r))) + 0.5);
  else
    o.r = ((0.5 * (cos(c.r) / sin(c.r))) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * (sin(c.g) / cos(c.g))) + 0.5);
  else
    o.g = ((0.5 * (cos(c.g) / sin(c.g))) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * (sin(c.b) / cos(c.b))) + 0.5);
  else
    o.b = ((0.5 * (cos(c.b) / sin(c.b))) + 0.5);
  gl_FragColor = vec4(o);
}


==============================
60.63829787234043
Mutations attempted: 282
Valid mutations:     171
Success rate:        60.64%
Processing this: /home/oof/webgl_cleaned/all_bvec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(4.0 * color.rgb);
	gl_FragColor = vec4(vec3(all(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(4.0 * color.rgb);\n\tgl_FragColor = vec4(vec3(all(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((+2.0 / (+1.0 - 2.0)), 1.0, (!true ? 2.0 : (1.0 - -0.0)), -1.0);

void main()
{
  vec3 c = floor((4.0 * color.rgb));
  gl_FragColor = vec4(vec3(all(bvec3(c))) , 1.0);
}


As vertex? : False
SUCCESS!
60.7773851590106
Processing this: /home/oof/webgl_cleaned/const_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	bool elms = true;
	if(a[0][0] !=  1.0) elms = false;
	if(a[0][1] !=  2.0) elms = false;
	if(a[0][2] !=  3.0) elms = false;
	if(a[0][3] !=  4.0) elms = false;
	if(a[1][0] !=  5.0) elms = false;
	if(a[1][1] !=  6.0) elms = false;
	if(a[1][2] !=  7.0) elms = false;
	if(a[1][3] !=  8.0) elms = false;
	if(a[2][0] !=  9.0) elms = false;
	if(a[2][1] != 10.0) elms = false;
	if(a[2][2] != 11.0) elms = false;
	if(a[2][3] != 12.0) elms = false;
	if(a[3][0] != 13.0) elms = false;
	if(a[3][1] != 14.0) elms = false;
	if(a[3][2] != 15.0) elms = false;
	if(a[3][3] != 16.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tbool elms = true;\n\tif(a[0][0] !=  1.0) elms = false;\n\tif(a[0][1] !=  2.0) elms = false;\n\tif(a[0][2] !=  3.0) elms = false;\n\tif(a[0][3] !=  4.0) elms = false;\n\tif(a[1][0] !=  5.0) elms = false;\n\tif(a[1][1] !=  6.0) elms = false;\n\tif(a[1][2] !=  7.0) elms = false;\n\tif(a[1][3] !=  8.0) elms = false;\n\tif(a[2][0] !=  9.0) elms = false;\n\tif(a[2][1] != 10.0) elms = false;\n\tif(a[2][2] != 11.0) elms = false;\n\tif(a[2][3] != 12.0) elms = false;\n\tif(a[3][0] != 13.0) elms = false;\n\tif(a[3][1] != 14.0) elms = false;\n\tif(a[3][2] != 15.0) elms = false;\n\tif(a[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.91549295774647
Processing this: /home/oof/webgl_cleaned/ivec4_empty_out_ivec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(out ivec4 par[3]);
bool is_all(const in ivec4 par, const in int value);
bool is_all(const in ivec4 array[3], const in ivec4 value);
void set_all(out ivec4 array[3], const in ivec4 value);
void main ()
{
	ivec4 par[3];
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	set_all(par, ivec4(1, 1, 1, 1));
	ret = function(par);
	if(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(out ivec4 par[3])
{
	set_all(par, ivec4(0, 0, 0, 0));
	return ivec4(1, 1, 1, 1);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in ivec4 array[3], const in ivec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 array[3], const in ivec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(out ivec4 par[3]);\nbool is_all(const in ivec4 par, const in int value);\nbool is_all(const in ivec4 array[3], const in ivec4 value);\nvoid set_all(out ivec4 array[3], const in ivec4 value);\nvoid main ()\n{\n\tivec4 par[3];\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tset_all(par, ivec4(1, 1, 1, 1));\n\tret = function(par);\n\tif(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(out ivec4 par[3])\n{\n\tset_all(par, ivec4(0, 0, 0, 0));\n\treturn ivec4(1, 1, 1, 1);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in ivec4 array[3], const in ivec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 array[3], const in ivec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.91549295774647
Processing this: /home/oof/webgl_cleaned/gl_MaxFragmentUniformVectors_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(float(gl_MaxFragmentUniformVectors) / 16.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(float(gl_MaxFragmentUniformVectors) / 16.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4((float(gl_MaxFragmentUniformVectors) / 16.5));
}


As vertex? : False
SUCCESS!
61.05263157894737
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(notEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(notEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 2.0, -1.0, 0.5);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.18881118881119
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par[3])
{
	set_all(par, 0);
	return 1;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par[3])\n{\n\tset_all(par, 0);\n\treturn 1;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
61.18881118881119
Processing this: /home/oof/webgl_cleaned/initfunc_empty_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void initialise_array(out float array[2], float init_val);
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	initialise_array(new_mad,25.0);
	if( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
void initialise_array(out float array[2], float init_val)
{
	array[0] = init_val;
	array[1] = init_val;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid initialise_array(out float array[2], float init_val);\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tinitialise_array(new_mad,25.0);\n\tif( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvoid initialise_array(out float array[2], float init_val)\n{\n\tarray[0] = init_val;\n\tarray[1] = init_val;\n}\n\x00')
61.18881118881119
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
61.18881118881119
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = (gtf_Color.rg + 0.01) / 1.01;
	color = vec4(log(c) / -4.61, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (gtf_Color.rg + 0.01) / 1.01;\n\tcolor = vec4(log(c) / -4.61, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((true ? 1.0 : (0.0 / 2.0)) - (-1.0 + 0.0)), ((-0.5 * --1.0) + 0.0), 1.0, (!true ? -(0.0 - 0.0) : (0.0 + 2.0)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((gtf_Color.rg + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((true ? 1.0 : (0.0 / 2.0)) - (-1.0 + 0.0)), ((-0.5 * --1.0) + 0.0), 1.0, (!true ? -(0.0 - 0.0) : (0.0 + 2.0)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((gtf_Color.rg + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.97560975609756
Processing this: /home/oof/webgl_cleaned/vec4_yxwz_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.yxwz;
	vec4 a = vec4(m.y, m.x, m.w, m.z);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.yxwz;\n\tvec4 a = vec4(m.y, m.x, m.w, m.z);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.yxwz;
  vec4 a = vec4(m.y , m.x , m.w , m.z);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
61.111111111111114
Mutations attempted: 288
Valid mutations:     176
Success rate:        61.11%
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvaryyvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float x = 2.0 * (gtf_Color.g - 0.5);
	float y = 2.0 * (gtf_Color.b - 0.5);
	float atan_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x > epsilon || abs(y) > epsilon)
	{
		if(x < 0.0 ^^ y < 0.0)
		{
			sign = -1.0;
		}
		if(abs(y) <= abs(x))
		{
			float c = abs(y / x);
			for(int i = 1; i < 12; i += 2)
			{
				atan_c += scale * pow(c, float(i)) / float(i);
				scale *= -1.0;
			}
			result = vec4(sign * atan_c / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
		}
		else
		{
			float c = abs(x / y);
			for(int i = 1; i < 12; i += 2)
			{
				atan_c += scale * pow(c, float(i)) / float(i);
				scale *= -1.0;
			}
			result = vec4(sign * (M_PI / 2.0 - atan_c) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
		}
		if(x < 0.0)
			if(y < 0.0) result.r -= 0.5;
			else if(y > 0.0) result.r += 0.5;
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat x = 2.0 * (gtf_Color.g - 0.5);\n\tfloat y = 2.0 * (gtf_Color.b - 0.5);\n\tfloat atan_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x > epsilon || abs(y) > epsilon)\n\t{\n\t\tif(x < 0.0 ^^ y < 0.0)\n\t\t{\n\t\t\tsign = -1.0;\n\t\t}\n\t\tif(abs(y) <= abs(x))\n\t\t{\n\t\t\tfloat c = abs(y / x);\n\t\t\tfor(int i = 1; i < 12; i += 2)\n\t\t\t{\n\t\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\t\tscale *= -1.0;\n\t\t\t}\n\t\t\tresult = vec4(sign * atan_c / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat c = abs(x / y);\n\t\t\tfor(int i = 1; i < 12; i += 2)\n\t\t\t{\n\t\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\t\tscale *= -1.0;\n\t\t\t}\n\t\t\tresult = vec4(sign * (M_PI / 2.0 - atan_c) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t\t}\n\t\tif(x < 0.0)\n\t\t\tif(y < 0.0) result.r -= 0.5;\n\t\t\telse if(y > 0.0) result.r += 0.5;\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4((false ? 2.0 : 0.5), +1.0, 1.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float x = (2.0 * (gtf_Color.g - 0.5));
  float y = (2.0 * (gtf_Color.b - 0.5));
  float atan_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    if (((x < 0.0) ^^ (y < 0.0)))
    {
      sign = -1.0;
    }
    if ((abs(y) <= abs(x)))
    {
      float c = abs((y / x));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * atan_c) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    else
    {
      float c = abs((x / y));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    if ((x < 0.0))
      if ((y < 0.0))
        (result.r -= 0.5);
      else
        if ((y > 0.0))
          (result.r += 0.5);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.245674740484425
Processing this: /home/oof/webgl_cleaned/radians_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 360.0 * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 360.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(+0.5, -1.0, -1.0, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((radians(c) / (4.0 * M_PI)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.37931034482759
Processing this: /home/oof/webgl_cleaned/log_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 31.0 * color.rg + 1.0;
	gl_FragColor = vec4(log(c) / 3.466, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 31.0 * color.rg + 1.0;\n\tgl_FragColor = vec4(log(c) / 3.466, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, (((true ? true : true) && !false) ? 2.0 : -1.0), 2.0, ++(true ? 1.0 : 2.0));

void main()
{
  vec2 c = ((31.0 * color.rg) + 1.0);
  gl_FragColor = vec4((log(c) / 3.466) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '++' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, (((true ? true : true) && !false) ? 2.0 : -1.0), 2.0, ++(true ? 1.0 : 2.0));

void main()
{
  vec2 c = ((31.0 * color.rg) + 1.0);
  gl_FragColor = vec4((log(c) / 3.466) , 0.0 , 1.0);
}


==============================
61.16838487972509
Processing this: /home/oof/webgl_cleaned/bvec4_2int_2float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	bvec4 a = bvec4(0, 23, 0.0, 23.0);
	float gray;
	if( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tbvec4 a = bvec4(0, 23, 0.0, 23.0);\n\tfloat gray;\n\tif( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, (-1.0 * (true ? 0.0 : -1.0)), (-(-1.0 - -1.0) - 1.0), (2.0 - (-1.0 / 0.5)), (((false && false) ? true : true) ? ((true && false) ? 0.0 : -1.0) : -1.0), -0.0, -1.0, 1.0, 0.0, 2.0, 0.5, 0.0, (((true ? 1.0 : 1.0) - -1.0) - --2.0), -1.0, -1.0, -1.0);

vec4 color;

void main()
{
  bvec4 a = bvec4(0 , 23 , 0.0 , 23.0);
  float gray;
  if (((((a[0] == false) && (a[1] == true)) && (a[2] == false)) && (a[3] == true)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, (-1.0 * (true ? 0.0 : -1.0)), (-(-1.0 - -1.0) - 1.0), (2.0 - (-1.0 / 0.5)), (((false && false) ? true : true) ? ((true && false) ? 0.0 : -1.0) : -1.0), -0.0, -1.0, 1.0, 0.0, 2.0, 0.5, 0.0, (((true ? 1.0 : 1.0) - -1.0) - --2.0), -1.0, -1.0, -1.0);

vec4 color;

void main()
{
  bvec4 a = bvec4(0 , 23 , 0.0 , 23.0);
  float gray;
  if (((((a[0] == false) && (a[1] == true)) && (a[2] == false)) && (a[3] == true)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.95890410958904
Processing this: /home/oof/webgl_cleaned/array_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
	b[0] = a[0];
	c[0] += d[0];
	a[0] += 1.0;
	e[0] += 1.0;
	b[1] = a[1];
	c[1] += d[1];
	a[1] += 1.0;
	e[1] += 1.0;
	b[2] = a[2];
	c[2] += d[2];
	a[2] += 1.0;
	e[2] += 1.0;
	b[3] = a[3];
	c[3] += d[3];
	a[3] += 1.0;
	e[3] += 1.0;
}
void main ()
{
	float a[4];
	float b[4];
	float c[4];
	float d[4];
	float e[4];
	float q = 0.0;
	float q2 = 0.0;
	a[0] = 1.0;
	b[0] = 2.0;
	c[0] = 3.0;
	d[0] = 4.0;
	e[0] = 1.0;
	a[1] = 1.0;
	b[1] = 2.0;
	c[1] = 3.0;
	d[1] = 4.0;
	e[1] = 1.0;
	a[2] = 1.0;
	b[2] = 2.0;
	c[2] = 3.0;
	d[2] = 4.0;
	e[2] = 1.0;
	a[3] = 1.0;
	b[3] = 2.0;
	c[3] = 3.0;
	d[3] = 4.0;
	e[3] = 1.0;
	qualifiers(a, b, c, d, e);
	if(a[0] == 1.0) q += 1.0;
	if(b[1] == 1.0) q += 2.0;
	if(c[2] == 7.0) q += 4.0;
	if(d[3] == 4.0) q2 += 1.0;
	if(e[0] == 1.0) q2 += 2.0;
	gl_FragColor = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])\n{\n\tb[0] = a[0];\n\tc[0] += d[0];\n\ta[0] += 1.0;\n\te[0] += 1.0;\n\tb[1] = a[1];\n\tc[1] += d[1];\n\ta[1] += 1.0;\n\te[1] += 1.0;\n\tb[2] = a[2];\n\tc[2] += d[2];\n\ta[2] += 1.0;\n\te[2] += 1.0;\n\tb[3] = a[3];\n\tc[3] += d[3];\n\ta[3] += 1.0;\n\te[3] += 1.0;\n}\nvoid main ()\n{\n\tfloat a[4];\n\tfloat b[4];\n\tfloat c[4];\n\tfloat d[4];\n\tfloat e[4];\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\ta[0] = 1.0;\n\tb[0] = 2.0;\n\tc[0] = 3.0;\n\td[0] = 4.0;\n\te[0] = 1.0;\n\ta[1] = 1.0;\n\tb[1] = 2.0;\n\tc[1] = 3.0;\n\td[1] = 4.0;\n\te[1] = 1.0;\n\ta[2] = 1.0;\n\tb[2] = 2.0;\n\tc[2] = 3.0;\n\td[2] = 4.0;\n\te[2] = 1.0;\n\ta[3] = 1.0;\n\tb[3] = 2.0;\n\tc[3] = 3.0;\n\td[3] = 4.0;\n\te[3] = 1.0;\n\tqualifiers(a, b, c, d, e);\n\tif(a[0] == 1.0) q += 1.0;\n\tif(b[1] == 1.0) q += 2.0;\n\tif(c[2] == 7.0) q += 4.0;\n\tif(d[3] == 4.0) q2 += 1.0;\n\tif(e[0] == 1.0) q2 += 2.0;\n\tgl_FragColor = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4];
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  4.0 = color[0];
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:48: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4];
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  4.0 = color[0];
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
}


==============================
60.75085324232082
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 16.0 * gtf_Color.rg;
	color = vec4(sqrt(c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 16.0 * gtf_Color.rg;\n\tcolor = vec4(sqrt(c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 2.0, +(false ? (2.0 + -1.0) : 0.5), +0.5);

void main()
{
  vec2 c = (16.0 * gtf_Color.rg);
  color = vec4((sqrt(c) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.8843537414966
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 4.0 * 2.0 * (gtf_Color.r - 0.5);
	float atan_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	vec4 result;
	if(c < 0.0)
	{
		sign = -1.0;
		c *= -1.0;
	}
	if(c <= 1.0)
	{
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	else
	{
		c = 1.0 / c;
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 4.0 * 2.0 * (gtf_Color.r - 0.5);\n\tfloat atan_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tvec4 result;\n\tif(c < 0.0)\n\t{\n\t\tsign = -1.0;\n\t\tc *= -1.0;\n\t}\n\tif(c <= 1.0)\n\t{\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tc = 1.0 / c;\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 1.0, -1.0, (0.0 - -1.0), 2.0, --1.0, -1.0, 0.0, 0.0, -0.5, -(!false ? +0.0 : +0.0), 0.5, +2.0, (((true ? true : true) ? (true || true) : false) ? +1.0 : (0.5 + 1.0)), (0.0 * -1.0), -1.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  float atan_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  vec4 result;
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  if ((c <= 1.0))
  {
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * atan_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  else
  {
    c = (1.0 / c);
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 1.0, -1.0, (0.0 - -1.0), 2.0, --1.0, -1.0, 0.0, 0.0, -0.5, -(!false ? +0.0 : +0.0), 0.5, +2.0, (((true ? true : true) ? (true || true) : false) ? +1.0 : (0.5 + 1.0)), (0.0 * -1.0), -1.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  float atan_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  vec4 result;
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  if ((c <= 1.0))
  {
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * atan_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  else
  {
    c = (1.0 / c);
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.67796610169491
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.5, (false ? -1.0 : -1.0), -1.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.810810810810814
Processing this: /home/oof/webgl_cleaned/varying1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float foo;
void main()
{
    foo = 5.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float foo;\nvoid main()\n{\n    foo = 5.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct48685 {
  uint f_9066;
  int f_8071;
  bool f_7592;
};

float foo = 2.0;

void main()
{
  foo = 5.0;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:5: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct48685 {
  uint f_9066;
  int f_8071;
  bool f_7592;
};

float foo = 2.0;

void main()
{
  foo = 5.0;
}


==============================
60.60606060606061
Processing this: /home/oof/webgl_cleaned/greaterThan_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, -1.0, (((-1.0 + 0.5) - (true ? -1.0 : 0.0)) * (0.0 - 0.0)), 0.0, ((true ? true : (true && true)) ? (true ? +-1.0 : -1.0) : 0.0), 0.0, +1.0, (false ? 0.5 : 2.0), -(+-1.0 + 1.0), -0.5, ((true ? 0.0 : +0.5) + 2.0), (!(false ? true : false) ? -(1.0 / 1.0) : ((false ? true : false) ? (0.0 * 1.0) : (true ? -1.0 : -1.0))), (0.5 / 1.0), -1.0, 2.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, -1.0, (((-1.0 + 0.5) - (true ? -1.0 : 0.0)) * (0.0 - 0.0)), 0.0, ((true ? true : (true && true)) ? (true ? +-1.0 : -1.0) : 0.0), 0.0, +1.0, (false ? 0.5 : 2.0), -(+-1.0 + 1.0), -0.5, ((true ? 0.0 : +0.5) + 2.0), (!(false ? true : false) ? -(1.0 / 1.0) : ((false ? true : false) ? (0.0 * 1.0) : (true ? -1.0 : -1.0))), (0.5 / 1.0), -1.0, 2.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.40268456375839
Mutations attempted: 298
Valid mutations:     180
Success rate:        60.40%
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	float c = color.r;
	gl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  float c = color.r;
  gl_FragColor = vec4(0.5);
}


As vertex? : False
SUCCESS!
60.535117056856194
Processing this: /home/oof/webgl_cleaned/2f_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform vec2 color;
varying vec2 col;
void main ()
{
	col = color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform vec2 color;\nvarying vec2 col;\nvoid main ()\n{\n\tcol = color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform vec2 color;

vec2 col = vec2(0.5, (((true ? true : true) ? true : (false ? false : false)) ? 0.0 : (false ? (0.5 * 1.0) : -1.0)));

void main()
{
  col = color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.66666666666667
Processing this: /home/oof/webgl_cleaned/min_vec3_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 min_c = vec3(0.5, 0.5, 0.5);
	vec3 c = gtf_Color.rgb;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	if(c[2] > min_c[2]) c[2] = min_c[2];
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 min_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = gtf_Color.rgb;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tif(c[2] > min_c[2]) c[2] = min_c[2];\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(((2.0 / 2.0) / 0.5), 0.0, (false ? 0.0 : 0.5), (-0.0 + 0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  if ((c[2] > min_c[2]))
    c[2] = min_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.797342192691026
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, -0.5, 2.0, -1.0);

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.9271523178808
Processing this: /home/oof/webgl_cleaned/intUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform int ival;
uniform ivec2 ival2;
uniform ivec3 ival3;
uniform ivec4 ival4;
void main()
{
    int sum = ival
            + ival2[0] + ival2[1]
            + ival3[0] + ival3[1] + ival3[2]
            + ival4[0] + ival4[1] + ival4[2] + ival4[3];
    gl_Position = vec4(sum, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform int ival;\nuniform ivec2 ival2;\nuniform ivec3 ival3;\nuniform ivec4 ival4;\nvoid main()\n{\n    int sum = ival\n            + ival2[0] + ival2[1]\n            + ival3[0] + ival3[1] + ival3[2]\n            + ival4[0] + ival4[1] + ival4[2] + ival4[3];\n    gl_Position = vec4(sum, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2 = ivec2(7, +ival);

uniform ivec3 ival3;

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2 = ivec2(7, +ival);

uniform ivec3 ival3;

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


==============================
60.726072607260726
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = -color.rg;
	gl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = -color.rg;
  gl_FragColor = vec4(exp2((5.0 * c)) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = -color.rg;
  gl_FragColor = vec4(exp2((5.0 * c)) , 0.0);
}


==============================
60.526315789473685
Processing this: /home/oof/webgl_cleaned/void_empty_empty_void_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float gray = 0.0;
void function();
void main ()
{
	gray = 0.0;
	function();
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
void function()
{
	gray = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat gray = 0.0;\nvoid function();\nvoid main ()\n{\n\tgray = 0.0;\n\tfunction();\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvoid function()\n{\n\tgray = 1.0;\n}\n\x00')
60.526315789473685
Processing this: /home/oof/webgl_cleaned/vec4_pqs_t_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.pqs;
	float t = al.t;
	vec4 a = vec4(m.p, t, m.s, m.t);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.pqs;\n\tfloat t = al.t;\n\tvec4 a = vec4(m.p, t, m.s, m.t);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.5, -1.0, (0.0 * 1.0));

void main()
{
  vec4 al = color;
  vec3 m = al.pqs;
  float t = al.t;
  vec4 a = vec4(m.p , t , m.s , m.t);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
60.65573770491803
Processing this: /home/oof/webgl_cleaned/fwidth_frag_ref_dx.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.78431372549019
Processing this: /home/oof/webgl_cleaned/dot_float_frag_xvaryyone_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(color.r), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(color.r), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, 2.0, 0.0, +(false ? 0.5 : (2.0 - 2.0)))(vec3(color.r));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, 2.0, 0.0, +(false ? 0.5 : (2.0 - 2.0)))(vec3(color.r));
}


==============================
60.586319218241044
Mutations attempted: 307
Valid mutations:     186
Success rate:        60.59%
Processing this: /home/oof/webgl_cleaned/struct_vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	color = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tcolor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  color = vec4(vec3(((((((((s.a[0] + s.a[1]) + s.a[2]) + s.a[3]) + s.b[0]) + s.b[1]) + s.b[2]) + s.b[3]) / 250.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.71428571428571
Processing this: /home/oof/webgl_cleaned/mod_vec3_frag_xvary_yconst1_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	c = c - 1.0 * floor(c / 1.0);
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tc = c - 1.0 * floor(c / 1.0);\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 0.0, (!!false ? (-1.0 * 0.0) : 2.0), ((true ? true : (true ? true : true)) ? (-1.0 / 1.0) : 0.0));

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  c = (c - (1.0 * floor((c / 1.0))));
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
SUCCESS!
60.84142394822006
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = color.rg;
  gl_FragColor = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.967741935483865
Processing this: /home/oof/webgl_cleaned/CorrectFuncOverload_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void testVoid (vec4 v, vec4 v1)
{
}
void testVoid (ivec4 v, ivec4 v1)
{
}
void main()
{
    vec4 v;
    ivec4 i;
    testVoid(i, i);
    testVoid(v, v);
    gl_FragColor = v;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid testVoid (vec4 v, vec4 v1)\n{\n}\nvoid testVoid (ivec4 v, ivec4 v1)\n{\n}\nvoid main()\n{\n    vec4 v;\n    ivec4 i;\n    testVoid(i, i);\n    testVoid(v, v);\n    gl_FragColor = v;\n}\n\x00')
60.967741935483865
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, (2.0 * ((0.0 - 2.0) + (true ? 1.0 : 1.0))), -0.5, 1.0);

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.09324758842444
Processing this: /home/oof/webgl_cleaned/mat3arrayindirect1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform mat3 testmat3[2];
varying vec4  color;
void main()
{
	vec3 result = vec3(0.0, 0.0, 0.0);
	result += testmat3[1][0];
	result += testmat3[1][1];
	result += testmat3[1][2];
	gl_FragColor = vec4(result/2.0, 0.5);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform mat3 testmat3[2];\nvarying vec4  color;\nvoid main()\n{\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tresult += testmat3[1][0];\n\tresult += testmat3[1][1];\n\tresult += testmat3[1][2];\n\tgl_FragColor = vec4(result/2.0, 0.5);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat3 testmat3[2];

vec4 color = vec4(0.0, -0.0, ((false ? (true && false) : !true) ? 0.5 : 0.0), (2.0 - -1.0));

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  (result += testmat3[1][0]);
  (result += testmat3[1][1]);
  (result += testmat3[1][2]);
  gl_FragColor = vec4((result / 2.0) , 0.5);
}


As vertex? : False
SUCCESS!
61.21794871794872
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(out vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(out vec4 par)
{
	set_all(par, 0.0);
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(out vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(out vec4 par)\n{\n\tset_all(par, 0.0);\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
61.21794871794872
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 31.0 * gtf_Color.rgb + 1.0;
	color = vec4(log(c) / 3.466, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 31.0 * gtf_Color.rgb + 1.0;\n\tcolor = vec4(log(c) / 3.466, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((true || false) ? 0.5 : (0.5 - -1.0));
  color = vec4((log(c) / 3.466) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: '=' : dimension mismatch
ERROR: 0:14: '=' : cannot convert from 'const float' to 'mediump 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((true || false) ? 0.5 : (0.5 - -1.0));
  color = vec4((log(c) / 3.466) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.0223642172524
Processing this: /home/oof/webgl_cleaned/CorrectParseTest1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct s {
    vec4 v;
} s2;
void main()
{
    s s1 = s(vec4(ivec4(4.0, vec2(5,6), 7.0)));
    vec4 v = vec4(2,ivec2(3.0, 4.0), 5.0);
    vec4 v4 = vec4(ivec4(8.0));
    gl_FragColor = v4 + v + s1.v;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct s {\n    vec4 v;\n} s2;\nvoid main()\n{\n    s s1 = s(vec4(ivec4(4.0, vec2(5,6), 7.0)));\n    vec4 v = vec4(2,ivec2(3.0, 4.0), 5.0);\n    vec4 v4 = vec4(ivec4(8.0));\n    gl_FragColor = v4 + v + s1.v;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct s {
  vec4 v;
} s2;

void main()
{
  s s1 = s(vec4(ivec4(4.0 , vec2(5 , 6) , 7.0)));
  vec4 v = vec4(2 , ivec2(3.0 , 4.0) , 5.0);
  vec4 v4 = vec4(ivec4(8.0));
  gl_FragColor = ((v4 + v) + s1.v);
}


As vertex? : False
SUCCESS!
61.146496815286625
Processing this: /home/oof/webgl_cleaned/float_empty_empty_float_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
61.146496815286625
Mutations attempted: 314
Valid mutations:     192
Success rate:        61.15%
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float s = al.s;
	float t = al.t;
	float p = al.p;
	float q = al.q;
	vec4 m = vec4(s,t,p,q);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat s = al.s;\n\tfloat t = al.t;\n\tfloat p = al.p;\n\tfloat q = al.q;\n\tvec4 m = vec4(s,t,p,q);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  float s = al.s;
  float t = al.t;
  float p = al.p;
  float q = al.q;
  vec4 m = vec4(s , t , p , q);
  gl_FragColor = m;
  vec4(-1.0, (false ? 2.0 : (!true ? -1.0 : (false ? 1.0 : -1.0))), 0.5, +0.0);
}


As vertex? : False
SUCCESS!
61.26984126984127
Processing this: /home/oof/webgl_cleaned/gl_MaxVertexTextureImageUnits_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	if(gl_MaxVertexTextureImageUnits >= 0)
		gl_FragColor = vec4(1.0);
	else
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tif(gl_MaxVertexTextureImageUnits >= 0)\n\t\tgl_FragColor = vec4(1.0);\n\telse\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((gl_MaxVertexTextureImageUnits >= 1))
    gl_FragColor = vec4(1.0);
  else
    gl_FragColor = vec4(0.0 , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((gl_MaxVertexTextureImageUnits >= 1))
    gl_FragColor = vec4(1.0);
  else
    gl_FragColor = vec4(0.0 , 0.0 , 0.0);
}


==============================
61.07594936708861
Processing this: /home/oof/webgl_cleaned/vec4_rgb_a_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.rgb;
	float a = al.a;
	vec4 b = vec4(m, a);
	gl_FragColor = b;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.rgb;\n\tfloat a = al.a;\n\tvec4 b = vec4(m, a);\n\tgl_FragColor = b;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 2.0, (0.5 + 2.0), 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.rgb;
  float a = al.a;
  vec4 b = vec4(m , a);
  gl_FragColor = b;
}


As vertex? : False
SUCCESS!
61.198738170347
Processing this: /home/oof/webgl_cleaned/asin_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(asin(c) / M_PI + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(asin(c) / M_PI + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((false ? false : true) || false) ? 0.5 : 0.5), --0.5, -((true && true) ? (2.0 + 0.5) : -1.0), (1.0 - ---1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4(((asin(c) / M_PI) + 0.5) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4((((false ? false : true) || false) ? 0.5 : 0.5), --0.5, -((true && true) ? (2.0 + 0.5) : -1.0), (1.0 - ---1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4(((asin(c) / M_PI) + 0.5) , 1.0);
}


==============================
61.0062893081761
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 4.0 * (gtf_Color.r);
	color = vec4(c * c / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 4.0 * (gtf_Color.r);\n\tcolor = vec4(c * c / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[3] = vec4(-1.0, -1.0, -0.5, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (4.0 * gtf_Color.r);
  color = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[3] of 4-component vector of float'
ERROR: 0:16: '*' : array / non-array mismatch
ERROR: 0:16: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[3] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[3] = vec4(-1.0, -1.0, -0.5, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (4.0 * gtf_Color.r);
  color = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.81504702194357
Processing this: /home/oof/webgl_cleaned/structcopy_bvec2bvec3bvec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	bvec2 a;
	bvec3 b;
	bvec4 c;
};
void main ()
{
	sabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );
	sabcd s2 = sabcd( bvec2(0, 0), bvec3(0.0, 0.0, 0.0), bvec4(0.0, 0.0, 0.0, 0.0 ) );
	s2 = s;
	float gray = 0.0;
	if( (s2.a[0]) && (s2.a[1]) && (s2.b[0]) && (!s2.b[1]) && (s2.b[2]) && (s2.c[0]) && (s2.c[1]) && (s2.c[2]) && (s2.c[3]) )
	  gray=1.0;
	else
          gray =0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tbvec2 a;\n\tbvec3 b;\n\tbvec4 c;\n};\nvoid main ()\n{\n\tsabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );\n\tsabcd s2 = sabcd( bvec2(0, 0), bvec3(0.0, 0.0, 0.0), bvec4(0.0, 0.0, 0.0, 0.0 ) );\n\ts2 = s;\n\tfloat gray = 0.0;\n\tif( (s2.a[0]) && (s2.a[1]) && (s2.b[0]) && (!s2.b[1]) && (s2.b[2]) && (s2.c[0]) && (s2.c[1]) && (s2.c[2]) && (s2.c[3]) )\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bvec2 a;
  bvec3 b;
  bvec4 c0;
};

void main()
{
  sabcd s = sabcd(bvec2(12 , 13) , bvec3(14.0 , 0.0 , 139.0) , bvec4(25.5 , 17.0 , 145 , 163));
  sabcd s2 = sabcd(bvec2(0 , 0) , bvec3(0.0 , 0.0 , 0.0) , bvec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  float gray = 0.0;
  if (((((((((s2.a[0] && s2.a[1]) && s2.b[0]) && !s2.b[1]) && s2.b[2]) && s2.c[0]) && s2.c[1]) && s2.c[2]) && s2.c[3]))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bvec2 a;
  bvec3 b;
  bvec4 c0;
};

void main()
{
  sabcd s = sabcd(bvec2(12 , 13) , bvec3(14.0 , 0.0 , 139.0) , bvec4(25.5 , 17.0 , 145 , 163));
  sabcd s2 = sabcd(bvec2(0 , 0) , bvec3(0.0 , 0.0 , 0.0) , bvec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  float gray = 0.0;
  if (((((((((s2.a[0] && s2.a[1]) && s2.b[0]) && !s2.b[1]) && s2.b[2]) && s2.c[0]) && s2.c[1]) && s2.c[2]) && s2.c[3]))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.62499999999999
Processing this: /home/oof/webgl_cleaned/empty_empty_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	new_mad[0]=float(1);
	new_mad[1]=float(2);
	if( (new_mad[0] == 1.0) && (new_mad[1] == 2.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tnew_mad[0]=float(1);\n\tnew_mad[1]=float(2);\n\tif( (new_mad[0] == 1.0) && (new_mad[1] == 2.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  int i = 0;
  float new_mad[2];
  float gray = 0.0;
  new_mad[0] = float(1);
  new_mad[1] = float(2);
  if (((new_mad[0] == 1.0) && (new_mad[1] == 2.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color = vec4(1.0, 2.0, 2.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'color' : undeclared identifier
ERROR: 0:15: 'assign' : l-value required (can't modify a const)
ERROR: 0:15: '=' : dimension mismatch
ERROR: 0:15: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const highp float'
ERROR: 0:16: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:16: 'gtf_Vertex' : undeclared identifier
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  int i = 0;
  float new_mad[2];
  float gray = 0.0;
  new_mad[0] = float(1);
  new_mad[1] = float(2);
  if (((new_mad[0] == 1.0) && (new_mad[1] == 2.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color = vec4(1.0, 2.0, 2.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


==============================
60.43613707165109
Processing this: /home/oof/webgl_cleaned/sin_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * gtf_Color.rgb;
	float sign = 1.0;
	vec3 sin_c = vec3(0.0);
	float fact;
	float fact_of;
	for(int i = 0; i < 12; i++)
	{
		fact = 1.0;
		for(int j = 2; j <= 23; j++)
			if (j <= 2 * i + 1)
				fact *= float(j);
		sin_c += sign * pow(c, vec3(2.0 * float(i) + 1.0)) / fact;
		sign *= -1.0;
	}
	color = vec4(0.5 * sin_c + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * gtf_Color.rgb;\n\tfloat sign = 1.0;\n\tvec3 sin_c = vec3(0.0);\n\tfloat fact;\n\tfloat fact_of;\n\tfor(int i = 0; i < 12; i++)\n\t{\n\t\tfact = 1.0;\n\t\tfor(int j = 2; j <= 23; j++)\n\t\t\tif (j <= 2 * i + 1)\n\t\t\t\tfact *= float(j);\n\t\tsin_c += sign * pow(c, vec3(2.0 * float(i) + 1.0)) / fact;\n\t\tsign *= -1.0;\n\t}\n\tcolor = vec4(0.5 * sin_c + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  vec4(-0.5, 0.5, 0.0, 0.0);
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * gtf_Color.rgb);
  float sign = 1.0;
  vec3 sin_c = vec3(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec3(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(0.0, -0.5);
}


As vertex? : True
SUCCESS!
60.55900621118012
Processing this: /home/oof/webgl_cleaned/vec3_stp_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.stp;
	vec4 a = vec4(m.stp,lightloc.q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.stp;\n\tvec4 a = vec4(m.stp,lightloc.q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 m = lightloc.stp;
  ivec2(7, 1);
  color = gtf_Color;
  vec4 lightloc = gtf_Vertex;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
  vec4 a = vec4(m.stp , lightloc.q);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'lightloc' : undeclared identifier
ERROR: 0:14: 'stp' :  field selection requires structure or vector on left hand side
ERROR: 0:14: '=' : dimension mismatch
ERROR: 0:14: '=' : cannot convert from 'const highp float' to 'mediump 3-component vector of float'
ERROR: 0:18: 'a' : undeclared identifier
ERROR: 0:18: '=' : dimension mismatch
ERROR: 0:18: 'assign' : cannot convert from 'highp 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 m = lightloc.stp;
  ivec2(7, 1);
  color = gtf_Color;
  vec4 lightloc = gtf_Vertex;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
  vec4 a = vec4(m.stp , lightloc.q);
}


==============================
60.371517027863774
Processing this: /home/oof/webgl_cleaned/ivec3_3int_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	ivec3 a = ivec3(20, 13, 17);
	float gray;
	if( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tivec3 a = ivec3(20, 13, 17);\n\tfloat gray;\n\tif( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, 0.5, -1.0, 0.0);

void main()
{
  ivec3 a = ivec3(20 , 13 , 17);
  float gray;
  if ((((a[0] == 20) && (a[1] == 13)) && (a[2] == 17)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.49382716049383
Mutations attempted: 324
Valid mutations:     196
Success rate:        60.49%
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 16.0 * gtf_Color.r;
	color = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 16.0 * gtf_Color.r;\n\tcolor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (16.0 * gtf_Color.r);
  color = vec4((sqrt(c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.61538461538461
Processing this: /home/oof/webgl_cleaned/cos_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.rg) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.rg) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, -1.0, 2.0, (false ? +0.0 : 2.0));

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.rg))) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.73619631901841
Processing this: /home/oof/webgl_cleaned/atan_vec2_vert_xvaryyvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 x = 2.0 * (gtf_Color.gg - 0.5);
	vec2 y = 2.0 * (gtf_Color.bb - 0.5);
	const float epsilon = 1.0e-4;
	color = vec4(0.0, 0.0, 0.0, 1.0);
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		color[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		color[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;
	}
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 x = 2.0 * (gtf_Color.gg - 0.5);\n\tvec2 y = 2.0 * (gtf_Color.bb - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tcolor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tcolor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;\n\t}\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 x = (2.0 * (gtf_Color.gg - 0.5));
  if (((x[1] > epsilon) ^^ (abs(y[1]) > epsilon)))
  {
    color[1] = (vec4(0.5, (true ? --0.0 : 1.0), 2.0, (((false ? false : false) ? -1.0 : 0.0) * 0.0)) + 0.5);
  }
  const float M_PI = 3.141592653589793;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    color[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  vec2 y = (2.0 * (gtf_Color.bb - 0.5));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'epsilon' : undeclared identifier
ERROR: 0:15: 'y' : undeclared identifier
ERROR: 0:15: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:15: 'epsilon' : undeclared identifier
ERROR: 0:17: '--' : l-value required (can't modify a const)
ERROR: 0:17: '=' : dimension mismatch
ERROR: 0:17: 'assign' : cannot convert from 'const 4-component vector of float' to 'mediump float'
ERROR: 0:23: 'y' : undeclared identifier
ERROR: 0:23: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:25: 'y' : undeclared identifier
ERROR: 0:25: 'expression' :  left of '[' is not of type array, matrix, or vector 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 x = (2.0 * (gtf_Color.gg - 0.5));
  if (((x[1] > epsilon) ^^ (abs(y[1]) > epsilon)))
  {
    color[1] = (vec4(0.5, (true ? --0.0 : 1.0), 2.0, (((false ? false : false) ? -1.0 : 0.0) * 0.0)) + 0.5);
  }
  const float M_PI = 3.141592653589793;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    color[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  vec2 y = (2.0 * (gtf_Color.bb - 0.5));
}


==============================
60.550458715596335
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? 0.5 : ((true ? true : true) ? (1.0 - 0.0) : +0.0)), (false ? 0.5 : 1.0), 0.5, 0.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(greaterThanEqual(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
60.670731707317074
Processing this: /home/oof/webgl_cleaned/any_bvec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	gl_FragColor = vec4(vec3(any(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tgl_FragColor = vec4(vec3(any(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec4(vec3(any(bvec3(c)))) = gl_FragColor;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec4(vec3(any(bvec3(c)))) = gl_FragColor;
}


==============================
60.48632218844985
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
mat4 function(in mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(in mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nmat4 function(in mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(in mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.48632218844985
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * gtf_Color.rg;
	color = vec4(c / 100.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * gtf_Color.rg;\n\tcolor = vec4(c / 100.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 2.0, -1.0, (false ? -0.0 : ((false && true) ? (-1.0 / -1.0) : +2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (100.0 * gtf_Color.rg);
  color = vec4((c / 100.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.60606060606061
Processing this: /home/oof/webgl_cleaned/exp_float_vert_xvaryneg_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	float c = gtf_Color.r;
	color = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((!(false ? true : false) ? (--1.0 - -1.0) : +-1.0), 2.0, ((true ? 0.0 : 0.5) * ((true || true) ? +0.0 : 0.0)), 2.0);

void main()
{
  const float exp1 = 2.7183;
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(exp1 , (3.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((!(false ? true : false) ? (--1.0 - -1.0) : +-1.0), 2.0, ((true ? 0.0 : 0.5) * ((true || true) ? +0.0 : 0.0)), 2.0);

void main()
{
  const float exp1 = 2.7183;
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(exp1 , (3.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.42296072507553
Processing this: /home/oof/webgl_cleaned/structnest_mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	mat2 b;
};
struct nesta
{
	mat2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tmat2 b;\n};\nstruct nesta\n{\n\tmat2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((0.0 * 1.0), (((true && true) && false) ? (true ? 0.5 : 2.0) : +2.0), 0.5, (((false || false) ? -1.0 : 1.0) - 0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  mat2 b;
};

struct nesta {
  mat2 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat2(11 , 13 , 29 , 33) , nestb(mat2(12 , 19 , 79 , 81))));
  color = vec4(vec3(((((((((s.nest_a.a[0][0] + s.nest_a.a[0][1]) + s.nest_a.a[1][0]) + s.nest_a.a[1][1]) + s.nest_a.nest_b.b[0][0]) + s.nest_a.nest_b.b[0][1]) + s.nest_a.nest_b.b[1][0]) + s.nest_a.nest_b.b[1][1]) / 277.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.54216867469879
Processing this: /home/oof/webgl_cleaned/vec4_xyzw_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.xyzw;
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.xyzw;\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.xyzw;
  gl_FragColor = m;
}


As vertex? : False
SUCCESS!
60.66066066066066
Mutations attempted: 333
Valid mutations:     202
Success rate:        60.66%
Processing this: /home/oof/webgl_cleaned/log2_vec2_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg + 0.01) / 1.01;
	gl_FragColor = vec4(log2(c) / -8.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg + 0.01) / 1.01;\n\tgl_FragColor = vec4(log2(c) / -8.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.5, 1.0, -0.5);

void main()
{
  vec2 c = ((color.rg + 0.01) / 1.01);
  gl_FragColor = vec4((log2(c) / -8.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.778443113772454
Processing this: /home/oof/webgl_cleaned/not_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 _not(in bvec3 a)
{
	bvec3 result;
	if(a[0]) result[0] = false;
	else result[0] = true;
	if(a[1]) result[1] = false;
	else result[1] = true;
	if(a[2]) result[2] = false;
	else result[2] = true;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	color = vec4(vec3(_not(bvec3(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 _not(in bvec3 a)\n{\n\tbvec3 result;\n\tif(a[0]) result[0] = false;\n\telse result[0] = true;\n\tif(a[1]) result[1] = false;\n\telse result[1] = true;\n\tif(a[2]) result[2] = false;\n\telse result[2] = true;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tcolor = vec4(vec3(_not(bvec3(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 _not(in bvec3 a)
{
  bvec3 result;
  if (a[0])
    result[0] = false;
  else
    result[0] = true;
  if (a[1])
    result[1] = false;
  else
    result[1] = true;
  if (a[2])
    ivec2(3, (!!true ? (true ? (false ? 0 : 0) : 2) : 5));
  else
    result[2] = true;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  color = vec4(vec3(_not(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.895522388059696
Processing this: /home/oof/webgl_cleaned/float_empty_out_float_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(out float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(out float par[3])
{
	set_all(par, 0.0);
	return 1.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(out float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(out float par[3])\n{\n\tset_all(par, 0.0);\n\treturn 1.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.895522388059696
Processing this: /home/oof/webgl_cleaned/refract_float_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 + 0.5), +2.0, +-1.0, 1.0, 1.0, +2.0, 2.0, ((false && false) ? +(2.0 / 0.0) : 2.0), -1.0, (false ? 0.0 : 0.0), (true ? (false ? 0.0 : (false ? -1.0 : -1.0)) : 2.0), ((false && true) ? -(1.0 - -1.0) : 0.0), -2.0, 2.0, ((1.0 - -1.0) - 2.0), 2.0);

vec4 color;

void main()
{
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 + 0.5), +2.0, +-1.0, 1.0, 1.0, +2.0, 2.0, ((false && false) ? +(2.0 / 0.0) : 2.0), -1.0, (false ? 0.0 : 0.0), (true ? (false ? 0.0 : (false ? -1.0 : -1.0)) : 2.0), ((false && true) ? -(1.0 - -1.0) : 0.0), -2.0, 2.0, ((1.0 - -1.0) - 2.0), 2.0);

vec4 color;

void main()
{
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.71428571428571
Processing this: /home/oof/webgl_cleaned/equal_bvec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(equal(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(equal(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(equal(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.83086053412463
Processing this: /home/oof/webgl_cleaned/4f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec4 color;
uniform ivec4 icolor;
uniform bool flag;
void main ()
{
	if(flag)
		gl_FragColor = vec4 (icolor[0], icolor[1], icolor[2], icolor[3]);
	else
		gl_FragColor = vec4 (color[0], color[1], color[2], color[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec4 color;\nuniform ivec4 icolor;\nuniform bool flag;\nvoid main ()\n{\n\tif(flag)\n\t\tgl_FragColor = vec4 (icolor[0], icolor[1], icolor[2], icolor[3]);\n\telse\n\t\tgl_FragColor = vec4 (color[0], color[1], color[2], color[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec4 color = vec4(2.0, 1.0, 1.0, 0.0);

uniform ivec4 icolor;

uniform bool flag;

void main()
{
  if (flag)
    gl_FragColor = vec4(icolor[0] , icolor[1] , icolor[2] , icolor[3]);
  else
    gl_FragColor = vec4(color[0] , color[1] , color[2] , color[3]);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec4 color = vec4(2.0, 1.0, 1.0, 0.0);

uniform ivec4 icolor;

uniform bool flag;

void main()
{
  if (flag)
    gl_FragColor = vec4(icolor[0] , icolor[1] , icolor[2] , icolor[3]);
  else
    gl_FragColor = vec4(color[0] , color[1] , color[2] , color[3]);
}


==============================
60.650887573964496
Processing this: /home/oof/webgl_cleaned/floor_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 0.0, -1.0, (!!false ? -(0.0 / -1.0) : 2.0));

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.766961651917406
Processing this: /home/oof/webgl_cleaned/precision_specifiers.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute mediump vec4 gtf_Color;
attribute mediump vec4 gtf_Vertex;
uniform mediump mat4 gtf_ModelViewProjectionMatrix;
varying mediump vec4 color;
void main ()
{
	mediump int x = 5;
	lowp int y = 3;
	mediump float x2 = 5.0;
	lowp float y2 = 1.0;
	color = vec4(x + y, x2 * y2, x, 1.0);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute mediump vec4 gtf_Color;\nattribute mediump vec4 gtf_Vertex;\nuniform mediump mat4 gtf_ModelViewProjectionMatrix;\nvarying mediump vec4 color;\nvoid main ()\n{\n\tmediump int x = 5;\n\tlowp int y = 3;\n\tmediump float x2 = 5.0;\n\tlowp float y2 = 1.0;\n\tcolor = vec4(x + y, x2 * y2, x, 1.0);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

mediump vec4 gtf_Color;

mediump vec4 gtf_Vertex;

uniform mediump mat4 gtf_ModelViewProjectionMatrix;

mediump vec4 color;

void main()
{
  mediump int x = 5;
  lowp int y = 3;
  mediump float x2 = 5.0;
  lowp float y2 = 1.0;
  color = vec4((x + y) , (x2 * y2) , x , 1.0);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.882352941176464
Processing this: /home/oof/webgl_cleaned/degrees_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, -1.0, +(-1.0 / 0.0), 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((2.0 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.997067448680355
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
mat4 function(inout mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(inout mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nmat4 function(inout mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(inout mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.997067448680355
Mutations attempted: 341
Valid mutations:     208
Success rate:        61.00%
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
mat4 function(inout mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(inout mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nmat4 function(inout mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(inout mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.997067448680355
Processing this: /home/oof/webgl_cleaned/initfunc_empty_array_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void initialise_array(out float array[2], float init_val);
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	initialise_array(new_mad,25.0);
	if( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )
	  gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
void initialise_array(out float array[2], float init_val)
{
	int i=0;
	array[0] = init_val;
	array[1] = init_val;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid initialise_array(out float array[2], float init_val);\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tinitialise_array(new_mad,25.0);\n\tif( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvoid initialise_array(out float array[2], float init_val)\n{\n\tint i=0;\n\tarray[0] = init_val;\n\tarray[1] = init_val;\n}\n\x00')
60.997067448680355
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((0.5 * 1.0), (true ? (2.0 / 0.5) : (1.0 - (1.0 - -1.0))), 0.0, (-1.0 * ((true ? true : true) ? (false ? 0.5 : 2.0) : 0.5)));

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.111111111111114
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 4.0 * 2.0 * (color.rgb - 0.5);
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	if(c[0] < 0.0)
	{
		sign[0] = -1.0;
		c[0] *= -1.0;
	}
	if(c[0] <= 1.0)
	{
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * atan_c[0] / M_PI + 0.5;
	}
	else
	{
		c[0] = 1.0 / c[0];
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;
	}
	if(c[1] < 0.0)
	{
		sign[1] = -1.0;
		c[1] *= -1.0;
	}
	if(c[1] <= 1.0)
	{
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * atan_c[1] / M_PI + 0.5;
	}
	else
	{
		c[1] = 1.0 / c[1];
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;
	}
	if(c[2] < 0.0)
	{
		sign[2] = -1.0;
		c[2] *= -1.0;
	}
	if(c[2] <= 1.0)
	{
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * atan_c[2] / M_PI + 0.5;
	}
	else
	{
		c[2] = 1.0 / c[2];
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 4.0 * 2.0 * (color.rgb - 0.5);\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(c[0] < 0.0)\n\t{\n\t\tsign[0] = -1.0;\n\t\tc[0] *= -1.0;\n\t}\n\tif(c[0] <= 1.0)\n\t{\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * atan_c[0] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[0] = 1.0 / c[0];\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;\n\t}\n\tif(c[1] < 0.0)\n\t{\n\t\tsign[1] = -1.0;\n\t\tc[1] *= -1.0;\n\t}\n\tif(c[1] <= 1.0)\n\t{\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * atan_c[1] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[1] = 1.0 / c[1];\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;\n\t}\n\tif(c[2] < 0.0)\n\t{\n\t\tsign[2] = -1.0;\n\t\tc[2] *= -1.0;\n\t}\n\tif(c[2] <= 1.0)\n\t{\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * atan_c[2] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[2] = 1.0 / c[2];\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'color' : undeclared identifier
ERROR: 0:4: '=' : dimension mismatch
ERROR: 0:4: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


==============================
60.932944606414
Processing this: /home/oof/webgl_cleaned/log2_vec3_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = (color.rgb + 0.01) / 1.01;
	gl_FragColor = vec4(log2(c) / -8.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (color.rgb + 0.01) / 1.01;\n\tgl_FragColor = vec4(log2(c) / -8.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color[8] = vec4(2.0, 0.5, (((false || false) && true) ? -1.0 : +2.0), 1.0);

void main()
{
  vec3 c = ((color.rgb + 0.01) / 1.01);
  gl_FragColor = vec4((log2(c) / -8.0) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: '=' : array / non-array mismatch
ERROR: 0:4: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[8] of 4-component vector of float'
ERROR: 0:8: '.' : cannot apply dot operator to an array
ERROR: 0:8: '+' : array / non-array mismatch
ERROR: 0:8: '+' : wrong operand types - no operation '+' exists that takes a left-hand operand of type 'mediump array[8] of 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:8: '/' : array / non-array mismatch
ERROR: 0:8: '/' : wrong operand types - no operation '/' exists that takes a left-hand operand of type 'mediump array[8] of 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:8: '=' : array / non-array mismatch
ERROR: 0:8: '=' : cannot convert from 'mediump array[8] of 4-component vector of float' to 'mediump 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color[8] = vec4(2.0, 0.5, (((false || false) && true) ? -1.0 : +2.0), 1.0);

void main()
{
  vec3 c = ((color.rgb + 0.01) / 1.01);
  gl_FragColor = vec4((log2(c) / -8.0) , 1.0);
}


==============================
60.75581395348837
Processing this: /home/oof/webgl_cleaned/refract_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((!true ? 0.5 : 0.0), -0.5, 0.5, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.86956521739131
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -1.0, (false ? 2.0 : -1.0), +2.0, (((false ? false : false) ? false : false) ? 0.5 : (true ? 0.0 : (0.0 * 1.0))), 2.0, 0.5, -1.0, (1.0 + -1.0), ((true && (false ? true : true)) ? (2.0 * (1.0 / -1.0)) : 0.0), ++0.5, (false ? (0.5 + -1.0) : 1.0), -1.0, 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -1.0, (false ? 2.0 : -1.0), +2.0, (((false ? false : false) ? false : false) ? 0.5 : (true ? 0.0 : (0.0 * 1.0))), 2.0, 0.5, -1.0, (1.0 + -1.0), ((true && (false ? true : true)) ? (2.0 * (1.0 / -1.0)) : 0.0), ++0.5, (false ? (0.5 + -1.0) : 1.0), -1.0, 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.69364161849711
Processing this: /home/oof/webgl_cleaned/structcopy_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	sabcd s2 = sabcd(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0 ) );
	s2 = s;
	gl_FragColor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.a[3] + s2.b[0] + s2.b[1] + s2.b[2] + s2.b[3]) / 250.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tsabcd s2 = sabcd(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0 ) );\n\ts2 = s;\n\tgl_FragColor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.a[3] + s2.b[0] + s2.b[1] + s2.b[2] + s2.b[3]) / 250.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  sabcd s2 = color(vec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  gl_FragColor = vec4(vec3(((((((((s2.a[0] + s2.a[1]) + s2.a[2]) + s2.a[3]) + s2.b[0]) + s2.b[1]) + s2.b[2]) + s2.b[3]) / 250.0)) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'color' : function name expected
ERROR: 0:14: '=' : cannot convert from 'const mediump float' to 'structure 'sabcd' (symbol id 3002)'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  sabcd s2 = color(vec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  gl_FragColor = vec4(vec3(((((((((s2.a[0] + s2.a[1]) + s2.a[2]) + s2.a[3]) + s2.b[0]) + s2.b[1]) + s2.b[2]) + s2.b[3]) / 250.0)) , 1.0);
}


==============================
60.51873198847262
Processing this: /home/oof/webgl_cleaned/ivec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform int vuni1;
uniform ivec2 vuni2;
uniform ivec3 vuni3;
uniform ivec4 vuni4;
varying vec4 color;
void main ()
{
	color = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform int vuni1;\nuniform ivec2 vuni2;\nuniform ivec3 vuni3;\nuniform ivec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform int vuni1;

uniform ivec2 vuni2 = ivec2(2, +vuni1);

uniform ivec3 vuni3;

uniform ivec4 vuni4;

vec4 color;

void main()
{
  color = vec4(float(vuni1) , float((vuni2[0] + vuni2[1])) , float(((vuni3[0] + vuni3[1]) + vuni3[2])) , float((((vuni4[0] + vuni4[1]) + vuni4[2]) + vuni4[3])));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform int vuni1;

uniform ivec2 vuni2 = ivec2(2, +vuni1);

uniform ivec3 vuni3;

uniform ivec4 vuni4;

vec4 color;

void main()
{
  color = vec4(float(vuni1) , float((vuni2[0] + vuni2[1])) , float(((vuni3[0] + vuni3[1]) + vuni3[2])) , float((((vuni4[0] + vuni4[1]) + vuni4[2]) + vuni4[3])));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.3448275862069
Processing this: /home/oof/webgl_cleaned/gl_FragCoord_xy_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main()
{
	gl_FragColor = vec4((434.0 / 500.0) * (color.gb - 0.5) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main()\n{\n\tgl_FragColor = vec4((434.0 / 500.0) * (color.gb - 0.5) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4((((434.0 / 500.0) * (color.gb - 0.5)) + 0.5) , 0.0);
  vec4(0.0, ((true && (true || false)) ? -1.0 : 0.0), 0.0, (false ? (false ? 0.5 : (true ? 0.0 : 0.5)) : ((2.0 / 1.0) / (2.0 - 2.0))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
WARNING: 0:9: '/' : Divide by zero during constant folding

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4((((434.0 / 500.0) * (color.gb - 0.5)) + 0.5) , 0.0);
  vec4(0.0, ((true && (true || false)) ? -1.0 : 0.0), 0.0, (false ? (false ? 0.5 : (true ? 0.0 : 0.5)) : ((2.0 / 1.0) / (2.0 - 2.0))));
}


==============================
60.17191977077364
Mutations attempted: 349
Valid mutations:     210
Success rate:        60.17%
Processing this: /home/oof/webgl_cleaned/fboShader0.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
varying vec4 texCoord[1];
varying vec4 color;
uniform mat4 gtf_ModelViewProjectionMatrix;
void main ()
{
    color = gtf_Color;
    texCoord[0] = gtf_MultiTexCoord0;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 texCoord[1];\nvarying vec4 color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid main ()\n{\n    color = gtf_Color;\n    texCoord[0] = gtf_MultiTexCoord0;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 + (true ? 0.0 : (true ? 0.5 : -1.0))), -((false ? 1.0 : 0.5) * +-1.0), 0.0, --1.0, +1.0, 2.0, (+0.0 + 0.0), 0.0, (((0.0 / 0.0) / 2.0) - -1.0), 2.0, (false ? +(0.5 - 0.0) : 2.0), ((1.0 - -0.5) - 0.0), -1.0, -1.0, (true ? -1.0 : (0.5 / 1.0)), ((1.0 / -1.0) / (0.0 / (false ? 2.0 : 0.0))));

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: '--' : l-value required (can't modify a const)
WARNING: 0:14: '/' : Zero divided by zero during constant folding generated NaN
WARNING: 0:14: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:14: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 + (true ? 0.0 : (true ? 0.5 : -1.0))), -((false ? 1.0 : 0.5) * +-1.0), 0.0, --1.0, +1.0, 2.0, (+0.0 + 0.0), 0.0, (((0.0 / 0.0) / 2.0) - -1.0), 2.0, (false ? +(0.5 - 0.0) : 2.0), ((1.0 - -0.5) - 0.0), -1.0, -1.0, (true ? -1.0 : (0.5 / 1.0)), ((1.0 / -1.0) / (0.0 / (false ? 2.0 : 0.0))));

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/exp2_float_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = color.r;
	gl_FragColor = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = color.r;\n\tgl_FragColor = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = color.r;
  gl_FragColor = vec4((1.0 / pow(2.0 , (5.0 * c))) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.11396011396012
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.0, 0.0, 2.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[2] of 4-component vector of float'
ERROR: 0:17: '*' : array / non-array mismatch
ERROR: 0:17: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[2] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:17: '=' : dimension mismatch
ERROR: 0:17: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.0, 0.0, 2.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.94318181818182
Processing this: /home/oof/webgl_cleaned/vec4_rgba_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.rgba;
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.rgba;\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 m = al.rgba;
  gl_FragColor = m;
  vec4 al = color;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'al' : undeclared identifier
ERROR: 0:8: 'rgba' :  field selection requires structure or vector on left hand side
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 m = al.rgba;
  gl_FragColor = m;
  vec4 al = color;
}


==============================
59.773371104815865
Processing this: /home/oof/webgl_cleaned/point_sprites.frag
Original source code: 
precision mediump float;
precision mediump int;

uniform sampler2D gtf_Texture0;
void main ()
{
	gl_FragColor = texture2D(gtf_Texture0, gl_PointCoord.st);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform sampler2D gtf_Texture0;\nvoid main ()\n{\n\tgl_FragColor = texture2D(gtf_Texture0, gl_PointCoord.st);\n}\n\x00')
59.773371104815865
Processing this: /home/oof/webgl_cleaned/sign_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(c * sign(c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(c * sign(c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = (true ? vec4(1.0, ((true && !true) ? 1.0 : 0.0), -1.0, (0.0 / -+0.0)) : vec4((false ? 0.0 : 1.0), +0.5, (((true ? false : false) ? (0.0 * 0.0) : (true ? 0.0 : -1.0)) * (true ? 0.5 : +0.0)), ((false ? !true : (true && true)) ? 0.5 : -1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((c * sign(c)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.887005649717516
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lessThan(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lessThan(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lessThan(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/vec3_ps_t_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	float k = m.t;
	vec2 n = m.ps;
	vec4 a = vec4(n.t, k, n.s, al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tfloat k = m.t;\n\tvec2 n = m.ps;\n\tvec4 a = vec4(n.t, k, n.s, al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 0.0, 2.0, 0.0);

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  float k = m.t;
  vec2 n = m.ps;
  vec4 a = vec4(n.t , k , n.s , al.q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
60.1123595505618
Processing this: /home/oof/webgl_cleaned/struct_bool_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	bool a;
	bool b;
	bool c;
	bool d;
};
void main ()
{
	sabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));
	float gray = 0.0;
	if( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tbool a;\n\tbool b;\n\tbool c;\n\tbool d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));\n\tfloat gray = 0.0;\n\tif( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.22408963585434
Processing this: /home/oof/webgl_cleaned/vec3_rg_b_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec2 t = m.rg;
	float k = m.b;
	vec4 a = vec4(t, k, lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec2 t = m.rg;\n\tfloat k = m.b;\n\tvec4 a = vec4(t, k, lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 a = vec4(t , k , lightloc.a);
  color = gtf_Color;
  vec3 m = lightloc.rgb;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
  float k = m.b;
  vec2 t = m.rg;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 't' : undeclared identifier
ERROR: 0:15: 'k' : undeclared identifier
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 a = vec4(t , k , lightloc.a);
  color = gtf_Color;
  vec3 m = lightloc.rgb;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
  float k = m.b;
  vec2 t = m.rg;
}


==============================
60.05586592178771
Mutations attempted: 358
Valid mutations:     215
Success rate:        60.06%
Processing this: /home/oof/webgl_cleaned/for_break_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int count = 0;
        for(int i=0;i<45;i++)
	{
	  count++;
	  if(count == 29)
            break;
	}
	float gray;
	if( count == 29)
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint count = 0;\n        for(int i=0;i<45;i++)\n\t{\n\t  count++;\n\t  if(count == 29)\n            break;\n\t}\n\tfloat gray;\n\tif( count == 29)\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, ((true ? -1.0 : --1.0) + +0.0), 2.0, -1.0, 1.0, (-1.0 / ((0.5 - 1.0) - 1.0)), +((false || false) ? -2.0 : 1.0), (((true && false) ? true : (true ? true : false)) ? 0.0 : ((false && false) ? 0.0 : -1.0)), 0.0, --0.5, 2.0, (((2.0 * 0.0) - -1.0) * -1.0), -(true ? --1.0 : (1.0 / 2.0)), (0.5 / -1.0), -0.0, +2.0);

vec4 color;

void main()
{
  int count = 0;
  for (int i = 0; (i < 45); i++)
  {
    count++;
    if ((count == 29))
      break;
  }
  float gray;
  if ((count == 29))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, ((true ? -1.0 : --1.0) + +0.0), 2.0, -1.0, 1.0, (-1.0 / ((0.5 - 1.0) - 1.0)), +((false || false) ? -2.0 : 1.0), (((true && false) ? true : (true ? true : false)) ? 0.0 : ((false && false) ? 0.0 : -1.0)), 0.0, --0.5, 2.0, (((2.0 * 0.0) - -1.0) * -1.0), -(true ? --1.0 : (1.0 / 2.0)), (0.5 / -1.0), -0.0, +2.0);

vec4 color;

void main()
{
  int count = 0;
  for (int i = 0; (i < 45); i++)
  {
    count++;
    if ((count == 29))
      break;
  }
  float gray;
  if ((count == 29))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.888579387186624
Processing this: /home/oof/webgl_cleaned/struct_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	gl_FragColor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tgl_FragColor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, (0.5 * 1.0), 2.0, (((1.0 - 1.0) * -2.0) * 2.0));

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  gl_FragColor = vec4(vec3(((((((((s.a[0] + s.a[1]) + s.a[2]) + s.a[3]) + s.b[0]) + s.b[1]) + s.b[2]) + s.b[3]) / 250.0)) , 1.0);
}


As vertex? : False
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/fwidth_frag_ref_dx.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY = vec2(1.0, 0.5);

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.11080332409973
Processing this: /home/oof/webgl_cleaned/equal_ivec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 eq(in ivec3 a, in ivec3 b)
{
	bvec3 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] == b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(eq(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 eq(in ivec3 a, in ivec3 b)\n{\n\tbvec3 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] == b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(eq(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.0, 1.0, (0.5 + +1.0));

bvec3 eq(in ivec3 a, in ivec3 b)
{
  bvec3 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(eq(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
60.22099447513812
Processing this: /home/oof/webgl_cleaned/radians_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 360.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 360.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (((false || true) ? 0.5 : -1.0) * 2.0), 0.5, 2.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((radians(c) / (4.0 * M_PI)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.33057851239669
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat3 m1 = mat3(gtf_Color.rgb, gtf_Color.rgb, gtf_Color.rgb);
	mat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);
	mat3 m3 = mat3(0.0);
	vec3 result = vec3(0.0, 0.0, 0.0);
	m3 = matrixCompMult(m1, m2);
	result[0] += m3[0][0];
	result[0] += m3[0][1];
	result[0] += m3[0][2];
	result[1] += m3[1][0];
	result[1] += m3[1][1];
	result[1] += m3[1][2];
	result[2] += m3[2][0];
	result[2] += m3[2][1];
	result[2] += m3[2][2];
	color = vec4(result / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m1 = mat3(gtf_Color.rgb, gtf_Color.rgb, gtf_Color.rgb);\n\tmat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);\n\tmat3 m3 = mat3(0.0);\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tm3 = matrixCompMult(m1, m2);\n\tresult[0] += m3[0][0];\n\tresult[0] += m3[0][1];\n\tresult[0] += m3[0][2];\n\tresult[1] += m3[1][0];\n\tresult[1] += m3[1][1];\n\tresult[1] += m3[1][2];\n\tresult[2] += m3[2][0];\n\tresult[2] += m3[2][1];\n\tresult[2] += m3[2][2];\n\tcolor = vec4(result / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color[8] = vec4(-1.0, -1.0, 0.0, 0.5);

void main()
{
  mat3 m1 = mat3(gtf_Color.rgb , gtf_Color.rgb , gtf_Color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3 = matrixCompMult(m1 , m2);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  color = vec4((result / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:10: '=' : array / non-array mismatch
ERROR: 0:10: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[8] of 4-component vector of float'
ERROR: 0:28: '=' : array / non-array mismatch
ERROR: 0:28: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump array[8] of 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color[8] = vec4(-1.0, -1.0, 0.0, 0.5);

void main()
{
  mat3 m1 = mat3(gtf_Color.rgb , gtf_Color.rgb , gtf_Color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3 = matrixCompMult(m1 , m2);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  color = vec4((result / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.16483516483516
Processing this: /home/oof/webgl_cleaned/bool_empty_empty_bool_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool function(bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(par && ret)
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bool function(bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool function(bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbool function(bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
60.16483516483516
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(inout mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_zeros) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(inout mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(inout mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_zeros) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(inout mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
60.16483516483516
Processing this: /home/oof/webgl_cleaned/max_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 max_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] < max_c[0]) c[0] = max_c[0];
	if(c[1] < max_c[1]) c[1] = max_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 max_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] < max_c[0]) c[0] = max_c[0];\n\tif(c[1] < max_c[1]) c[1] = max_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((2.0 / -1.0), 0.5, 1.0, 2.0);

void main()
{
  const vec2 max_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  if ((c[1] < max_c[1]))
    c[1] = max_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.273972602739725
Processing this: /home/oof/webgl_cleaned/vec3_st_p_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	float k = m.p;
	vec2 n = m.st;
	vec4 a = vec4(n, k, al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tfloat k = m.p;\n\tvec2 n = m.st;\n\tvec4 a = vec4(n, k, al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((0.5 / -1.0), (1.0 / 0.0), -2.0, (true ? 0.5 : 0.0));

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  float k = m.p;
  vec2 n = m.st;
  vec4 a = vec4(n , k , al.q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
60.38251366120219
Mutations attempted: 366
Valid mutations:     221
Success rate:        60.38%
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, -1.0, 1.0, 0.0);

void main()
{
  vec2 c = color.rg;
  gl_FragColor = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.49046321525886
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = (gtf_Color.rgb + 0.01) / 1.01;
	color = vec4(log(c) / -4.61, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (gtf_Color.rgb + 0.01) / 1.01;\n\tcolor = vec4(log(c) / -4.61, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(--1.0, (((true ? 0.0 : -1.0) * 0.0) / ((true ? true : true) ? (false ? 0.5 : 0.0) : 2.0)), -1.0, +(false ? +0.5 : +2.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
WARNING: 0:6: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(--1.0, (((true ? 0.0 : -1.0) * 0.0) / ((true ? true : true) ? (false ? 0.5 : 0.0) : 2.0)), -1.0, +(false ? +0.5 : +2.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.32608695652174
Processing this: /home/oof/webgl_cleaned/bvec4_empty_out_bvec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(out bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, false) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(out bvec4 par)
{
	set_all(par, false);
	return bvec4(true, true, true, true);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(out bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, false) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(out bvec4 par)\n{\n\tset_all(par, false);\n\treturn bvec4(true, true, true, true);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
60.32608695652174
Processing this: /home/oof/webgl_cleaned/clamp_vec3_vert_xvary_yconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec3 c = gtf_Color.rgb;
	if(c[0] > max_c) c[0] = max_c;
	if(c[0] < min_c) c[0] = min_c;
	if(c[1] > max_c) c[1] = max_c;
	if(c[1] < min_c) c[1] = min_c;
	if(c[2] > max_c) c[2] = max_c;
	if(c[2] < min_c) c[2] = min_c;
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tvec3 c = gtf_Color.rgb;\n\tif(c[0] > max_c) c[0] = max_c;\n\tif(c[0] < min_c) c[0] = min_c;\n\tif(c[1] > max_c) c[1] = max_c;\n\tif(c[1] < min_c) c[1] = min_c;\n\tif(c[2] > max_c) c[2] = max_c;\n\tif(c[2] < min_c) c[2] = min_c;\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, +1.0, 1.0, (true ? 2.0 : --1.0));

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec3 c = gtf_Color.rgb;
  if ((c[0] > max_c))
    c[0] = max_c;
  if ((c[0] < min_c))
    c[0] = min_c;
  if ((c[1] > max_c))
    c[1] = max_c;
  if ((c[1] < min_c))
    c[1] = min_c;
  if ((c[2] > max_c))
    c[2] = max_c;
  if ((c[2] < min_c))
    c[2] = min_c;
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, +1.0, 1.0, (true ? 2.0 : --1.0));

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec3 c = gtf_Color.rgb;
  if ((c[0] > max_c))
    c[0] = max_c;
  if ((c[0] < min_c))
    c[0] = min_c;
  if ((c[1] > max_c))
    c[1] = max_c;
  if ((c[1] < min_c))
    c[1] = min_c;
  if ((c[2] > max_c))
    c[2] = max_c;
  if ((c[2] < min_c))
    c[2] = min_c;
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.16260162601627
Processing this: /home/oof/webgl_cleaned/vec4_tsq_p_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.tsq;
	float p = al.p;
	vec4 a = vec4(m.t, m.s, p, m.p);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.tsq;\n\tfloat p = al.p;\n\tvec4 a = vec4(m.t, m.s, p, m.p);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color[8] = vec4(+-1.0, 0.5, 0.5, 1.0);

void main()
{
  vec4 al = color;
  vec3 m = al.tsq;
  float p = al.p;
  vec4 a = vec4(m.t , m.s , p , m.p);
  gl_FragColor = a;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: '=' : array / non-array mismatch
ERROR: 0:4: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[8] of 4-component vector of float'
ERROR: 0:8: '=' : array / non-array mismatch
ERROR: 0:8: '=' : cannot convert from 'mediump array[8] of 4-component vector of float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color[8] = vec4(+-1.0, 0.5, 0.5, 1.0);

void main()
{
  vec4 al = color;
  vec3 m = al.tsq;
  float p = al.p;
  vec4 a = vec4(m.t , m.s , p , m.p);
  gl_FragColor = a;
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/point_rasterization.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform float gtf_PointSize;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
	gl_PointSize = gtf_PointSize;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform float gtf_PointSize;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n\tgl_PointSize = gtf_PointSize;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform float gtf_PointSize;

vec4 color = vec4(+2.0, ((true ? +0.0 : -1.0) * 0.5), (0.5 * 1.0), 2.0);

void main()
{
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  gl_PointSize = gtf_PointSize;
}


As vertex? : True
SUCCESS!
60.1078167115903
Processing this: /home/oof/webgl_cleaned/array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
	b[0] = a[0];
	c[0] += d[0];
	a[0] += 1.0;
	e[0] += 1.0;
	b[1] = a[1];
	c[1] += d[1];
	a[1] += 1.0;
	e[1] += 1.0;
	b[2] = a[2];
	c[2] += d[2];
	a[2] += 1.0;
	e[2] += 1.0;
	b[3] = a[3];
	c[3] += d[3];
	a[3] += 1.0;
	e[3] += 1.0;
}
void main ()
{
	float a[4];
	float b[4];
	float c[4];
	float d[4];
	float e[4];
	float q = 0.0;
	float q2 = 0.0;
	a[0] = 1.0;
	b[0] = 2.0;
	c[0] = 3.0;
	d[0] = 4.0;
	e[0] = 1.0;
	a[1] = 1.0;
	b[1] = 2.0;
	c[1] = 3.0;
	d[1] = 4.0;
	e[1] = 1.0;
	a[2] = 1.0;
	b[2] = 2.0;
	c[2] = 3.0;
	d[2] = 4.0;
	e[2] = 1.0;
	a[3] = 1.0;
	b[3] = 2.0;
	c[3] = 3.0;
	d[3] = 4.0;
	e[3] = 1.0;
	qualifiers(a, b, c, d, e);
	if(a[0] == 1.0) q += 1.0;
	if(b[1] == 1.0) q += 2.0;
	if(c[2] == 7.0) q += 4.0;
	if(d[3] == 4.0) q2 += 1.0;
	if(e[0] == 1.0) q2 += 2.0;
	color = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])\n{\n\tb[0] = a[0];\n\tc[0] += d[0];\n\ta[0] += 1.0;\n\te[0] += 1.0;\n\tb[1] = a[1];\n\tc[1] += d[1];\n\ta[1] += 1.0;\n\te[1] += 1.0;\n\tb[2] = a[2];\n\tc[2] += d[2];\n\ta[2] += 1.0;\n\te[2] += 1.0;\n\tb[3] = a[3];\n\tc[3] += d[3];\n\ta[3] += 1.0;\n\te[3] += 1.0;\n}\nvoid main ()\n{\n\tfloat a[4];\n\tfloat b[4];\n\tfloat c[4];\n\tfloat d[4];\n\tfloat e[4];\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\ta[0] = 1.0;\n\tb[0] = 2.0;\n\tc[0] = 3.0;\n\td[0] = 4.0;\n\te[0] = 1.0;\n\ta[1] = 1.0;\n\tb[1] = 2.0;\n\tc[1] = 3.0;\n\td[1] = 4.0;\n\te[1] = 1.0;\n\ta[2] = 1.0;\n\tb[2] = 2.0;\n\tc[2] = 3.0;\n\td[2] = 4.0;\n\te[2] = 1.0;\n\ta[3] = 1.0;\n\tb[3] = 2.0;\n\tc[3] = 3.0;\n\td[3] = 4.0;\n\te[3] = 1.0;\n\tqualifiers(a, b, c, d, e);\n\tif(a[0] == 1.0) q += 1.0;\n\tif(b[1] == 1.0) q += 2.0;\n\tif(c[2] == 7.0) q += 4.0;\n\tif(d[3] == 4.0) q2 += 1.0;\n\tif(e[0] == 1.0) q2 += 2.0;\n\tcolor = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, 0.5, -1.0, 0.5, 1.0, 0.0, 0.5, +1.0, ((false ? (true ? false : true) : (true && true)) ? ((true || true) ? 0.5 : 0.0) : 0.0), ((true || false) ? 1.0 : 0.0), (0.0 / ((true || false) ? 1.0 : (false ? -1.0 : 1.0))), 0.0, --(2.0 + 0.0), (true ? 2.0 : (!false ? 0.0 : 2.0)), (false ? +(false ? 0.0 : 1.0) : 2.0), 0.5);

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4];
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  d[2] = 4.0;
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  color = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, 0.5, -1.0, 0.5, 1.0, 0.0, 0.5, +1.0, ((false ? (true ? false : true) : (true && true)) ? ((true || true) ? 0.5 : 0.0) : 0.0), ((true || false) ? 1.0 : 0.0), (0.0 / ((true || false) ? 1.0 : (false ? -1.0 : 1.0))), 0.0, --(2.0 + 0.0), (true ? 2.0 : (!false ? 0.0 : 2.0)), (false ? +(false ? 0.0 : 1.0) : 2.0), 0.5);

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4];
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  d[2] = 4.0;
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  color = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.946236559139784
Processing this: /home/oof/webgl_cleaned/mix_vec3_frag_xvary_yconsthalf_aconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 y = vec3(0.5, 0.5, 0.5);
	const vec3 a = vec3(0.5, 0.5, 0.5);
	gl_FragColor = vec4(mix(color.rgb, y, a), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 y = vec3(0.5, 0.5, 0.5);\n\tconst vec3 a = vec3(0.5, 0.5, 0.5);\n\tgl_FragColor = vec4(mix(color.rgb, y, a), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 y[4] = vec3(0.5 , 0.5 , 0.5);
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  gl_FragColor = vec4(mix(color.rgb , y , a) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:8: 'const' : cannot declare arrays of this qualifier
ERROR: 0:8: '=' : array / non-array mismatch
ERROR: 0:8: '=' : cannot convert from 'const 3-component vector of float' to 'const mediump array[4] of 3-component vector of float'
ERROR: 0:10: 'mix' : no matching overloaded function found
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 y[4] = vec3(0.5 , 0.5 , 0.5);
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  gl_FragColor = vec4(mix(color.rgb , y , a) , 1.0);
}


==============================
59.78552278820375
Processing this: /home/oof/webgl_cleaned/structcopy_mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
 mat4 a;
};
void main ()
{
	sabcd s = sabcd(mat4(12.0, 29.0, 13.0, 26.0,
			     71.0, 63.0, 90.0, 118.0,
			     128.0, 44.0, 57.0, 143.0,
			     151.0, 14.0, 15.0, 21.0 ) );
	sabcd s2 = sabcd(mat4(0.0, 0.0, 0.0, 0.0,
			     0.0, 0.0, 0.0, 0.0,
			     0.0, 0.0, 0.0, 0.0,
			     0.0, 0.0, 0.0, 0.0 ) );
	s2 = s;
	float sum=0.0;
	sum = sum + s2.a[0][0];
	sum = sum + s2.a[0][1];
	sum = sum + s2.a[0][2];
	sum = sum + s2.a[0][3];
	sum = sum + s2.a[1][0];
	sum = sum + s2.a[1][1];
	sum = sum + s2.a[1][2];
	sum = sum + s2.a[1][3];
	sum = sum + s2.a[2][0];
	sum = sum + s2.a[2][1];
	sum = sum + s2.a[2][2];
	sum = sum + s2.a[2][3];
	sum = sum + s2.a[3][0];
	sum = sum + s2.a[3][1];
	sum = sum + s2.a[3][2];
	sum = sum + s2.a[3][3];
	color = vec4( vec3(  sum / 995.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n mat4 a;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(mat4(12.0, 29.0, 13.0, 26.0,\n\t\t\t     71.0, 63.0, 90.0, 118.0,\n\t\t\t     128.0, 44.0, 57.0, 143.0,\n\t\t\t     151.0, 14.0, 15.0, 21.0 ) );\n\tsabcd s2 = sabcd(mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t     0.0, 0.0, 0.0, 0.0,\n\t\t\t     0.0, 0.0, 0.0, 0.0,\n\t\t\t     0.0, 0.0, 0.0, 0.0 ) );\n\ts2 = s;\n\tfloat sum=0.0;\n\tsum = sum + s2.a[0][0];\n\tsum = sum + s2.a[0][1];\n\tsum = sum + s2.a[0][2];\n\tsum = sum + s2.a[0][3];\n\tsum = sum + s2.a[1][0];\n\tsum = sum + s2.a[1][1];\n\tsum = sum + s2.a[1][2];\n\tsum = sum + s2.a[1][3];\n\tsum = sum + s2.a[2][0];\n\tsum = sum + s2.a[2][1];\n\tsum = sum + s2.a[2][2];\n\tsum = sum + s2.a[2][3];\n\tsum = sum + s2.a[3][0];\n\tsum = sum + s2.a[3][1];\n\tsum = sum + s2.a[3][2];\n\tsum = sum + s2.a[3][3];\n\tcolor = vec4( vec3(  sum / 995.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  mat4 a[(false ? (2.0 * -1.0) : 0.0)];
};

void main()
{
  sabcd s = sabcd(mat4(12.0 , 29.0 , 13.0 , 26.0 , 71.0 , 63.0 , 90.0 , 118.0 , 128.0 , 44.0 , 57.0 , 143.0 , 151.0 , 14.0 , 15.0 , 21.0));
  sabcd s2 = sabcd(mat4(0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  float sum = 0.0;
  sum = (sum + s2.a[0][0]);
  sum = (sum + s2.a[0][1]);
  sum = (sum + s2.a[0][2]);
  sum = (sum + s2.a[0][3]);
  sum = (sum + s2.a[1][0]);
  sum = (sum + s2.a[1][1]);
  sum = (sum + s2.a[1][2]);
  sum = (sum + s2.a[1][3]);
  sum = (sum + s2.a[2][0]);
  sum = (sum + s2.a[2][1]);
  sum = (sum + s2.a[2][2]);
  sum = (sum + s2.a[2][3]);
  sum = (sum + s2.a[3][0]);
  sum = (sum + s2.a[3][1]);
  sum = (sum + s2.a[3][2]);
  sum = (sum + s2.a[3][3]);
  color = vec4(vec3((sum / 995.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: '' : array size must be a constant integer expression
ERROR: 0:16: 'constructor' : Structure constructor arguments do not match structure fields
ERROR: 0:16: '=' : undefined operation for structs containing arrays
ERROR: 0:16: '=' : cannot convert from 'const structure 'sabcd' (symbol id 3004)' to 'structure 'sabcd' (symbol id 3004)'
ERROR: 0:17: 'constructor' : Structure constructor arguments do not match structure fields
ERROR: 0:17: '=' : undefined operation for structs containing arrays
ERROR: 0:17: '=' : cannot convert from 'const structure 'sabcd' (symbol id 3004)' to 'structure 'sabcd' (symbol id 3004)'
ERROR: 0:18: '=' : undefined operation for structs containing arrays
ERROR: 0:18: 'assign' : cannot convert from 'structure 'sabcd' (symbol id 3004)' to 'structure 'sabcd' (symbol id 3004)'
ERROR: 0:20: '=' : dimension mismatch
ERROR: 0:20: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:21: '=' : dimension mismatch
ERROR: 0:21: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:22: '=' : dimension mismatch
ERROR: 0:22: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:23: '=' : dimension mismatch
ERROR: 0:23: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:24: '[]' : array index out of range
ERROR: 0:24: '=' : dimension mismatch
ERROR: 0:24: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:25: '[]' : array index out of range
ERROR: 0:25: '=' : dimension mismatch
ERROR: 0:25: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:26: '[]' : array index out of range
ERROR: 0:26: '=' : dimension mismatch
ERROR: 0:26: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:27: '[]' : array index out of range
ERROR: 0:27: '=' : dimension mismatch
ERROR: 0:27: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:28: '[]' : array index out of range
ERROR: 0:28: '=' : dimension mismatch
ERROR: 0:28: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:29: '[]' : array index out of range
ERROR: 0:29: '=' : dimension mismatch
ERROR: 0:29: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:30: '[]' : array index out of range
ERROR: 0:30: '=' : dimension mismatch
ERROR: 0:30: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:31: '[]' : array index out of range
ERROR: 0:31: '=' : dimension mismatch
ERROR: 0:31: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:32: '[]' : array index out of range
ERROR: 0:32: '=' : dimension mismatch
ERROR: 0:32: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:33: '[]' : array index out of range
ERROR: 0:33: '=' : dimension mismatch
ERROR: 0:33: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:34: '[]' : array index out of range
ERROR: 0:34: '=' : dimension mismatch
ERROR: 0:34: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'
ERROR: 0:35: '[]' : array index out of range
ERROR: 0:35: '=' : dimension mismatch
ERROR: 0:35: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  mat4 a[(false ? (2.0 * -1.0) : 0.0)];
};

void main()
{
  sabcd s = sabcd(mat4(12.0 , 29.0 , 13.0 , 26.0 , 71.0 , 63.0 , 90.0 , 118.0 , 128.0 , 44.0 , 57.0 , 143.0 , 151.0 , 14.0 , 15.0 , 21.0));
  sabcd s2 = sabcd(mat4(0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  float sum = 0.0;
  sum = (sum + s2.a[0][0]);
  sum = (sum + s2.a[0][1]);
  sum = (sum + s2.a[0][2]);
  sum = (sum + s2.a[0][3]);
  sum = (sum + s2.a[1][0]);
  sum = (sum + s2.a[1][1]);
  sum = (sum + s2.a[1][2]);
  sum = (sum + s2.a[1][3]);
  sum = (sum + s2.a[2][0]);
  sum = (sum + s2.a[2][1]);
  sum = (sum + s2.a[2][2]);
  sum = (sum + s2.a[2][3]);
  sum = (sum + s2.a[3][0]);
  sum = (sum + s2.a[3][1]);
  sum = (sum + s2.a[3][2]);
  sum = (sum + s2.a[3][3]);
  color = vec4(vec3((sum / 995.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.62566844919787
Processing this: /home/oof/webgl_cleaned/default_textured.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 gtf_TexCoord[1];
attribute vec4 gtf_MultiTexCoord0;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
	gl_PointSize = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 gtf_TexCoord[1];\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n\tgl_PointSize = 1.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.0, -1.0, 2.0, 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0;

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  gl_PointSize = 1.0;
}


As vertex? : True
SUCCESS!
59.73333333333334
Mutations attempted: 375
Valid mutations:     224
Success rate:        59.73%
Processing this: /home/oof/webgl_cleaned/int_empty_inout_int_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(inout int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(inout int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(inout int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(inout int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.73333333333334
Processing this: /home/oof/webgl_cleaned/CorrectSwizzle1_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Normal;
uniform mat4 gtf_NormalMatrix;
void main()
{
   vec4 v = vec4(1,2,3,4);
   vec3 v3 = vec3(5,6,7);
   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);
   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Normal;\nuniform mat4 gtf_NormalMatrix;\nvoid main()\n{\n   vec4 v = vec4(1,2,3,4);\n   vec3 v3 = vec3(5,6,7);\n   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);\n   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Normal = vec4(-1.0, 1.0, 0.0, (1.0 + -(0.0 + 0.0)));

uniform mat4 gtf_NormalMatrix;

void main()
{
  vec4 v = vec4(1 , 2 , 3 , 4);
  vec3 v3 = vec3(5 , 6 , 7);
  vec4 v4 = vec4(normalize(v3.yzy).xyz.zyx , 1.0);
  gl_Position = (v4 + vec4(normalize((gtf_NormalMatrix * gtf_Normal)).xyz.zyx , v4.y));
}


As vertex? : True
SUCCESS!
59.840425531914896
Processing this: /home/oof/webgl_cleaned/lighting_diffuse.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat3 gtf_NormalMatrix;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
attribute vec3 gtf_Normal;
varying vec4 color;
vec4 Ambient;
vec4 Diffuse;
vec4 Specular;
const vec3 lightPosition = vec3(0.0, 0.0, 10.0);
const float lightAttenuationConstant = 1.0;
const float lightAttenuationLinear = 0.0;
const float lightAttenuationQuadratic = 0.0;
const vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 0.0);
vec4 lightDiffuse = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 materialAmbient = vec4(0.0, 0.0, 0.0, 1.0);
const vec4 materialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);
const vec4 materialSpecular = vec4(0.0, 0.0, 0.0, 0.0);
const float materialShininess = 20.0;
const vec4 sceneColor = vec4(0.0, 0.0, 0.0, 0.0);
void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
   float nDotVP;
   float nDotHV;
   float pf;
   float attenuation;
   float d;
   vec3  VP;
   vec3  halfVector;
   VP = lightPosition - ecPosition3;
   d = length(VP);
   VP = normalize(VP);
   attenuation = 1.0 / (lightAttenuationConstant +
       lightAttenuationLinear * d +
       lightAttenuationQuadratic * d * d);
   halfVector = normalize(VP + eye);
   nDotVP = max(0.0, dot(normal, VP));
   nDotHV = max(0.0, dot(normal, halfVector));
   if (nDotVP == 0.0)
   {
       pf = 0.0;
   }
   else
   {
       pf = pow(nDotHV, materialShininess);
   }
   Ambient  += lightAmbient * attenuation;
   Diffuse  += lightDiffuse * nDotVP * attenuation;
}
vec3 fnormal()
{
    vec3 normal = gtf_Normal * gtf_NormalMatrix;
    normal = normalize(normal);
    return vec3(0.0, 0.0, 1.0);
}
void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
    vec3 ecPosition3;
    vec3 eye;
    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;
    eye = vec3 (0.0, 0.0, 1.0);
    Ambient  = vec4 (0.0);
    Diffuse  = vec4 (0.0);
    Specular = vec4 (0.0);
	lightDiffuse = gtf_Color;
    pointLight(0, normal, eye, ecPosition3);
    color = sceneColor +
      Ambient  * materialAmbient +
      Diffuse  * materialDiffuse;
    color += Specular * materialSpecular;
    color = clamp( color, 0.0, 1.0 );
    color.a *= alphaFade;
}
void main ()
{
    vec3  transformedNormal;
    float alphaFade = 1.0;
    vec4 ecPosition = gtf_ModelViewMatrix * gtf_Vertex;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
    transformedNormal = fnormal();
    flight(transformedNormal, ecPosition, alphaFade);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat3 gtf_NormalMatrix;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nattribute vec3 gtf_Normal;\nvarying vec4 color;\nvec4 Ambient;\nvec4 Diffuse;\nvec4 Specular;\nconst vec3 lightPosition = vec3(0.0, 0.0, 10.0);\nconst float lightAttenuationConstant = 1.0;\nconst float lightAttenuationLinear = 0.0;\nconst float lightAttenuationQuadratic = 0.0;\nconst vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 lightDiffuse = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 materialAmbient = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 materialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 materialSpecular = vec4(0.0, 0.0, 0.0, 0.0);\nconst float materialShininess = 20.0;\nconst vec4 sceneColor = vec4(0.0, 0.0, 0.0, 0.0);\nvoid pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)\n{\n   float nDotVP;\n   float nDotHV;\n   float pf;\n   float attenuation;\n   float d;\n   vec3  VP;\n   vec3  halfVector;\n   VP = lightPosition - ecPosition3;\n   d = length(VP);\n   VP = normalize(VP);\n   attenuation = 1.0 / (lightAttenuationConstant +\n       lightAttenuationLinear * d +\n       lightAttenuationQuadratic * d * d);\n   halfVector = normalize(VP + eye);\n   nDotVP = max(0.0, dot(normal, VP));\n   nDotHV = max(0.0, dot(normal, halfVector));\n   if (nDotVP == 0.0)\n   {\n       pf = 0.0;\n   }\n   else\n   {\n       pf = pow(nDotHV, materialShininess);\n   }\n   Ambient  += lightAmbient * attenuation;\n   Diffuse  += lightDiffuse * nDotVP * attenuation;\n}\nvec3 fnormal()\n{\n    vec3 normal = gtf_Normal * gtf_NormalMatrix;\n    normal = normalize(normal);\n    return vec3(0.0, 0.0, 1.0);\n}\nvoid flight(in vec3 normal, in vec4 ecPosition, float alphaFade)\n{\n    vec3 ecPosition3;\n    vec3 eye;\n    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;\n    eye = vec3 (0.0, 0.0, 1.0);\n    Ambient  = vec4 (0.0);\n    Diffuse  = vec4 (0.0);\n    Specular = vec4 (0.0);\n\tlightDiffuse = gtf_Color;\n    pointLight(0, normal, eye, ecPosition3);\n    color = sceneColor +\n      Ambient  * materialAmbient +\n      Diffuse  * materialDiffuse;\n    color += Specular * materialSpecular;\n    color = clamp( color, 0.0, 1.0 );\n    color.a *= alphaFade;\n}\nvoid main ()\n{\n    vec3  transformedNormal;\n    float alphaFade = 1.0;\n    vec4 ecPosition = gtf_ModelViewMatrix * gtf_Vertex;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n    transformedNormal = fnormal();\n    flight(transformedNormal, ecPosition, alphaFade);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat3 gtf_NormalMatrix;

vec4 gtf_Vertex;

vec4 gtf_Color;

vec3 gtf_Normal;

vec4 color;

vec4 Ambient;

vec4 Diffuse;

vec4 Specular;

const vec3 lightPosition = vec3(0.0 , 0.0 , 10.0);

const float lightAttenuationConstant = 1.0;

const float lightAttenuationLinear = 0.0;

const float lightAttenuationQuadratic = 0.0;

const vec4 lightAmbient = vec4(0.0 , 0.0 , 0.0 , 0.0);

vec4 lightDiffuse = vec4(1.0 , 0.0 , 0.0 , 1.0);

const vec4 materialAmbient = vec4(0.0 , 0.0 , 0.0 , 1.0);

const vec4 materialDiffuse = vec4(1.0 , 1.0 , 1.0 , 1.0);

const vec4 materialSpecular = vec4(0.0 , 0.0 , 0.0 , 0.0);

const float materialShininess = 20.0;

const vec4 sceneColor = vec4(0.0 , 0.0 , 0.0 , 0.0);

void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
  float nDotVP;
  float nDotHV;
  float pf;
  float attenuation;
  float d;
  vec3 VP;
  vec3 halfVector;
  VP = (lightPosition - ecPosition3);
  d = length(VP);
  VP = normalize(VP);
  attenuation = (1.0 / ((lightAttenuationConstant + (lightAttenuationLinear * d)) + ((lightAttenuationQuadratic * d) * d)));
  halfVector = normalize((VP + eye));
  nDotVP = max(0.0 , dot(normal , VP));
  nDotHV = max(0.0 , dot(normal , halfVector));
  if ((nDotVP == 0.0))
  {
    pf = 0.0;
  }
  else
  {
    pf = pow(nDotHV , materialShininess);
  }
  (Ambient += (lightAmbient * attenuation));
  (Diffuse += ((lightDiffuse * nDotVP) * attenuation));
}

vec3 fnormal()
{
  vec3 normal = (gtf_Normal * gtf_NormalMatrix);
  normal = normalize(normal);
  return vec3(0.0 , 0.0 , 1.0);
}

void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
  vec3 ecPosition3;
  vec3 eye;
  ecPosition3 = (vec3(ecPosition) / ecPosition.w);
  eye = vec3(0.0 , 0.0 , 1.0);
  Ambient = vec4(0.0);
  Diffuse = vec4(0.0);
  Specular = vec4(0.0);
  lightDiffuse = gtf_Color;
  pointLight(0 , normal , eye , ecPosition3);
  color = ((sceneColor + (Ambient * materialAmbient)) + (Diffuse * materialDiffuse));
  (color += (Specular * materialSpecular));
  color = clamp(color , 0.0 , 1.0);
  (color.a *= alphaFade);
}

void main()
{
  vec3 transformedNormal;
  float alphaFade = 1.0;
  vec4 ecPosition = (gtf_ModelViewMatrix * gtf_Vertex);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  transformedNormal = fnormal();
  flight(transformedNormal , ecPosition , alphaFade);
}


As vertex? : True
SUCCESS!
59.94694960212201
Processing this: /home/oof/webgl_cleaned/fract_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 1.0));
  c = (abs((fract(c) - 0.5)) * 2.0);
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.05291005291006
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xconst2_yvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((true && (false || true)) ? 0.0 : +(false ? 1.0 : -1.0)), (!false ? 0.0 : -1.0), 0.0, (false ? (true ? -1.0 : (true ? 0.5 : 0.5)) : 0.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((pow(vec2(2.0) , (2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.15831134564644
Processing this: /home/oof/webgl_cleaned/gl_MaxFragmentUniformVectors_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(float(gl_MaxFragmentUniformVectors) / 16.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(gl_MaxFragmentUniformVectors) / 16.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(1.0, 2.0, 1.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4((float(gl_MaxFragmentUniformVectors) / 16.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.26315789473684
Processing this: /home/oof/webgl_cleaned/mat4_empty_empty_mat4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
mat4 function(mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nmat4 function(mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.26315789473684
Processing this: /home/oof/webgl_cleaned/sqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = sqrt(100.0 * gtf_Color.r);
	color = vec4(c * c / 100.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = sqrt(100.0 * gtf_Color.r);\n\tcolor = vec4(c * c / 100.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+(true ? (true ? 0.0 : 2.0) : 2.0), 1.0, ((false ? 0.0 : -1.0) / ((false ? true : false) ? 2.0 : -1.0)), 0.5, ((0.0 / -1.0) + +2.0), +-0.5, -2.0, 2.0, 2.0, ((false && (true ? false : false)) ? (0.0 + 0.5) : 2.0), 1.0, 1.0, (0.5 + -(-1.0 / 2.0)), (((false || true) ? 2.0 : (false ? 1.0 : 0.5)) - 1.0), 1.0, -(-1.0 + 1.0));

vec4 color;

void main()
{
  float c = sqrt((100.0 * gtf_Color.r));
  color = vec4(((c * c) / 100.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+(true ? (true ? 0.0 : 2.0) : 2.0), 1.0, ((false ? 0.0 : -1.0) / ((false ? true : false) ? 2.0 : -1.0)), 0.5, ((0.0 / -1.0) + +2.0), +-0.5, -2.0, 2.0, 2.0, ((false && (true ? false : false)) ? (0.0 + 0.5) : 2.0), 1.0, 1.0, (0.5 + -(-1.0 / 2.0)), (((false || true) ? 2.0 : (false ? 1.0 : 0.5)) - 1.0), 1.0, -(-1.0 + 1.0));

vec4 color;

void main()
{
  float c = sqrt((100.0 * gtf_Color.r));
  color = vec4(((c * c) / 100.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.10498687664042
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvaryyvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (color.ggg - 0.5);
	vec3 y = 2.0 * (color.bbb - 0.5);
	const float epsilon = 1.0e-4;
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		gl_FragColor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		gl_FragColor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		gl_FragColor[2] = atan(y[2], x[2]) / (2.0 * M_PI) + 0.5;
	}
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 x = 2.0 * (color.ggg - 0.5);\n\tvec3 y = 2.0 * (color.bbb - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tgl_FragColor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tgl_FragColor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[2] > epsilon || abs(y[2]) > epsilon)\n\t{\n\t\tgl_FragColor[2] = atan(y[2], x[2]) / (2.0 * M_PI) + 0.5;\n\t}\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb - 0.5));
  const float epsilon = 0.0001;
  gl_FragColor = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    gl_FragColor[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    gl_FragColor[1] = ((atan(y[1] , x[1]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[4] > epsilon) || (abs(y[2]) != epsilon)))
  {
    ivec2(7, 9) = (((2.5 * M_PI) / atan(y[2])) + 0.5);
  }
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:21: '[]' : vector field selection out of range
ERROR: 0:23: 'assign' : l-value required (can't modify a const)
ERROR: 0:23: 'assign' : cannot convert from 'mediump float' to 'const 2-component vector of int'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb - 0.5));
  const float epsilon = 0.0001;
  gl_FragColor = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    gl_FragColor[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    gl_FragColor[1] = ((atan(y[1] , x[1]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[4] > epsilon) || (abs(y[2]) != epsilon)))
  {
    ivec2(7, 9) = (((2.5 * M_PI) / atan(y[2])) + 0.5);
  }
}


==============================
59.947643979057595
Processing this: /home/oof/webgl_cleaned/distance_float_vert_xvaryyhalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(distance(gtf_Color.r, 0.5)), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(distance(gtf_Color.r, 0.5)), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4(vec3(distance(gtf_Color.r , 0.5)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.052219321148826
Mutations attempted: 383
Valid mutations:     230
Success rate:        60.05%
Processing this: /home/oof/webgl_cleaned/reflect_float_frag_ivarynconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (color.g + 1.0) / 2.0;
	float v2 = (color.b + 1.0) / 2.0;
	gl_FragColor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (color.g + 1.0) / 2.0;\n\tfloat v2 = (color.b + 1.0) / 2.0;\n\tgl_FragColor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g + 1.0) / 2.0);
  float v2 = ((color.b + 1.0) / 2.0);
  gl_FragColor = (true ? 1.0 : (false ? 2.0 : 1.0))((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: 'gl_FragColor' : undeclared identifier
ERROR: 0:11: 'assign' : l-value required (can't modify a const)
ERROR: 0:11: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g + 1.0) / 2.0);
  float v2 = ((color.b + 1.0) / 2.0);
  gl_FragColor = (true ? 1.0 : (false ? 2.0 : 1.0))((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0);
}


==============================
59.895833333333336
Processing this: /home/oof/webgl_cleaned/smoothstep_float_frag_xvary_edgeconstquarter_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float edge0 = 0.25;
	const float edge1 = 0.75;
	float c = clamp((color.r - edge0) / (edge1 - edge0), 0.0, 1.0);
	gl_FragColor = vec4(c * c * (3.0 - 2.0 * c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge0 = 0.25;\n\tconst float edge1 = 0.75;\n\tfloat c = clamp((color.r - edge0) / (edge1 - edge0), 0.0, 1.0);\n\tgl_FragColor = vec4(c * c * (3.0 - 2.0 * c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float edge0 = 0.25;
  const float edge1 = 0.75;
  float c = clamp(((color.r - edge0) / (edge1 - edge0)) , 0.0 , 1.0);
  gl_FragColor = vec4(((c * c) * (3.0 - (2.0 * c))) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/atan_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 4.0 * 2.0 * (gtf_Color.rg - 0.5);
	vec2 atan_c = vec2(0.0);
	vec2 scale = vec2(1.0);
	vec2 sign = vec2(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	if(c[0] < 0.0)
	{
		sign[0] = -1.0;
		c[0] *= -1.0;
	}
	if(c[0] <= 1.0)
	{
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * atan_c[0] / M_PI + 0.5;
	}
	else
	{
		c[0] = 1.0 / c[0];
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;
	}
	if(c[1] < 0.0)
	{
		sign[1] = -1.0;
		c[1] *= -1.0;
	}
	if(c[1] <= 1.0)
	{
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * atan_c[1] / M_PI + 0.5;
	}
	else
	{
		c[1] = 1.0 / c[1];
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 4.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tvec2 atan_c = vec2(0.0);\n\tvec2 scale = vec2(1.0);\n\tvec2 sign = vec2(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(c[0] < 0.0)\n\t{\n\t\tsign[0] = -1.0;\n\t\tc[0] *= -1.0;\n\t}\n\tif(c[0] <= 1.0)\n\t{\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * atan_c[0] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[0] = 1.0 / c[0];\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;\n\t}\n\tif(c[1] < 0.0)\n\t{\n\t\tsign[1] = -1.0;\n\t\tc[1] *= -1.0;\n\t}\n\tif(c[1] <= 1.0)\n\t{\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * atan_c[1] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[1] = 1.0 / c[1];\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((false ? -1.0 : 0.5), 0.0, ((true ? 0.5 : 0.5) * (0.5 * (true ? 2.0 : 0.0))), (1.0 / +-0.0), 2.0, (1.0 / (false ? 0.0 : (true ? -1.0 : 2.0))), (0.5 * ((-1.0 - -1.0) * 0.5)), 0.5, +(1.0 / (2.0 - 0.0)), +((true ? 0.5 : 2.0) + -1.0), 0.5, 0.0, (((true ? -1.0 : -1.0) * -0.0) - 2.0), 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((4.0 * 2.0) * (gtf_Color.rg - 0.5));
  vec2 atan_c = vec2(0.0);
  vec2 scale = vec2(1.0);
  vec2 sign = vec2(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((false ? -1.0 : 0.5), 0.0, ((true ? 0.5 : 0.5) * (0.5 * (true ? 2.0 : 0.0))), (1.0 / +-0.0), 2.0, (1.0 / (false ? 0.0 : (true ? -1.0 : 2.0))), (0.5 * ((-1.0 - -1.0) * 0.5)), 0.5, +(1.0 / (2.0 - 0.0)), +((true ? 0.5 : 2.0) + -1.0), 0.5, 0.0, (((true ? -1.0 : -1.0) * -0.0) - 2.0), 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((4.0 * 2.0) * (gtf_Color.rg - 0.5));
  vec2 atan_c = vec2(0.0);
  vec2 scale = vec2(1.0);
  vec2 sign = vec2(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.84455958549223
Processing this: /home/oof/webgl_cleaned/reflect_float_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (color.g + 1.0) / 2.0;
	float v2 = (color.b + 1.0) / 2.0;
	gl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (color.g + 1.0) / 2.0;\n\tfloat v2 = (color.b + 1.0) / 2.0;\n\tgl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (!(false ? false : false) ? 0.0 : (1.0 - 0.0)), ((!true || true) ? -(-1.0 * -1.0) : -1.0), 0.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g + 1.0) / 2.0);
  float v2 = ((color.b + 1.0) / 2.0);
  gl_FragColor = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.9483204134367
Processing this: /home/oof/webgl_cleaned/mod_vec2_vert_xvary_yconst1.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(mod(c, 1.0), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(mod(c, 1.0), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix[3] = mat4(-1.0, -(false ? (1.0 * -1.0) : (0.0 * 0.0)), 2.0, (0.0 / (true ? (2.0 / 0.0) : --1.0)), 0.0, (false ? -0.5 : -1.0), (((false && false) ? 0.5 : 0.5) + 0.0), (((false ? true : false) ? false : !false) ? (true ? (2.0 / 2.0) : -1.0) : 2.0), (1.0 - ((false ? true : true) ? +0.5 : (true ? 1.0 : 0.0))), ((true ? (0.0 / 1.0) : -1.0) + -(true ? 2.0 : 1.0)), (false ? 2.0 : (2.0 / (-1.0 + -1.0))), (1.0 * (-1.0 - -2.0)), 0.0, (false ? ((true ? -1.0 : -1.0) * 2.0) : ((false ? -1.0 : -1.0) + (true ? 2.0 : -1.0))), 0.5, ((!true ? (false ? true : false) : true) ? 0.0 : (2.0 + 0.0)));

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(mod(c , 1.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 
ERROR: 0:16: '*' : array / non-array mismatch
ERROR: 0:16: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump array[3] of 4X4 matrix of float' and a right operand of type 'mediump 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:16: '=' : array / non-array mismatch
ERROR: 0:16: 'assign' : cannot convert from 'uniform mediump array[3] of 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix[3] = mat4(-1.0, -(false ? (1.0 * -1.0) : (0.0 * 0.0)), 2.0, (0.0 / (true ? (2.0 / 0.0) : --1.0)), 0.0, (false ? -0.5 : -1.0), (((false && false) ? 0.5 : 0.5) + 0.0), (((false ? true : false) ? false : !false) ? (true ? (2.0 / 2.0) : -1.0) : 2.0), (1.0 - ((false ? true : true) ? +0.5 : (true ? 1.0 : 0.0))), ((true ? (0.0 / 1.0) : -1.0) + -(true ? 2.0 : 1.0)), (false ? 2.0 : (2.0 / (-1.0 + -1.0))), (1.0 * (-1.0 - -2.0)), 0.0, (false ? ((true ? -1.0 : -1.0) * 2.0) : ((false ? -1.0 : -1.0) + (true ? 2.0 : -1.0))), 0.5, ((!true ? (false ? true : false) : true) ? 0.0 : (2.0 + 0.0)));

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(mod(c , 1.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.79381443298969
Processing this: /home/oof/webgl_cleaned/vec3_st_p_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	float k = m.p;
	vec2 n = m.st;
	vec4 a = vec4(n, k, al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tfloat k = m.p;\n\tvec2 n = m.st;\n\tvec4 a = vec4(n, k, al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  float k = m.p;
  vec2 n = m.st;
  vec4 a = vec4(n , k , al.q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.89717223650386
Processing this: /home/oof/webgl_cleaned/default.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  color = color;
}


As vertex? : False
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/struct_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec3 a;
	vec3 b;
};
void main ()
{
	sabcd s = sabcd(vec3(12.0, 29.0, 32.0), vec3(13.0, 26.0, 38.0 ) );
	color = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.b[0] + s.b[1] + s.b[2]) / 150.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec3 a;\n\tvec3 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec3(12.0, 29.0, 32.0), vec3(13.0, 26.0, 38.0 ) );\n\tcolor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.b[0] + s.b[1] + s.b[2]) / 150.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  vec3 a;
  vec3 b;
};

void main()
{
  sabcd s = sabcd(vec3(12.0 , 29.0 , 32.0) , vec3(13.0 , 26.0 , 38.0));
  color = vec4(vec3(((((((s.a[0] + s.a[1]) + s.a[2]) + s.b[0]) + s.b[1]) + s.b[2]) / 150.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.10230179028133
Processing this: /home/oof/webgl_cleaned/vec4_qspt_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.qspt;
	vec4 a = vec4(m.t, m.q, m.p, m.s);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.qspt;\n\tvec4 a = vec4(m.t, m.q, m.p, m.s);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+(+0.0 + -1.0), ((true && (true ? true : false)) ? -1.0 : -0.0), 0.0, 1.0, (true ? 1.0 : -(false ? 0.0 : 0.0)), (true ? 0.5 : ((true ? 0.0 : 1.0) - (1.0 / 0.5))), 0.0, -1.0, -1.0, 1.0, 2.0, 1.0, 0.0, 1.0, (false ? 2.0 : +0.5), 0.5);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.qspt;
  vec4 a = vec4(m.t , m.q , m.p , m.s);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+(+0.0 + -1.0), ((true && (true ? true : false)) ? -1.0 : -0.0), 0.0, 1.0, (true ? 1.0 : -(false ? 0.0 : 0.0)), (true ? 0.5 : ((true ? 0.0 : 1.0) - (1.0 / 0.5))), 0.0, -1.0, -1.0, 1.0, 2.0, 1.0, 0.0, 1.0, (false ? 2.0 : +0.5), 0.5);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.qspt;
  vec4 a = vec4(m.t , m.q , m.p , m.s);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
59.94897959183674
Processing this: /home/oof/webgl_cleaned/ivec4_empty_empty_ivec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(ivec4 par[3]);
bool is_all(const in ivec4 par, const in int value);
bool is_all(const in ivec4 array[3], const in ivec4 value);
void set_all(out ivec4 array[3], const in ivec4 value);
void main ()
{
	ivec4 par[3];
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	set_all(par, ivec4(1, 1, 1, 1));
	ret = function(par);
	if(is_all(par, ivec4(1, 1, 1, 1)) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(ivec4 par[3])
{
	if(is_all(par, ivec4(1, 1, 1, 1)))
	{
		set_all(par, ivec4(0, 0, 0, 0));
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in ivec4 array[3], const in ivec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 array[3], const in ivec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(ivec4 par[3]);\nbool is_all(const in ivec4 par, const in int value);\nbool is_all(const in ivec4 array[3], const in ivec4 value);\nvoid set_all(out ivec4 array[3], const in ivec4 value);\nvoid main ()\n{\n\tivec4 par[3];\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tset_all(par, ivec4(1, 1, 1, 1));\n\tret = function(par);\n\tif(is_all(par, ivec4(1, 1, 1, 1)) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(ivec4 par[3])\n{\n\tif(is_all(par, ivec4(1, 1, 1, 1)))\n\t{\n\t\tset_all(par, ivec4(0, 0, 0, 0));\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in ivec4 array[3], const in ivec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 array[3], const in ivec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.94897959183674
Mutations attempted: 392
Valid mutations:     235
Success rate:        59.95%
Processing this: /home/oof/webgl_cleaned/dot_vec2_vert_xvaryyhalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(gtf_Color.r + gtf_Color.g) * 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(gtf_Color.r + gtf_Color.g) * 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +0.5, 2.0, 2.0, 2.0, (true ? (+2.0 + --1.0) : 1.0), (false ? -1.0 : (true ? 0.5 : 0.0)), +-1.0, 0.0, 0.0, 2.0, 0.5, (false ? (true ? (1.0 - 2.0) : 0.0) : (0.0 + (true ? 2.0 : 0.0))), (-1.0 * 0.5), 2.0, 2.0);

vec4 color;

void main()
{
  color = vec4((vec3((gtf_Color.r + gtf_Color.g)) * 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +0.5, 2.0, 2.0, 2.0, (true ? (+2.0 + --1.0) : 1.0), (false ? -1.0 : (true ? 0.5 : 0.0)), +-1.0, 0.0, 0.0, 2.0, 0.5, (false ? (true ? (1.0 - 2.0) : 0.0) : (0.0 + (true ? 2.0 : 0.0))), (-1.0 * 0.5), 2.0, 2.0);

vec4 color;

void main()
{
  color = vec4((vec3((gtf_Color.r + gtf_Color.g)) * 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.796437659033074
Processing this: /home/oof/webgl_cleaned/vec4_rg_ba_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.rg;
	vec2 n = lightloc.ba;
	vec4 a = vec4(m,n);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.rg;\n\tvec2 n = lightloc.ba;\n\tvec4 a = vec4(m,n);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-1.0 * 0.5), 0.0, (false ? 0.5 : ((true ? false : false) ? -1.0 : 2.0)), ++0.5, ((!true ? (false ? 0.5 : -1.0) : 0.0) - (!false ? 0.0 : (false ? 0.5 : 0.0))), (1.0 / (0.0 * 0.0)), 1.0, -1.0, 0.5, (((false ? 0.0 : 1.0) / (0.5 * -1.0)) * -(0.5 / 2.0)), -1.0, 0.5, -1.0, 0.0, -1.0, ((false ? 0.0 : +-1.0) / ((false ? false : false) ? -1.0 : -1.0)));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.rg;
  vec2 n = lightloc.ba;
  vec4 a = vec4(m , n);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-1.0 * 0.5), 0.0, (false ? 0.5 : ((true ? false : false) ? -1.0 : 2.0)), ++0.5, ((!true ? (false ? 0.5 : -1.0) : 0.0) - (!false ? 0.0 : (false ? 0.5 : 0.0))), (1.0 / (0.0 * 0.0)), 1.0, -1.0, 0.5, (((false ? 0.0 : 1.0) / (0.5 * -1.0)) * -(0.5 / 2.0)), -1.0, 0.5, -1.0, 0.0, -1.0, ((false ? 0.0 : +-1.0) / ((false ? false : false) ? -1.0 : -1.0)));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.rg;
  vec2 n = lightloc.ba;
  vec4 a = vec4(m , n);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
59.64467005076142
Processing this: /home/oof/webgl_cleaned/2f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec2 color;
void main ()
{
	gl_FragColor = vec4 (color, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec2 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec2 color;

void main()
{
  ivec2(4, 2) = vec4(color , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a const)
ERROR: 0:8: 'assign' : cannot convert from 'const 4-component vector of float' to 'const 2-component vector of int'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec2 color;

void main()
{
  ivec2(4, 2) = vec4(color , 0.0);
}


==============================
59.49367088607595
Processing this: /home/oof/webgl_cleaned/log2_float_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r + 0.01) / 1.01;
	color = vec4(log2(c) / -8.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r + 0.01) / 1.01;\n\tcolor = vec4(log2(c) / -8.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((2.0 / (true ? 2.0 : (false ? -1.0 : 0.0))), (+0.0 + -(true ? -1.0 : 1.0)), 0.5, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((gtf_Color.r + 0.01) / 1.01);
  color = vec4((log2(c) / -8.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.59595959595959
Processing this: /home/oof/webgl_cleaned/struct_mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
 mat2 a;
};
void main ()
{
	sabcd s = sabcd(mat2(12.0, 29.0, 13.0, 26.0) );
	color = vec4( vec3(  (s.a[0][0] + s.a[0][1] + s.a[1][0] + s.a[1][1]) / 80.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n mat2 a;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(mat2(12.0, 29.0, 13.0, 26.0) );\n\tcolor = vec4( vec3(  (s.a[0][0] + s.a[0][1] + s.a[1][0] + s.a[1][1]) / 80.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 color;

struct sabcd {
  mat2 a;
};

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  sabcd s = sabcd(mat2(12.0 , 29.0 , 13.0 , 26.0));
  color = vec4(vec3(((((s.a[0][0] + s.a[0][1]) + s.a[1][0]) + s.a[1][1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(s.a, 5);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:19: 'constructor' : too many arguments

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 color;

struct sabcd {
  mat2 a;
};

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  sabcd s = sabcd(mat2(12.0 , 29.0 , 13.0 , 26.0));
  color = vec4(vec3(((((s.a[0][0] + s.a[0][1]) + s.a[1][0]) + s.a[1][1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(s.a, 5);
}


==============================
59.44584382871536
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 16.0 * color.r;
	gl_FragColor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 16.0 * color.r;\n\tgl_FragColor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, ((true ? false : (true ? false : true)) ? 1.0 : (1.0 * -1.0)), 0.5, (true ? 1.0 : 0.0));

void main()
{
  float c = (16.0 * color.r);
  gl_FragColor = vec4((sqrt(c) / 4.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.54773869346733
Processing this: /home/oof/webgl_cleaned/tan_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 0.5 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);
	vec3 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;
	else
		o.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;
	else
		o.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;
	if(abs(c.b) < 0.5)
		o.b = 0.5 * (sin(c.b) / cos(c.b)) + 0.5;
	else
		o.b = 0.5 * (cos(c.b) / sin(c.b)) + 0.5;
	color = vec4(o, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 0.5 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;\n\telse\n\t\to.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;\n\telse\n\t\to.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;\n\tif(abs(c.b) < 0.5)\n\t\to.b = 0.5 * (sin(c.b) / cos(c.b)) + 0.5;\n\telse\n\t\to.b = 0.5 * (cos(c.b) / sin(c.b)) + 0.5;\n\tcolor = vec4(o, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 2.0, -1.0, 0.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (gtf_Color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * (sin(c.r) / cos(c.r))) + 0.5);
  else
    o.r = ((0.5 * (cos(c.r) / sin(c.r))) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * (sin(c.g) / cos(c.g))) + 0.5);
  else
    o.g = ((0.5 * (cos(c.g) / sin(c.g))) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * (sin(c.b) / cos(c.b))) + 0.5);
  else
    o.b = ((0.5 * (cos(c.b) / sin(c.b))) + 0.5);
  color = vec4(o , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.64912280701754
Processing this: /home/oof/webgl_cleaned/abs_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 2.0 * (color.r - 0.5);
	if(c < 0.0) c *= -1.0;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (color.r - 0.5);\n\tif(c < 0.0) c *= -1.0;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, -1.0, 0.0, 1.0);

void main()
{
  float c = (2.0 * (color.r - 0.5));
  if ((c < 0.0))
    (c *= -1.0);
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.75
Processing this: /home/oof/webgl_cleaned/const_mat3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0, 2.0, 3.0,
	                     4.0, 5.0, 6.0,
	                     7.0, 8.0, 9.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[0][2] != 3.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 5.0) elms = false;
	if(a[1][2] != 6.0) elms = false;
	if(a[2][0] != 7.0) elms = false;
	if(a[2][1] != 8.0) elms = false;
	if(a[2][2] != 9.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0];
	if( x < 12.0-0.1 || x > 12.0+0.1 ) rows = false;
	x = a[0][1] + a[1][1] + a[2][1];
	if(x < 15.0-0.1 || x > 15.0+0.1 ) rows = false;
	x = a[0][2] + a[1][2] + a[2][2];
	if(x < 18.0-0.1 || x > 18.0+0.1 ) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2];
	if( x < 6.0-0.1 || x > 6.0+0.1 ) cols = false;
	x = a[1][0] + a[1][1] + a[1][2];
	if(x < 15.0-0.1 || x > 15.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2];
	if(x < 24.0-0.1 || x > 24.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0, 2.0, 3.0,\n\t                     4.0, 5.0, 6.0,\n\t                     7.0, 8.0, 9.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[0][2] != 3.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 5.0) elms = false;\n\tif(a[1][2] != 6.0) elms = false;\n\tif(a[2][0] != 7.0) elms = false;\n\tif(a[2][1] != 8.0) elms = false;\n\tif(a[2][2] != 9.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0];\n\tif( x < 12.0-0.1 || x > 12.0+0.1 ) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1];\n\tif(x < 15.0-0.1 || x > 15.0+0.1 ) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2];\n\tif(x < 18.0-0.1 || x > 18.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2];\n\tif( x < 6.0-0.1 || x > 6.0+0.1 ) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2];\n\tif(x < 15.0-0.1 || x > 15.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2];\n\tif(x < 24.0-0.1 || x > 24.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[-15][-8] != 4.0))
    elms = false;
  if ((a[1][1] != 5.0))
    elms = false;
  if ((a[1][2] != 6.0))
    elms = false;
  if ((a[2][0] != 7.0))
    elms = false;
  if ((a[2][1] != 8.0))
    elms = false;
  if ((a[2][2] != 9.0))
    elms = false;
  bool rows = true;
  x = ((a[0][0] + a[1][0]) + a[2][0]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    rows = false;
  x = ((a[0][1] + a[1][1]) + a[2][1]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    rows = false;
  x = ((a[0][2] + a[1][2]) + a[2][2]);
  if (((x < (18.0 - 0.1)) || (x > (18.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((a[0][0] + a[0][1]) + a[0][2]);
  if (((x < (6.0 - 0.1)) || (x > (6.0 + 0.1))))
    cols = false;
  x = ((a[1][0] + a[1][1]) + a[1][2]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = ((a[2][0] + a[2][1]) + a[2][2]);
  if (((x < (24.0 - 0.1)) || (x > (24.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: '[]' : index expression is negative
ERROR: 0:15: '[]' : index expression is negative

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[-15][-8] != 4.0))
    elms = false;
  if ((a[1][1] != 5.0))
    elms = false;
  if ((a[1][2] != 6.0))
    elms = false;
  if ((a[2][0] != 7.0))
    elms = false;
  if ((a[2][1] != 8.0))
    elms = false;
  if ((a[2][2] != 9.0))
    elms = false;
  bool rows = true;
  x = ((a[0][0] + a[1][0]) + a[2][0]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    rows = false;
  x = ((a[0][1] + a[1][1]) + a[2][1]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    rows = false;
  x = ((a[0][2] + a[1][2]) + a[2][2]);
  if (((x < (18.0 - 0.1)) || (x > (18.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((a[0][0] + a[0][1]) + a[0][2]);
  if (((x < (6.0 - 0.1)) || (x > (6.0 + 0.1))))
    cols = false;
  x = ((a[1][0] + a[1][1]) + a[1][2]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = ((a[2][0] + a[2][1]) + a[2][2]);
  if (((x < (24.0 - 0.1)) || (x > (24.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
59.60099750623441
Processing this: /home/oof/webgl_cleaned/22i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec2 color[2];
void main ()
{
	float r = float(color[0][0]);
	float g = float(color[0][1]);
	float b = float(color[1][0]);
	float a = float(color[1][1]);
	gl_FragColor = vec4 (r/256.0, g/256.0, b/256.0, a/256.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec2 color[2];\nvoid main ()\n{\n\tfloat r = float(color[0][0]);\n\tfloat g = float(color[0][1]);\n\tfloat b = float(color[1][0]);\n\tfloat a = float(color[1][1]);\n\tgl_FragColor = vec4 (r/256.0, g/256.0, b/256.0, a/256.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec2 color[2];

void main()
{
  float r = float(color[0][0]);
  float g = -1.0;
  float b = float(color[1][0]);
  float a = float(color[1][1]);
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , (b / 256.0) , (a / 256.0));
}


As vertex? : False
SUCCESS!
59.70149253731343
Mutations attempted: 402
Valid mutations:     240
Success rate:        59.70%
Processing this: /home/oof/webgl_cleaned/logical_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
bool result = true;
	bool a = true;
	bool b = true;
	if( (a&&b) )
		result = result && true;
	else
		result = result && false;
	if( (a||b) )
		result = result && true;
	else
		result = result && false;
	if( !(a^^b) )
		result = result && true;
	else
		result = result && false;
	a = true;
	b = false;
	if( !(a&&b) )
		result = result && true;
	else
		result = result && false;
	if( (a||b) )
		result = result && true;
	else
		result = result && false;
	if( (a^^b) )
		result = result && true;
	else
		result = result && false;
	a = false;
	b = true;
	if( !(a&&b) )
		result = result && true;
	else
		result = result && false;
	if( (a||b) )
		result = result && true;
	else
		result = result && false;
	if( (a^^b) )
		result = result && true;
	else
		result = result && false;
	a = false;
	b = false;
	if( !(a&&b) )
		result = result && true;
	else
		result = result && false;
	if( !(a||b) )
		result = result && true;
	else
		result = result && false;
	if( !(a^^b) )
		result = result && true;
	else
		result = result && false;
	float gray;
	if( result )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\nbool result = true;\n\tbool a = true;\n\tbool b = true;\n\tif( (a&&b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( (a||b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( !(a^^b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\ta = true;\n\tb = false;\n\tif( !(a&&b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( (a||b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( (a^^b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\ta = false;\n\tb = true;\n\tif( !(a&&b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( (a||b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( (a^^b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\ta = false;\n\tb = false;\n\tif( !(a&&b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( !(a||b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tif( !(a^^b) )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tfloat gray;\n\tif( result )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  bool result = true;
  bool a = true;
  bool b = true;
  if ((a && b))
    result = (result && true);
  else
    result = (result && false);
  if ((a || b))
    result = (result && true);
  else
    result = (result && false);
  if (!(a ^^ b))
    result = (result && true);
  else
    result = (result && false);
  a = true;
  b = false;
  if (!(a && b))
    result = (result && true);
  else
    result = (result && false);
  if ((a || b))
    result = (result && true);
  else
    result = (result && false);
  if ((a ^^ b))
    result = (result && true);
  else
    result = (result && false);
  a = false;
  b = true;
  if (!(a && b))
    result = (result && true);
  else
    result = (result && false);
  if ((a || b))
    result = (result && true);
  else
    result = (result && false);
  if ((a ^^ b))
    result = (result && true);
  else
    result = (result && false);
  a = false;
  b = false;
  if (!(a && b))
    result = (result && true);
  else
    result = (result && false);
  if (!(a || b))
    result = (result && true);
  else
    result = (result && false);
  if (!(a ^^ b))
    result = (result && true);
  else
    result = (result && false);
  float gray;
  if (result)
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.801488833746895
Processing this: /home/oof/webgl_cleaned/3b_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform bvec3 color;
varying vec3 col;
void main ()
{
	col = vec3(color);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform bvec3 color;\nvarying vec3 col;\nvoid main ()\n{\n\tcol = vec3(color);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform bvec3 color = bvec3(-1.0, (((true ? false : true) && !true) ? ((1.0 - 2.0) - (true ? 1.0 : 2.0)) : +(false ? 1.0 : 2.0)), 1.0);

vec3 col;

void main()
{
  col = vec3(color);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform bvec3 color = bvec3(-1.0, (((true ? false : true) && !true) ? ((1.0 - 2.0) - (true ? 1.0 : 2.0)) : +(false ? 1.0 : 2.0)), 1.0);

vec3 col;

void main()
{
  col = vec3(color);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.65346534653465
Processing this: /home/oof/webgl_cleaned/structnest_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	vec2 b;
};
struct nesta
{
	vec2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec2(11, 13), nestb(vec2(12, 19) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] ) / 55.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tvec2 b;\n};\nstruct nesta\n{\n\tvec2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec2(11, 13), nestb(vec2(12, 19) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] ) / 55.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  vec2 b;
};

struct nesta {
  vec2 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec2(11 , 13) , nestb(vec2(12 , 19))));
  color = vec4(vec3(((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) / 55.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.75308641975309
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = (!(true ? false : false) ? vec4(-0.5, 0.0, 2.0, 2.0) : vec4(2.0, 1.0, (false ? (false ? 1.0 : +2.0) : +(false ? 0.5 : -1.0)), 0.0));

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.85221674876847
Processing this: /home/oof/webgl_cleaned/struct_mat3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
 mat3 a;
};
void main ()
{
	sabcd s = sabcd(mat3(12.0, 29.0, 13.0, 26.0, 71.0, 63.0, 90.0, 118.0, 128.0) );
	float sum=0.0;
	sum = sum + s.a[0][0];
	sum = sum + s.a[0][1];
	sum = sum + s.a[0][2];
	sum = sum + s.a[1][0];
	sum = sum + s.a[1][1];
	sum = sum + s.a[1][2];
	sum = sum + s.a[2][0];
	sum = sum + s.a[2][1];
	sum = sum + s.a[2][2];
	color = vec4( vec3(  sum / 550.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n mat3 a;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(mat3(12.0, 29.0, 13.0, 26.0, 71.0, 63.0, 90.0, 118.0, 128.0) );\n\tfloat sum=0.0;\n\tsum = sum + s.a[0][0];\n\tsum = sum + s.a[0][1];\n\tsum = sum + s.a[0][2];\n\tsum = sum + s.a[1][0];\n\tsum = sum + s.a[1][1];\n\tsum = sum + s.a[1][2];\n\tsum = sum + s.a[2][0];\n\tsum = sum + s.a[2][1];\n\tsum = sum + s.a[2][2];\n\tcolor = vec4( vec3(  sum / 550.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.5, -1.0, 0.0, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  mat3 a;
};

void main()
{
  sabcd s = sabcd(mat3(12.0 , 29.0 , 13.0 , 26.0 , 71.0 , 63.0 , 90.0 , 118.0 , 128.0));
  float sum = 0.0;
  sum = (sum + s.a[0][0]);
  sum = (sum + s.a[0][1]);
  sum = (sum + s.a[0][2]);
  sum = (sum + s.a[1][0]);
  sum = (sum + s.a[1][1]);
  sum = (sum + s.a[1][2]);
  sum = (sum + s.a[2][0]);
  sum = (sum + s.a[2][1]);
  sum = (sum + s.a[2][2]);
  color = vec4(vec3((sum / 550.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.95085995085995
Processing this: /home/oof/webgl_cleaned/mat2_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat2 m = mat2(0.5);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if((m[0][0] != 0.5))
		result = black;
	if((m[0][1] != 0.0))
		result = black;
	if((m[1][0] != 0.0))
		result = black;
	if((m[1][1] != 0.5))
		result = black;
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m = mat2(0.5);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif((m[0][0] != 0.5))\n\t\tresult = black;\n\tif((m[0][1] != 0.0))\n\t\tresult = black;\n\tif((m[1][0] != 0.0))\n\t\tresult = black;\n\tif((m[1][1] != 0.5))\n\t\tresult = black;\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat2 m = mat2(0.5);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != 0.5))
    result = black;
  if ((m[0][1] != 0.0))
    result = black;
  if ((m[1][0] != 0.0))
    result = black;
  if ((m[1][1] != 0.5))
    result = black;
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix + gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: '+' : wrong operand types - no operation '+' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:24: '=' : dimension mismatch
ERROR: 0:24: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat2 m = mat2(0.5);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != 0.5))
    result = black;
  if ((m[0][1] != 0.0))
    result = black;
  if ((m[1][0] != 0.0))
    result = black;
  if ((m[1][1] != 0.5))
    result = black;
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix + gtf_Vertex);
}


==============================
59.80392156862745
Processing this: /home/oof/webgl_cleaned/vec3_zx_y_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	float k = m.y;
	vec2 n = m.zx;
	vec4 a = vec4(n.y, k, n.x, al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tfloat k = m.y;\n\tvec2 n = m.zx;\n\tvec4 a = vec4(n.y, k, n.x, al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!true ? +(false ? 0.0 : 0.5) : +0.5), 0.5, (+(true ? -1.0 : 2.0) - (false ? (-1.0 / 2.0) : 0.5)), (true ? ((false && true) ? -1.0 : 1.0) : -1.0));

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  float k = m.y;
  vec2 n = m.zx;
  vec4 a = vec4(n.y , k , n.x , al.w);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.90220048899756
Processing this: /home/oof/webgl_cleaned/prefixdecrement_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m=23;
	int k = --m;
	float gray;
	if( (k==22) && (m==22) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m=23;\n\tint k = --m;\n\tfloat gray;\n\tif( (k==22) && (m==22) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(2.0, (true ? ((false ? 0.0 : 2.0) * +-1.0) : ((0.5 - 2.0) * 2.0)), (true ? (0.5 + (0.5 / 1.0)) : 2.0), -0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 23;
  int k = --m;
  float gray;
  if (((k == 22) && (m == 22)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/gl_FrontFacing_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
	if(gl_FrontFacing)
		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
	else
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n\tif(gl_FrontFacing)\n\t\tgl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n\telse\n\t\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  if (gl_FrontFacing)
    gl_FragColor = vec4(0.0 , 1.0 , 0.0);
  else
    gl_FragColor = vec4(1.0 , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:7: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  if (gl_FrontFacing)
    gl_FragColor = vec4(0.0 , 1.0 , 0.0);
  else
    gl_FragColor = vec4(1.0 , 0.0 , 0.0);
}


==============================
59.854014598540154
Processing this: /home/oof/webgl_cleaned/cross_vec3_frag_xvaryyconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = vec3(1.0, 0.0, 0.0);
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	gl_FragColor = vec4((cross(v1, v2) + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = vec3(1.0, 0.0, 0.0);\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tgl_FragColor = vec4((cross(v1, v2) + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = vec3(1.0 , 0.0 , 0.0);
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * color(color));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  gl_FragColor = vec4(((cross(v1 , v2) + 1.0) / 2.0) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: 'color' : function name expected

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = vec3(1.0 , 0.0 , 0.0);
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * color(color));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  gl_FragColor = vec4(((cross(v1 , v2) + 1.0) / 2.0) , 1.0);
}


==============================
59.70873786407766
Mutations attempted: 412
Valid mutations:     246
Success rate:        59.71%
Processing this: /home/oof/webgl_cleaned/distance_vec2_frag_xvaryyhalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(distance(color.rg, vec2(0.5))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(distance(color.rg, vec2(0.5))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4(-+(true ? 1.0 : 0.5), 0.5, 1.0, 2.0) = vec4(vec3(distance(color.rg , vec2(0.5))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4(-+(true ? 1.0 : 0.5), 0.5, 1.0, 2.0) = vec4(vec3(distance(color.rg , vec2(0.5))));
}


==============================
59.56416464891041
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 31.0 * gtf_Color.rgb + 1.0;
	color = vec4(log(c) / 3.466, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 31.0 * gtf_Color.rgb + 1.0;\n\tcolor = vec4(log(c) / 3.466, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-1.0, (false ? 1.0 : 2.0), -0.5, ((true ? !true : (false ? true : false)) ? 0.5 : 1.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((31.0 * gtf_Color.rgb) + 1.0);
  color = vec4((log(c) / 3.466) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.66183574879227
Processing this: /home/oof/webgl_cleaned/normalize_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -1.0, 0.0, (-1.0 + -1.0));

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  gl_FragColor = vec4(normalize(tmp_Color.rg) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.75903614457832
Processing this: /home/oof/webgl_cleaned/mat3_3vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat3 m = mat3(color.rgb, color.rgb, color.rgb);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if(m[0][0] != color.r) result = black;
	if(m[0][1] != color.g) result = black;
	if(m[0][2] != color.b) result = black;
	if(m[1][0] != color.r) result = black;
	if(m[1][1] != color.g) result = black;
	if(m[1][2] != color.b) result = black;
	if(m[2][0] != color.r) result = black;
	if(m[2][1] != color.g) result = black;
	if(m[2][2] != color.b) result = black;
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m = mat3(color.rgb, color.rgb, color.rgb);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif(m[0][0] != color.r) result = black;\n\tif(m[0][1] != color.g) result = black;\n\tif(m[0][2] != color.b) result = black;\n\tif(m[1][0] != color.r) result = black;\n\tif(m[1][1] != color.g) result = black;\n\tif(m[1][2] != color.b) result = black;\n\tif(m[2][0] != color.r) result = black;\n\tif(m[2][1] != color.g) result = black;\n\tif(m[2][2] != color.b) result = black;\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  mat3 m = mat3(color.rgb , color.rgb , color.rgb);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((0[2] != color.r))
    color = color;
  if ((m[0][1] != color.g))
    result = black;
  if ((m[0][2] != color.b))
    result = black;
  if ((m[1][0] != color.r))
    result = black;
  if ((m[1][1] != color.g))
    result = black;
  if ((m[1][2] != color.b))
    result = black;
  if ((m[2][0] != color.r))
    result = black;
  if ((m[2][1] != color.g))
    result = black;
  if ((m[2][2] != color.b))
    result = black;
  gl_FragColor = result;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: 'expression' :  left of '[' is not of type array, matrix, or vector 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  mat3 m = mat3(color.rgb , color.rgb , color.rgb);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((0[2] != color.r))
    color = color;
  if ((m[0][1] != color.g))
    result = black;
  if ((m[0][2] != color.b))
    result = black;
  if ((m[1][0] != color.r))
    result = black;
  if ((m[1][1] != color.g))
    result = black;
  if ((m[1][2] != color.b))
    result = black;
  if ((m[2][0] != color.r))
    result = black;
  if ((m[2][1] != color.g))
    result = black;
  if ((m[2][2] != color.b))
    result = black;
  gl_FragColor = result;
}


==============================
59.61538461538461
Processing this: /home/oof/webgl_cleaned/normalize_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(tmp_Color.r / length(tmp_Color.r), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(tmp_Color.r / length(tmp_Color.r), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  color = vec4(ivec2(4, (7 * (4 - +8))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  color = vec4(ivec2(4, (7 * (4 - +8))));
}


==============================
59.47242206235012
Processing this: /home/oof/webgl_cleaned/matrix2VSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (0.5 + 1.0), -1.0, 1.0);

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
59.569377990430624
Processing this: /home/oof/webgl_cleaned/vec3_stp_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.stp;
	vec4 a = vec4(m.stp,lightloc.q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.stp;\n\tvec4 a = vec4(m.stp,lightloc.q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-(1.0 + 1.0), 0.5, -(-1.0 + (-1.0 * -1.0)), 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.stp;
  vec4 a = vec4(m.stp , lightloc.q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.665871121718375
Processing this: /home/oof/webgl_cleaned/structcopy_bool_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	bool a;
	bool b;
	bool c;
	bool d;
};
void main ()
{
	sabcd s1 = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));
	sabcd s2 = sabcd(bool(0.0), bool(0.0), bool(0.0), bool(0.0));
	s2 = s1;
	float gray = 0.0;
	if( (s2.a==true) && (s2.b==false) && (s2.c == true) && (s2.d==false))
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray,gray,gray,1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tbool a;\n\tbool b;\n\tbool c;\n\tbool d;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));\n\tsabcd s2 = sabcd(bool(0.0), bool(0.0), bool(0.0), bool(0.0));\n\ts2 = s1;\n\tfloat gray = 0.0;\n\tif( (s2.a==true) && (s2.b==false) && (s2.c == true) && (s2.d==false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray,gray,gray,1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s1 = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  sabcd s2 = sabcd(bool(0.0) , bool(0.0) , bool(0.0) , bool(0.0));
  s2 = s1;
  float gray = 0.0;
  if (((((-1.0 == false) && (false == s2.b)) && (true == s2.c)) && (s2.d == false)))
    1.0 = gray;
  else
    gray = -0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:17: '==' : wrong operand types - no operation '==' exists that takes a left-hand operand of type 'const float' and a right operand of type 'const bool' (or there is no acceptable conversion)
ERROR: 0:18: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s1 = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  sabcd s2 = sabcd(bool(0.0) , bool(0.0) , bool(0.0) , bool(0.0));
  s2 = s1;
  float gray = 0.0;
  if (((((-1.0 == false) && (false == s2.b)) && (true == s2.c)) && (s2.d == false)))
    1.0 = gray;
  else
    gray = -0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
59.523809523809526
Processing this: /home/oof/webgl_cleaned/ceil_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec3 ceil_ref(vec3 x)
{
	if(x[0] != floor(x[0])) x[0] = floor(x[0]) + 1.0;
	if(x[1] != floor(x[1])) x[1] = floor(x[1]) + 1.0;
	if(x[2] != floor(x[2])) x[2] = floor(x[2]) + 1.0;
	return x;
}
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4((ceil_ref(c) + 10.0) / 20.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec3 ceil_ref(vec3 x)\n{\n\tif(x[0] != floor(x[0])) x[0] = floor(x[0]) + 1.0;\n\tif(x[1] != floor(x[1])) x[1] = floor(x[1]) + 1.0;\n\tif(x[2] != floor(x[2])) x[2] = floor(x[2]) + 1.0;\n\treturn x;\n}\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4((ceil_ref(c) + 10.0) / 20.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

vec3 ceil_ref(vec3 x)
{
  if ((x[0] != floor(x[0])))
    x[0] = (floor(x[0]) + 1.0);
  if ((x[1] != floor(x[1])))
    x[1] = (floor(x[1]) + 1.0);
  if ((x[2] != floor(x[2])))
    x[2] = (floor(x[2]) + 1.0);
  return x;
}

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil_ref(c) + 10.0) / 20.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:20: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

vec3 ceil_ref(vec3 x)
{
  if ((x[0] != floor(x[0])))
    x[0] = (floor(x[0]) + 1.0);
  if ((x[1] != floor(x[1])))
    x[1] = (floor(x[1]) + 1.0);
  if ((x[2] != floor(x[2])))
    x[2] = (floor(x[2]) + 1.0);
  return x;
}

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil_ref(c) + 10.0) / 20.0));
}


==============================
59.38242280285036
Processing this: /home/oof/webgl_cleaned/step_vec3_frag_xvary_edgeconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 edge = vec3(0.5, 0.5, 0.5);
	vec3 c = color.rgb;
	if(c[0] >= edge[0])
	{
		c[0] = 1.0;
	}
	else
	{
		c[0] = 0.0;
	}
	if(c[1] >= edge[1])
	{
		c[1] = 1.0;
	}
	else
	{
		c[1] = 0.0;
	}
	if(c[2] >= edge[2])
	{
		c[2] = 1.0;
	}
	else
	{
		c[2] = 0.0;
	}
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge = vec3(0.5, 0.5, 0.5);\n\tvec3 c = color.rgb;\n\tif(c[0] >= edge[0])\n\t{\n\t\tc[0] = 1.0;\n\t}\n\telse\n\t{\n\t\tc[0] = 0.0;\n\t}\n\tif(c[1] >= edge[1])\n\t{\n\t\tc[1] = 1.0;\n\t}\n\telse\n\t{\n\t\tc[1] = 0.0;\n\t}\n\tif(c[2] >= edge[2])\n\t{\n\t\tc[2] = 1.0;\n\t}\n\telse\n\t{\n\t\tc[2] = 0.0;\n\t}\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+((true ? false : true) ? (0.5 * 0.5) : (true ? 0.5 : 0.5)), (!true ? 0.0 : 2.0), +1.0, ((-0.0 - (false ? 0.0 : 2.0)) / -0.0));

void main()
{
  const vec3 edge = vec3(0.5 , 0.5 , 0.5);
  vec3 c = color.rgb;
  if ((c[0] >= edge[0]))
  {
    c[0] = 1.0;
  }
  else
  {
    c[0] = 0.0;
  }
  if ((c[1] >= edge[1]))
  {
    c[1] = 1.0;
  }
  else
  {
    c[1] = 0.0;
  }
  if ((c[2] >= edge[2]))
  {
    c[2] = 1.0;
  }
  else
  {
    c[2] = 0.0;
  }
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
SUCCESS!
59.47867298578199
Mutations attempted: 422
Valid mutations:     251
Success rate:        59.48%
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 ne(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(ne(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 ne(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(ne(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 ne(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] != a[0]))
    result[0] = true;
  else
    1[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
  ivec2(((false || (true ? false : false)) ? -(true ? 7 : 7) : 0), 4);
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(ne(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:18: 'assign' : l-value required (can't modify a const)
ERROR: 0:18: 'assign' : cannot convert from 'const bool' to 'const highp float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 ne(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] != a[0]))
    result[0] = true;
  else
    1[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
  ivec2(((false || (true ? false : false)) ? -(true ? 7 : 7) : 0), 4);
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(ne(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.33806146572104
Processing this: /home/oof/webgl_cleaned/acos_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	vec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 asin_c = vec2(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	gl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tvec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tvec2 weight = arrVal - floor(arrVal);\n\tvec2 asin_c = vec2(0.0);\n\tif (arr0x == 0)\n\t\tasin_c.x = lerp(asinValues[0], asinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tasin_c.x = lerp(asinValues[1], asinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tasin_c.x = lerp(asinValues[2], asinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tasin_c.x = lerp(asinValues[3], asinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tasin_c.x = lerp(asinValues[4], asinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tasin_c.x = lerp(asinValues[5], asinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tasin_c.x = lerp(asinValues[6], asinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tasin_c.x = lerp(asinValues[7], asinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tasin_c.x = lerp(asinValues[8], asinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tasin_c.x = lerp(asinValues[9], asinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tasin_c.x = lerp(asinValues[10], asinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tasin_c.x = lerp(asinValues[11], asinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tasin_c.x = lerp(asinValues[12], asinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tasin_c.x = lerp(asinValues[13], asinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tasin_c.x = lerp(asinValues[14], asinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tasin_c.x = lerp(asinValues[15], asinValues[16], weight.x);\n        else if (arr0x == 16)\n                asin_c.x = asinValues[16];\n\tif (arr0y == 0)\n\t\tasin_c.y = lerp(asinValues[0], asinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tasin_c.y = lerp(asinValues[1], asinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tasin_c.y = lerp(asinValues[2], asinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tasin_c.y = lerp(asinValues[3], asinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tasin_c.y = lerp(asinValues[4], asinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tasin_c.y = lerp(asinValues[5], asinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tasin_c.y = lerp(asinValues[6], asinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tasin_c.y = lerp(asinValues[7], asinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tasin_c.y = lerp(asinValues[8], asinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tasin_c.y = lerp(asinValues[9], asinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tasin_c.y = lerp(asinValues[10], asinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tasin_c.y = lerp(asinValues[11], asinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tasin_c.y = lerp(asinValues[12], asinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tasin_c.y = lerp(asinValues[13], asinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tasin_c.y = lerp(asinValues[14], asinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tasin_c.y = lerp(asinValues[15], asinValues[16], weight.y);\n        else if (arr0y == 16)\n                asin_c.y = asinValues[16];\n\tgl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[1] = -0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.43396226415094
Processing this: /home/oof/webgl_cleaned/array_const_mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
		             5.0,  6.0,  7.0,  8.0,
			     9.0, 10.0, 11.0, 12.0,
			    13.0, 14.0, 15.0, 16.0);
	const mat4 b = mat4(17.0, 18.0, 19.0, 20.0,
		            21.0, 22.0, 23.0, 24.0,
			    25.0, 26.0, 27.0, 28.0,
			    29.0, 30.0, 31.0, 32.0);
	mat4 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t\t             5.0,  6.0,  7.0,  8.0,\n\t\t\t     9.0, 10.0, 11.0, 12.0,\n\t\t\t    13.0, 14.0, 15.0, 16.0);\n\tconst mat4 b = mat4(17.0, 18.0, 19.0, 20.0,\n\t\t            21.0, 22.0, 23.0, 24.0,\n\t\t\t    25.0, 26.0, 27.0, 28.0,\n\t\t\t    29.0, 30.0, 31.0, 32.0);\n\tmat4 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(((true && false) ? -(false ? 0.5 : 1.0) : (false ? 1.0 : (false ? 0.5 : 0.0))), -1.0, 1.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.529411764705884
Processing this: /home/oof/webgl_cleaned/precision_specifiers.frag
Original source code: 
precision mediump float;
precision mediump int;

varying mediump vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvarying mediump vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

mediump vec4 color;

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
59.624413145539904
Processing this: /home/oof/webgl_cleaned/reflect_vec2_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	color = vec4((reflect(v1, v2) + 1.0) / 2.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tcolor = vec4((reflect(v1, v2) + 1.0) / 2.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1 = vec2(-0.5, -((true ? true : false) ? (false ? 2.0 : -1.0) : (false ? 1.0 : 1.0)));
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.71896955503513
Processing this: /home/oof/webgl_cleaned/mat2_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat2 m = mat2(gtf_Color.rg, gtf_Color.ba);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if(m[0][0] != gtf_Color.r) result = black;
	if(m[0][1] != gtf_Color.g) result = black;
	if(m[1][0] != gtf_Color.b) result = black;
	if(m[1][1] != gtf_Color.a) result = black;
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m = mat2(gtf_Color.rg, gtf_Color.ba);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif(m[0][0] != gtf_Color.r) result = black;\n\tif(m[0][1] != gtf_Color.g) result = black;\n\tif(m[1][0] != gtf_Color.b) result = black;\n\tif(m[1][1] != gtf_Color.a) result = black;\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat2 m = mat2(gtf_Color.rg , gtf_Color.ba);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != gtf_Color.r))
    result = black;
  if ((m[0][1] != gtf_Color.g))
    result = black;
  if ((m[1][0] != gtf_Color.b))
    result = black;
  if ((m[1][1] != gtf_Color.a))
    result = black;
  color = gtf_Vertex;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.813084112149525
Processing this: /home/oof/webgl_cleaned/vec4_tsqp_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.tsqp;
	vec4 a = vec4(m.t, m.s, m.q, m.p);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.tsqp;\n\tvec4 a = vec4(m.t, m.s, m.q, m.p);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.tsqp;
  vec4 a = vec4(m.t , m.s , m.q , m.p);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.90675990675991
Processing this: /home/oof/webgl_cleaned/CorrectExtension10_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
59.90675990675991
Processing this: /home/oof/webgl_cleaned/max_vec2_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 max_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(max(c, max_c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 max_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(max(c, max_c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  color = vec4(max(c , max_c) , 0.0);
  vec2 c = color.rg;
  const vec2 max_c = vec2(0.5 , 0.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'c' : undeclared identifier
ERROR: 0:8: 'max_c' : undeclared identifier
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  color = vec4(max(c , max_c) , 0.0);
  vec2 c = color.rg;
  const vec2 max_c = vec2(0.5 , 0.5);
}


==============================
59.76744186046512
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 31.0 * gtf_Color.rg + 1.0;
	color = vec4(log(c) / 3.466, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 31.0 * gtf_Color.rg + 1.0;\n\tcolor = vec4(log(c) / 3.466, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 1.0, --(false ? 2.0 : 0.0), +(0.5 / +0.5));

void main()
{
  vec2 c = ((31.0 * gtf_Color.rg) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 1.0, --(false ? 2.0 : 0.0), +(0.5 / +0.5));

void main()
{
  vec2 c = ((31.0 * gtf_Color.rg) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.62877030162414
Mutations attempted: 431
Valid mutations:     257
Success rate:        59.63%
Processing this: /home/oof/webgl_cleaned/vec3_vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 b = vec4(13.0, 53.0, 139.0, 217.0);
	vec3 a = vec3(b);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 b = vec4(13.0, 53.0, 139.0, 217.0);\n\tvec3 a = vec3(b);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, +0.5, 0.0, 2.0);

void main()
{
  vec4 b = vec4(13.0 , 53.0 , 139.0 , 217.0);
  vec3 a = vec3(b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.72222222222222
Processing this: /home/oof/webgl_cleaned/vec4_qspt_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.qspt;
	vec4 a = vec4(m.t, m.q, m.p, m.s);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.qspt;\n\tvec4 a = vec4(m.t, m.q, m.p, m.s);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, 0.0, -1.0, ((!true ? true : !true) ? 2.0 : (true ? -2.0 : (1.0 - -1.0))), -((false ? 0.0 : 0.0) + (0.5 * 1.0)), ((true ? 1.0 : -0.5) * 2.0), 2.0, 0.5, 1.0, 0.0, +-2.0, 0.5, (((false && false) ? 0.0 : -1.0) * ((false ? false : true) ? +-1.0 : 0.5)), 2.0, ((false ? 1.0 : -0.5) / 2.0));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.qspt;
  vec4 a = vec4(m.t , m.q , m.p , m.s);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, 0.0, -1.0, ((!true ? true : !true) ? 2.0 : (true ? -2.0 : (1.0 - -1.0))), -((false ? 0.0 : 0.0) + (0.5 * 1.0)), ((true ? 1.0 : -0.5) * 2.0), 2.0, 0.5, 1.0, 0.0, +-2.0, 0.5, (((false && false) ? 0.0 : -1.0) * ((false ? false : true) ? +-1.0 : 0.5)), 2.0, ((false ? 1.0 : -0.5) / 2.0));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.qspt;
  vec4 a = vec4(m.t , m.q , m.p , m.s);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
59.58429561200924
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg * 99.0) + 1.0;
	gl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg * 99.0) + 1.0;\n\tgl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = ((color.rg * 99.0) + 1.0);
  gl_FragColor = vec4((1.0 / sqrt(c)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.67741935483871
Processing this: /home/oof/webgl_cleaned/pow_vec3_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 4.0 * (gtf_Color.rgb);
	color = vec4(c * c / 4.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 4.0 * (gtf_Color.rgb);\n\tcolor = vec4(c * c / 4.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, ((0.0 / --1.0) - 0.5), ((true ? false : false) ? 0.0 : 2.0), 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (4.0 * gtf_Color.rgb);
  color = vec4(((c * c) / 4.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, ((0.0 / --1.0) - 0.5), ((true ? false : false) ? 0.0 : 2.0), 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (4.0 * gtf_Color.rgb);
  color = vec4(((c * c) / 4.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.54022988505747
Processing this: /home/oof/webgl_cleaned/clamp_vec2_frag_xvary_yconstquarter_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.25, 0.25);
	const vec2 max_c = vec2(0.75, 0.75);
	vec2 c = color.rg;
	if(c[0] < min_c[0]) c[0] = min_c[0];
	if(c[1] < min_c[1]) c[1] = min_c[1];
	if(c[0] > max_c[0]) c[0] = max_c[0];
	if(c[1] > max_c[1]) c[1] = max_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.25, 0.25);\n\tconst vec2 max_c = vec2(0.75, 0.75);\n\tvec2 c = color.rg;\n\tif(c[0] < min_c[0]) c[0] = min_c[0];\n\tif(c[1] < min_c[1]) c[1] = min_c[1];\n\tif(c[0] > max_c[0]) c[0] = max_c[0];\n\tif(c[1] > max_c[1]) c[1] = max_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 0.0, ((!false ? false : !true) ? (1.0 / 0.0) : ((false && false) ? (true ? 0.5 : 0.5) : (-1.0 - 0.0))), -0.5);

void main()
{
  const vec2 min_c = vec2(0.25 , 0.25);
  const vec2 max_c = vec2(0.75 , 0.75);
  vec2 c = color.rg;
  if ((c[0] < min_c[0]))
    c[0] = min_c[0];
  if ((c[1] < min_c[1]))
    c[1] = min_c[1];
  if ((c[0] > max_c[0]))
    c[0] = max_c[0];
  if ((c[1] > max_c[1]))
    c[1] = max_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.63302752293578
Processing this: /home/oof/webgl_cleaned/equal_vec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 eq(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] == b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(eq(c, vec3(0.0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 eq(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] == b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(eq(c, vec3(0.0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 eq(in vec3 a, in vec3 b)
{
  return result;
  if ((vec3(2.0, 0.0, 0.5) == b[1]))
    result[1] = true;
  else
    b[1] = false;
  bvec3 result;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(eq(c , vec3(0.0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'result' : undeclared identifier
ERROR: 0:8: 'return' : function return is not matching type:
ERROR: 0:9: '==' : dimension mismatch
ERROR: 0:9: '==' : wrong operand types - no operation '==' exists that takes a left-hand operand of type 'const 3-component vector of float' and a right operand of type 'mediump float' (or there is no acceptable conversion)
ERROR: 0:10: 'result' : undeclared identifier
ERROR: 0:10: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:10: 'assign' : l-value required (can't modify a const)
ERROR: 0:10: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:12: 'assign' : cannot convert from 'const bool' to 'mediump float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec3 eq(in vec3 a, in vec3 b)
{
  return result;
  if ((vec3(2.0, 0.0, 0.5) == b[1]))
    result[1] = true;
  else
    b[1] = false;
  bvec3 result;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(eq(c , vec3(0.0)));
  gl_FragColor = vec4(result , 1.0);
}


==============================
59.49656750572082
Processing this: /home/oof/webgl_cleaned/acos_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	vec3 acos_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	if(c.r < 0.0)
	{
		sign.r = -1.0;
		c.r *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.r += scale.r * pow(c.r, float(i)) / float(i);
		scale.r *= float(i) / float(i + 1);
	}
	acos_c.r = M_PI / 2.0 - sign.r * acos_c.r;
	if(c.g < 0.0)
	{
		sign.g = -1.0;
		c.g *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.g += scale.g * pow(c.g, float(i)) / float(i);
		scale.g *= float(i) / float(i + 1);
	}
	acos_c.g = M_PI / 2.0 - sign.g * acos_c.g;
	if(c.b < 0.0)
	{
		sign.b = -1.0;
		c.b *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.b += scale.b * pow(c.b, float(i)) / float(i);
		scale.b *= float(i) / float(i + 1);
	}
	acos_c.b = M_PI / 2.0 - sign.b * acos_c.b;
	color = vec4(acos_c / M_PI, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 acos_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tif(c.r < 0.0)\n\t{\n\t\tsign.r = -1.0;\n\t\tc.r *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.r += scale.r * pow(c.r, float(i)) / float(i);\n\t\tscale.r *= float(i) / float(i + 1);\n\t}\n\tacos_c.r = M_PI / 2.0 - sign.r * acos_c.r;\n\tif(c.g < 0.0)\n\t{\n\t\tsign.g = -1.0;\n\t\tc.g *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.g += scale.g * pow(c.g, float(i)) / float(i);\n\t\tscale.g *= float(i) / float(i + 1);\n\t}\n\tacos_c.g = M_PI / 2.0 - sign.g * acos_c.g;\n\tif(c.b < 0.0)\n\t{\n\t\tsign.b = -1.0;\n\t\tc.b *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.b += scale.b * pow(c.b, float(i)) / float(i);\n\t\tscale.b *= float(i) / float(i + 1);\n\t}\n\tacos_c.b = M_PI / 2.0 - sign.b * acos_c.b;\n\tcolor = vec4(acos_c / M_PI, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  vec3 acos_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  if ((c.r < 0.0))
  {
    sign.r = -1.0;
    (c.r *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.r += ((scale.r * pow(c.r , float(i))) / float(i)));
    (scale.r *= (float(i) / float((i + 1))));
  }
  acos_c.r = ((M_PI / 2.0) - (sign.r * acos_c.r));
  if ((c.g < 0.0))
  {
    sign.g = -1.0;
    (c.g *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.g += ((scale.g * pow(c.g , float(i))) / float(i)));
    (scale.g *= (float(i) / float((i + 1))));
  }
  acos_c.g = ((M_PI / 2.0) - (sign.g * acos_c.g));
  if ((c.b < 0.0))
  {
    sign.b = -1.0;
    (c.b *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.b += ((scale.b * pow(c.b , float(i))) / float(i)));
    (scale.b *= (float(i) / float((i + 1))));
  }
  acos_c.b = ((M_PI / 2.0) - (sign.b * acos_c.b));
  color = vec4((acos_c / M_PI) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.589041095890416
Processing this: /home/oof/webgl_cleaned/notEqual_ivec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 ne(in ivec3 a, in ivec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(ne(ivec3(c), ivec3(0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 ne(in ivec3 a, in ivec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(ne(ivec3(c), ivec3(0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.0, (-1.0 / 0.5), 0.0, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 ne(in ivec3 a, in ivec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.68109339407744
Processing this: /home/oof/webgl_cleaned/structcopy_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
 mat2 a;
};
void main ()
{
	sabcd s = sabcd(mat2(12.0, 29.0, 13.0, 26.0) );
	sabcd s2 = sabcd(mat2(0.0, 0.0, 0.0, 0.0) );
	s2 = s;
	gl_FragColor =  vec4( vec3(  (s2.a[0][0] + s2.a[0][1] + s2.a[1][0] + s2.a[1][1]) / 80.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n mat2 a;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(mat2(12.0, 29.0, 13.0, 26.0) );\n\tsabcd s2 = sabcd(mat2(0.0, 0.0, 0.0, 0.0) );\n\ts2 = s;\n\tgl_FragColor =  vec4( vec3(  (s2.a[0][0] + s2.a[0][1] + s2.a[1][0] + s2.a[1][1]) / 80.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

struct sabcd {
  mat2 a;
};

void main()
{
  sabcd s = sabcd(mat2(12.0 , 29.0 , 13.0 , 26.0));
  sabcd s2 = sabcd(mat2(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  gl_FragColor = vec4(vec3(((((s2.a[0][0] + s2.a[0][1]) + s2.a[1][0]) + s2.a[1][1]) / 80.0)) , 1.0);
}


As vertex? : False
SUCCESS!
59.77272727272728
Processing this: /home/oof/webgl_cleaned/asin_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	vec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 asin_c = vec2(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	gl_FragColor = vec4(asin_c / M_PI + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tvec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tvec2 weight = arrVal - floor(arrVal);\n\tvec2 asin_c = vec2(0.0);\n\tif (arr0x == 0)\n\t\tasin_c.x = lerp(asinValues[0], asinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tasin_c.x = lerp(asinValues[1], asinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tasin_c.x = lerp(asinValues[2], asinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tasin_c.x = lerp(asinValues[3], asinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tasin_c.x = lerp(asinValues[4], asinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tasin_c.x = lerp(asinValues[5], asinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tasin_c.x = lerp(asinValues[6], asinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tasin_c.x = lerp(asinValues[7], asinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tasin_c.x = lerp(asinValues[8], asinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tasin_c.x = lerp(asinValues[9], asinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tasin_c.x = lerp(asinValues[10], asinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tasin_c.x = lerp(asinValues[11], asinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tasin_c.x = lerp(asinValues[12], asinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tasin_c.x = lerp(asinValues[13], asinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tasin_c.x = lerp(asinValues[14], asinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tasin_c.x = lerp(asinValues[15], asinValues[16], weight.x);\n        else if (arr0x == 16)\n                asin_c.x = asinValues[16];\n\tif (arr0y == 0)\n\t\tasin_c.y = lerp(asinValues[0], asinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tasin_c.y = lerp(asinValues[1], asinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tasin_c.y = lerp(asinValues[2], asinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tasin_c.y = lerp(asinValues[3], asinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tasin_c.y = lerp(asinValues[4], asinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tasin_c.y = lerp(asinValues[5], asinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tasin_c.y = lerp(asinValues[6], asinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tasin_c.y = lerp(asinValues[7], asinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tasin_c.y = lerp(asinValues[8], asinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tasin_c.y = lerp(asinValues[9], asinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tasin_c.y = lerp(asinValues[10], asinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tasin_c.y = lerp(asinValues[11], asinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tasin_c.y = lerp(asinValues[12], asinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tasin_c.y = lerp(asinValues[13], asinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tasin_c.y = lerp(asinValues[14], asinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tasin_c.y = lerp(asinValues[15], asinValues[16], weight.y);\n        else if (arr0y == 16)\n                asin_c.y = asinValues[16];\n\tgl_FragColor = vec4(asin_c / M_PI + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + (s * (b - b)));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4(((asin_c / M_PI) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.863945578231295
Mutations attempted: 441
Valid mutations:     264
Success rate:        59.86%
Processing this: /home/oof/webgl_cleaned/distance_vec3_vert_xvaryyhalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(distance(gtf_Color.rgb, vec3(0.5))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(distance(gtf_Color.rgb, vec3(0.5))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct89635 {
  float f_5567;
};

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 0.5, (!false ? ((true ? false : true) ? (-1.0 - 1.0) : 2.0) : -1.0), (((false && true) ? (false ? 0.0 : 0.5) : 2.0) + +(2.0 - 2.0)));

void main()
{
  color = vec4(vec3(distance(gtf_Color.rgb , vec3(0.5))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.95475113122172
Processing this: /home/oof/webgl_cleaned/vec3_xyz_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	vec4 a = vec4(m.xyz,al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tvec4 a = vec4(m.xyz,al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color[3] = vec4(2.0, 2.0, 1.0, 2.0);

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  vec4 a = vec4(m.xyz , al.w);
  gl_FragColor = a;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: '=' : array / non-array mismatch
ERROR: 0:4: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[3] of 4-component vector of float'
ERROR: 0:8: '=' : array / non-array mismatch
ERROR: 0:8: '=' : cannot convert from 'mediump array[3] of 4-component vector of float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color[3] = vec4(2.0, 2.0, 1.0, 2.0);

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  vec4 a = vec4(m.xyz , al.w);
  gl_FragColor = a;
}


==============================
59.81941309255079
Processing this: /home/oof/webgl_cleaned/sin_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * color.r;
	float arrVal = c * 2.546478971;
	int arr0 = int(floor(arrVal));
	float weight = arrVal - floor(arrVal);
	float sin_c = 0.0;
	if (arr0 == 0)
		sin_c = lerp(sinValues[0], sinValues[1], weight);
	else if (arr0 == 1)
		sin_c = lerp(sinValues[1], sinValues[2], weight);
	else if (arr0 == 2)
		sin_c = lerp(sinValues[2], sinValues[3], weight);
	else if (arr0 == 3)
		sin_c = lerp(sinValues[3], sinValues[4], weight);
	else if (arr0 == 4)
		sin_c = lerp(sinValues[4], sinValues[5], weight);
	else if (arr0 == 5)
		sin_c = lerp(sinValues[5], sinValues[6], weight);
	else if (arr0 == 6)
		sin_c = lerp(sinValues[6], sinValues[7], weight);
	else if (arr0 == 7)
		sin_c = lerp(sinValues[7], sinValues[8], weight);
	else if (arr0 == 8)
		sin_c = lerp(sinValues[8], sinValues[9], weight);
	else if (arr0 == 9)
		sin_c = lerp(sinValues[9], sinValues[10], weight);
	else if (arr0 == 10)
		sin_c = lerp(sinValues[10], sinValues[11], weight);
	else if (arr0 == 11)
		sin_c = lerp(sinValues[11], sinValues[12], weight);
	else if (arr0 == 12)
		sin_c = lerp(sinValues[12], sinValues[13], weight);
	else if (arr0 == 13)
		sin_c = lerp(sinValues[13], sinValues[14], weight);
	else if (arr0 == 14)
		sin_c = lerp(sinValues[14], sinValues[15], weight);
	else if (arr0 == 15)
		sin_c = lerp(sinValues[15], sinValues[16], weight);
        else if (arr0 == 16)
                sin_c = sinValues[16];
	gl_FragColor = vec4(0.5 * sin_c + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * color.r;\n\tfloat arrVal = c * 2.546478971;\n\tint arr0 = int(floor(arrVal));\n\tfloat weight = arrVal - floor(arrVal);\n\tfloat sin_c = 0.0;\n\tif (arr0 == 0)\n\t\tsin_c = lerp(sinValues[0], sinValues[1], weight);\n\telse if (arr0 == 1)\n\t\tsin_c = lerp(sinValues[1], sinValues[2], weight);\n\telse if (arr0 == 2)\n\t\tsin_c = lerp(sinValues[2], sinValues[3], weight);\n\telse if (arr0 == 3)\n\t\tsin_c = lerp(sinValues[3], sinValues[4], weight);\n\telse if (arr0 == 4)\n\t\tsin_c = lerp(sinValues[4], sinValues[5], weight);\n\telse if (arr0 == 5)\n\t\tsin_c = lerp(sinValues[5], sinValues[6], weight);\n\telse if (arr0 == 6)\n\t\tsin_c = lerp(sinValues[6], sinValues[7], weight);\n\telse if (arr0 == 7)\n\t\tsin_c = lerp(sinValues[7], sinValues[8], weight);\n\telse if (arr0 == 8)\n\t\tsin_c = lerp(sinValues[8], sinValues[9], weight);\n\telse if (arr0 == 9)\n\t\tsin_c = lerp(sinValues[9], sinValues[10], weight);\n\telse if (arr0 == 10)\n\t\tsin_c = lerp(sinValues[10], sinValues[11], weight);\n\telse if (arr0 == 11)\n\t\tsin_c = lerp(sinValues[11], sinValues[12], weight);\n\telse if (arr0 == 12)\n\t\tsin_c = lerp(sinValues[12], sinValues[13], weight);\n\telse if (arr0 == 13)\n\t\tsin_c = lerp(sinValues[13], sinValues[14], weight);\n\telse if (arr0 == 14)\n\t\tsin_c = lerp(sinValues[14], sinValues[15], weight);\n\telse if (arr0 == 15)\n\t\tsin_c = lerp(sinValues[15], sinValues[16], weight);\n        else if (arr0 == 16)\n                sin_c = sinValues[16];\n\tgl_FragColor = vec4(0.5 * sin_c + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * color.r);
  float arrVal = (c * 2.546478971);
  int arr0 = int(floor(arrVal));
  float weight = (arrVal - floor(arrVal));
  float sin_c = 0.0;
  if ((arr0 == 0))
    sin_c = lerp(sinValues[0] , sinValues[1] , weight);
  else
    if ((arr0 == 1))
      sin_c = lerp(sinValues[1] , sinValues[2] , weight);
    else
      if ((arr0 == 2))
        sin_c = lerp(sinValues[2] , sinValues[3] , weight);
      else
        if ((arr0 == 3))
          sin_c = lerp(sinValues[3] , sinValues[4] , weight);
        else
          if ((arr0 == 4))
            sin_c = lerp(sinValues[4] , sinValues[5] , weight);
          else
            if ((arr0 == 5))
              sin_c = lerp(sinValues[5] , sinValues[6] , weight);
            else
              if ((arr0 == 6))
                sin_c = lerp(sinValues[6] , sinValues[7] , weight);
              else
                if ((arr0 == 7))
                  sin_c = lerp(sinValues[7] , sinValues[8] , weight);
                else
                  if ((arr0 == 8))
                    sin_c = lerp(sinValues[8] , sinValues[9] , weight);
                  else
                    if ((arr0 == 9))
                      sin_c = lerp(sinValues[9] , sinValues[10] , weight);
                    else
                      if ((arr0 == 10))
                        sin_c = lerp(sinValues[10] , sinValues[11] , weight);
                      else
                        if ((arr0 == 11))
                          sin_c = lerp(sinValues[11] , sinValues[12] , weight);
                        else
                          if ((arr0 == 12))
                            sin_c = lerp(sinValues[12] , sinValues[13] , weight);
                          else
                            if ((arr0 == 13))
                              sin_c = lerp(sinValues[13] , sinValues[14] , weight);
                            else
                              if ((arr0 == 14))
                                sin_c = lerp(sinValues[14] , sinValues[15] , weight);
                              else
                                if ((arr0 == 15))
                                  sin_c = lerp(sinValues[15] , sinValues[16] , weight);
                                else
                                  if ((arr0 == 16))
                                    sin_c = sinValues[16];
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:87: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * color.r);
  float arrVal = (c * 2.546478971);
  int arr0 = int(floor(arrVal));
  float weight = (arrVal - floor(arrVal));
  float sin_c = 0.0;
  if ((arr0 == 0))
    sin_c = lerp(sinValues[0] , sinValues[1] , weight);
  else
    if ((arr0 == 1))
      sin_c = lerp(sinValues[1] , sinValues[2] , weight);
    else
      if ((arr0 == 2))
        sin_c = lerp(sinValues[2] , sinValues[3] , weight);
      else
        if ((arr0 == 3))
          sin_c = lerp(sinValues[3] , sinValues[4] , weight);
        else
          if ((arr0 == 4))
            sin_c = lerp(sinValues[4] , sinValues[5] , weight);
          else
            if ((arr0 == 5))
              sin_c = lerp(sinValues[5] , sinValues[6] , weight);
            else
              if ((arr0 == 6))
                sin_c = lerp(sinValues[6] , sinValues[7] , weight);
              else
                if ((arr0 == 7))
                  sin_c = lerp(sinValues[7] , sinValues[8] , weight);
                else
                  if ((arr0 == 8))
                    sin_c = lerp(sinValues[8] , sinValues[9] , weight);
                  else
                    if ((arr0 == 9))
                      sin_c = lerp(sinValues[9] , sinValues[10] , weight);
                    else
                      if ((arr0 == 10))
                        sin_c = lerp(sinValues[10] , sinValues[11] , weight);
                      else
                        if ((arr0 == 11))
                          sin_c = lerp(sinValues[11] , sinValues[12] , weight);
                        else
                          if ((arr0 == 12))
                            sin_c = lerp(sinValues[12] , sinValues[13] , weight);
                          else
                            if ((arr0 == 13))
                              sin_c = lerp(sinValues[13] , sinValues[14] , weight);
                            else
                              if ((arr0 == 14))
                                sin_c = lerp(sinValues[14] , sinValues[15] , weight);
                              else
                                if ((arr0 == 15))
                                  sin_c = lerp(sinValues[15] , sinValues[16] , weight);
                                else
                                  if ((arr0 == 16))
                                    sin_c = sinValues[16];
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 0.0);
}


==============================
59.68468468468468
Processing this: /home/oof/webgl_cleaned/vec3_grb_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec3 t = m.grb;
	vec4 a = vec4(t.g, t.r, t.b, lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec3 t = m.grb;\n\tvec4 a = vec4(t.g, t.r, t.b, lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, -1.0, (1.0 - -1.0), 0.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec3 t = m.grb;
  vec4 a = vec4(t.g , t.r , t.b , lightloc.a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.7752808988764
Processing this: /home/oof/webgl_cleaned/exp_vec3_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = -gtf_Color.rgb;
	color = vec4(exp(3.0 * c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -gtf_Color.rgb;\n\tcolor = vec4(exp(3.0 * c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-1.0, -1.0, ++0.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = -gtf_Color.rgb;
  color = vec4(exp((3.0 * c)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '++' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-1.0, -1.0, ++0.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = -gtf_Color.rgb;
  color = vec4(exp((3.0 * c)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.64125560538116
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xconst2_yvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(pow(2.0, 2.0 * c) / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(pow(2.0, 2.0 * c) / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? 1.0 : -1.0), 1.0, 0.0, -1.0);

void main()
{
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = vec4((pow(2.0 , (2.0 * c)) / 4.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.73154362416108
Processing this: /home/oof/webgl_cleaned/22f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec2 color[2];
void main ()
{
	gl_FragColor = vec4 (color[0][0], color[0][1], color[1][0], color[1][1]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec2 color[2];\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0], color[0][1], color[1][0], color[1][1]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec2 color[2] = vec2[2](vec2(0.0, -1.0), vec2(0.5, 2.0));

void main()
{
  gl_FragColor = vec4(color[0][0] , color[0][1] , color[1][0] , color[1][1]);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec2 color[2] = vec2[2](vec2(0.0, -1.0), vec2(0.5, 2.0));

void main()
{
  gl_FragColor = vec4(color[0][0] , color[0][1] , color[1][0] , color[1][1]);
}


==============================
59.59821428571429
Processing this: /home/oof/webgl_cleaned/mat4_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat4 a = mat4(   1.0,    2.0,     4.0,     8.0,
	                16.0,   32.0,    64.0,   128.0,
	               256.0,  512.0,  1024.0,  2048.0,
	              4096.0, 8192.0, 16384.0, 32768.0);
	mat4 b = a;
	bool elms = true;
	if(b[0][0] !=     1.0) elms = false;
	if(b[0][1] !=     2.0) elms = false;
	if(b[0][2] !=     4.0) elms = false;
	if(b[0][3] !=     8.0) elms = false;
	if(b[1][0] !=    16.0) elms = false;
	if(b[1][1] !=    32.0) elms = false;
	if(b[1][2] !=    64.0) elms = false;
	if(b[1][3] !=   128.0) elms = false;
	if(b[2][0] !=   256.0) elms = false;
	if(b[2][1] !=   512.0) elms = false;
	if(b[2][2] !=  1024.0) elms = false;
	if(b[2][3] !=  2048.0) elms = false;
	if(b[3][0] !=  4096.0) elms = false;
	if(b[3][1] !=  8192.0) elms = false;
	if(b[3][2] != 16384.0) elms = false;
	if(b[3][3] != 32768.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0] + b[3][0];
	if(x < 4369.0-0.1 || x > 4369.0+0.1) rows = false;
	x = b[0][1] + b[1][1] + b[2][1] + b[3][1];
	if(x < 8738.0-0.1 || x > 8738.0+0.1) rows = false;
	x = b[0][2] + b[1][2] + b[2][2] + b[3][2];
	if(x < 17476.0-0.1 || x > 17476.0+0.1) rows = false;
	x = b[0][3] + b[1][3] + b[2][3] + b[3][3];
	if(x < 34952.0-0.1 || x > 34952.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2] + b[0][3];
	if(x < 15.0-0.1 || x > 15.0+0.1) cols = false;
	x = b[1][0] + b[1][1] + b[1][2] + b[1][3];
	if(x < 240.0-0.1 || x > 240.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2] + b[2][3];
	if(x < 3840.0-0.1 || x > 3840.0+0.1) cols = false;
	x = b[3][0] + b[3][1] + b[3][2] + b[3][3];
	if(x < 61440.0-0.1 || x > 61440.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat4 a = mat4(   1.0,    2.0,     4.0,     8.0,\n\t                16.0,   32.0,    64.0,   128.0,\n\t               256.0,  512.0,  1024.0,  2048.0,\n\t              4096.0, 8192.0, 16384.0, 32768.0);\n\tmat4 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=     1.0) elms = false;\n\tif(b[0][1] !=     2.0) elms = false;\n\tif(b[0][2] !=     4.0) elms = false;\n\tif(b[0][3] !=     8.0) elms = false;\n\tif(b[1][0] !=    16.0) elms = false;\n\tif(b[1][1] !=    32.0) elms = false;\n\tif(b[1][2] !=    64.0) elms = false;\n\tif(b[1][3] !=   128.0) elms = false;\n\tif(b[2][0] !=   256.0) elms = false;\n\tif(b[2][1] !=   512.0) elms = false;\n\tif(b[2][2] !=  1024.0) elms = false;\n\tif(b[2][3] !=  2048.0) elms = false;\n\tif(b[3][0] !=  4096.0) elms = false;\n\tif(b[3][1] !=  8192.0) elms = false;\n\tif(b[3][2] != 16384.0) elms = false;\n\tif(b[3][3] != 32768.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0] + b[3][0];\n\tif(x < 4369.0-0.1 || x > 4369.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1] + b[3][1];\n\tif(x < 8738.0-0.1 || x > 8738.0+0.1) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2] + b[3][2];\n\tif(x < 17476.0-0.1 || x > 17476.0+0.1) rows = false;\n\tx = b[0][3] + b[1][3] + b[2][3] + b[3][3];\n\tif(x < 34952.0-0.1 || x > 34952.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2] + b[0][3];\n\tif(x < 15.0-0.1 || x > 15.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2] + b[1][3];\n\tif(x < 240.0-0.1 || x > 240.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2] + b[2][3];\n\tif(x < 3840.0-0.1 || x > 3840.0+0.1) cols = false;\n\tx = b[3][0] + b[3][1] + b[3][2] + b[3][3];\n\tif(x < 61440.0-0.1 || x > 61440.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(---0.0, --2.0, +((true ? true : false) ? (true ? 0.0 : 2.0) : --1.0), 2.0);

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0 , 512.0 , 1024.0 , 2048.0 , 4096.0 , 8192.0 , 16384.0 , 32768.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[0][3] != 8.0))
    elms = false;
  if ((b[1][0] != 16.0))
    elms = false;
  if ((b[1][1] != 32.0))
    elms = false;
  if ((b[1][2] != 64.0))
    elms = false;
  if ((b[1][3] != 128.0))
    elms = false;
  if ((b[2][0] != 256.0))
    elms = false;
  if ((b[2][1] != 512.0))
    elms = false;
  if ((b[2][2] != 1024.0))
    elms = false;
  if ((b[2][3] != 2048.0))
    elms = false;
  if ((b[3][0] != 4096.0))
    elms = false;
  if ((b[3][1] != 8192.0))
    elms = false;
  if ((b[3][2] != 16384.0))
    elms = false;
  if ((b[3][3] != 32768.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (4369.0 - 0.1)) || (x > (4369.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (8738.0 - 0.1)) || (x > (8738.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (17476.0 - 0.1)) || (x > (17476.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (34952.0 - 0.1)) || (x > (34952.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((b[0][0] + b[0][1]) + b[0][2]) + b[0][3]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (240.0 - 0.1)) || (x > (240.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (3840.0 - 0.1)) || (x > (3840.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (61440.0 - 0.1)) || (x > (61440.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(---0.0, --2.0, +((true ? true : false) ? (true ? 0.0 : 2.0) : --1.0), 2.0);

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0 , 512.0 , 1024.0 , 2048.0 , 4096.0 , 8192.0 , 16384.0 , 32768.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[0][3] != 8.0))
    elms = false;
  if ((b[1][0] != 16.0))
    elms = false;
  if ((b[1][1] != 32.0))
    elms = false;
  if ((b[1][2] != 64.0))
    elms = false;
  if ((b[1][3] != 128.0))
    elms = false;
  if ((b[2][0] != 256.0))
    elms = false;
  if ((b[2][1] != 512.0))
    elms = false;
  if ((b[2][2] != 1024.0))
    elms = false;
  if ((b[2][3] != 2048.0))
    elms = false;
  if ((b[3][0] != 4096.0))
    elms = false;
  if ((b[3][1] != 8192.0))
    elms = false;
  if ((b[3][2] != 16384.0))
    elms = false;
  if ((b[3][3] != 32768.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (4369.0 - 0.1)) || (x > (4369.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (8738.0 - 0.1)) || (x > (8738.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (17476.0 - 0.1)) || (x > (17476.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (34952.0 - 0.1)) || (x > (34952.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((b[0][0] + b[0][1]) + b[0][2]) + b[0][3]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (240.0 - 0.1)) || (x > (240.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (3840.0 - 0.1)) || (x > (3840.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (61440.0 - 0.1)) || (x > (61440.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.46547884187082
Processing this: /home/oof/webgl_cleaned/relational_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool lessthan  = (m<k);
	bool greaterthan = (m>k);
	bool lessthanorequalto = (m <= 102);
	bool greaterthanorequalto = (k >=12);
	float gray;
	if( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool lessthan  = (m<k);\n\tbool greaterthan = (m>k);\n\tbool lessthanorequalto = (m <= 102);\n\tbool greaterthanorequalto = (k >=12);\n\tfloat gray;\n\tif( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (color >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: '>=' : wrong operand types - no operation '>=' exists that takes a left-hand operand of type 'mediump 4-component vector of float' and a right operand of type 'const int' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (color >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
59.333333333333336
Processing this: /home/oof/webgl_cleaned/distance_vec2_frag_xvaryyhalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(sqrt(pow(abs(color.r - 0.5), 2.0) + pow(abs(color.g - 0.5), 2.0))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(sqrt(pow(abs(color.r - 0.5), 2.0) + pow(abs(color.g - 0.5), 2.0))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((1.0 / (1.0 * (false ? 1.0 : 1.0))), (-(0.5 + -1.0) / (true ? 2.0 : 0.5)), 0.5, 0.5);

void main()
{
  gl_FragColor = vec4(vec3(sqrt((pow(abs((color.r - 0.5)) , 2.0) + pow(abs((color.g - 0.5)) , 2.0)))) , 1.0);
}


As vertex? : False
SUCCESS!
59.42350332594235
Mutations attempted: 451
Valid mutations:     268
Success rate:        59.42%
Processing this: /home/oof/webgl_cleaned/structnest_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct nestb
{
	vec2 b;
};
struct nesta
{
	vec2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec2(11, 13), nestb(vec2(12, 19) ) ) );
	gl_FragColor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] ) / 55.0 ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct nestb\n{\n\tvec2 b;\n};\nstruct nesta\n{\n\tvec2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec2(11, 13), nestb(vec2(12, 19) ) ) );\n\tgl_FragColor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] ) / 55.0 ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nestb {
  vec2 b;
};

struct nesta {
  vec2 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec2(11 , 13) , nestb(vec2(12 , 19))));
  gl_FragColor = vec4(vec3(((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) / 55.0)) , 1.0);
}


As vertex? : False
SUCCESS!
59.51327433628318
Processing this: /home/oof/webgl_cleaned/dFdx_frag_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -2.0, -0.0, -1.0, -1.0, 1.0, +2.0, (1.0 / 0.0), -1.0, (((true ? false : true) ? (true ? false : false) : !true) ? ((1.0 + -1.0) / (true ? 0.5 : 0.0)) : 1.0), 0.5, -(false ? +1.0 : 0.0), (true ? (!true ? -1.0 : (false ? 0.5 : 0.5)) : 0.0), (false ? 1.0 : (true ? 0.5 : -0.0)), (false ? (!false ? 1.0 : (false ? 2.0 : 2.0)) : 1.0), 0.5);

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -2.0, -0.0, -1.0, -1.0, 1.0, +2.0, (1.0 / 0.0), -1.0, (((true ? false : true) ? (true ? false : false) : !true) ? ((1.0 + -1.0) / (true ? 0.5 : 0.0)) : 1.0), 0.5, -(false ? +1.0 : 0.0), (true ? (!true ? -1.0 : (false ? 0.5 : 0.5)) : 0.0), (false ? 1.0 : (true ? 0.5 : -0.0)), (false ? (!false ? 1.0 : (false ? 2.0 : 2.0)) : 1.0), 0.5);

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.38189845474614
Processing this: /home/oof/webgl_cleaned/vec4_qs_pt_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.qs;
	vec2 n = lightloc.pt;
	vec4 a = vec4(m.t, n.t, n.s, m.s);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.qs;\n\tvec2 n = lightloc.pt;\n\tvec4 a = vec4(m.t, n.t, n.s, m.s);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.qs;
  vec2 n = lightloc.pt;
  vec4 a = vec4(m.t , n.t , n.s , m.s);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.471365638766514
Processing this: /home/oof/webgl_cleaned/ivec_tests.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform int funi1;
uniform ivec2 funi2;
uniform ivec3 funi3;
uniform ivec4 funi4;
varying vec4 color;
void main ()
{
	vec4 temp = vec4(float(funi1), float(funi2[0] + funi2[1]), float(funi3[0] + funi3[1] + funi3[2]), float(funi4[0] + funi4[1] + funi4[2] + funi4[3]));
	gl_FragColor = temp + color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform int funi1;\nuniform ivec2 funi2;\nuniform ivec3 funi3;\nuniform ivec4 funi4;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 temp = vec4(float(funi1), float(funi2[0] + funi2[1]), float(funi3[0] + funi3[1] + funi3[2]), float(funi4[0] + funi4[1] + funi4[2] + funi4[3]));\n\tgl_FragColor = temp + color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec4 funi4;

vec4 color;

uniform int funi1;

void main()
{
  vec4 temp = vec4(float(funi1) , float((funi2[0] + funi2[1])) , float(((funi3[0] + funi3[1]) + funi3[2])) , float((((funi4[0] + funi4[1]) + funi4[2]) + funi4[3])));
  gl_FragColor = (temp + color);
}

uniform ivec2 funi2;

uniform ivec3 funi3 = ivec3(funi1, funi1, -6);


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'funi2' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: 'funi2' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: 'funi3' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: 'funi3' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:12: 'funi3' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:18: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform ivec4 funi4;

vec4 color;

uniform int funi1;

void main()
{
  vec4 temp = vec4(float(funi1) , float((funi2[0] + funi2[1])) , float(((funi3[0] + funi3[1]) + funi3[2])) , float((((funi4[0] + funi4[1]) + funi4[2]) + funi4[3])));
  gl_FragColor = (temp + color);
}

uniform ivec2 funi2;

uniform ivec3 funi3 = ivec3(funi1, funi1, -6);


==============================
59.34065934065934
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 1) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.34065934065934
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	gl_FragColor = vec4(mix(color.rg, y, a), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tgl_FragColor = vec4(mix(color.rg, y, a), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  gl_FragColor = vec4(mix(color.rg , y , a) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.42982456140351
Processing this: /home/oof/webgl_cleaned/asin_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (color.r - 0.5);
	float arrVal = (c + 1.0) * 8.0;
	int arr0 = int(floor(arrVal));
	float weight = arrVal - floor(arrVal);
	float asin_c = 0.0;
	if (arr0 == 0)
		asin_c = lerp(asinValues[0], asinValues[1], weight);
	else if (arr0 == 1)
		asin_c = lerp(asinValues[1], asinValues[2], weight);
	else if (arr0 == 2)
		asin_c = lerp(asinValues[2], asinValues[3], weight);
	else if (arr0 == 3)
		asin_c = lerp(asinValues[3], asinValues[4], weight);
	else if (arr0 == 4)
		asin_c = lerp(asinValues[4], asinValues[5], weight);
	else if (arr0 == 5)
		asin_c = lerp(asinValues[5], asinValues[6], weight);
	else if (arr0 == 6)
		asin_c = lerp(asinValues[6], asinValues[7], weight);
	else if (arr0 == 7)
		asin_c = lerp(asinValues[7], asinValues[8], weight);
	else if (arr0 == 8)
		asin_c = lerp(asinValues[8], asinValues[9], weight);
	else if (arr0 == 9)
		asin_c = lerp(asinValues[9], asinValues[10], weight);
	else if (arr0 == 10)
		asin_c = lerp(asinValues[10], asinValues[11], weight);
	else if (arr0 == 11)
		asin_c = lerp(asinValues[11], asinValues[12], weight);
	else if (arr0 == 12)
		asin_c = lerp(asinValues[12], asinValues[13], weight);
	else if (arr0 == 13)
		asin_c = lerp(asinValues[13], asinValues[14], weight);
	else if (arr0 == 14)
		asin_c = lerp(asinValues[14], asinValues[15], weight);
	else if (arr0 == 15)
		asin_c = lerp(asinValues[15], asinValues[16], weight);
	else if (arr0 == 16)
		asin_c = asinValues[16];
	gl_FragColor = vec4(asin_c / M_PI + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (color.r - 0.5);\n\tfloat arrVal = (c + 1.0) * 8.0;\n\tint arr0 = int(floor(arrVal));\n\tfloat weight = arrVal - floor(arrVal);\n\tfloat asin_c = 0.0;\n\tif (arr0 == 0)\n\t\tasin_c = lerp(asinValues[0], asinValues[1], weight);\n\telse if (arr0 == 1)\n\t\tasin_c = lerp(asinValues[1], asinValues[2], weight);\n\telse if (arr0 == 2)\n\t\tasin_c = lerp(asinValues[2], asinValues[3], weight);\n\telse if (arr0 == 3)\n\t\tasin_c = lerp(asinValues[3], asinValues[4], weight);\n\telse if (arr0 == 4)\n\t\tasin_c = lerp(asinValues[4], asinValues[5], weight);\n\telse if (arr0 == 5)\n\t\tasin_c = lerp(asinValues[5], asinValues[6], weight);\n\telse if (arr0 == 6)\n\t\tasin_c = lerp(asinValues[6], asinValues[7], weight);\n\telse if (arr0 == 7)\n\t\tasin_c = lerp(asinValues[7], asinValues[8], weight);\n\telse if (arr0 == 8)\n\t\tasin_c = lerp(asinValues[8], asinValues[9], weight);\n\telse if (arr0 == 9)\n\t\tasin_c = lerp(asinValues[9], asinValues[10], weight);\n\telse if (arr0 == 10)\n\t\tasin_c = lerp(asinValues[10], asinValues[11], weight);\n\telse if (arr0 == 11)\n\t\tasin_c = lerp(asinValues[11], asinValues[12], weight);\n\telse if (arr0 == 12)\n\t\tasin_c = lerp(asinValues[12], asinValues[13], weight);\n\telse if (arr0 == 13)\n\t\tasin_c = lerp(asinValues[13], asinValues[14], weight);\n\telse if (arr0 == 14)\n\t\tasin_c = lerp(asinValues[14], asinValues[15], weight);\n\telse if (arr0 == 15)\n\t\tasin_c = lerp(asinValues[15], asinValues[16], weight);\n\telse if (arr0 == 16)\n\t\tasin_c = asinValues[16];\n\tgl_FragColor = vec4(asin_c / M_PI + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((((false ? true : false) || true) ? 0.5 : 2.0) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (color.r - 0.5));
  float arrVal = ((c + 1.0) * 8.0);
  int arr0 = int(floor(arrVal));
  float weight = (arrVal - floor(arrVal));
  float asin_c = 0.0;
  if ((arr0 == 0))
    asin_c = lerp(asinValues[0] , asinValues[1] , weight);
  else
    if ((arr0 == 1))
      asin_c = lerp(asinValues[1] , asinValues[2] , weight);
    else
      if ((arr0 == 2))
        asin_c = lerp(asinValues[2] , asinValues[3] , weight);
      else
        if ((arr0 == 3))
          asin_c = lerp(asinValues[3] , asinValues[4] , weight);
        else
          if ((arr0 == 4))
            asin_c = lerp(asinValues[4] , asinValues[5] , weight);
          else
            if ((arr0 == 5))
              asin_c = lerp(asinValues[5] , asinValues[6] , weight);
            else
              if ((arr0 == 6))
                asin_c = lerp(asinValues[6] , asinValues[7] , weight);
              else
                if ((arr0 == 7))
                  asin_c = lerp(asinValues[7] , asinValues[8] , weight);
                else
                  if ((arr0 == 8))
                    asin_c = lerp(asinValues[8] , asinValues[9] , weight);
                  else
                    if ((arr0 == 9))
                      asin_c = lerp(asinValues[9] , asinValues[10] , weight);
                    else
                      if ((arr0 == 10))
                        asin_c = lerp(asinValues[10] , asinValues[11] , weight);
                      else
                        if ((arr0 == 11))
                          asin_c = lerp(asinValues[11] , asinValues[12] , weight);
                        else
                          if ((arr0 == 12))
                            asin_c = lerp(asinValues[12] , asinValues[13] , weight);
                          else
                            if ((arr0 == 13))
                              asin_c = lerp(asinValues[13] , asinValues[14] , weight);
                            else
                              if ((arr0 == 14))
                                asin_c = lerp(asinValues[14] , asinValues[15] , weight);
                              else
                                if ((arr0 == 15))
                                  asin_c = lerp(asinValues[15] , asinValues[16] , weight);
                                else
                                  if ((arr0 == 16))
                                    asin_c = asinValues[16];
  gl_FragColor = vec4(((asin_c / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.51859956236324
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  vec4((true ? ((1.0 - 0.0) - (0.5 * 2.0)) : +-0.5), 0.0, 2.0, (!false ? 0.0 : 1.0)) = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(6, (true ? 0 : 8));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'constructor' : not enough data provided for construction
ERROR: 0:16: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  vec4((true ? ((1.0 - 0.0) - (0.5 * 2.0)) : +-0.5), 0.0, 2.0, (!false ? 0.0 : 1.0)) = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(6, (true ? 0 : 8));
}


==============================
59.388646288209614
Processing this: /home/oof/webgl_cleaned/log2_vec3_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = (color.rgb + 0.01) / 1.01;
	gl_FragColor = vec4(log2(c) / -8.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (color.rgb + 0.01) / 1.01;\n\tgl_FragColor = vec4(log2(c) / -8.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((2.0 / 1.0), (((false && false) || true) ? -(0.5 - 1.0) : 1.0), ((!true && !true) ? 0.0 : +0.5), -1.0);

void main()
{
  vec3 c = ((color.rgb + 0.01) / 1.01);
  gl_FragColor = vec4((log2(c) / -8.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.47712418300654
Processing this: /home/oof/webgl_cleaned/abs_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	if((c[0] < 0.0)) c[0] *= -1.0;
	if((c[1] < 0.0)) c[1] *= -1.0;
	if((c[2] < 0.0)) c[2] *= -1.0;
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tif((c[0] < 0.0)) c[0] *= -1.0;\n\tif((c[1] < 0.0)) c[1] *= -1.0;\n\tif((c[2] < 0.0)) c[2] *= -1.0;\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct74036 {
  ivec4 f_1216;
  bool f_7302;
};

vec4 gtf_Vertex;

vec4 gtf_Color = vec4(((!true && true) ? 2.0 : -1.0), 2.0, 2.0, (!!false ? (-2.0 - (1.0 + -1.0)) : -1.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  if ((c[2] < 0.0))
    (c[2] *= -1.0);
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.56521739130435
Mutations attempted: 460
Valid mutations:     274
Success rate:        59.57%
Processing this: /home/oof/webgl_cleaned/any_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool _any(in bvec3 a)
{
	bool temp = false;
	if(a[0]) temp = true;
	if(a[1]) temp = true;
	if(a[2]) temp = true;
	return temp;
}
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	color = vec4(vec3(_any(bvec3(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool _any(in bvec3 a)\n{\n\tbool temp = false;\n\tif(a[0]) temp = true;\n\tif(a[1]) temp = true;\n\tif(a[2]) temp = true;\n\treturn temp;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tcolor = vec4(vec3(_any(bvec3(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4((0.0 / -(-1.0 + -1.0)), (!_any(bvec3(0.5, 2.0, -1.0)) ? ((true && false) ? 2.0 : (0.0 + 0.0)) : +2.0), 1.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bool _any(in bvec3 a)
{
  bool temp = false;
  if (a[0])
    temp = true;
  if (a[1])
    temp = true;
  if (a[2])
    temp = true;
  return temp;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  color = vec4(vec3(_any(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '_any' : no matching overloaded function found
ERROR: 0:6: '!' : wrong operand type - no operation '!' exists that takes an operand of type const mediump float (or there is no acceptable conversion)
ERROR: 0:6: '' : boolean expression expected

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4((0.0 / -(-1.0 + -1.0)), (!_any(bvec3(0.5, 2.0, -1.0)) ? ((true && false) ? 2.0 : (0.0 + 0.0)) : +2.0), 1.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bool _any(in bvec3 a)
{
  bool temp = false;
  if (a[0])
    temp = true;
  if (a[1])
    temp = true;
  if (a[2])
    temp = true;
  return temp;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  color = vec4(vec3(_any(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.436008676789584
Processing this: /home/oof/webgl_cleaned/mat3arrayindirect1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform mat3 testmat3[2];
varying vec4  color;
void main()
{
	vec3 result = vec3(0.0, 0.0, 0.0);
	result += testmat3[1][0];
	result += testmat3[1][1];
	result += testmat3[1][2];
	gl_FragColor = vec4(result/2.0, 0.5);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform mat3 testmat3[2];\nvarying vec4  color;\nvoid main()\n{\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tresult += testmat3[1][0];\n\tresult += testmat3[1][1];\n\tresult += testmat3[1][2];\n\tgl_FragColor = vec4(result/2.0, 0.5);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat3 testmat3[2] = mat3[2](mat3(-1.0, 2.0, 2.0, -0.5, -1.0, -0.5, 0.5, 0.5, 1.0), mat3(1.0, 0.5, 0.5, 1.0, 1.0, -0.5, 1.0, 2.0, 0.5));

vec4 color;

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  (result += testmat3[1][0]);
  (result += testmat3[1][1]);
  (result += testmat3[1][2]);
  gl_FragColor = vec4((result / 2.0) , 0.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat3 testmat3[2] = mat3[2](mat3(-1.0, 2.0, 2.0, -0.5, -1.0, -0.5, 0.5, 0.5, 1.0), mat3(1.0, 0.5, 0.5, 1.0, 1.0, -0.5, 1.0, 2.0, 0.5));

vec4 color;

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  (result += testmat3[1][0]);
  (result += testmat3[1][1]);
  (result += testmat3[1][2]);
  gl_FragColor = vec4((result / 2.0) , 0.5);
}


==============================
59.307359307359306
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 lte(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] <= b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(lte(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 lte(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] <= b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(lte(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 1.0, -0.5, 2.0);

bvec3 lte(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] <= b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(lte(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.395248380129594
Processing this: /home/oof/webgl_cleaned/vec3_ps_t_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	float k = m.t;
	vec2 n = m.ps;
	vec4 a = vec4(n.t, k, n.s, al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tfloat k = m.t;\n\tvec2 n = m.ps;\n\tvec4 a = vec4(n.t, k, n.s, al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? 0.0 : 2.0), (true ? 0.0 : 0.0), (-(0.0 * 0.5) / 0.5), 0.0);

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  float k = m.t;
  vec2 n = m.ps;
  vec4 a = vec4(n.t , k , n.s , al.q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.48275862068966
Processing this: /home/oof/webgl_cleaned/empty_uniform_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const int array_size = 2;
uniform float new_mad2[array_size];
void main ()
{
	int i=0;
	float new_mad[array_size];
	float gray = 0.0;
	new_mad[0] = new_mad2[0];
	new_mad[1] = new_mad2[1];
	if( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst int array_size = 2;\nuniform float new_mad2[array_size];\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[array_size];\n\tfloat gray = 0.0;\n\tnew_mad[0] = new_mad2[0];\n\tnew_mad[1] = new_mad2[1];\n\tif( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const int array_size = 2;

uniform float new_mad2[array_size];

void main()
{
  int i = 0;
  float new_mad[array_size];
  float gray = 0.0;
  new_mad[0] = new_mad2[0];
  new_mad[1] = new_mad2[1];
  if (((new_mad[0] == 45.0) && (new_mad[1] == 14.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.56989247311828
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 lt(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] < b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] < b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lt(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 lt(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] < b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] < b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lt(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.0, 1.0, 0.0);

bvec2 lt(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] < b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] < b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lt(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.65665236051502
Processing this: /home/oof/webgl_cleaned/vec3_rg_b_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec2 t = m.rg;
	float k = m.b;
	vec4 a = vec4(t, k, lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec2 t = m.rg;\n\tfloat k = m.b;\n\tvec4 a = vec4(t, k, lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct45327 {
  ivec2 f_4032[4];
  mat4 f_1875;
};

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec2 t = m.rg;
  float k = m.b;
  vec4 a = vec4(t , k , lightloc.a);
  gtf_Color = color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.743040685224834
Processing this: /home/oof/webgl_cleaned/ceil_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec3 ceil_ref(vec3 x)
{
	if(x[0] != floor(x[0])) x[0] = floor(x[0]) + 1.0;
	if(x[1] != floor(x[1])) x[1] = floor(x[1]) + 1.0;
	if(x[2] != floor(x[2])) x[2] = floor(x[2]) + 1.0;
	return x;
}
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4((ceil_ref(c) + 10.0) / 20.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec3 ceil_ref(vec3 x)\n{\n\tif(x[0] != floor(x[0])) x[0] = floor(x[0]) + 1.0;\n\tif(x[1] != floor(x[1])) x[1] = floor(x[1]) + 1.0;\n\tif(x[2] != floor(x[2])) x[2] = floor(x[2]) + 1.0;\n\treturn x;\n}\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4((ceil_ref(c) + 10.0) / 20.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+(!false ? (false ? -1.0 : 1.0) : 2.0), 2.0, (!(false ? false : true) ? 2.0 : -0.0), 1.0);

vec3 ceil_ref(vec3 x)
{
  if ((x[0] != floor(x[0])))
    x[0] = (floor(x[0]) + 1.0);
  if ((x[1] != floor(x[1])))
    x[1] = (floor(x[1]) + 1.0);
  if ((x[2] != floor(x[2])))
    x[2] = (floor(x[2]) + 1.0);
  return x;
}

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil_ref(c) + 10.0) / 20.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.82905982905983
Processing this: /home/oof/webgl_cleaned/faceforward_float_frag_nvaryiconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (color.g * 2.0) - 1.0;
	float v2 = (color.b * 2.0) - 1.0;
	if(dot(v1, v2) >= 0.0) v1 *= -1.0;
	gl_FragColor = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (color.g * 2.0) - 1.0;\n\tfloat v2 = (color.b * 2.0) - 1.0;\n\tif(dot(v1, v2) >= 0.0) v1 *= -1.0;\n\tgl_FragColor = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-1.0 + 1.0), -1.0, (((true ? 2.0 : 0.5) - -1.0) / 1.0), (0.0 - -1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g * 2.0) - 1.0);
  float v2 = ((color.b * 2.0) - 1.0);
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  gl_FragColor = vec4(((v1 + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.914712153518124
Processing this: /home/oof/webgl_cleaned/2f_vert.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec2 col;
void main ()
{
	gl_FragColor = vec4 (col, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec2 col;\nvoid main ()\n{\n\tgl_FragColor = vec4 (col, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec2 col;

void main()
{
  gl_FragColor = vec4(col , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec2 col;

void main()
{
  gl_FragColor = vec4(col , 0.0);
}


==============================
59.787234042553195
Mutations attempted: 470
Valid mutations:     281
Success rate:        59.79%
Processing this: /home/oof/webgl_cleaned/dot_vec2_frag_xvaryyhalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(dot(color.rg, vec2(0.5))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(dot(color.rg, vec2(0.5))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4(vec3(dot(color.rg , vec2(0.5)))) = gl_FragColor;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4(vec3(dot(color.rg , vec2(0.5)))) = gl_FragColor;
}


==============================
59.660297239915074
Processing this: /home/oof/webgl_cleaned/asin_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	vec3 asin_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	if(c.r < 0.0)
	{
		sign.r = -1.0;
		c.r *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		asin_c.r += scale.r * pow(c.r, float(i)) / float(i);
		scale.r *= float(i) / float(i + 1);
	}
	if(c.g < 0.0)
	{
		sign.g = -1.0;
		c.g *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		asin_c.g += scale.g * pow(c.g, float(i)) / float(i);
		scale.g *= float(i) / float(i + 1);
	}
	if(c.b < 0.0)
	{
		sign.b = -1.0;
		c.b *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		asin_c.b += scale.b * pow(c.b, float(i)) / float(i);
		scale.b *= float(i) / float(i + 1);
	}
	color = vec4(sign * asin_c / M_PI + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 asin_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tif(c.r < 0.0)\n\t{\n\t\tsign.r = -1.0;\n\t\tc.r *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tasin_c.r += scale.r * pow(c.r, float(i)) / float(i);\n\t\tscale.r *= float(i) / float(i + 1);\n\t}\n\tif(c.g < 0.0)\n\t{\n\t\tsign.g = -1.0;\n\t\tc.g *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tasin_c.g += scale.g * pow(c.g, float(i)) / float(i);\n\t\tscale.g *= float(i) / float(i + 1);\n\t}\n\tif(c.b < 0.0)\n\t{\n\t\tsign.b = -1.0;\n\t\tc.b *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tasin_c.b += scale.b * pow(c.b, float(i)) / float(i);\n\t\tscale.b *= float(i) / float(i + 1);\n\t}\n\tcolor = vec4(sign * asin_c / M_PI + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -0.5, 0.5, -1.0, 0.0, -1.0, 0.0, 1.0, 0.5, -1.0, 1.0, 2.0, 2.0, 0.5, 0.0, 0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  vec3 asin_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  if ((c.r < 0.0))
  {
    sign.r = -1.0;
    (c.r *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c.r += ((scale.r * pow(c.r , float(i))) / float(i)));
    (scale.r *= (float(i) / float((i + 1))));
  }
  if ((c.g < 0.0))
  {
    sign.g = -1.0;
    (c.g *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c.g += ((scale.g * pow(c.g , float(i))) / float(i)));
    (scale.g *= (float(i) / float((i + 1))));
  }
  if ((c.b < 0.0))
  {
    sign.b = -1.0;
    (c.b *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c.b += ((scale.b * pow(c.b , float(i))) / float(i)));
    (scale.b *= (float(i) / float((i + 1))));
  }
  color = vec4((((sign * asin_c) / M_PI) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -0.5, 0.5, -1.0, 0.0, -1.0, 0.0, 1.0, 0.5, -1.0, 1.0, 2.0, 2.0, 0.5, 0.0, 0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  vec3 asin_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  if ((c.r < 0.0))
  {
    sign.r = -1.0;
    (c.r *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c.r += ((scale.r * pow(c.r , float(i))) / float(i)));
    (scale.r *= (float(i) / float((i + 1))));
  }
  if ((c.g < 0.0))
  {
    sign.g = -1.0;
    (c.g *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c.g += ((scale.g * pow(c.g , float(i))) / float(i)));
    (scale.g *= (float(i) / float((i + 1))));
  }
  if ((c.b < 0.0))
  {
    sign.b = -1.0;
    (c.b *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c.b += ((scale.b * pow(c.b , float(i))) / float(i)));
    (scale.b *= (float(i) / float((i + 1))));
  }
  color = vec4((((sign * asin_c) / M_PI) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.53389830508474
Processing this: /home/oof/webgl_cleaned/equal_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 eq(in bvec3 a, in bvec3 b)
{
	bvec3 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] == b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	vec3 result = vec3(eq(bvec3(c), bvec3(true)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 eq(in bvec3 a, in bvec3 b)\n{\n\tbvec3 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] == b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tvec3 result = vec3(eq(bvec3(c), bvec3(true)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 eq(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[1] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = vec3(eq(bvec3(c) , bvec3(true)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
59.61945031712473
Processing this: /home/oof/webgl_cleaned/step_float_vert_xvary_edgeconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float edge = 0.5;
	color = vec4(step(edge, gtf_Color.r), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge = 0.5;\n\tcolor = vec4(step(edge, gtf_Color.r), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, 0.0, +2.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float edge = 0.5;
  color = vec4(step(edge , gtf_Color.r) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.70464135021098
Processing this: /home/oof/webgl_cleaned/pow_vec3_vert_xconsthalf_yvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = -2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.0, 0.5, ((true ? true : (true ? false : true)) ? 1.0 : (2.0 + 0.5)), -(0.5 / (false ? -1.0 : 0.5)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (gtf_Color.rgb - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.78947368421053
Processing this: /home/oof/webgl_cleaned/equality_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool equalto = (m == 102);
	bool notequalto = (k != 102);
	float gray;
	if( equalto && notequalto )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool equalto = (m == 102);\n\tbool notequalto = (k != 102);\n\tfloat gray;\n\tif( equalto && notequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool equalto = (m == 102);
  bool notequalto = (k != 102);
  float gray;
  if ((equalto && notequalto))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = color(gray , gray , gray);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:17: 'gl_FragColor' : undeclared identifier
ERROR: 0:17: 'color' : function name expected
ERROR: 0:17: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool equalto = (m == 102);
  bool notequalto = (k != 102);
  float gray;
  if ((equalto && notequalto))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = color(gray , gray , gray);
}


==============================
59.66386554621849
Processing this: /home/oof/webgl_cleaned/fboShader0.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
varying vec4 texCoord[1];
varying vec4 color;
uniform mat4 gtf_ModelViewProjectionMatrix;
void main ()
{
    color = gtf_Color;
    texCoord[0] = gtf_MultiTexCoord0;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 texCoord[1];\nvarying vec4 color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid main ()\n{\n    color = gtf_Color;\n    texCoord[0] = gtf_MultiTexCoord0;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(2.0, 0.5, 0.0, 1.0);

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.74842767295597
Processing this: /home/oof/webgl_cleaned/atan_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 4.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(atan(c) / M_PI + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 4.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(atan(c) / M_PI + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((4.0 * 2.0) * (color.rg - 0.5));
  ((false ? 2.0 : 1.0) + ((0.5 + 0.5) - 1.0)) = vec4(((atan(c) / M_PI) + 0.5) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction
ERROR: 0:10: 'assign' : l-value required (can't modify a const)
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((4.0 * 2.0) * (color.rg - 0.5));
  ((false ? 2.0 : 1.0) + ((0.5 + 0.5) - 1.0)) = vec4(((atan(c) / M_PI) + 0.5) , 0.0);
}


==============================
59.62343096234309
Processing this: /home/oof/webgl_cleaned/bool_empty_out_bool_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(out bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(!par && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(out bool par)
{
	par = false;
	return true;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(out bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(!par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(out bool par)\n{\n\tpar = false;\n\treturn true;\n}\n\x00')
59.62343096234309
Processing this: /home/oof/webgl_cleaned/qualifiers_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float qualifiers(in float a, out float b, inout float c, const in float d, float e)
{
	b = a;
	c += d;
	a += 1.0;
	return e;
}
void main ()
{
	float a = 1.0, b = 2.0, c = 3.0, d = 4.0, e = 1.0, f = 0.0;
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == 1.0) q += 1.0;
	if(b == 1.0) q += 2.0;
	if(c == 7.0) q += 4.0;
	if(d == 4.0) q2 += 1.0;
	if(e == 1.0) q2 += 2.0;
	if(f == 1.0) q2 += 4.0;
	color = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat qualifiers(in float a, out float b, inout float c, const in float d, float e)\n{\n\tb = a;\n\tc += d;\n\ta += 1.0;\n\treturn e;\n}\nvoid main ()\n{\n\tfloat a = 1.0, b = 2.0, c = 3.0, d = 4.0, e = 1.0, f = 0.0;\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == 1.0) q += 1.0;\n\tif(b == 1.0) q += 2.0;\n\tif(c == 7.0) q += 4.0;\n\tif(d == 4.0) q2 += 1.0;\n\tif(e == 1.0) q2 += 2.0;\n\tif(f == 1.0) q2 += 4.0;\n\tcolor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, ((false ? -1.0 : (2.0 / 0.0)) * qualifiers(-1.0, 2.0, (true ? -1.0 : 0.5), (1.0 * -1.0), qualifiers(0.5, 2.0, 0.0, 0.5, 2.0))), +(0.0 + (false ? 0.5 : -1.0)), 2.0);

float qualifiers(in float a, out float b, inout float c, const in float d, float e)
{
  b = a;
  (c += d);
  (a += 1.0);
  return e;
}

void main()
{
  float a = 1.0 , b = 2.0 , c = 3.0 , d = 4.0 , e = 1.0 , f = 0.0;
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == 1.0))
    (q += 1.0);
  if ((b == 1.0))
    (q += 2.0);
  if ((c == 7.0))
    (q += 4.0);
  if ((d == 4.0))
    (q2 += 1.0);
  if ((e == 1.0))
    (q2 += 2.0);
  if ((f == 1.0))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'qualifiers' : no matching overloaded function found
ERROR: 0:8: 'qualifiers' : no matching overloaded function found
WARNING: 0:8: '*' : Constant folded undefined multiplication generated NaN

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, ((false ? -1.0 : (2.0 / 0.0)) * qualifiers(-1.0, 2.0, (true ? -1.0 : 0.5), (1.0 * -1.0), qualifiers(0.5, 2.0, 0.0, 0.5, 2.0))), +(0.0 + (false ? 0.5 : -1.0)), 2.0);

float qualifiers(in float a, out float b, inout float c, const in float d, float e)
{
  b = a;
  (c += d);
  (a += 1.0);
  return e;
}

void main()
{
  float a = 1.0 , b = 2.0 , c = 3.0 , d = 4.0 , e = 1.0 , f = 0.0;
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == 1.0))
    (q += 1.0);
  if ((b == 1.0))
    (q += 2.0);
  if ((c == 7.0))
    (q += 4.0);
  if ((d == 4.0))
    (q2 += 1.0);
  if ((e == 1.0))
    (q2 += 2.0);
  if ((f == 1.0))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.49895615866389
Mutations attempted: 479
Valid mutations:     285
Success rate:        59.50%
Processing this: /home/oof/webgl_cleaned/all_bvec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(4.0 * gtf_Color.rgb);
	color = vec4(vec3(all(bvec3(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(4.0 * gtf_Color.rgb);\n\tcolor = vec4(vec3(all(bvec3(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, 0.5, 0.0, -0.5, 2.0, 1.0, -1.0, -0.5, 2.0, 0.0, -1.0, 1.0, 1.0, -0.5, 0.0);

vec4 color;

void main()
{
  vec3 c = floor((4.0 * gtf_Color.rgb));
  color = vec4(vec3(all(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, 0.5, 0.0, -0.5, 2.0, 1.0, -1.0, -0.5, 2.0, 0.0, -1.0, 1.0, 1.0, -0.5, 0.0);

vec4 color;

void main()
{
  vec3 c = floor((4.0 * gtf_Color.rgb));
  color = vec4(vec3(all(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.375
Processing this: /home/oof/webgl_cleaned/exp2_float_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = -gtf_Color.r;
	color = vec4(exp2(5.0 * c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = -gtf_Color.r;\n\tcolor = vec4(exp2(5.0 * c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 1.0, (false ? 2.0 : (0.0 + (2.0 * 0.5))), -(false ? -0.5 : 2.0));

void main()
{
  float c = -gtf_Color.r;
  color = vec4(exp2((5.0 * c)) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.45945945945946
Processing this: /home/oof/webgl_cleaned/mat4_empty_empty_mat4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_ones) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_ones) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
59.45945945945946
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 1.0, 0.0, -0.5);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.54356846473029
Processing this: /home/oof/webgl_cleaned/mix_vec2_vert_xvary_yconsthalf_aconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = gtf_Color.rg;
	color = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((true ? (0.0 * 1.0) : (-1.0 + 2.0)) - 0.0), 2.0, +0.5, -((false && false) ? (true ? 0.0 : -1.0) : (true ? 0.5 : 2.0)));

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = gtf_Color.rg;
  color = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.62732919254658
Processing this: /home/oof/webgl_cleaned/pow_vec2_frag_xvary_yconst2.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 4.0 * (color.rg);
	gl_FragColor = vec4(pow(c, vec2(2.0)) / 4.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 4.0 * (color.rg);\n\tgl_FragColor = vec4(pow(c, vec2(2.0)) / 4.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 2.0, 1.0, 1.0);

void main()
{
  vec2 c = (4.0 * color.rg);
  gl_FragColor = vec4((pow(c , vec2(2.0)) / 4.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.71074380165289
Processing this: /home/oof/webgl_cleaned/dot_float_frag_xvaryyone.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(dot(color.r, 1.0)), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(dot(color.r, 1.0)), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(---1.0, 1.0, (true ? +(true ? 0.5 : 2.0) : +0.5), -1.0);

void main()
{
  gl_FragColor = vec4(vec3(dot(color.r , 1.0)) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(---1.0, 1.0, (true ? +(true ? 0.5 : 2.0) : +0.5), -1.0);

void main()
{
  gl_FragColor = vec4(vec3(dot(color.r , 1.0)) , 1.0);
}


==============================
59.58762886597938
Processing this: /home/oof/webgl_cleaned/exp_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	vec2 c = color.rg;
	gl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = color.rg;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  vec4(((true || !false) ? -+0.5 : ((true && true) ? +-1.0 : 2.0)), -2.0, 0.5, (false ? ((false && true) ? --1.0 : 0.5) : -0.5));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = color.rg;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  vec4(((true || !false) ? -+0.5 : ((true && true) ? +-1.0 : 2.0)), -2.0, 0.5, (false ? ((false && true) ? --1.0 : 0.5) : -0.5));
}


==============================
59.465020576131685
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	float s = lightloc.s;
	float t = lightloc.t;
	float p = lightloc.p;
	float q = lightloc.q;
	vec4 m = vec4(s, t, p, q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tfloat s = lightloc.s;\n\tfloat t = lightloc.t;\n\tfloat p = lightloc.p;\n\tfloat q = lightloc.q;\n\tvec4 m = vec4(s, t, p, q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 * 1.0), (2.0 * -1.0), (0.5 - 1.0), 1.0, -1.0, (false ? -1.0 : 0.0), -1.0, +0.5, 0.5, 1.0, 2.0, 0.0, 0.0, 1.0, 0.0, 0.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  float s = lightloc.s;
  float t = lightloc.t;
  float p = lightloc.p;
  float q = lightloc.q;
  vec4 m = vec4(s , t , p , q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 * 1.0), (2.0 * -1.0), (0.5 - 1.0), 1.0, -1.0, (false ? -1.0 : 0.0), -1.0, +0.5, 0.5, 1.0, 2.0, 0.0, 0.0, 1.0, 0.0, 0.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  float s = lightloc.s;
  float t = lightloc.t;
  float p = lightloc.p;
  float q = lightloc.q;
  vec4 m = vec4(s , t , p , q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


==============================
59.34291581108829
Processing this: /home/oof/webgl_cleaned/fract_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	c = abs((c - floor(c)) - 0.5) * 2.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tc = abs((c - floor(c)) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((1.0 + ((0.0 + 2.0) / (1.0 + 1.0))), (-1.0 * -(true ? -1.0 : 0.5)), 1.0, 1.0);

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (abs(((c - floor(c)) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.42622950819673
Mutations attempted: 488
Valid mutations:     290
Success rate:        59.43%
Processing this: /home/oof/webgl_cleaned/CorrectConstFolding1_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
   const struct s2 {
       int i;
       vec3 v3;
       bvec4 bv4;
   } s22  = s2(8, vec3(9, 10, 11), bvec4(true, false, true, false));
   struct s4 {
       int ii;
       vec4 v4;
      };
   const struct s1 {
      s2 ss;
      int i;
      float f;
      mat4 m;
 	s4 s44;
   } s11 = s1(s22, 2, 4.0, mat4(5), s4(6, vec4(7, 8, 9, 10))) ;
  const int field3 = s11.i * s11.ss.i;
  const vec4 field4 = s11.s44.v4 * s11.s44.v4;
  const vec4 v4 = vec4(s11.ss.v3.y, s11.m[3][3], field3, field4[2]);
  gl_Position = v4;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n   const struct s2 {\n       int i;\n       vec3 v3;\n       bvec4 bv4;\n   } s22  = s2(8, vec3(9, 10, 11), bvec4(true, false, true, false));\n   struct s4 {\n       int ii;\n       vec4 v4;\n      };\n   const struct s1 {\n      s2 ss;\n      int i;\n      float f;\n      mat4 m;\n \ts4 s44;\n   } s11 = s1(s22, 2, 4.0, mat4(5), s4(6, vec4(7, 8, 9, 10))) ;\n  const int field3 = s11.i * s11.ss.i;\n  const vec4 field4 = s11.s44.v4 * s11.s44.v4;\n  const vec4 v4 = vec4(s11.ss.v3.y, s11.m[3][3], field3, field4[2]);\n  gl_Position = v4;\n}\n\x00')
59.42622950819673
Processing this: /home/oof/webgl_cleaned/vec3_stp_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.stp;
	vec4 a = vec4(m.stp,lightloc.q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.stp;\n\tvec4 a = vec4(m.stp,lightloc.q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.0, (false ? 0.5 : 0.5), 1.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.stp;
  vec4 a = vec4(m.stp , lightloc.q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.50920245398773
Processing this: /home/oof/webgl_cleaned/DepthRange_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
	gl_FragColor = vec4(gl_DepthRange.near, gl_DepthRange.far, gl_DepthRange.diff, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n\tgl_FragColor = vec4(gl_DepthRange.near, gl_DepthRange.far, gl_DepthRange.diff, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  +(0.0 * 2.0);
  ivec2((false ? 5 : +(false ? 6 : 6)), 3);
}


As vertex? : False
SUCCESS!
59.591836734693885
Processing this: /home/oof/webgl_cleaned/vec3_xy_z_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec2 t = m.xy;
	float k = m.z;
	vec4 a = vec4(t, k, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec2 t = m.xy;\n\tfloat k = m.z;\n\tvec4 a = vec4(t, k, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct92722 {
  ivec4 f_2685;
  ivec3 f_4700[8];
  bvec4 f_9413[3];
  mat2 f_2413;
};

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, -0.5, -0.5, 0.5);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec2 t = m.xy;
  float k = m.z;
  vec4 a = vec4(t , k , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.67413441955194
Processing this: /home/oof/webgl_cleaned/bool_empty_out_bool_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(out bool par[3]);
bool is_all(const in bool array[3], const in bool value);
void set_all(out bool array[3], const in bool value);
void main ()
{
	bool par[3];
	bool ret = false;
	float gray = 0.0;
	set_all(par, true);
	ret = function(par);
	if(is_all(par, false) && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(out bool par[3])
{
	set_all(par, false);
	return true;
}
bool is_all(const in bool array[3], const in bool value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bool array[3], const in bool value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(out bool par[3]);\nbool is_all(const in bool array[3], const in bool value);\nvoid set_all(out bool array[3], const in bool value);\nvoid main ()\n{\n\tbool par[3];\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tset_all(par, true);\n\tret = function(par);\n\tif(is_all(par, false) && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(out bool par[3])\n{\n\tset_all(par, false);\n\treturn true;\n}\nbool is_all(const in bool array[3], const in bool value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bool array[3], const in bool value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.67413441955194
Processing this: /home/oof/webgl_cleaned/log_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float x = 31.0 * color.r + 1.0;
	float y = 0.0;
	float z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	gl_FragColor = vec4(y / 3.466, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = 31.0 * color.r + 1.0;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tgl_FragColor = vec4(y / 3.466, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-1.0 * 0.5), (0.5 - (true ? +1.0 : (0.0 - -1.0))), -1.0, (-(2.0 * 1.0) + -1.0));

void main()
{
  float x = ((31.0 * color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  gl_FragColor = vec4((y / 3.466) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.756097560975604
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvaryyvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float x = 2.0 * (gtf_Color.g - 0.5);
	float y = 2.0 * (gtf_Color.b - 0.5);
	const float epsilon = 1.0e-4;
	color = vec4(0.0, 0.0, 0.0, 1.0);
	if(x > epsilon || abs(y) > epsilon)
	{
		color = vec4(atan(y, x) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
	}
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat x = 2.0 * (gtf_Color.g - 0.5);\n\tfloat y = 2.0 * (gtf_Color.b - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x > epsilon || abs(y) > epsilon)\n\t{\n\t\tcolor = vec4(atan(y, x) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t}\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color[16] = vec4((0.0 + 0.0), (-1.0 / +0.0), 2.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float x = (2.0 * (gtf_Color.g - 0.5));
  float y = (2.0 * (gtf_Color.b - 0.5));
  const float epsilon = 0.0001;
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    color = vec4(((atan(y , x) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[16] of 4-component vector of float'
ERROR: 0:15: '.' : cannot apply dot operator to an array
ERROR: 0:15: '-' : array / non-array mismatch
ERROR: 0:15: '-' : wrong operand types - no operation '-' exists that takes a left-hand operand of type 'mediump array[16] of 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:15: '*' : array / non-array mismatch
ERROR: 0:15: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'const float' and a right operand of type 'mediump array[16] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:16: '.' : cannot apply dot operator to an array
ERROR: 0:16: '-' : array / non-array mismatch
ERROR: 0:16: '-' : wrong operand types - no operation '-' exists that takes a left-hand operand of type 'mediump array[16] of 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:16: '*' : array / non-array mismatch
ERROR: 0:16: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'const float' and a right operand of type 'mediump array[16] of 4-component vector of float' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color[16] = vec4((0.0 + 0.0), (-1.0 / +0.0), 2.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float x = (2.0 * (gtf_Color.g - 0.5));
  float y = (2.0 * (gtf_Color.b - 0.5));
  const float epsilon = 0.0001;
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    color = vec4(((atan(y , x) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.63488843813387
Processing this: /home/oof/webgl_cleaned/vec4_empty_in_vec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(in vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(in vec4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(in vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(in vec4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
59.63488843813387
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec2 lt(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] < b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] < b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lt(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec2 lt(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] < b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] < b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lt(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lt(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] < b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] < b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lt(ivec2(c) , ivec2(0)));
  color = 0(result , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'assign' : cannot convert from 'const int' to 'mediump 4-component vector of float'
ERROR: 0:24: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lt(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] < b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] < b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lt(ivec2(c) , ivec2(0)));
  color = 0(result , 0.0);
}


==============================
59.51417004048582
Processing this: /home/oof/webgl_cleaned/log_vec2_frag_xvary01_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 x = (color.rg + 0.01) / 1.01;
	vec2 y = vec2(0.0);
	vec2 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec2 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	gl_FragColor = vec4(y / -4.61, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 x = (color.rg + 0.01) / 1.01;\n\tvec2 y = vec2(0.0);\n\tvec2 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec2 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tgl_FragColor = vec4(y / -4.61, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 x = ((color.rg + 0.01) / 1.01);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  gl_FragColor = vec4((y / -4.61) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:20: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 x = ((color.rg + 0.01) / 1.01);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  gl_FragColor = vec4((y / -4.61) , 0.0);
}


==============================
59.3939393939394
Mutations attempted: 495
Valid mutations:     294
Success rate:        59.39%
Processing this: /home/oof/webgl_cleaned/vec4_xyz_w_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	float w = al.w;
	vec4 a = vec4(m, w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tfloat w = al.w;\n\tvec4 a = vec4(m, w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (1.0 - (-1.0 / (-1.0 * 0.0))), (-1.0 / 1.0), 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  float w = al.w;
  vec4 a = vec4(m , w);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.4758064516129
Processing this: /home/oof/webgl_cleaned/ceil_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 1.0, 0.0, (0.5 + 0.0));

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.55734406438632
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(lessThanEqual(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(lessThanEqual(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(lessThanEqual(c , vec3(0.0)));
  color = main()(result);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: '=' : operation with void operands
ERROR: 0:16: 'assign' : cannot convert from 'void' to 'mediump 4-component vector of float'
ERROR: 0:16: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(lessThanEqual(c , vec3(0.0)));
  color = main()(result);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.43775100401606
Processing this: /home/oof/webgl_cleaned/sqrt_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 100.0 * color.r;
	gl_FragColor = vec4(c / 100.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 100.0 * color.r;\n\tgl_FragColor = vec4(c / 100.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = (100.0 * color.r);
  gl_FragColor = vec4((c / 100.0) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = (100.0 * color.r);
  gl_FragColor = vec4((c / 100.0) , 0.0 , 0.0);
}


==============================
59.318637274549104
Processing this: /home/oof/webgl_cleaned/2i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec2 color;
void main ()
{
	gl_FragColor = vec4 (color[0], color[1], 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec2 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0], color[1], 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec2 color = ivec2(7, 5);

void main()
{
  gl_FragColor = vec4(color[0] , color[1] , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform ivec2 color = ivec2(7, 5);

void main()
{
  gl_FragColor = vec4(color[0] , color[1] , 0.0 , 1.0);
}


==============================
59.199999999999996
Processing this: /home/oof/webgl_cleaned/gl_MaxTextureImageUnits_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(float(gl_MaxTextureImageUnits) / 8.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(gl_MaxTextureImageUnits) / 8.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4(vec4((false ? +0.5 : 0.5), (false ? -1.0 : 1.0), -1.0, 1.0)) = color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4(vec4((false ? +0.5 : 0.5), (false ? -1.0 : 1.0), -1.0, 1.0)) = color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.08183632734531
Processing this: /home/oof/webgl_cleaned/bool_empty_inout_bool_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool function(inout bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(!par && ret)
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bool function(inout bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool function(inout bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(!par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbool function(inout bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
59.08183632734531
Processing this: /home/oof/webgl_cleaned/1f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform float color;
void main ()
{
	gl_FragColor = vec4 (color, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform float color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float color;

void main()
{
  vec4((((true ? false : false) ? 0.5 : 2.0) / +color), -1.0, 0.0, color) = gl_FragColor;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'assign' : l-value required

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float color;

void main()
{
  vec4((((true ? false : false) ? 0.5 : 2.0) / +color), -1.0, 0.0, color) = gl_FragColor;
}


==============================
58.964143426294825
Processing this: /home/oof/webgl_cleaned/vec4_wx_zy_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.wx;
	vec2 n = lightloc.zy;
	vec4 a = vec4(m.y, n.y, n.x, m.x);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.wx;\n\tvec2 n = lightloc.zy;\n\tvec4 a = vec4(m.y, n.y, n.x, m.x);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.0, -0.5, 2.0, -0.5, -1.0, 1.0, 0.5, 2.0, 1.0, -1.0, 2.0, 1.0, 0.5, 0.0, 2.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.wx;
  vec2 n = lightloc.zy;
  vec4 a = vec4(m.y , n.y , n.x , m.x);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.0, -0.5, 2.0, -0.5, -1.0, 1.0, 0.5, 2.0, 1.0, -1.0, 2.0, 1.0, 0.5, 0.0, 2.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.wx;
  vec2 n = lightloc.zy;
  vec4 a = vec4(m.y , n.y , n.x , m.x);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
58.8469184890656
Processing this: /home/oof/webgl_cleaned/mat3arrayindirect0_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform mat3 testmat3[2];
varying vec4  color;
void main()
{
     vec3 result = vec3(0.0, 0.0, 0.0);
	result += testmat3[0][0] + testmat3[1][0];
	result += testmat3[0][1] + testmat3[1][1];
	result += testmat3[0][2] + testmat3[1][2];
     gl_FragColor = vec4(result/2.0, 0.5);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform mat3 testmat3[2];\nvarying vec4  color;\nvoid main()\n{\n     vec3 result = vec3(0.0, 0.0, 0.0);\n\tresult += testmat3[0][0] + testmat3[1][0];\n\tresult += testmat3[0][1] + testmat3[1][1];\n\tresult += testmat3[0][2] + testmat3[1][2];\n     gl_FragColor = vec4(result/2.0, 0.5);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat3 testmat3[2];

vec4 color;

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  (result += (testmat3[0][0] + testmat3[1][0]));
  (result += (testmat3[-16][1] + testmat3[1][17]));
  (result += (testmat3[0][2] + testmat3[1][2]));
  gl_FragColor = vec4((result / 2.0) , 0.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: '[]' : index expression is negative
ERROR: 0:12: '[]' : matrix field selection out of range

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat3 testmat3[2];

vec4 color;

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  (result += (testmat3[0][0] + testmat3[1][0]));
  (result += (testmat3[-16][1] + testmat3[1][17]));
  (result += (testmat3[0][2] + testmat3[1][2]));
  gl_FragColor = vec4((result / 2.0) , 0.5);
}


==============================
58.730158730158735
Mutations attempted: 504
Valid mutations:     296
Success rate:        58.73%
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((false && true) ? 1.0 : 0.5), 1.0, (true ? +0.0 : +-1.0), +0.0);

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.81188118811881
Processing this: /home/oof/webgl_cleaned/floor_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.69565217391305
Processing this: /home/oof/webgl_cleaned/vertexOnly2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    gl_Position = vec4(4.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    gl_Position = vec4(4.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(4.0);
}


As vertex? : False
SUCCESS!
58.777120315581854
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = -color.rg;
	gl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = -color.rg;
  gl_FragColor = vec4(exp2((5.0 * c)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
58.85826771653543
Processing this: /home/oof/webgl_cleaned/exp2_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = gtf_Color.rgb;
	color = vec4(exp2(5.0 * c) / 32.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(exp2(5.0 * c) / 32.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((false || true) ? 1.0 : (-1.0 - 0.5)) * ((false && true) ? 0.5 : 1.0)), (true ? ((1.0 * 1.0) / 1.0) : 0.5), 1.0, (true ? 0.0 : ((false || false) ? -1.0 : -1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

vec4 gtf_Vertex;

void main()
{
  vec3 c = gtf_Color.rgb;
  color = vec4((exp2((5.0 * c)) / 32.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.93909626719057
Processing this: /home/oof/webgl_cleaned/mod_float_vert_xvary_yconst1_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	c = c - 1.0 * floor(c / 1.0);
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tc = c - 1.0 * floor(c / 1.0);\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(+1.0, +((1.0 + 2.0) / 0.0), (-2.0 * (true ? (true ? 0.0 : -1.0) : 0.0)), 0.0);

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (c - (1.0 * floor((c / 1.0))));
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.01960784313726
Processing this: /home/oof/webgl_cleaned/vec4_grab_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.grab;
	vec4 a = vec4(m.g, m.r, m.a, m.b);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.grab;\n\tvec4 a = vec4(m.g, m.r, m.a, m.b);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? 0.5 : -(true ? 0.5 : 0.0)), (-1.0 / 2.0), +2.0, 1.0);

void main()
{
  vec4 al = color;
  vec4 m = al.grab;
  vec4 a = vec4(m.g , m.r , m.a , m.b);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.099804305283755
Processing this: /home/oof/webgl_cleaned/notEqual_ivec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 ne(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(ne(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 ne(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(ne(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 ne(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(ne(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(+(true ? 9 : -1), +7);
}


As vertex? : True
SUCCESS!
59.1796875
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 16.0 * color.rgb;
	gl_FragColor = vec4(pow(c, vec3(0.5)) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 16.0 * color.rgb;\n\tgl_FragColor = vec4(pow(c, vec3(0.5)) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, -1.0, 0.5, 2.0);

void main()
{
  vec3 c = (16.0 * color.rgb);
  gl_FragColor = vec4((pow(c , vec3(0.5)) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.25925925925925
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 16.0 * color.rgb;
	gl_FragColor = vec4(pow(c, vec3(0.5)) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 16.0 * color.rgb;\n\tgl_FragColor = vec4(pow(c, vec3(0.5)) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = (16.0 * color.rgb);
  gl_FragColor = vec4(0.5);
}


As vertex? : False
SUCCESS!
59.33852140077821
Mutations attempted: 514
Valid mutations:     305
Success rate:        59.34%
Processing this: /home/oof/webgl_cleaned/tan_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 0.5 * M_PI * 2.0 * (gtf_Color.rg - 0.5);
	vec2 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;
	else
		o.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;
	else
		o.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;
	color = vec4(o, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 0.5 * M_PI * 2.0 * (gtf_Color.rg - 0.5);\n\tvec2 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;\n\telse\n\t\to.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;\n\telse\n\t\to.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;\n\tcolor = vec4(o, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-1.0, 1.0, 0.5, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((0.5 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  vec2 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * (sin(c.r) / cos(c.r))) + 0.5);
  else
    o.r = ((0.5 * (cos(c.r) / sin(c.r))) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * (sin(c.g) / cos(c.g))) + 0.5);
  else
    o.g = ((0.5 * (cos(c.g) / sin(c.g))) + 0.5);
  color = vec4(o , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.417475728155345
Processing this: /home/oof/webgl_cleaned/array_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
	b[0] = a[0];
	c[0] += d[0];
	a[0] += 1.0;
	e[0] += 1.0;
	b[1] = a[1];
	c[1] += d[1];
	a[1] += 1.0;
	e[1] += 1.0;
	b[2] = a[2];
	c[2] += d[2];
	a[2] += 1.0;
	e[2] += 1.0;
	b[3] = a[3];
	c[3] += d[3];
	a[3] += 1.0;
	e[3] += 1.0;
}
void main ()
{
	float a[4];
	float b[4];
	float c[4];
	float d[4];
	float e[4];
	float q = 0.0;
	float q2 = 0.0;
	a[0] = 1.0;
	b[0] = 2.0;
	c[0] = 3.0;
	d[0] = 4.0;
	e[0] = 1.0;
	a[1] = 1.0;
	b[1] = 2.0;
	c[1] = 3.0;
	d[1] = 4.0;
	e[1] = 1.0;
	a[2] = 1.0;
	b[2] = 2.0;
	c[2] = 3.0;
	d[2] = 4.0;
	e[2] = 1.0;
	a[3] = 1.0;
	b[3] = 2.0;
	c[3] = 3.0;
	d[3] = 4.0;
	e[3] = 1.0;
	qualifiers(a, b, c, d, e);
	if(a[0] == 1.0) q += 1.0;
	if(b[1] == 1.0) q += 2.0;
	if(c[2] == 7.0) q += 4.0;
	if(d[3] == 4.0) q2 += 1.0;
	if(e[0] == 1.0) q2 += 2.0;
	gl_FragColor = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])\n{\n\tb[0] = a[0];\n\tc[0] += d[0];\n\ta[0] += 1.0;\n\te[0] += 1.0;\n\tb[1] = a[1];\n\tc[1] += d[1];\n\ta[1] += 1.0;\n\te[1] += 1.0;\n\tb[2] = a[2];\n\tc[2] += d[2];\n\ta[2] += 1.0;\n\te[2] += 1.0;\n\tb[3] = a[3];\n\tc[3] += d[3];\n\ta[3] += 1.0;\n\te[3] += 1.0;\n}\nvoid main ()\n{\n\tfloat a[4];\n\tfloat b[4];\n\tfloat c[4];\n\tfloat d[4];\n\tfloat e[4];\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\ta[0] = 1.0;\n\tb[0] = 2.0;\n\tc[0] = 3.0;\n\td[0] = 4.0;\n\te[0] = 1.0;\n\ta[1] = 1.0;\n\tb[1] = 2.0;\n\tc[1] = 3.0;\n\td[1] = 4.0;\n\te[1] = 1.0;\n\ta[2] = 1.0;\n\tb[2] = 2.0;\n\tc[2] = 3.0;\n\td[2] = 4.0;\n\te[2] = 1.0;\n\ta[3] = 1.0;\n\tb[3] = 2.0;\n\tc[3] = 3.0;\n\td[3] = 4.0;\n\te[3] = 1.0;\n\tqualifiers(a, b, c, d, e);\n\tif(a[0] == 1.0) q += 1.0;\n\tif(b[1] == 1.0) q += 2.0;\n\tif(c[2] == 7.0) q += 4.0;\n\tif(d[3] == 4.0) q2 += 1.0;\n\tif(e[0] == 1.0) q2 += 2.0;\n\tgl_FragColor = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4] = float[4](-1.0, 0.0, 0.5, 0.5);
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  d[2] = 4.0;
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:28: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:28: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:28: '=' : Invalid operation for arrays
ERROR: 0:28: '=' : cannot convert from 'const array[4] of float' to 'mediump array[4] of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4] = float[4](-1.0, 0.0, 0.5, 0.5);
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  d[2] = 4.0;
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
}


==============================
59.30232558139535
Processing this: /home/oof/webgl_cleaned/notEqual_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(notEqual(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(notEqual(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(notEqual(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.381044487427474
Processing this: /home/oof/webgl_cleaned/bvec4_empty_inout_bvec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(inout bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, false) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(inout bvec4 par)
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(inout bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, false) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(inout bvec4 par)\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
59.381044487427474
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	float s = lightloc.s;
	float t = lightloc.t;
	float p = lightloc.p;
	float q = lightloc.q;
	vec4 m = vec4(s, t, p, q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tfloat s = lightloc.s;\n\tfloat t = lightloc.t;\n\tfloat p = lightloc.p;\n\tfloat q = lightloc.q;\n\tvec4 m = vec4(s, t, p, q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((true ? +-0.5 : 0.5), 0.0, -(1.0 + (2.0 - 0.5)), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  float s = lightloc.s;
  float t = lightloc.t;
  float p = lightloc.p;
  float q = lightloc.q;
  vec4 m = vec4(s , t , p , q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
SUCCESS!
59.45945945945946
Processing this: /home/oof/webgl_cleaned/tan_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 0.5 * M_PI * 2.0 * (color.r - 0.5);
	float o;
	if(abs(c) < 0.5)
		o = 0.5 * tan(c) + 0.5;
	else
		o = 0.5 / tan(c) + 0.5;
	gl_FragColor = vec4(o, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 0.5 * M_PI * 2.0 * (color.r - 0.5);\n\tfloat o;\n\tif(abs(c) < 0.5)\n\t\to = 0.5 * tan(c) + 0.5;\n\telse\n\t\to = 0.5 / tan(c) + 0.5;\n\tgl_FragColor = vec4(o, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct50768 {
  uint f_8013[8];
  mat4 f_9112;
  vec4 f_1920;
  ivec4 f_3927[3];
};

vec4 color = vec4(1.0, 1.0, -0.5, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((0.5 * M_PI) * 2.0) * (color.r - 0.5));
  float o;
  if ((abs(c) < 0.5))
    o = ((0.5 * tan(c)) + 0.5);
  else
    o = ((0.5 / tan(c)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:5: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct50768 {
  uint f_8013[8];
  mat4 f_9112;
  vec4 f_1920;
  ivec4 f_3927[3];
};

vec4 color = vec4(1.0, 1.0, -0.5, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((0.5 * M_PI) * 2.0) * (color.r - 0.5));
  float o;
  if ((abs(c) < 0.5))
    o = ((0.5 * tan(c)) + 0.5);
  else
    o = ((0.5 / tan(c)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 0.0 , 1.0);
}


==============================
59.34489402697495
Processing this: /home/oof/webgl_cleaned/normalize_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = gtf_Color + vec4(0.25);
	color = vec4(tmp_Color.r / length(tmp_Color.r), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = gtf_Color + vec4(0.25);\n\tcolor = vec4(tmp_Color.r / length(tmp_Color.r), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct80455 {
  vec4 f_413[4];
  mat2 f_3888;
  vec3 f_3707;
  mat3 f_3080;
};

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, (false ? -1.0 : ((2.0 + 2.0) / 0.5)), -1.0, 2.0, +(false ? (true ? 2.0 : 1.0) : (true ? 0.5 : 0.0)), 0.0, (!(true ? false : true) ? 0.5 : (0.0 / -1.0)), -1.0, -1.0, -(true ? 0.5 : (true ? 1.0 : 0.0)), -++0.0, --1.0, 0.0, +0.5, 0.0, 1.0);

vec4 color;

void main()
{
  vec4 tmp_Color = (gtf_Color + vec4(0.25));
  color = vec4((tmp_Color.r / length(tmp_Color.r)) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: '++' : l-value required (can't modify a const)
ERROR: 0:15: '--' : l-value required (can't modify a const)
ERROR: 0:15: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct80455 {
  vec4 f_413[4];
  mat2 f_3888;
  vec3 f_3707;
  mat3 f_3080;
};

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, (false ? -1.0 : ((2.0 + 2.0) / 0.5)), -1.0, 2.0, +(false ? (true ? 2.0 : 1.0) : (true ? 0.5 : 0.0)), 0.0, (!(true ? false : true) ? 0.5 : (0.0 / -1.0)), -1.0, -1.0, -(true ? 0.5 : (true ? 1.0 : 0.0)), -++0.0, --1.0, 0.0, +0.5, 0.0, 1.0);

vec4 color;

void main()
{
  vec4 tmp_Color = (gtf_Color + vec4(0.25));
  color = vec4((tmp_Color.r / length(tmp_Color.r)) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.23076923076923
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
59.23076923076923
Processing this: /home/oof/webgl_cleaned/compressed_paletted_texture.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 gtf_TexCoord[1];
attribute vec4 gtf_MultiTexCoord0;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 gtf_TexCoord[1];\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 0.5, 0.5, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0;

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.309021113243766
Processing this: /home/oof/webgl_cleaned/preprocess2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
 int sum =1;
 sum = __LINE__;
 sum = __FILE__;
 sum = __LINE__;
 sum = __FILE__;
 sum = __LINE__ + __FILE__ ;
 sum = __FILE__;
 sum = __VERSION__;
 sum = sum + __LINE__ ;
 sum = __LINE__;
 sum = __FILE__;
 sum = __VERSION__;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n int sum =1;\n sum = __LINE__;\n sum = __FILE__;\n sum = __LINE__;\n sum = __FILE__;\n sum = __LINE__ + __FILE__ ;\n sum = __FILE__;\n sum = __VERSION__;\n sum = sum + __LINE__ ;\n sum = __LINE__;\n sum = __FILE__;\n sum = __VERSION__;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  int sum = 1;
  sum = __LINE__;
  sum = __FILE__;
  sum = __LINE__;
  sum = __FILE__;
  sum = (__LINE__ + __FILE__);
  sum = __FILE__;
  sum = __VERSION__;
  sum = (sum + __LINE__);
  sum = __LINE__;
  sum = __FILE__;
  sum = __VERSION__;
}


As vertex? : False
SUCCESS!
59.38697318007663
Mutations attempted: 522
Valid mutations:     310
Success rate:        59.39%
Processing this: /home/oof/webgl_cleaned/ceil_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec3 ceil_ref(vec3 x)
{
	if(x[0] != floor(x[0])) x[0] = floor(x[0]) + 1.0;
	if(x[1] != floor(x[1])) x[1] = floor(x[1]) + 1.0;
	if(x[2] != floor(x[2])) x[2] = floor(x[2]) + 1.0;
	return x;
}
void main ()
{
	vec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4((ceil_ref(c) + 10.0) / 20.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec3 ceil_ref(vec3 x)\n{\n\tif(x[0] != floor(x[0])) x[0] = floor(x[0]) + 1.0;\n\tif(x[1] != floor(x[1])) x[1] = floor(x[1]) + 1.0;\n\tif(x[2] != floor(x[2])) x[2] = floor(x[2]) + 1.0;\n\treturn x;\n}\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4((ceil_ref(c) + 10.0) / 20.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

vec3 ceil_ref(vec3 x)
{
  if ((x[2] != floor(x[2])))
    x[2] = (floor(x[2]) + 1.0);
  if ((x[1] != floor(x[1])))
    x[1] = (floor(x[1]) + 1.0);
  return x;
  if ((floor(x[0]) != x[-2]))
    vec3(0.5, +-1.0, -1.0) = (x(x[0]) + 1.0);
}

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((ceil_ref(c) + 10.0) / 20.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:19: '[]' : index expression is negative
ERROR: 0:20: 'x' : function name expected
ERROR: 0:20: 'assign' : l-value required (can't modify a const)
ERROR: 0:20: '=' : dimension mismatch
ERROR: 0:20: 'assign' : cannot convert from 'const mediump float' to 'const 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

vec3 ceil_ref(vec3 x)
{
  if ((x[2] != floor(x[2])))
    x[2] = (floor(x[2]) + 1.0);
  if ((x[1] != floor(x[1])))
    x[1] = (floor(x[1]) + 1.0);
  return x;
  if ((floor(x[0]) != x[-2]))
    vec3(0.5, +-1.0, -1.0) = (x(x[0]) + 1.0);
}

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((ceil_ref(c) + 10.0) / 20.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.273422562141484
Processing this: /home/oof/webgl_cleaned/intUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform int ival;
uniform ivec2 ival2;
uniform ivec3 ival3;
uniform ivec4 ival4;
void main()
{
    int sum = ival
            + ival2[0] + ival2[1]
            + ival3[0] + ival3[1] + ival3[2]
            + ival4[0] + ival4[1] + ival4[2] + ival4[3];
    gl_Position = vec4(sum, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform int ival;\nuniform ivec2 ival2;\nuniform ivec3 ival3;\nuniform ivec4 ival4;\nvoid main()\n{\n    int sum = ival\n            + ival2[0] + ival2[1]\n            + ival3[0] + ival3[1] + ival3[2]\n            + ival4[0] + ival4[1] + ival4[2] + ival4[3];\n    gl_Position = vec4(sum, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2;

uniform ivec3 ival3 = ivec3(((false || (false || true)) ? 8 : (!true ? (true ? 7 : ival) : 6)), 0, ival);

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2;

uniform ivec3 ival3 = ivec3(((false || (false || true)) ? 8 : (!true ? (true ? 7 : ival) : 6)), 0, ival);

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


==============================
59.16030534351145
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 lte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lte(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 lte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lte(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    b[8] = true;
  else
    color[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '[]' : vector field selection out of range
ERROR: 0:10: 'assign' : cannot convert from 'const bool' to 'mediump float'
ERROR: 0:12: 'assign' : cannot convert from 'const bool' to 'mediump float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    b[8] = true;
  else
    color[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


==============================
59.04761904761905
Processing this: /home/oof/webgl_cleaned/mod_vec2_vert_xvary_yconst1_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	c = c - 1.0 * floor(c / 1.0);
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tc = c - 1.0 * floor(c / 1.0);\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, +0.5, -1.0, +((2.0 + -1.0) / 0.5));

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  c = (c - (1.0 * floor((c / 1.0))));
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.125475285171106
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 1) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.125475285171106
Processing this: /home/oof/webgl_cleaned/reflect_float_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	color = vec4((reflect(v1, v2) + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tcolor = vec4((reflect(v1, v2) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = mat4(2.0, +-1.0, -1.0, 2.0, (((false && true) ? (false || false) : (true ? true : true)) ? 0.5 : 0.5), -1.0, 0.0, +(true ? -1.0 : (false ? 0.5 : 0.5)), 0.0, (true ? 0.0 : 2.0), 1.0, 0.5, (!(false ? false : true) ? -1.0 : ((true && false) ? 2.0 : 2.0)), 0.5, -1.0, -0.5);
  ivec2(5, 2);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: '=' : dimension mismatch
ERROR: 0:18: 'assign' : cannot convert from 'const 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = mat4(2.0, +-1.0, -1.0, 2.0, (((false && true) ? (false || false) : (true ? true : true)) ? 0.5 : 0.5), -1.0, 0.0, +(true ? -1.0 : (false ? 0.5 : 0.5)), 0.0, (true ? 0.0 : 2.0), 1.0, 0.5, (!(false ? false : true) ? -1.0 : ((true && false) ? 2.0 : 2.0)), 0.5, -1.0, -0.5);
  ivec2(5, 2);
}


==============================
59.01328273244781
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = -color.rg;
	gl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = -color.rg;
  color(exp2((5.0 * c)) , 0.0) = gl_FragColor;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: 'gl_FragColor' : undeclared identifier
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = -color.rg;
  color(exp2((5.0 * c)) , 0.0) = gl_FragColor;
}


==============================
58.90151515151515
Processing this: /home/oof/webgl_cleaned/max_float_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = color.r;
	if(c < max_c) c = max_c;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = color.r;\n\tif(c < max_c) c = max_c;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, -1.0, 0.5, (!(true || false) ? 2.0 : ((false ? true : false) ? 1.0 : -1.0)));

void main()
{
  const float max_c = 0.5;
  float c = color.r;
  if ((c < max_c))
    c = max_c;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
58.97920604914933
Processing this: /home/oof/webgl_cleaned/equal_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(equal(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(equal(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+2.0, -(true ? 2.0 : (true ? -1.0 : 0.0)), ((false ? false : false) ? --2.0 : (1.0 * (true ? 0.0 : 2.0))), ((true && !true) ? -(-1.0 + 0.5) : (-1.0 / (false ? 0.0 : 1.0))), (((true ? false : false) ? (false || true) : false) ? -0.0 : -(1.0 / 1.0)), -((false ? -1.0 : -1.0) + (true ? 1.0 : 2.0)), (-1.0 * 1.0), 0.5, (false ? ((true ? 0.0 : 2.0) * 2.0) : ((false ? 0.0 : 2.0) / -1.0)), 0.5, -1.0, -2.0, (false ? 0.0 : 0.5), 0.5, -1.0, (0.0 * -1.0));

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(equal(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+2.0, -(true ? 2.0 : (true ? -1.0 : 0.0)), ((false ? false : false) ? --2.0 : (1.0 * (true ? 0.0 : 2.0))), ((true && !true) ? -(-1.0 + 0.5) : (-1.0 / (false ? 0.0 : 1.0))), (((true ? false : false) ? (false || true) : false) ? -0.0 : -(1.0 / 1.0)), -((false ? -1.0 : -1.0) + (true ? 1.0 : 2.0)), (-1.0 * 1.0), 0.5, (false ? ((true ? 0.0 : 2.0) * 2.0) : ((false ? 0.0 : 2.0) / -1.0)), 0.5, -1.0, -2.0, (false ? 0.0 : 0.5), 0.5, -1.0, (0.0 * -1.0));

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(equal(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.867924528301884
Processing this: /home/oof/webgl_cleaned/float_empty_out_float_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(out float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(out float par)
{
	par = 0.0;
	return 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(out float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(out float par)\n{\n\tpar = 0.0;\n\treturn 1.0;\n}\n\x00')
58.867924528301884
Mutations attempted: 530
Valid mutations:     312
Success rate:        58.87%
Processing this: /home/oof/webgl_cleaned/mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat2 a = mat2(1.0, 2.0,
	              4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat2 a = mat2(1.0, 2.0,\n\t              4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, (!(true || false) ? (2.0 / +2.0) : +(false ? 2.0 : -1.0)), 1.0, 1.0);

void main()
{
  float x;
  mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.94538606403014
Processing this: /home/oof/webgl_cleaned/distance_vec2_vert_xvaryyhalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(sqrt(pow(abs(gtf_Color.r - 0.5), 2.0) + pow(abs(gtf_Color.g - 0.5), 2.0))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(sqrt(pow(abs(gtf_Color.r - 0.5), 2.0) + pow(abs(gtf_Color.g - 0.5), 2.0))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((-1.0 * (1.0 + 0.0)) / 0.0), 2.0, -1.0, 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4(vec3(sqrt((pow(abs((gtf_Color.r - 0.5)) , 2.0) + pow(abs((gtf_Color.g - 0.5)) , 2.0)))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.02255639097744
Processing this: /home/oof/webgl_cleaned/refract_float_vert_ivarynconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	float result;
	float eta = 0.5;
	float k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));
	if(k < 0.0)
		result = 0.0;
	else
		result = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;
	color = vec4((result + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tfloat result;\n\tfloat eta = 0.5;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));\n\tif(k < 0.0)\n\t\tresult = 0.0;\n\telse\n\t\tresult = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;\n\tcolor = vec4((result + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 0.5, 0.5, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  float result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = 0.0;
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  color = vec4(((result + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.09943714821764
Processing this: /home/oof/webgl_cleaned/CorrectExtension1_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
59.09943714821764
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xconsthalf_yvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(pow(0.5, 2.0 * c) / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(pow(0.5, 2.0 * c) / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (0.0 * -1.0), ((!false && true) ? -(true ? 0.0 : 0.5) : 1.0), 0.0);

void main()
{
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = vec4((pow(0.5 , (2.0 * c)) / 4.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.176029962546814
Processing this: /home/oof/webgl_cleaned/struct_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	color = vec4( vec3(  (s.a[0] + s.a[1] + s.b[0] + s.b[1]) / 80.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tcolor = vec4( vec3(  (s.a[0] + s.a[1] + s.b[0] + s.b[1]) / 80.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 * ((false || false) ? (1.0 / 1.0) : (false ? 0.5 : 0.0))), (false ? 2.0 : ((0.5 * 2.0) + 0.5)), 1.0, -1.0, (0.5 * ++0.5), 0.5, 2.0, (-1.0 + -1.0), (true ? --1.0 : 2.0), (false ? --1.0 : -1.0), -1.0, --1.0, 0.5, 0.0, -1.0, (((false || false) ? (true || false) : false) ? -(0.0 - 0.5) : 0.0));

vec4 color;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  color = vec4(vec3(((((s.a[0] + s.a[1]) + s.b[0]) + s.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '++' : l-value required (can't modify a const)
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 * ((false || false) ? (1.0 / 1.0) : (false ? 0.5 : 0.0))), (false ? 2.0 : ((0.5 * 2.0) + 0.5)), 1.0, -1.0, (0.5 * ++0.5), 0.5, 2.0, (-1.0 + -1.0), (true ? --1.0 : 2.0), (false ? --1.0 : -1.0), -1.0, --1.0, 0.5, 0.0, -1.0, (((false || false) ? (true || false) : false) ? -(0.0 - 0.5) : 0.0));

vec4 color;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  color = vec4(vec3(((((s.a[0] + s.a[1]) + s.b[0]) + s.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.06542056074766
Processing this: /home/oof/webgl_cleaned/const_mat3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0, 2.0, 3.0,
	                     4.0, 5.0, 6.0,
	                     7.0, 8.0, 9.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[0][2] != 3.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 5.0) elms = false;
	if(a[1][2] != 6.0) elms = false;
	if(a[2][0] != 7.0) elms = false;
	if(a[2][1] != 8.0) elms = false;
	if(a[2][2] != 9.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0];
	if( x < 12.0-0.1 || x > 12.0+0.1 ) rows = false;
	x = a[0][1] + a[1][1] + a[2][1];
	if(x < 15.0-0.1 || x > 15.0+0.1 ) rows = false;
	x = a[0][2] + a[1][2] + a[2][2];
	if(x < 18.0-0.1 || x > 18.0+0.1 ) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2];
	if( x < 6.0-0.1 || x > 6.0+0.1 ) cols = false;
	x = a[1][0] + a[1][1] + a[1][2];
	if(x < 15.0-0.1 || x > 15.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2];
	if(x < 24.0-0.1 || x > 24.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0, 2.0, 3.0,\n\t                     4.0, 5.0, 6.0,\n\t                     7.0, 8.0, 9.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[0][2] != 3.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 5.0) elms = false;\n\tif(a[1][2] != 6.0) elms = false;\n\tif(a[2][0] != 7.0) elms = false;\n\tif(a[2][1] != 8.0) elms = false;\n\tif(a[2][2] != 9.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0];\n\tif( x < 12.0-0.1 || x > 12.0+0.1 ) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1];\n\tif(x < 15.0-0.1 || x > 15.0+0.1 ) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2];\n\tif(x < 18.0-0.1 || x > 18.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2];\n\tif( x < 6.0-0.1 || x > 6.0+0.1 ) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2];\n\tif(x < 15.0-0.1 || x > 15.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2];\n\tif(x < 24.0-0.1 || x > 24.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    rows = false;
  if ((a[2][1] != 8.0))
    elms = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  const mat3 a = mat3(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  float x;
  if ((a[2][2] != 9.0))
    elms = false;
  x = ((a[0][0] + a[0][1]) + a[0][2]);
  if (((x < (6.0 - 0.1)) || (x > (6.0 + 0.1))))
    cols = false;
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    rows = false;
  x = ((a[0][1] + a[1][1]) + a[2][1]);
  x = ((a[0][2] + a[1][2]) + a[2][2]);
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  x = ((a[2][0] + a[2][1]) + a[2][2]);
  if (((x < (24.0 - 0.1)) || (x > (24.0 + 0.1))))
    cols = false;
  if ((a[1][2] != 6.0))
    elms = false;
  if (((x < (18.0 - 0.1)) || (x > (18.0 + 0.1))))
    rows = false;
  bool elms = true;
  bool rows = true;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
  x = ((a[0][0] + a[1][0]) + a[2][0]);
  x = ((a[1][0] + a[1][1]) + a[1][2]);
  if ((a[2][0] != 7.0))
    elms = false;
  if ((a[1][1] != 5.0))
    elms = false;
  bool cols = true;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'x' : undeclared identifier
ERROR: 0:6: 'x' : undeclared identifier
ERROR: 0:7: 'rows' : undeclared identifier
ERROR: 0:7: 'assign' : l-value required (can't modify a const)
ERROR: 0:7: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:8: 'a' : undeclared identifier
ERROR: 0:8: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:8: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:9: 'elms' : undeclared identifier
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:9: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:10: 'elms' : undeclared identifier
ERROR: 0:10: 'rows' : undeclared identifier
ERROR: 0:10: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const highp float' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:10: 'cols' : undeclared identifier
ERROR: 0:10: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:12: 'x' : undeclared identifier
ERROR: 0:12: 'x' : undeclared identifier
ERROR: 0:13: 'cols' : undeclared identifier
ERROR: 0:13: 'assign' : l-value required (can't modify a const)
ERROR: 0:13: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:15: 'elms' : undeclared identifier
ERROR: 0:15: 'assign' : l-value required (can't modify a const)
ERROR: 0:15: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:17: 'elms' : undeclared identifier
ERROR: 0:17: 'assign' : l-value required (can't modify a const)
ERROR: 0:17: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:20: 'elms' : undeclared identifier
ERROR: 0:20: 'assign' : l-value required (can't modify a const)
ERROR: 0:20: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:23: 'cols' : undeclared identifier
ERROR: 0:23: 'assign' : l-value required (can't modify a const)
ERROR: 0:23: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:25: 'rows' : undeclared identifier
ERROR: 0:25: 'assign' : l-value required (can't modify a const)
ERROR: 0:25: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:29: 'elms' : undeclared identifier
ERROR: 0:29: 'assign' : l-value required (can't modify a const)
ERROR: 0:29: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:31: 'elms' : undeclared identifier
ERROR: 0:31: 'assign' : l-value required (can't modify a const)
ERROR: 0:31: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:34: 'cols' : undeclared identifier
ERROR: 0:34: 'assign' : l-value required (can't modify a const)
ERROR: 0:34: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:36: 'elms' : undeclared identifier
ERROR: 0:36: 'assign' : l-value required (can't modify a const)
ERROR: 0:36: 'assign' : cannot convert from 'const bool' to 'const highp float'
ERROR: 0:38: 'rows' : undeclared identifier
ERROR: 0:38: 'assign' : l-value required (can't modify a const)
ERROR: 0:38: 'assign' : cannot convert from 'const bool' to 'const highp float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    rows = false;
  if ((a[2][1] != 8.0))
    elms = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  const mat3 a = mat3(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  float x;
  if ((a[2][2] != 9.0))
    elms = false;
  x = ((a[0][0] + a[0][1]) + a[0][2]);
  if (((x < (6.0 - 0.1)) || (x > (6.0 + 0.1))))
    cols = false;
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    rows = false;
  x = ((a[0][1] + a[1][1]) + a[2][1]);
  x = ((a[0][2] + a[1][2]) + a[2][2]);
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  x = ((a[2][0] + a[2][1]) + a[2][2]);
  if (((x < (24.0 - 0.1)) || (x > (24.0 + 0.1))))
    cols = false;
  if ((a[1][2] != 6.0))
    elms = false;
  if (((x < (18.0 - 0.1)) || (x > (18.0 + 0.1))))
    rows = false;
  bool elms = true;
  bool rows = true;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
  x = ((a[0][0] + a[1][0]) + a[2][0]);
  x = ((a[1][0] + a[1][1]) + a[1][2]);
  if ((a[2][0] != 7.0))
    elms = false;
  if ((a[1][1] != 5.0))
    elms = false;
  bool cols = true;
}


==============================
58.95522388059702
Processing this: /home/oof/webgl_cleaned/float_empty_inout_float_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(inout float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(inout float par[3])
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return 1.0;
	}
	else
		return 0.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(inout float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(inout float par[3])\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
58.95522388059702
Processing this: /home/oof/webgl_cleaned/sqrt_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 100.0 * color.r;
	gl_FragColor = vec4(c / 100.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 100.0 * color.r;\n\tgl_FragColor = vec4(c / 100.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = (100.0 * color.r);
  gl_FragColor = vec4((c / 100.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.0316573556797
Processing this: /home/oof/webgl_cleaned/structnest_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	vec2 b;
};
struct nesta
{
	vec2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec2(11, 13), nestb(vec2(12, 19) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] ) / 55.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tvec2 b;\n};\nstruct nesta\n{\n\tvec2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec2(11, 13), nestb(vec2(12, 19) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] ) / 55.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nesta {
  vec2 a;
  nestb nest_b;
};

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  nest s = nest(nesta(vec2(11 , 13) , nestb(vec2(12 , 19))));
  color = vec4(vec3(((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) / 55.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex;

struct nestb {
  vec2 b;
};

struct nest {
  nesta nest_a;
};

vec4 color;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'nestb' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct nesta {
  vec2 a;
  nestb nest_b;
};

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  nest s = nest(nesta(vec2(11 , 13) , nestb(vec2(12 , 19))));
  color = vec4(vec3(((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) / 55.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex;

struct nestb {
  vec2 b;
};

struct nest {
  nesta nest_a;
};

vec4 color;


==============================
58.921933085501855
Mutations attempted: 538
Valid mutations:     317
Success rate:        58.92%
Processing this: /home/oof/webgl_cleaned/lighting_diffuse.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
    gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n    gl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  2.0;
}


As vertex? : False
SUCCESS!
58.998144712430424
Processing this: /home/oof/webgl_cleaned/fract_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((false ? ((2.0 - 1.0) - (false ? 2.0 : 2.0)) : 1.0), ((false || false) ? 1.0 : 0.0), 1.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.074074074074076
Processing this: /home/oof/webgl_cleaned/buffer_objects_multitexturing.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
attribute vec4 gtf_MultiTexCoord1;
varying vec4 color;
varying vec4 gtf_TexCoord[2];
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gtf_TexCoord[1] = gtf_MultiTexCoord1;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nattribute vec4 gtf_MultiTexCoord1;\nvarying vec4 color;\nvarying vec4 gtf_TexCoord[2];\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgtf_TexCoord[1] = gtf_MultiTexCoord1;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 gtf_MultiTexCoord1;

vec4 color;

vec4 gtf_TexCoord[2];

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gtf_TexCoord[1] = gtf_MultiTexCoord1;
  0.5 = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:23: 'assign' : l-value required (can't modify a const)
ERROR: 0:23: '=' : dimension mismatch
ERROR: 0:23: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 gtf_MultiTexCoord1;

vec4 color;

vec4 gtf_TexCoord[2];

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gtf_TexCoord[1] = gtf_MultiTexCoord1;
  0.5 = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.9648798521257
Processing this: /home/oof/webgl_cleaned/min_vec3_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 min_c = vec3(0.5, 0.5, 0.5);
	vec3 c = color.rgb;
	gl_FragColor = vec4(min(c, min_c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 min_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(min(c, min_c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5);
  vec3 c = color.rgb;
  gl_FragColor = vec4(min(c , min_c) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5);
  vec3 c = color.rgb;
  gl_FragColor = vec4(min(c , min_c) , 1.0);
}


==============================
58.85608856088561
Processing this: /home/oof/webgl_cleaned/faceforward_float_vert_nvaryiconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g * 2.0) - 1.0;
	float v2 = (gtf_Color.b * 2.0) - 1.0;
	if(dot(v1, v2) >= 0.0) v1 *= -1.0;
	color = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g * 2.0) - 1.0;\n\tfloat v2 = (gtf_Color.b * 2.0) - 1.0;\n\tif(dot(v1, v2) >= 0.0) v1 *= -1.0;\n\tcolor = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g * 2.0) - 1.0);
  float v2 = ((gtf_Color.b * 2.0) - 1.0);
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  color = vec4(((v1 + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.93186003683242
Processing this: /home/oof/webgl_cleaned/dot_float_vert_xvaryyone_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(gtf_Color.r), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(gtf_Color.r), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((-1.0 + 0.0), 0.5, ((1.0 - 2.0) - --0.5), ++-1.0);

void main()
{
  color = vec4(vec3(gtf_Color.r) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '++' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((-1.0 + 0.0), 0.5, ((1.0 - 2.0) - --0.5), ++-1.0);

void main()
{
  color = vec4(vec3(gtf_Color.r) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.82352941176471
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconst2_yvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4((exp2((2.0 * c)) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
58.89908256880734
Processing this: /home/oof/webgl_cleaned/successfulcompile_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform float	mortarThickness;
uniform vec3	brickColor;
uniform vec3	mortarColor;
uniform float	brickMortarWidth;
uniform float	brickMortarHeight;
uniform float	mwf;
uniform float	mhf;
varying vec3  Position;
varying float lightIntensity;
void main ()
{
    vec3	ct;
    float	ss, tt, w, h;
    vec3 pos = Position;
    ss = pos.x / brickMortarWidth;
    tt = pos.z / brickMortarHeight;
    if (fract (tt * 0.5) > 0.5)
        ss += 0.5;
    ss = fract (ss);
    tt = fract (tt);
    w = step (mwf, ss) - step (1.0 - mwf, ss);
    h = step (mhf, tt) - step (1.0 - mhf, tt);
    ct = clamp(mix (mortarColor, brickColor, w * h) * lightIntensity, 0.0, 1.0);
    gl_FragColor = vec4 (ct, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform float\tmortarThickness;\nuniform vec3\tbrickColor;\nuniform vec3\tmortarColor;\nuniform float\tbrickMortarWidth;\nuniform float\tbrickMortarHeight;\nuniform float\tmwf;\nuniform float\tmhf;\nvarying vec3  Position;\nvarying float lightIntensity;\nvoid main ()\n{\n    vec3\tct;\n    float\tss, tt, w, h;\n    vec3 pos = Position;\n    ss = pos.x / brickMortarWidth;\n    tt = pos.z / brickMortarHeight;\n    if (fract (tt * 0.5) > 0.5)\n        ss += 0.5;\n    ss = fract (ss);\n    tt = fract (tt);\n    w = step (mwf, ss) - step (1.0 - mwf, ss);\n    h = step (mhf, tt) - step (1.0 - mhf, tt);\n    ct = clamp(mix (mortarColor, brickColor, w * h) * lightIntensity, 0.0, 1.0);\n    gl_FragColor = vec4 (ct, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float mortarThickness;

uniform vec3 brickColor;

uniform vec3 mortarColor;

uniform float brickMortarWidth;

uniform float brickMortarHeight;

uniform float mwf = -1.0;

uniform float mhf;

vec3 Position;

float lightIntensity;

void main()
{
  vec3 ct;
  float ss, tt, w, h;
  vec3 pos = Position;
  ss = (pos.x / brickMortarWidth);
  tt = (pos.z / brickMortarHeight);
  if ((fract((tt * 0.5)) > 0.5))
    (ss += 0.5);
  ss = fract(ss);
  tt = fract(tt);
  w = (step(mwf , ss) - step((1.0 - mwf) , ss));
  h = (step(mhf , tt) - step((1.0 - mhf) , tt));
  ct = clamp((mix(mortarColor , brickColor , (w * h)) * lightIntensity) , 0.0 , 1.0);
  gl_FragColor = vec4(ct , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float mortarThickness;

uniform vec3 brickColor;

uniform vec3 mortarColor;

uniform float brickMortarWidth;

uniform float brickMortarHeight;

uniform float mwf = -1.0;

uniform float mhf;

vec3 Position;

float lightIntensity;

void main()
{
  vec3 ct;
  float ss, tt, w, h;
  vec3 pos = Position;
  ss = (pos.x / brickMortarWidth);
  tt = (pos.z / brickMortarHeight);
  if ((fract((tt * 0.5)) > 0.5))
    (ss += 0.5);
  ss = fract(ss);
  tt = fract(tt);
  w = (step(mwf , ss) - step((1.0 - mwf) , ss));
  h = (step(mhf , tt) - step((1.0 - mhf) , tt));
  ct = clamp((mix(mortarColor , brickColor , (w * h)) * lightIntensity) , 0.0 , 1.0);
  gl_FragColor = vec4(ct , 1.0);
}


==============================
58.791208791208796
Processing this: /home/oof/webgl_cleaned/prefixincrement_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 23;
	int k = ++m;
	float gray;
	if( ( k == 24 ) && ( m == 24 ) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 23;\n\tint k = ++m;\n\tfloat gray;\n\tif( ( k == 24 ) && ( m == 24 ) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+-(2.0 + 2.0), 2.0, ((true ? -1.0 : (1.0 - 1.0)) * ((true ? 1.0 : 0.5) + (true ? 2.0 : 1.0))), 1.0);

void main()
{
  int m = 23;
  int k = ++m;
  float gray;
  if (((k == 24) && (m == 24)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
58.866544789762344
Processing this: /home/oof/webgl_cleaned/mat3_9float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat3 m = mat3(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if(m[0][0] != color.r) result = black;
	if(m[0][1] != color.g) result = black;
	if(m[0][2] != color.b) result = black;
	if(m[1][0] != color.r) result = black;
	if(m[1][1] != color.g) result = black;
	if(m[1][2] != color.b) result = black;
	if(m[2][0] != color.r) result = black;
	if(m[2][1] != color.g) result = black;
	if(m[2][2] != color.b) result = black;
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m = mat3(color.r, color.g, color.b, color.r, color.g, color.b, color.r, color.g, color.b);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif(m[0][0] != color.r) result = black;\n\tif(m[0][1] != color.g) result = black;\n\tif(m[0][2] != color.b) result = black;\n\tif(m[1][0] != color.r) result = black;\n\tif(m[1][1] != color.g) result = black;\n\tif(m[1][2] != color.b) result = black;\n\tif(m[2][0] != color.r) result = black;\n\tif(m[2][1] != color.g) result = black;\n\tif(m[2][2] != color.b) result = black;\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.0, 2.0, 0.5);

void main()
{
  mat3 m = mat3(color.r , color.g , color.b , color.r , color.g , color.b , color.r , color.g , color.b);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != color.r))
    result = black;
  if ((m[0][1] != color.g))
    result = black;
  if ((m[0][2] != color.b))
    result = black;
  if ((m[1][0] != color.r))
    result = black;
  if ((m[1][1] != color.g))
    result = black;
  if ((m[1][2] != color.b))
    result = black;
  if ((m[2][0] != color.r))
    result = black;
  if ((m[2][1] != color.g))
    result = black;
  if ((m[2][2] != color.b))
    result = black;
  gl_FragColor = result;
}


As vertex? : False
SUCCESS!
58.941605839416056
Mutations attempted: 548
Valid mutations:     323
Success rate:        58.94%
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 31.0 * gtf_Color.rg + 1.0;
	color = vec4(log(c) / 3.466, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 31.0 * gtf_Color.rg + 1.0;\n\tcolor = vec4(log(c) / 3.466, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, 0.5, 0.5, -0.5, -1.0, 0.5, 0.5, 2.0, -0.5, 0.0, -0.5, 0.0, 0.5, 2.0, 1.0);

vec4 color;

void main()
{
  vec2 c = ((31.0 * gtf_Color.rg) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, 0.5, 0.5, -0.5, -1.0, 0.5, 0.5, 2.0, -0.5, 0.0, -0.5, 0.0, 0.5, 2.0, 1.0);

vec4 color;

void main()
{
  vec2 c = ((31.0 * gtf_Color.rg) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.834244080145716
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (false ? ((false ? 2.0 : 1.0) + 1.0) : 0.0), 0.0, -(true ? 0.0 : 2.0));

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
58.909090909090914
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	float s = lightloc.s;
	float t = lightloc.t;
	float p = lightloc.p;
	float q = lightloc.q;
	vec4 m = vec4(s, t, p, q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tfloat s = lightloc.s;\n\tfloat t = lightloc.t;\n\tfloat p = lightloc.p;\n\tfloat q = lightloc.q;\n\tvec4 m = vec4(s, t, p, q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-1.0, 0.5, -1.0, 1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  float s = lightloc.s;
  float t = lightloc.t;
  float p = lightloc.p;
  float q = lightloc.q;
  vec4 m = vec4(s , t , p , q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
SUCCESS!
58.98366606170599
Processing this: /home/oof/webgl_cleaned/fract_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	c = abs((c - floor(c)) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tc = abs((c - floor(c)) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, -1.0, -1.0, -1.0);

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 0.5));
  c = (abs(((c - floor(c)) - 0.5)) * 2.0);
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.05797101449275
Processing this: /home/oof/webgl_cleaned/asin_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(asin(c) / M_PI + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(asin(c) / M_PI + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 1.0, 0.0, -0.5, 1.0, -0.5, 0.0, 2.0, 0.0, 2.0, 2.0, 0.5, 0.0, 2.0, 1.0, -1.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  color = vec4(((asin(c) / M_PI) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 1.0, 0.0, -0.5, 1.0, -0.5, 0.0, 2.0, 0.0, 2.0, 2.0, 0.5, 0.0, 2.0, 1.0, -1.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  color = vec4(((asin(c) / M_PI) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.95117540687161
Processing this: /home/oof/webgl_cleaned/4b_firstthree_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform bvec4 color;
void main ()
{
	gl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform bvec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct23956 {
  float f_3192;
  bvec3 f_616;
  uint f_3345;
  int f_7777;
  int f_5247;
  int f_4376;
};

uniform bvec4 color;

void main()
{
  gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]));
  main();
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:7: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct23956 {
  float f_3192;
  bvec3 f_616;
  uint f_3345;
  int f_7777;
  int f_5247;
  int f_4376;
};

uniform bvec4 color;

void main()
{
  gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]));
  main();
}


==============================
58.844765342960294
Processing this: /home/oof/webgl_cleaned/CorrectSwizzle1_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Normal;
uniform mat4 gtf_NormalMatrix;
void main()
{
   vec4 v = vec4(1,2,3,4);
   vec3 v3 = vec3(5,6,7);
   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);
   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Normal;\nuniform mat4 gtf_NormalMatrix;\nvoid main()\n{\n   vec4 v = vec4(1,2,3,4);\n   vec3 v3 = vec3(5,6,7);\n   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);\n   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Normal = vec4(-1.0, 0.0, 0.0, 0.0);

uniform mat4 gtf_NormalMatrix;

void main()
{
  vec4 v = vec4(1 , 2 , 3 , 4);
  vec3 v3 = vec3(5 , 6 , 7);
  vec4 v4 = vec4(normalize(v3.yzy).xyz.zyx , 1.0);
  gl_Position = (v4 + vec4(normalize((gtf_NormalMatrix * gtf_Normal)).xyz.zyx , v4.y));
}


As vertex? : True
SUCCESS!
58.91891891891892
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(notEqual(c, vec3(0.0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(notEqual(c, vec3(0.0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(result , 1.0);
  vec3 result = vec3(notEqual(c , vec3(0.0)));
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'result' : undeclared identifier
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'c' : undeclared identifier
ERROR: 0:9: 'notEqual' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(result , 1.0);
  vec3 result = vec3(notEqual(c , vec3(0.0)));
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
}


==============================
58.81294964028777
Processing this: /home/oof/webgl_cleaned/qualifiers_struct_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,
sabcd e)
{
        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
        b = a;
        c.a += d.a;
        c.b += d.b;
        c.c += d.c;
        c.d += d.d;
        a.a += one.a;
        a.b += one.b;
        a.c += one.c;
        a.d += one.d;
        return e;
}
void main ()
{
	sabcd a = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd b = sabcd(2.0, 2.0, 2.0, 2.0);
	sabcd c = sabcd(3.0, 3.0, 3.0, 3.0);
	sabcd d = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd e = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd f = sabcd(0.0, 0.0, 0.0, 0.0);
	sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd four = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == one) q += 1.0;
	if(b == one) q += 2.0;
	if(c == seven) q += 4.0;
	if(d == four) q2 += 1.0;
	if(e == one) q2 += 2.0;
	if(f == one) q2 += 4.0;
	color = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nsabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,\nsabcd e)\n{\n        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n        b = a;\n        c.a += d.a;\n        c.b += d.b;\n        c.c += d.c;\n        c.d += d.d;\n        a.a += one.a;\n        a.b += one.b;\n        a.c += one.c;\n        a.d += one.d;\n        return e;\n}\nvoid main ()\n{\n\tsabcd a = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd b = sabcd(2.0, 2.0, 2.0, 2.0);\n\tsabcd c = sabcd(3.0, 3.0, 3.0, 3.0);\n\tsabcd d = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd e = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd f = sabcd(0.0, 0.0, 0.0, 0.0);\n\tsabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd four = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == one) q += 1.0;\n\tif(b == one) q += 2.0;\n\tif(c == seven) q += 4.0;\n\tif(d == four) q2 += 1.0;\n\tif(e == one) q2 += 2.0;\n\tif(f == one) q2 += 4.0;\n\tcolor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 2.0, ((1.0 + (false ? 2.0 : 2.0)) / -+2.0), (-1.0 * ((true || false) ? 0.5 : 0.5)));

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d, sabcd e)
{
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  b = a;
  (c.a += d.a);
  (c.b += d.b);
  (c.c += d.c);
  (c.d += d.d);
  (a.a += one.a);
  (a.b += one.b);
  (a.c += one.c);
  (a.d += one.d);
  return e;
}

void main()
{
  sabcd a = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd b = sabcd(2.0 , 2.0 , 2.0 , 2.0);
  sabcd c = sabcd(3.0 , 3.0 , 3.0 , 3.0);
  sabcd d = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd e = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd f = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd four = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd seven = sabcd(7.0 , 7.0 , 7.0 , 7.0);
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == one))
    (q += 1.0);
  if ((b == one))
    (q += 2.0);
  if ((c == seven))
    (q += 4.0);
  if ((d == four))
    (q2 += 1.0);
  if ((e == one))
    (q2 += 2.0);
  if ((f == one))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.88689407540395
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(in mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_ones) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(in mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(in mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_ones) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(in mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
58.88689407540395
Mutations attempted: 557
Valid mutations:     328
Success rate:        58.89%
Processing this: /home/oof/webgl_cleaned/selection_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int j = 30;
	int k = 37;
	int y = 10;
	int n = 12;
	bool result1 = false;
	bool result2 = false;
	(j>k)?( result1 = true ):( result1 = false );
	(y<n)?( result2 = true ):( result2 = false );
	float gray;
	if( !result1 && result2 )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint j = 30;\n\tint k = 37;\n\tint y = 10;\n\tint n = 12;\n\tbool result1 = false;\n\tbool result2 = false;\n\t(j>k)?( result1 = true ):( result1 = false );\n\t(y<n)?( result2 = true ):( result2 = false );\n\tfloat gray;\n\tif( !result1 && result2 )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int j = 30;
  int k = 37;
  int y = 10;
  int n = 12;
  bool result1 = false;
  bool result2 = false;
  ((j > k) ? result1 = true : result1 = false);
  ((y < n) ? result2 = true : result2 = false);
  float gray;
  if ((!result1 && result2))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.96057347670251
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = -color.rg;
	gl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (true ? 1.0 : (true ? 2.0 : (true ? 0.5 : 1.0))), (true ? ((true ? 1.0 : 0.5) * -1.0) : +-1.0), (!true ? (-0.5 * (true ? -1.0 : 2.0)) : 0.0));

void main()
{
  vec2 c = -color.rg;
  gl_FragColor = vec4(exp2((5.0 * c)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.0339892665474
Processing this: /home/oof/webgl_cleaned/mat4_empty_out_mat4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(out mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_zeros) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(out mat4 par[2])
{
	set_all(par, mat_zeros);
	return mat_ones;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(out mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_zeros) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(out mat4 par[2])\n{\n\tset_all(par, mat_zeros);\n\treturn mat_ones;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
59.0339892665474
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.10714285714286
Processing this: /home/oof/webgl_cleaned/assignments_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 12;
	int n = 102;
	bool result = true;
	int r = m;
	if( r==12 )
		result = result && true;
	else
		result = result && false;
	r += m;
	if( r == 24 )
		result = result && true;
	else
		result = result && false;
	r-= m;
	if( r == 12 )
		result = result && true;
	else
		result = result && false;
	r*= m;
	if ( r == 144 )
		result = result && true;
	else
		result = result && false;
	r/= m;
	if( r >= 11 && r <= 13 )
		result = result && true;
	else
		result = result && false;
	float gray;
	if( result )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 12;\n\tint n = 102;\n\tbool result = true;\n\tint r = m;\n\tif( r==12 )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tr += m;\n\tif( r == 24 )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tr-= m;\n\tif( r == 12 )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tr*= m;\n\tif ( r == 144 )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tr/= m;\n\tif( r >= 11 && r <= 13 )\n\t\tresult = result && true;\n\telse\n\t\tresult = result && false;\n\tfloat gray;\n\tif( result )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 1.0, -0.5, 2.0);

void main()
{
  int m = 12;
  int n = 102;
  bool result = true;
  int r = m;
  if ((r == 12))
    result = (result && true);
  else
    result = (result && false);
  (r += m);
  if ((r == 24))
    result = (result && true);
  else
    result = (result && false);
  (r -= m);
  if ((r == 12))
    result = (result && true);
  else
    result = (result && false);
  (r *= m);
  if ((r == 144))
    result = (result && true);
  else
    result = (result && false);
  (r /= m);
  if (((r >= 11) && (r <= 13)))
    result = (result && true);
  else
    result = (result && false);
  float gray;
  if (result)
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.180035650623886
Processing this: /home/oof/webgl_cleaned/ivec3_3int_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	ivec3 a = ivec3(20, 13, 17);
	float gray;
	if( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tivec3 a = ivec3(20, 13, 17);\n\tfloat gray;\n\tif( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  ivec3 a = ivec3(20 , 13 , 17);
  float gray = 1.0;
  if ((((a[0] == 20) && (a[1] == 13)) && (a[2] == 17)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
  vec4(+1.0, (!(false ? true : true) ? 2.0 : 0.0), +((0.5 / 0.5) * +2.0), gray);
}


As vertex? : False
SUCCESS!
59.252669039145914
Processing this: /home/oof/webgl_cleaned/array_const_mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
		             5.0,  6.0,  7.0,  8.0,
			     9.0, 10.0, 11.0, 12.0,
			    13.0, 14.0, 15.0, 16.0);
	const mat4 b = mat4(17.0, 18.0, 19.0, 20.0,
		            21.0, 22.0, 23.0, 24.0,
			    25.0, 26.0, 27.0, 28.0,
			    29.0, 30.0, 31.0, 32.0);
	mat4 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t\t             5.0,  6.0,  7.0,  8.0,\n\t\t\t     9.0, 10.0, 11.0, 12.0,\n\t\t\t    13.0, 14.0, 15.0, 16.0);\n\tconst mat4 b = mat4(17.0, 18.0, 19.0, 20.0,\n\t\t            21.0, 22.0, 23.0, 24.0,\n\t\t\t    25.0, 26.0, 27.0, 28.0,\n\t\t\t    29.0, 30.0, 31.0, 32.0);\n\tmat4 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, (0.0 / -0.5), (+(0.0 - 2.0) - (0.0 * (0.5 - 2.0))), (--1.0 + (+0.0 / (0.0 - -1.0))));

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, (0.0 / -0.5), (+(0.0 - 2.0) - (0.0 * (0.5 - 2.0))), (--1.0 + (+0.0 / (0.0 - -1.0))));

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.14742451154529
Processing this: /home/oof/webgl_cleaned/fract_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);
	c = abs((c - floor(c)) - 0.5) * 2.0;
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tc = abs((c - floor(c)) - 0.5) * 2.0;\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, -1.0, 0.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  c = (abs(((c - floor(c)) - 0.5)) * 2.0);
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.21985815602837
Processing this: /home/oof/webgl_cleaned/3i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec3 color;
void main ()
{
	gl_FragColor = vec4 (color[0], color[1], color[2], 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec3 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0], color[1], color[2], 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec3 color[3] = ivec3(7, 7, 3);

void main()
{
  gl_FragColor = vec4(color[0] , color[1] , color[2] , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 
ERROR: 0:8: 'constructor' : too many arguments

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform ivec3 color[3] = ivec3(7, 7, 3);

void main()
{
  gl_FragColor = vec4(color[0] , color[1] , color[2] , 1.0);
}


==============================
59.11504424778761
Processing this: /home/oof/webgl_cleaned/successfulcompile_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec3 gtf_Normal;
attribute vec4 gtf_Vertex;
uniform mat3 gtf_NormalMatrix;
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying float lightIntensity;
varying vec3 Position;
uniform vec3 LightPosition;
uniform float Scale;
void main() {
	vec4 pos = gtf_ModelViewMatrix * gtf_Vertex;
	Position = vec3(gtf_Vertex) * Scale;
	vec3 tnorm = normalize(gtf_NormalMatrix * gtf_Normal);
	lightIntensity = dot(normalize(LightPosition - vec3(pos)), tnorm) * 1.5;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec3 gtf_Normal;\nattribute vec4 gtf_Vertex;\nuniform mat3 gtf_NormalMatrix;\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying float lightIntensity;\nvarying vec3 Position;\nuniform vec3 LightPosition;\nuniform float Scale;\nvoid main() {\n\tvec4 pos = gtf_ModelViewMatrix * gtf_Vertex;\n\tPosition = vec3(gtf_Vertex) * Scale;\n\tvec3 tnorm = normalize(gtf_NormalMatrix * gtf_Normal);\n\tlightIntensity = dot(normalize(LightPosition - vec3(pos)), tnorm) * 1.5;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity;

vec3 Position;

uniform vec3 LightPosition;

uniform float Scale = (!(true || true) ? +(0.0 * 0.0) : ((false ? 0.5 : lightIntensity) / (0.5 - -1.0)));

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = (vec3(gtf_Vertex) * Scale);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  lightIntensity = (dot(normalize((LightPosition - vec3(pos))) , tnorm) * 1.5);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:20: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity;

vec3 Position;

uniform vec3 LightPosition;

uniform float Scale = (!(true || true) ? +(0.0 * 0.0) : ((false ? 0.5 : lightIntensity) / (0.5 - -1.0)));

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = (vec3(gtf_Vertex) * Scale);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  lightIntensity = (dot(normalize((LightPosition - vec3(pos))) , tnorm) * 1.5);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.01060070671378
Mutations attempted: 566
Valid mutations:     334
Success rate:        59.01%
Processing this: /home/oof/webgl_cleaned/const_mat3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0,   2.0,   4.0,
	                     8.0,  16.0,  32.0,
	                    64.0, 128.0, 256.0);
	bool elms = true;
	if(a[0][0] !=   1.0) elms = false;
	if(a[0][1] !=   2.0) elms = false;
	if(a[0][2] !=   4.0) elms = false;
	if(a[1][0] !=   8.0) elms = false;
	if(a[1][1] !=  16.0) elms = false;
	if(a[1][2] !=  32.0) elms = false;
	if(a[2][0] !=  64.0) elms = false;
	if(a[2][1] != 128.0) elms = false;
	if(a[2][2] != 256.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0];
	if( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;
	x = a[0][1] + a[1][1] + a[2][1];
	if(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;
	x = a[0][2] + a[1][2] + a[2][2];
	if(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2];
	if( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;
	x = a[1][0] + a[1][1] + a[1][2];
	if(x < 56.0-0.1 || x > 56.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2];
	if(x < 448.0-0.1 || x > 448.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0,   2.0,   4.0,\n\t                     8.0,  16.0,  32.0,\n\t                    64.0, 128.0, 256.0);\n\tbool elms = true;\n\tif(a[0][0] !=   1.0) elms = false;\n\tif(a[0][1] !=   2.0) elms = false;\n\tif(a[0][2] !=   4.0) elms = false;\n\tif(a[1][0] !=   8.0) elms = false;\n\tif(a[1][1] !=  16.0) elms = false;\n\tif(a[1][2] !=  32.0) elms = false;\n\tif(a[2][0] !=  64.0) elms = false;\n\tif(a[2][1] != 128.0) elms = false;\n\tif(a[2][2] != 256.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0];\n\tif( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1];\n\tif(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2];\n\tif(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2];\n\tif( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2];\n\tif(x < 56.0-0.1 || x > 56.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2];\n\tif(x < 448.0-0.1 || x > 448.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(1.0, -0.5, 0.5, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 4.0))
    elms = false;
  if ((a[1][0] != 8.0))
    elms = false;
  if ((a[1][1] != 16.0))
    elms = false;
  if ((a[1][2] != 32.0))
    elms = false;
  if ((a[2][0] != 64.0))
    elms = false;
  if ((a[2][1] != 128.0))
    elms = false;
  if ((a[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((a[0][0] + a[1][0]) + a[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((a[0][1] + a[1][1]) + a[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((a[0][2] + a[1][2]) + a[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((a[0][0] + a[0][1]) + a[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((a[1][0] + a[1][1]) + a[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((a[2][0] + a[2][1]) + a[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.082892416225754
Processing this: /home/oof/webgl_cleaned/mat_tests2.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute mat2 att2;
attribute mat3 att3;
varying vec4 color;
void main ()
{
	color = vec4( att2[0][0] + att2[0][1] + att2[1][0] + att2[1][1],
		      att3[0][0] + att3[0][1] + att3[0][2] + att3[1][0] + att3[1][1] + att3[1][2] + att3[2][0] + att3[2][1] + att3[2][2],
                     1.0, 1.0 );
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute mat2 att2;\nattribute mat3 att3;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4( att2[0][0] + att2[0][1] + att2[1][0] + att2[1][1],\n\t\t      att3[0][0] + att3[0][1] + att3[0][2] + att3[1][0] + att3[1][1] + att3[1][2] + att3[2][0] + att3[2][1] + att3[2][2],\n                     1.0, 1.0 );\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

mat2 att2;

mat3 att3;

vec4 color = vec4(0.0, -1.0, 2.0, -0.5);

void main()
{
  color = vec4((((att2[0][0] + att2[0][1]) + att2[1][0]) + att2[1][1]) , ((((((((att3[0][0] + att3[0][1]) + att3[0][2]) + att3[1][0]) + att3[1][1]) + att3[1][2]) + att3[2][0]) + att3[2][1]) + att3[2][2]) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.154929577464785
Processing this: /home/oof/webgl_cleaned/for_nested_continue_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int count1 = 0, count2 = 0;
	int val1 = 0, val2 = 0;
    	for(int i=0;i<10;i++)
	{
	  	count1++;
		count2 = 0;
		for(int j=0;j<10;j++)
		{
			count2++;
			if(count2 == 5)
				continue;
			else
				val2 += count2;
		}
	  	if(count1 == 5)
            		continue;
	  	else
	    		val1 += count1;
	}
	float gray;
	if( (val1 == 50) && (val2 == 500) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint count1 = 0, count2 = 0;\n\tint val1 = 0, val2 = 0;\n    \tfor(int i=0;i<10;i++)\n\t{\n\t  \tcount1++;\n\t\tcount2 = 0;\n\t\tfor(int j=0;j<10;j++)\n\t\t{\n\t\t\tcount2++;\n\t\t\tif(count2 == 5)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tval2 += count2;\n\t\t}\n\t  \tif(count1 == 5)\n            \t\tcontinue;\n\t  \telse\n\t    \t\tval1 += count1;\n\t}\n\tfloat gray;\n\tif( (val1 == 50) && (val2 == 500) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 0.5, 1.0, (true ? 0.5 : (2.0 + -1.0)));

void main()
{
  int count1 = 0 , count2 = 0;
  int val1 = 0 , val2 = 0;
  for (int i = 0; (i < 10); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 10); j++)
    {
      count2++;
      if ((count2 == 5))
        continue;
      else
        (val2 += count2);
    }
    if ((count1 == 5))
      continue;
    else
      (val1 += count1);
  }
  float gray;
  if (((val1 == 50) && (val2 == 500)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.22671353251317
Processing this: /home/oof/webgl_cleaned/empty_uniform_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const int array_size = 2;
uniform float new_mad2[array_size];
void main ()
{
	int i=0;
	float new_mad[array_size];
	float gray = 0.0;
	new_mad[0] = new_mad2[0];
	new_mad[1] = new_mad2[1];
	if( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst int array_size = 2;\nuniform float new_mad2[array_size];\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[array_size];\n\tfloat gray = 0.0;\n\tnew_mad[0] = new_mad2[0];\n\tnew_mad[1] = new_mad2[1];\n\tif( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const int array_size = 2;

uniform float new_mad2[array_size];

void main()
{
  int i = 0;
  float new_mad[array_size];
  float gray = 0.0;
  new_mad[0] = new_mad2[0];
  new_mad[1] = new_mad2[1];
  if (((new_mad[0] == 45.0) && (new_mad[1] == 14.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.29824561403508
Processing this: /home/oof/webgl_cleaned/relational_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool lessthan  = (m<k);
	bool greaterthan = (m>k);
	bool lessthanorequalto = (m <= 102);
	bool greaterthanorequalto = (k >=12);
	float gray;
	if( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool lessthan  = (m<k);\n\tbool greaterthan = (m>k);\n\tbool lessthanorequalto = (m <= 102);\n\tbool greaterthanorequalto = (k >=12);\n\tfloat gray;\n\tif( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (k >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.36952714535902
Processing this: /home/oof/webgl_cleaned/4i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec4 color;
void main ()
{
	gl_FragColor = vec4 (color[0], color[1], color[2], color[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0], color[1], color[2], color[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec4 color = ivec4(-5, (5 - (-0 / (false ? 4 : 5))), (((true || true) ? -3 : 2) + 4), ((!true ? (false || true) : (false ? false : true)) ? +(true ? 1 : 4) : 8));

void main()
{
  gl_FragColor = vec4(color[0] , color[1] , color[2] , color[3]);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform ivec4 color = ivec4(-5, (5 - (-0 / (false ? 4 : 5))), (((true || true) ? -3 : 2) + 4), ((!true ? (false || true) : (false ? false : true)) ? +(true ? 1 : 4) : 8));

void main()
{
  gl_FragColor = vec4(color[0] , color[1] , color[2] , color[3]);
}


==============================
59.265734265734274
Processing this: /home/oof/webgl_cleaned/bvec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform bool vuni1;
uniform bvec2 vuni2;
uniform bvec3 vuni3;
uniform bvec4 vuni4;
varying vec4 color;
void main ()
{
	if(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])
	color = vec4(1.0, 0.0, 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform bool vuni1;\nuniform bvec2 vuni2;\nuniform bvec3 vuni3;\nuniform bvec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tif(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])\n\tcolor = vec4(1.0, 0.0, 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform bool vuni1;

uniform bvec2 vuni2;

uniform bvec3 vuni3;

uniform bvec4 vuni4 = vuni4;

vec4 color;

void main()
{
  if (((vuni1 || ((((vuni2[0] && vuni2[1]) && vuni3[0]) && vuni3[1]) && vuni3[2])) || (((vuni4[0] && vuni4[1]) && vuni4[2]) && vuni4[3])))
    color = vec4(1.0 , 0.0 , 0.5 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'vuni4' : undeclared identifier
ERROR: 0:14: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform bool vuni1;

uniform bvec2 vuni2;

uniform bvec3 vuni3;

uniform bvec4 vuni4 = vuni4;

vec4 color;

void main()
{
  if (((vuni1 || ((((vuni2[0] && vuni2[1]) && vuni3[0]) && vuni3[1]) && vuni3[2])) || (((vuni4[0] && vuni4[1]) && vuni4[2]) && vuni4[3])))
    color = vec4(1.0 , 0.0 , 0.5 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.16230366492147
Processing this: /home/oof/webgl_cleaned/const_mat2_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	mat2 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 8.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = b[0][1] + b[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = b[1][0] + b[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tmat2 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-1.0, ((2.0 * +-1.0) * 0.5), +-1.0, -+-1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.23344947735192
Processing this: /home/oof/webgl_cleaned/dot_vec3_frag_xvaryythird.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(dot(color.rgb, vec3(0.3333))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(dot(color.rgb, vec3(0.3333))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.5, 0.5, (--1.0 / -1.0));

void main()
{
  gl_FragColor = vec4(vec3(dot(color.rgb , vec3(0.3333))) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.5, 0.5, (--1.0 / -1.0));

void main()
{
  gl_FragColor = vec4(vec3(dot(color.rgb , vec3(0.3333))) , 1.0);
}


==============================
59.130434782608695
Processing this: /home/oof/webgl_cleaned/ivec4_empty_out_ivec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
ivec4 function(out ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
ivec4 function(out ivec4 par)
{
	set_all(par, 0);
	return ivec4(1, 1, 1, 1);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nivec4 function(out ivec4 par);\nbool is_all(const in ivec4 par, const in int value);\nvoid set_all(out ivec4 par, const in int value);\nvoid main ()\n{\n\tivec4 par = ivec4(1, 1, 1, 1);\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nivec4 function(out ivec4 par)\n{\n\tset_all(par, 0);\n\treturn ivec4(1, 1, 1, 1);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 par, const in int value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
59.130434782608695
Mutations attempted: 575
Valid mutations:     340
Success rate:        59.13%
Processing this: /home/oof/webgl_cleaned/structcopy_bvec2bvec3bvec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	bvec2 a;
	bvec3 b;
	bvec4 c;
};
void main ()
{
	sabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );
	sabcd s2 = sabcd( bvec2(0, 0), bvec3(0.0, 0.0, 0.0), bvec4(0.0, 0.0, 0.0, 0.0 ) );
	s2 = s;
	float gray = 0.0;
	if( (s2.a[0]) && (s2.a[1]) && (s2.b[0]) && (!s2.b[1]) && (s2.b[2]) && (s2.c[0]) && (s2.c[1]) && (s2.c[2]) )
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tbvec2 a;\n\tbvec3 b;\n\tbvec4 c;\n};\nvoid main ()\n{\n\tsabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );\n\tsabcd s2 = sabcd( bvec2(0, 0), bvec3(0.0, 0.0, 0.0), bvec4(0.0, 0.0, 0.0, 0.0 ) );\n\ts2 = s;\n\tfloat gray = 0.0;\n\tif( (s2.a[0]) && (s2.a[1]) && (s2.b[0]) && (!s2.b[1]) && (s2.b[2]) && (s2.c[0]) && (s2.c[1]) && (s2.c[2]) )\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  bvec2 a;
  bvec3 b;
  bvec4 c;
};

void main()
{
  sabcd s = sabcd(bvec2(12 , 13) , bvec3(14.0 , 0.0 , 139.0) , bvec4(25.5 , 17.0 , 145 , 163));
  sabcd s2 = sabcd(bvec2(0 , 0) , bvec3(0.0 , 0.0 , 0.0) , bvec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  float gray = 0.0;
  if ((((((((s2.a[0] && s2.a[1]) && s2.b[0]) && !s2.b[1]) && s2.b[2]) && s2.c[0]) && s2.c[1]) && s2.c[2]))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.201388888888886
Processing this: /home/oof/webgl_cleaned/webgl_function.vert
Original source code: 
precision mediump float;
precision mediump int;

vec4 webgl_foo() {
  return vec4(1.0);
}
void main() {
  gl_Position = webgl_foo();
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvec4 webgl_foo() {\n  return vec4(1.0);\n}\nvoid main() {\n  gl_Position = webgl_foo();\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 webgl_foo()
{
  return vec4(1.0);
}

void main()
{
  gl_Position = webgl_foo();
}


As vertex? : True
SUCCESS!
59.27209705372617
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 ne(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(ne(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 ne(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(ne(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 ne(in vec2 b, in vec2 a)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(ne(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.34256055363322
Processing this: /home/oof/webgl_cleaned/clamp_float_frag_xvary_yconstquarter.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = color.r;
	gl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = color.r;
  vec4(clamp(c , min_c , max_c) , 0.0 , 0.0) = color;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: 'constructor' : not enough data provided for construction
ERROR: 0:11: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = color.r;
  vec4(clamp(c , min_c , max_c) , 0.0 , 0.0) = color;
}


==============================
59.240069084628665
Processing this: /home/oof/webgl_cleaned/max_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 max_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] < max_c[0]) c[0] = max_c[0];
	if(c[1] < max_c[1]) c[1] = max_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 max_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] < max_c[0]) c[0] = max_c[0];\n\tif(c[1] < max_c[1]) c[1] = max_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((color[0] != max_c[1]))
    c[0] = max_c[0];
  gl_FragColor = vec4(c , 0.0 , 1.0);
  vec2 c = color.rg;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  const vec2 max_c = vec2(0.5 , 0.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'max_c' : undeclared identifier
ERROR: 0:8: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:9: 'c' : undeclared identifier
ERROR: 0:9: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:9: 'max_c' : undeclared identifier
ERROR: 0:9: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:10: 'c' : undeclared identifier
ERROR: 0:10: 'constructor' : not enough data provided for construction
ERROR: 0:12: 'max_c' : undeclared identifier
ERROR: 0:12: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:13: 'max_c' : undeclared identifier
ERROR: 0:13: 'expression' :  left of '[' is not of type array, matrix, or vector 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((color[0] != max_c[1]))
    c[0] = max_c[0];
  gl_FragColor = vec4(c , 0.0 , 1.0);
  vec2 c = color.rg;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  const vec2 max_c = vec2(0.5 , 0.5);
}


==============================
59.13793103448276
Processing this: /home/oof/webgl_cleaned/sign_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(c * sign(c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(c * sign(c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(2.0, 0.5, ((true ? false : false) ? -(1.0 / 0.5) : ((false || false) ? 0.0 : -1.0)), (+2.0 / (false ? 0.0 : 0.0)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((c * sign(c)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.20826161790017
Processing this: /home/oof/webgl_cleaned/normalize_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(normalize(tmp_Color.rgb), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(normalize(tmp_Color.rgb), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, 1.0, 0.5, 0.0);

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  gl_FragColor = vec4(normalize(tmp_Color.rgb) , 1.0);
}


As vertex? : False
SUCCESS!
59.27835051546392
Processing this: /home/oof/webgl_cleaned/mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	mat2 a = mat2(1.0, 2.0,
	              4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tmat2 a = mat2(1.0, 2.0,\n\t              4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  -1.0 = (a[-16][1] + ivec2(2.0, 0.5)[-1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:21: '[]' : index expression is negative
ERROR: 0:21: '[]' : index expression is negative
ERROR: 0:21: '+' : wrong operand types - no operation '+' exists that takes a left-hand operand of type 'mediump float' and a right operand of type 'const int' (or there is no acceptable conversion)
ERROR: 0:21: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  -1.0 = (a[-16][1] + ivec2(2.0, 0.5)[-1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
59.17667238421955
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xvary_yconst2_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 4.0 * (color.r);
	gl_FragColor = vec4(c * c / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 4.0 * (color.r);\n\tgl_FragColor = vec4(c * c / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (!true ? 2.0 : 1.0), -1.0, 2.0);

void main()
{
  float c = (4.0 * color.r);
  gl_FragColor = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.24657534246576
Processing this: /home/oof/webgl_cleaned/faceforward_vec2_vert_nvaryiconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	if(dot(v1, v2) >= 0.0) v1 *= -1.0;
	color = vec4((v1 + 1.0) / 2.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tif(dot(v1, v2) >= 0.0) v1 *= -1.0;\n\tcolor = vec4((v1 + 1.0) / 2.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[3] = vec4(1.0, 0.0, 1.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  color = vec4(((v1 + 1.0) / 2.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[3] of 4-component vector of float'
ERROR: 0:24: '*' : array / non-array mismatch
ERROR: 0:24: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[3] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:24: '=' : dimension mismatch
ERROR: 0:24: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[3] = vec4(1.0, 0.0, 1.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  color = vec4(((v1 + 1.0) / 2.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.14529914529915
Mutations attempted: 585
Valid mutations:     346
Success rate:        59.15%
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconsthalf_yvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = -2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (color.rgb - 0.5));
  gl_FragColor = color((exp2((2.0 * c)) / 4.0));
  vec4(--1.0, 1.0, ((true ? true : false) ? 0.5 : 0.0), 2.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'gl_FragColor' : undeclared identifier
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:10: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (color.rgb - 0.5));
  gl_FragColor = color((exp2((2.0 * c)) / 4.0));
  vec4(--1.0, 1.0, ((true ? true : false) ? 0.5 : 0.0), 2.0);
}


==============================
59.044368600682596
Processing this: /home/oof/webgl_cleaned/tan_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 0.5 * M_PI * 2.0 * (color.rgb - 0.5);
	vec3 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * tan(c.r) + 0.5;
	else
		o.r = 0.5 / tan(c.r) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * tan(c.g) + 0.5;
	else
		o.g = 0.5 / tan(c.g) + 0.5;
	if(abs(c.b) < 0.5)
		o.b = 0.5 * tan(c.b) + 0.5;
	else
		o.b = 0.5 / tan(c.b) + 0.5;
	gl_FragColor = vec4(o, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 0.5 * M_PI * 2.0 * (color.rgb - 0.5);\n\tvec3 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * tan(c.r) + 0.5;\n\telse\n\t\to.r = 0.5 / tan(c.r) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * tan(c.g) + 0.5;\n\telse\n\t\to.g = 0.5 / tan(c.g) + 0.5;\n\tif(abs(c.b) < 0.5)\n\t\to.b = 0.5 * tan(c.b) + 0.5;\n\telse\n\t\to.b = 0.5 / tan(c.b) + 0.5;\n\tgl_FragColor = vec4(o, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-(+1.0 - 0.5), (((false ? true : true) ? (false ? 0.5 : 0.0) : -1.0) + 2.0), 2.0, -((0.5 + 0.0) * 0.0));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * tan(c.b)) + 0.5);
  else
    o.b = ((0.5 / tan(c.b)) + 0.5);
  gl_FragColor = vec4(o , 1.0);
}


As vertex? : False
SUCCESS!
59.11413969335605
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec2 gt(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(gt(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec2 gt(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(gt(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 gt(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] < b[1]))
    ((true ? true : false) ? 2.0 : (false ? 1.0 : 2.0));
  else
    ivec2(9, 5) = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(gt(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'assign' : l-value required (can't modify a const)
ERROR: 0:16: 'assign' : cannot convert from 'const bool' to 'const 2-component vector of int'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec2 gt(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] < b[1]))
    ((true ? true : false) ? 2.0 : (false ? 1.0 : 2.0));
  else
    ivec2(9, 5) = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(gt(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


==============================
59.013605442176875
Processing this: /home/oof/webgl_cleaned/ivec3_3int_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	ivec3 a = ivec3(20, 13, 17);
	float gray;
	if( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tivec3 a = ivec3(20, 13, 17);\n\tfloat gray;\n\tif( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  ivec3 a = ivec3(20 , 13 , 17);
  float gray;
  if ((((a[0] == 20) && (a[1] == 13)) && (a[2] == 17)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.08319185059423
Processing this: /home/oof/webgl_cleaned/nested_if_else_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int setval = 30;
	if(--setval!=29)
		if( (setval+=11) == 40)
			if(setval/4 == 11)
				setval = 11;
			else if(setval/4 == 10)
				if(setval-3 == 37)
					setval=12;
				else setval = 9;
			else setval = 10;
		else setval = 30;
	else if(setval == 29)
		if((setval+=19) != 48)
			setval = 13;
		else if((setval+=19) == 29)
			setval = 28;
		else setval = 53;
	else setval = 32;
	float gray;
	if( setval == 53 )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint setval = 30;\n\tif(--setval!=29)\n\t\tif( (setval+=11) == 40)\n\t\t\tif(setval/4 == 11)\n\t\t\t\tsetval = 11;\n\t\t\telse if(setval/4 == 10)\n\t\t\t\tif(setval-3 == 37)\n\t\t\t\t\tsetval=12;\n\t\t\t\telse setval = 9;\n\t\t\telse setval = 10;\n\t\telse setval = 30;\n\telse if(setval == 29)\n\t\tif((setval+=19) != 48)\n\t\t\tsetval = 13;\n\t\telse if((setval+=19) == 29)\n\t\t\tsetval = 28;\n\t\telse setval = 53;\n\telse setval = 32;\n\tfloat gray;\n\tif( setval == 53 )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int setval = 30;
  if ((--setval != 29))
    if (((setval += 11) == 40))
      if (((setval / 4) == 11))
        setval = 11;
      else
        if (((setval / 4) == 10))
          if (((setval - 3) == 37))
            setval = 12;
          else
            setval = 9;
        else
          setval = 10;
    else
      setval = 30;
  else
    if ((setval == 29))
      if (((setval += 19) != 48))
        setval = 13;
      else
        if (((setval += 19) == 29))
          setval = 28;
        else
          setval = 53;
    else
      setval = 32;
  float gray;
  if ((setval == 0))
    color = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:36: '=' : dimension mismatch
ERROR: 0:36: 'assign' : cannot convert from 'const float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int setval = 30;
  if ((--setval != 29))
    if (((setval += 11) == 40))
      if (((setval / 4) == 11))
        setval = 11;
      else
        if (((setval / 4) == 10))
          if (((setval - 3) == 37))
            setval = 12;
          else
            setval = 9;
        else
          setval = 10;
    else
      setval = 30;
  else
    if ((setval == 29))
      if (((setval += 19) != 48))
        setval = 13;
      else
        if (((setval += 19) == 29))
          setval = 28;
        else
          setval = 53;
    else
      setval = 32;
  float gray;
  if ((setval == 0))
    color = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
58.98305084745763
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +2.0, (!false ? 0.5 : (true ? 0.5 : -1.0)), +0.5, 2.0, ((1.0 + (0.5 - 1.0)) + 2.0), (1.0 * 0.5), (true ? 0.5 : 0.5), (!true ? 0.0 : -1.0), (true ? -1.0 : ((-1.0 + 1.0) * (false ? 2.0 : 1.0))), (((true && true) ? 0.0 : +0.0) + +(true ? 2.0 : 0.5)), -1.0, (2.0 + 2.0), +-1.0, 2.0, +-1.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +2.0, (!false ? 0.5 : (true ? 0.5 : -1.0)), +0.5, 2.0, ((1.0 + (0.5 - 1.0)) + 2.0), (1.0 * 0.5), (true ? 0.5 : 0.5), (!true ? 0.0 : -1.0), (true ? -1.0 : ((-1.0 + 1.0) * (false ? 2.0 : 1.0))), (((true && true) ? 0.0 : +0.0) + +(true ? 2.0 : 0.5)), -1.0, (2.0 + 2.0), +-1.0, 2.0, +-1.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.88324873096447
Processing this: /home/oof/webgl_cleaned/equal_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(equal(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(equal(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.0, (1.0 + -1.0), (((false ? true : false) ? (false ? 1.0 : 0.0) : -1.0) - 0.0));

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(equal(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
58.952702702702695
Processing this: /home/oof/webgl_cleaned/mat3arrayindirect0_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat3 testmat3[2];
varying vec4  color;
void main()
{
     vec3 result = vec3(0.0, 0.0, 0.0);
     for(int j = 0; j < 3; j++)
     {
	result += testmat3[0][j] + testmat3[1][j];
     }
     color = vec4(result/2.0, 0.5);
     gl_Position     = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat3 testmat3[2];\nvarying vec4  color;\nvoid main()\n{\n     vec3 result = vec3(0.0, 0.0, 0.0);\n     for(int j = 0; j < 3; j++)\n     {\n\tresult += testmat3[0][j] + testmat3[1][j];\n     }\n     color = vec4(result/2.0, 0.5);\n     gl_Position     = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(--0.5, +0.5, 1.0, (false ? (false ? 2.0 : 0.0) : 0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat3 testmat3[2];

vec4 color;

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  for (int j = 0; (j < 3); j++)
  {
    (result += (testmat3[0][j] + testmat3[1][j]));
  }
  color = vec4((result / 2.0) , 0.5);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(--0.5, +0.5, 1.0, (false ? (false ? 2.0 : 0.0) : 0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat3 testmat3[2];

vec4 color;

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  for (int j = 0; (j < 3); j++)
  {
    (result += (testmat3[0][j] + testmat3[1][j]));
  }
  color = vec4((result / 2.0) , 0.5);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.85328836424958
Processing this: /home/oof/webgl_cleaned/mod_x_large_y_large_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(mod(300.0, 100.0), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(mod(300.0, 100.0), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = color(mod(300.0 , 100.0) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'gl_FragColor' : undeclared identifier
ERROR: 0:8: 'color' : function name expected
ERROR: 0:8: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = color(mod(300.0 , 100.0) , 0.0 , 0.0);
}


==============================
58.75420875420876
Processing this: /home/oof/webgl_cleaned/atan_vec2_vert_xvaryyvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 x = 2.0 * (gtf_Color.gg - 0.5);
	vec2 y = 2.0 * (gtf_Color.bb - 0.5);
	vec2 c;
	vec2 atan_c = vec2(0.0);
	vec2 scale = vec2(1.0);
	vec2 sign = vec2(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		if(x[0] < 0.0 ^^ y[0] < 0.0)
		{
			sign[0] = -1.0;
		}
		if(abs(y[0]) <= abs(x[0]))
		{
			c[0] = abs(y[0] / x[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[0] = abs(x[0] / y[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;
		}
		if(x[0] < 0.0)
			if(y[0] < 0.0) result[0] -= 0.5;
			else if(y[0] > 0.0) result[0] += 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		if(x[1] < 0.0 ^^ y[1] < 0.0)
		{
			sign[1] = -1.0;
		}
		if(abs(y[1]) <= abs(x[1]))
		{
			c[1] = abs(y[1] / x[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[1] = abs(x[1] / y[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;
		}
		if(x[1] < 0.0)
			if(y[1] < 0.0) result[1] -= 0.5;
			else if(y[1] > 0.0) result[1] += 0.5;
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 x = 2.0 * (gtf_Color.gg - 0.5);\n\tvec2 y = 2.0 * (gtf_Color.bb - 0.5);\n\tvec2 c;\n\tvec2 atan_c = vec2(0.0);\n\tvec2 scale = vec2(1.0);\n\tvec2 sign = vec2(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tif(x[0] < 0.0 ^^ y[0] < 0.0)\n\t\t{\n\t\t\tsign[0] = -1.0;\n\t\t}\n\t\tif(abs(y[0]) <= abs(x[0]))\n\t\t{\n\t\t\tc[0] = abs(y[0] / x[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[0] = abs(x[0] / y[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[0] < 0.0)\n\t\t\tif(y[0] < 0.0) result[0] -= 0.5;\n\t\t\telse if(y[0] > 0.0) result[0] += 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tif(x[1] < 0.0 ^^ y[1] < 0.0)\n\t\t{\n\t\t\tsign[1] = -1.0;\n\t\t}\n\t\tif(abs(y[1]) <= abs(x[1]))\n\t\t{\n\t\t\tc[1] = abs(y[1] / x[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[1] = abs(x[1] / y[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[1] < 0.0)\n\t\t\tif(y[1] < 0.0) result[1] -= 0.5;\n\t\t\telse if(y[1] > 0.0) result[1] += 0.5;\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, (2.0 / 2.0), 1.0, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 x = (2.0 * (gtf_Color.gg - 0.5));
  vec2 y = (2.0 * (gtf_Color.bb - 0.5));
  vec2 c;
  vec2 atan_c = vec2(0.0);
  vec2 scale = vec2(1.0);
  vec2 sign = vec2(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      sign[0] = -1.0;
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      c[0] = abs((y[0] / x[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[0] = abs((x[0] / y[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      sign[1] = -1.0;
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      c[1] = abs((y[1] / x[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[1] = abs((x[1] / y[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
58.82352941176471
Mutations attempted: 595
Valid mutations:     350
Success rate:        58.82%
Processing this: /home/oof/webgl_cleaned/pow_vec2_frag_xconst2_yvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (-1.0 / 0.0), 0.5, -1.0);

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  gl_FragColor = vec4((pow(vec2(2.0) , (2.0 * c)) / 4.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
58.89261744966443
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	float c = color.r;
	gl_FragColor = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((false || false) ? 0.0 : (0.5 + 1.0)) - 1.0), 0.5, 2.0, -0.5);

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  float c = color.r;
  gl_FragColor = vec4((pow(exp1 , (3.0 * c)) / exp3) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
58.96147403685092
Processing this: /home/oof/webgl_cleaned/cos_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * gtf_Color.rgb;
	float sign = -1.0;
	vec3 cos_c = vec3(1.0,1.0,1.0);
	float fact = 1.0;
	for(int i = 2; i <= 20; i += 2)
	{
		fact *= float(i)*float(i-1);
		cos_c += sign*pow(c, vec3(float(i),float(i),float(i)))/fact;
		sign = -sign;
	}
	color = vec4(0.5 * cos_c + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * gtf_Color.rgb;\n\tfloat sign = -1.0;\n\tvec3 cos_c = vec3(1.0,1.0,1.0);\n\tfloat fact = 1.0;\n\tfor(int i = 2; i <= 20; i += 2)\n\t{\n\t\tfact *= float(i)*float(i-1);\n\t\tcos_c += sign*pow(c, vec3(float(i),float(i),float(i)))/fact;\n\t\tsign = -sign;\n\t}\n\tcolor = vec4(0.5 * cos_c + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

vec4 gtf_Vertex;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * gtf_Color.rgb);
  float sign = -1.0;
  vec3 cos_c = vec3(1.0 , 1.0 , 1.0);
  float fact = 1.0;
  for (int i = 2; (i <= 20); (i += 2))
  {
    (fact *= (float(i) * float((i - 1))));
    (cos_c += ((sign * pow(c , vec3(float(i) , float(i) , float(i)))) / fact));
    sign = -sign;
  }
  color = vec4(((0.5 * cos_c) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.030100334448164
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, +0.5, 1.0, 1.0, 0.5, 2.0, 0.0, (!(false && false) ? 0.5 : +2.0), +2.0, (!false ? (-2.0 * 0.0) : 0.0), (((true ? false : false) || (true || true)) ? -0.5 : 1.0), (true ? 0.0 : 0.5), -1.0, 1.0, ((!true ? true : false) ? 0.0 : ((false ? false : false) ? (false ? 1.0 : 0.5) : +0.0)), --0.5);

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThanEqual(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, +0.5, 1.0, 1.0, 0.5, 2.0, 0.0, (!(false && false) ? 0.5 : +2.0), +2.0, (!false ? (-2.0 * 0.0) : 0.0), (((true ? false : false) || (true || true)) ? -0.5 : 1.0), (true ? 0.0 : 0.5), -1.0, 1.0, ((!true ? true : false) ? 0.0 : ((false ? false : false) ? (false ? 1.0 : 0.5) : +0.0)), --0.5);

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThanEqual(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.931552587646074
Processing this: /home/oof/webgl_cleaned/not_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 _not(in bvec3 a)
{
	bvec3 result;
	if(a[0]) result[0] = false;
	else result[0] = true;
	if(a[1]) result[1] = false;
	else result[1] = true;
	if(a[2]) result[2] = false;
	else result[2] = true;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	color = vec4(vec3(_not(bvec3(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 _not(in bvec3 a)\n{\n\tbvec3 result;\n\tif(a[0]) result[0] = false;\n\telse result[0] = true;\n\tif(a[1]) result[1] = false;\n\telse result[1] = true;\n\tif(a[2]) result[2] = false;\n\telse result[2] = true;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tcolor = vec4(vec3(_not(bvec3(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(+(2.0 + 1.0), 1.0, -1.0, 0.5);

bvec3 _not(in bvec3 a)
{
  bvec3 result;
  if (a[0])
    result[0] = false;
  else
    result[0] = true;
  if (a[1])
    result[1] = false;
  else
    result[1] = true;
  if (a[2])
    result[2] = false;
  else
    result[2] = true;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  color = vec4(vec3(_not(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.0
Processing this: /home/oof/webgl_cleaned/structUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 a_vertex;
attribute vec3 a_normal;
uniform mat4 u_modelViewProjMatrix;
struct MyStruct
{
  int x;
  int y;
};
uniform MyStruct u_struct;
uniform float u_array[4];
varying vec3 v_normal;
void main()
{
    v_normal = a_normal;
    gl_Position = u_modelViewProjMatrix * a_vertex +
        vec4(u_struct.x, u_struct.y, 0, 1) +
        vec4(u_array[0], u_array[1], u_array[2], u_array[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 a_vertex;\nattribute vec3 a_normal;\nuniform mat4 u_modelViewProjMatrix;\nstruct MyStruct\n{\n  int x;\n  int y;\n};\nuniform MyStruct u_struct;\nuniform float u_array[4];\nvarying vec3 v_normal;\nvoid main()\n{\n    v_normal = a_normal;\n    gl_Position = u_modelViewProjMatrix * a_vertex +\n        vec4(u_struct.x, u_struct.y, 0, 1) +\n        vec4(u_array[0], u_array[1], u_array[2], u_array[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 a_vertex;

vec3 a_normal;

uniform mat4 u_modelViewProjMatrix;

struct MyStruct {
  int x;
  int y;
};

uniform MyStruct u_struct;

uniform float u_array[4];

vec3 v_normal = vec3(0.5, +0.5, -1.0);

void main()
{
  v_normal = a_normal;
  gl_Position = (((u_modelViewProjMatrix * a_vertex) + vec4(u_struct.x , u_struct.y , 0 , 1)) + vec4(u_array[0] , u_array[1] , u_array[2] , u_array[3]));
}


As vertex? : True
SUCCESS!
59.06821963394343
Processing this: /home/oof/webgl_cleaned/equal_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(equal(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(equal(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor((4.5 - (9.5 * gtf_Color.rg)));
  vec2 result = vec2(equal(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.136212624584715
Processing this: /home/oof/webgl_cleaned/ivec4_empty_out_ivec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(out ivec4 par[3]);
bool is_all(const in ivec4 par, const in int value);
bool is_all(const in ivec4 array[3], const in ivec4 value);
void set_all(out ivec4 array[3], const in ivec4 value);
void main ()
{
	ivec4 par[3];
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	set_all(par, ivec4(1, 1, 1, 1));
	ret = function(par);
	if(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(out ivec4 par[3])
{
	set_all(par, ivec4(0, 0, 0, 0));
	return ivec4(1, 1, 1, 1);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in ivec4 array[3], const in ivec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 array[3], const in ivec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(out ivec4 par[3]);\nbool is_all(const in ivec4 par, const in int value);\nbool is_all(const in ivec4 array[3], const in ivec4 value);\nvoid set_all(out ivec4 array[3], const in ivec4 value);\nvoid main ()\n{\n\tivec4 par[3];\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tset_all(par, ivec4(1, 1, 1, 1));\n\tret = function(par);\n\tif(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(out ivec4 par[3])\n{\n\tset_all(par, ivec4(0, 0, 0, 0));\n\treturn ivec4(1, 1, 1, 1);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in ivec4 array[3], const in ivec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 array[3], const in ivec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.136212624584715
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
59.136212624584715
Processing this: /home/oof/webgl_cleaned/floor_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4((floor(c) + 10.0) / 20.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4((floor(c) + 10.0) / 20.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 1.0, 1.0, 2.0);

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((floor(c) + 10.0) / 20.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.20398009950249
Mutations attempted: 603
Valid mutations:     357
Success rate:        59.20%
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.0, 0.0, 2.0);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.27152317880795
Processing this: /home/oof/webgl_cleaned/atan_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 4.0 * 2.0 * (color.r - 0.5);
	float atan_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	vec4 result;
	if(c < 0.0)
	{
		sign = -1.0;
		c *= -1.0;
	}
	if(c <= 1.0)
	{
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	else
	{
		c = 1.0 / c;
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 4.0 * 2.0 * (color.r - 0.5);\n\tfloat atan_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tvec4 result;\n\tif(c < 0.0)\n\t{\n\t\tsign = -1.0;\n\t\tc *= -1.0;\n\t}\n\tif(c <= 1.0)\n\t{\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tc = 1.0 / c;\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct12027 {
  uint f_4553;
  bool f_4794;
  mat4 f_4815;
  bool f_2630;
};

vec4 color;

void main()
{
  if ((c <= 1.0))
  {
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * atan_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  else
  {
    c = (1.0 / c);
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  float c = ((4.0 * 2.0) * (color.r - 0.5));
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  float sign = 1.0;
  float atan_c = 0.0;
  const float M_PI = 3.141592653589793;
  float scale = 1.0;
  vec4 result;
  gl_FragColor = result;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:5: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct12027 {
  uint f_4553;
  bool f_4794;
  mat4 f_4815;
  bool f_2630;
};

vec4 color;

void main()
{
  if ((c <= 1.0))
  {
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * atan_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  else
  {
    c = (1.0 / c);
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  float c = ((4.0 * 2.0) * (color.r - 0.5));
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  float sign = 1.0;
  float atan_c = 0.0;
  const float M_PI = 3.141592653589793;
  float scale = 1.0;
  vec4 result;
  gl_FragColor = result;
}


==============================
59.17355371900827
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 2.0, 0.5, 0.5);

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.240924092409244
Processing this: /home/oof/webgl_cleaned/lessThan_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(lessThan(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(lessThan(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 1.0, 0.0, 0.5, 1.0, -1.0, 0.0, 0.5, -0.5, -0.5, 0.5, 0.5, -1.0, 0.0, 1.0, 2.0);

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(lessThan(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 1.0, 0.0, 0.5, 1.0, -1.0, 0.0, 0.5, -0.5, -0.5, 0.5, 0.5, -1.0, 0.0, 1.0, 2.0);

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(lessThan(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.14332784184514
Processing this: /home/oof/webgl_cleaned/_webgl_struct.vert
Original source code: 
precision mediump float;
precision mediump int;

struct _webgl_Foo {
  int bar;
};
void main() {
  _webgl_Foo foo = _webgl_Foo(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nstruct _webgl_Foo {\n  int bar;\n};\nvoid main() {\n  _webgl_Foo foo = _webgl_Foo(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct _webgl_Foo {
  int bar;
};

void main()
{
  _webgl_Foo foo = _webgl_Foo(1);
}


As vertex? : True
SUCCESS!
59.210526315789465
Processing this: /home/oof/webgl_cleaned/float_empty_out_float_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(out float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(out float par)
{
	par = 0.0;
	return 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(out float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(out float par)\n{\n\tpar = 0.0;\n\treturn 1.0;\n}\n\x00')
59.210526315789465
Processing this: /home/oof/webgl_cleaned/ivec4_empty_inout_ivec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
ivec4 function(inout ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
ivec4 function(inout ivec4 par)
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nivec4 function(inout ivec4 par);\nbool is_all(const in ivec4 par, const in int value);\nvoid set_all(out ivec4 par, const in int value);\nvoid main ()\n{\n\tivec4 par = ivec4(1, 1, 1, 1);\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nivec4 function(inout ivec4 par)\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 par, const in int value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
59.210526315789465
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvaryneg_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	vec2 c = gtf_Color.rg;
	color = vec4(1.0 / pow(vec2(exp1), 3.0 * c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(1.0 / pow(vec2(exp1), 3.0 * c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  vec2 c = gtf_Color.rg;
  color = vec4((1.0 / pow(vec2(exp1) , (3.0 * c))) , 0.0 , 1.0);
  gl_Position = (gtf_Vertex * gtf_ModelViewProjectionMatrix);
}


As vertex? : True
SUCCESS!
59.277504105090316
Processing this: /home/oof/webgl_cleaned/vec4_tsqp_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.tsqp;
	vec4 a = vec4(m.t, m.s, m.q, m.p);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.tsqp;\n\tvec4 a = vec4(m.t, m.s, m.q, m.p);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 0.0, 0.0, -(!true ? (true ? 2.0 : 1.0) : -1.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.tsqp;
  vec4 a = vec4(m.t , m.s , m.q , m.p);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.34426229508196
Processing this: /home/oof/webgl_cleaned/ivec4_empty_in_ivec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
ivec4 function(in ivec4 par[3]);
bool is_all(const in ivec4 par, const in int value);
bool is_all(const in ivec4 array[3], const in ivec4 value);
void set_all(out ivec4 array[3], const in ivec4 value);
void main ()
{
	ivec4 par[3];
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	set_all(par, ivec4(1, 1, 1, 1));
	ret = function(par);
	if(is_all(par, ivec4(1, 1, 1, 1)) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
ivec4 function(in ivec4 par[3])
{
	if(is_all(par, ivec4(1, 1, 1, 1)))
	{
		set_all(par, ivec4(0, 0, 0, 0));
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in ivec4 array[3], const in ivec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 array[3], const in ivec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nivec4 function(in ivec4 par[3]);\nbool is_all(const in ivec4 par, const in int value);\nbool is_all(const in ivec4 array[3], const in ivec4 value);\nvoid set_all(out ivec4 array[3], const in ivec4 value);\nvoid main ()\n{\n\tivec4 par[3];\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tset_all(par, ivec4(1, 1, 1, 1));\n\tret = function(par);\n\tif(is_all(par, ivec4(1, 1, 1, 1)) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nivec4 function(in ivec4 par[3])\n{\n\tif(is_all(par, ivec4(1, 1, 1, 1)))\n\t{\n\t\tset_all(par, ivec4(0, 0, 0, 0));\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in ivec4 array[3], const in ivec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 array[3], const in ivec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.34426229508196
Mutations attempted: 610
Valid mutations:     362
Success rate:        59.34%
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xconst2_yvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(exp2(2.0 * c) / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(exp2(2.0 * c) / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+0.5, 0.0, (0.0 - 0.5), (false ? 2.0 : (true ? -1.0 : (-1.0 + 0.0))));

void main()
{
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = vec4((exp2((2.0 * c)) / 4.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.41080196399346
Processing this: /home/oof/webgl_cleaned/vec3_rb_g_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.rgb;
	float k = m.g;
	vec2 n = m.rb;
	vec4 a = vec4(n.r, k, n.g, al.a);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.rgb;\n\tfloat k = m.g;\n\tvec2 n = m.rb;\n\tvec4 a = vec4(n.r, k, n.g, al.a);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+0.5, 0.0, 0.0, 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.rgb;
  float k = m.g;
  vec2 n = m.rb;
  vec4 a = vec4(n.r , k , n.g , al.a);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.47712418300654
Processing this: /home/oof/webgl_cleaned/matrix2VSU.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat4 transforms;
uniform mat4 anotherMatrix;
varying vec4 color;
void main()
{
  color = gtf_Color;
   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat4 transforms;\nuniform mat4 anotherMatrix;\nvarying vec4 color;\nvoid main()\n{\n  color = gtf_Color;\n   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color = vec4(0.0, -0.5, 0.5, 0.0);

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms) * anotherMatrix) * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.54323001631321
Processing this: /home/oof/webgl_cleaned/exp_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	float c = gtf_Color.r;
	color = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  float c = gtf_Color.r;
  color = vec4((pow(exp1 , (3.0 * c)) / exp3) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.60912052117264
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.5, 1.0, 1.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(exp1) , (3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.674796747967484
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
59.674796747967484
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(1.0 / pow(vec2(2.0), 5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(1.0 / pow(vec2(2.0), 5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, +1.0, (0.0 * 0.5), 0.5);

void main()
{
  vec2 c = color.rg;
  gl_FragColor = vec4((1.0 / pow(vec2(2.0) , (5.0 * c))) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.74025974025974
Processing this: /home/oof/webgl_cleaned/vec4_br_ag_2vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec2 m = al.br;
	vec2 n = al.ag;
	vec4 a = vec4(m.g, n.g, m.r, n.r);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec2 m = al.br;\n\tvec2 n = al.ag;\n\tvec4 a = vec4(m.g, n.g, m.r, n.r);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec2 m = al.br;
  vec2 n = al.ag;
  vec4 a = vec4(m.g , n.g , m.r , n.r);
  gl_FragColor = a;
  ivec2(1.0, 0.0);
}


As vertex? : False
SUCCESS!
59.80551053484603
Processing this: /home/oof/webgl_cleaned/log2_vec3_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const float ln2 = 0.69314718055994530941723212145818;
void main ()
{
	vec3 x = (gtf_Color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0 / ln2;
	color = vec4(y / -8.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst float ln2 = 0.69314718055994530941723212145818;\nvoid main ()\n{\n\tvec3 x = (gtf_Color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0 / ln2;\n\tcolor = vec4(y / -8.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const float ln2 = 0.6931471805599453;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (-2.0 / ln2));
  color = vec4((y / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.8705501618123
Processing this: /home/oof/webgl_cleaned/acos_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (color.rgb - 0.5);
	vec3 arrVal = (c + vec3(1.0, 1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	int arr0z = int(floor(arrVal.z));
	vec3 weight = arrVal - floor(arrVal);
	vec3 asin_c = vec3(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	if (arr0z == 0)
		asin_c.z = lerp(asinValues[0], asinValues[1], weight.z);
	else if (arr0z == 1)
		asin_c.z = lerp(asinValues[1], asinValues[2], weight.z);
	else if (arr0z == 2)
		asin_c.z = lerp(asinValues[2], asinValues[3], weight.z);
	else if (arr0z == 3)
		asin_c.z = lerp(asinValues[3], asinValues[4], weight.z);
	else if (arr0z == 4)
		asin_c.z = lerp(asinValues[4], asinValues[5], weight.z);
	else if (arr0z == 5)
		asin_c.z = lerp(asinValues[5], asinValues[6], weight.z);
	else if (arr0z == 6)
		asin_c.z = lerp(asinValues[6], asinValues[7], weight.z);
	else if (arr0z == 7)
		asin_c.z = lerp(asinValues[7], asinValues[8], weight.z);
	else if (arr0z == 8)
		asin_c.z = lerp(asinValues[8], asinValues[9], weight.z);
	else if (arr0z == 9)
		asin_c.z = lerp(asinValues[9], asinValues[10], weight.z);
	else if (arr0z == 10)
		asin_c.z = lerp(asinValues[10], asinValues[11], weight.z);
	else if (arr0z == 11)
		asin_c.z = lerp(asinValues[11], asinValues[12], weight.z);
	else if (arr0z == 12)
		asin_c.z = lerp(asinValues[12], asinValues[13], weight.z);
	else if (arr0z == 13)
		asin_c.z = lerp(asinValues[13], asinValues[14], weight.z);
	else if (arr0z == 14)
		asin_c.z = lerp(asinValues[14], asinValues[15], weight.z);
	else if (arr0z == 15)
		asin_c.z = lerp(asinValues[15], asinValues[16], weight.z);
        else if (arr0z == 16)
                asin_c.z = asinValues[16];
	gl_FragColor = vec4(0.5 - asin_c / M_PI, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tvec3 arrVal = (c + vec3(1.0, 1.0, 1.0)) * 8.0;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tint arr0z = int(floor(arrVal.z));\n\tvec3 weight = arrVal - floor(arrVal);\n\tvec3 asin_c = vec3(0.0);\n\tif (arr0x == 0)\n\t\tasin_c.x = lerp(asinValues[0], asinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tasin_c.x = lerp(asinValues[1], asinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tasin_c.x = lerp(asinValues[2], asinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tasin_c.x = lerp(asinValues[3], asinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tasin_c.x = lerp(asinValues[4], asinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tasin_c.x = lerp(asinValues[5], asinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tasin_c.x = lerp(asinValues[6], asinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tasin_c.x = lerp(asinValues[7], asinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tasin_c.x = lerp(asinValues[8], asinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tasin_c.x = lerp(asinValues[9], asinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tasin_c.x = lerp(asinValues[10], asinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tasin_c.x = lerp(asinValues[11], asinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tasin_c.x = lerp(asinValues[12], asinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tasin_c.x = lerp(asinValues[13], asinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tasin_c.x = lerp(asinValues[14], asinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tasin_c.x = lerp(asinValues[15], asinValues[16], weight.x);\n        else if (arr0x == 16)\n                asin_c.x = asinValues[16];\n\tif (arr0y == 0)\n\t\tasin_c.y = lerp(asinValues[0], asinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tasin_c.y = lerp(asinValues[1], asinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tasin_c.y = lerp(asinValues[2], asinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tasin_c.y = lerp(asinValues[3], asinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tasin_c.y = lerp(asinValues[4], asinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tasin_c.y = lerp(asinValues[5], asinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tasin_c.y = lerp(asinValues[6], asinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tasin_c.y = lerp(asinValues[7], asinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tasin_c.y = lerp(asinValues[8], asinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tasin_c.y = lerp(asinValues[9], asinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tasin_c.y = lerp(asinValues[10], asinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tasin_c.y = lerp(asinValues[11], asinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tasin_c.y = lerp(asinValues[12], asinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tasin_c.y = lerp(asinValues[13], asinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tasin_c.y = lerp(asinValues[14], asinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tasin_c.y = lerp(asinValues[15], asinValues[16], weight.y);\n        else if (arr0y == 16)\n                asin_c.y = asinValues[16];\n\tif (arr0z == 0)\n\t\tasin_c.z = lerp(asinValues[0], asinValues[1], weight.z);\n\telse if (arr0z == 1)\n\t\tasin_c.z = lerp(asinValues[1], asinValues[2], weight.z);\n\telse if (arr0z == 2)\n\t\tasin_c.z = lerp(asinValues[2], asinValues[3], weight.z);\n\telse if (arr0z == 3)\n\t\tasin_c.z = lerp(asinValues[3], asinValues[4], weight.z);\n\telse if (arr0z == 4)\n\t\tasin_c.z = lerp(asinValues[4], asinValues[5], weight.z);\n\telse if (arr0z == 5)\n\t\tasin_c.z = lerp(asinValues[5], asinValues[6], weight.z);\n\telse if (arr0z == 6)\n\t\tasin_c.z = lerp(asinValues[6], asinValues[7], weight.z);\n\telse if (arr0z == 7)\n\t\tasin_c.z = lerp(asinValues[7], asinValues[8], weight.z);\n\telse if (arr0z == 8)\n\t\tasin_c.z = lerp(asinValues[8], asinValues[9], weight.z);\n\telse if (arr0z == 9)\n\t\tasin_c.z = lerp(asinValues[9], asinValues[10], weight.z);\n\telse if (arr0z == 10)\n\t\tasin_c.z = lerp(asinValues[10], asinValues[11], weight.z);\n\telse if (arr0z == 11)\n\t\tasin_c.z = lerp(asinValues[11], asinValues[12], weight.z);\n\telse if (arr0z == 12)\n\t\tasin_c.z = lerp(asinValues[12], asinValues[13], weight.z);\n\telse if (arr0z == 13)\n\t\tasin_c.z = lerp(asinValues[13], asinValues[14], weight.z);\n\telse if (arr0z == 14)\n\t\tasin_c.z = lerp(asinValues[14], asinValues[15], weight.z);\n\telse if (arr0z == 15)\n\t\tasin_c.z = lerp(asinValues[15], asinValues[16], weight.z);\n        else if (arr0z == 16)\n                asin_c.z = asinValues[16];\n\tgl_FragColor = vec4(0.5 - asin_c / M_PI, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  vec4(+0.0, lerp(-1.0, lerp(-0.5, +0.5, lerp(1.0, 1.0, -1.0)), (false ? 2.0 : -1.0)), -1.0, 1.0)[2] = 0.75268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  vec3 arrVal = ((c + vec3(1.0 , 1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  int arr0z = int(floor(arrVal.z));
  vec3 weight = (arrVal - floor(arrVal));
  vec3 asin_c = vec3(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  if ((arr0z == 0))
    asin_c.z = lerp(asinValues[0] , asinValues[1] , weight.z);
  else
    if ((arr0z == 1))
      asin_c.z = lerp(asinValues[1] , asinValues[2] , weight.z);
    else
      if ((arr0z == 2))
        asin_c.z = lerp(asinValues[2] , asinValues[3] , weight.z);
      else
        if ((arr0z == 3))
          asin_c.z = lerp(asinValues[3] , asinValues[4] , weight.z);
        else
          if ((arr0z == 4))
            asin_c.z = lerp(asinValues[4] , asinValues[5] , weight.z);
          else
            if ((arr0z == 5))
              asin_c.z = lerp(asinValues[5] , asinValues[6] , weight.z);
            else
              if ((arr0z == 6))
                asin_c.z = lerp(asinValues[6] , asinValues[7] , weight.z);
              else
                if ((arr0z == 7))
                  asin_c.z = lerp(asinValues[7] , asinValues[8] , weight.z);
                else
                  if ((arr0z == 8))
                    asin_c.z = lerp(asinValues[8] , asinValues[9] , weight.z);
                  else
                    if ((arr0z == 9))
                      asin_c.z = lerp(asinValues[9] , asinValues[10] , weight.z);
                    else
                      if ((arr0z == 10))
                        asin_c.z = lerp(asinValues[10] , asinValues[11] , weight.z);
                      else
                        if ((arr0z == 11))
                          asin_c.z = lerp(asinValues[11] , asinValues[12] , weight.z);
                        else
                          if ((arr0z == 12))
                            asin_c.z = lerp(asinValues[12] , asinValues[13] , weight.z);
                          else
                            if ((arr0z == 13))
                              asin_c.z = lerp(asinValues[13] , asinValues[14] , weight.z);
                            else
                              if ((arr0z == 14))
                                asin_c.z = lerp(asinValues[14] , asinValues[15] , weight.z);
                              else
                                if ((arr0z == 15))
                                  asin_c.z = lerp(asinValues[15] , asinValues[16] , weight.z);
                                else
                                  if ((arr0z == 16))
                                    asin_c.z = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'assign' : l-value required

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  vec4(+0.0, lerp(-1.0, lerp(-0.5, +0.5, lerp(1.0, 1.0, -1.0)), (false ? 2.0 : -1.0)), -1.0, 1.0)[2] = 0.75268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  vec3 arrVal = ((c + vec3(1.0 , 1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  int arr0z = int(floor(arrVal.z));
  vec3 weight = (arrVal - floor(arrVal));
  vec3 asin_c = vec3(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  if ((arr0z == 0))
    asin_c.z = lerp(asinValues[0] , asinValues[1] , weight.z);
  else
    if ((arr0z == 1))
      asin_c.z = lerp(asinValues[1] , asinValues[2] , weight.z);
    else
      if ((arr0z == 2))
        asin_c.z = lerp(asinValues[2] , asinValues[3] , weight.z);
      else
        if ((arr0z == 3))
          asin_c.z = lerp(asinValues[3] , asinValues[4] , weight.z);
        else
          if ((arr0z == 4))
            asin_c.z = lerp(asinValues[4] , asinValues[5] , weight.z);
          else
            if ((arr0z == 5))
              asin_c.z = lerp(asinValues[5] , asinValues[6] , weight.z);
            else
              if ((arr0z == 6))
                asin_c.z = lerp(asinValues[6] , asinValues[7] , weight.z);
              else
                if ((arr0z == 7))
                  asin_c.z = lerp(asinValues[7] , asinValues[8] , weight.z);
                else
                  if ((arr0z == 8))
                    asin_c.z = lerp(asinValues[8] , asinValues[9] , weight.z);
                  else
                    if ((arr0z == 9))
                      asin_c.z = lerp(asinValues[9] , asinValues[10] , weight.z);
                    else
                      if ((arr0z == 10))
                        asin_c.z = lerp(asinValues[10] , asinValues[11] , weight.z);
                      else
                        if ((arr0z == 11))
                          asin_c.z = lerp(asinValues[11] , asinValues[12] , weight.z);
                        else
                          if ((arr0z == 12))
                            asin_c.z = lerp(asinValues[12] , asinValues[13] , weight.z);
                          else
                            if ((arr0z == 13))
                              asin_c.z = lerp(asinValues[13] , asinValues[14] , weight.z);
                            else
                              if ((arr0z == 14))
                                asin_c.z = lerp(asinValues[14] , asinValues[15] , weight.z);
                              else
                                if ((arr0z == 15))
                                  asin_c.z = lerp(asinValues[15] , asinValues[16] , weight.z);
                                else
                                  if ((arr0z == 16))
                                    asin_c.z = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 1.0);
}


==============================
59.77382875605816
Mutations attempted: 619
Valid mutations:     370
Success rate:        59.77%
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec2 gt(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(gt(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec2 gt(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(gt(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 gt(in ivec2 a, in ivec2 b)
{
  bvec2 result = bvec2(0.0, -0.5);
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(gt(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.83870967741935
Processing this: /home/oof/webgl_cleaned/CorrectSwizzle2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    float f, f1, f2;
    f = f1 = f2;
    f += f1 += f2;
    vec4 v, v1, v2;
    v = v1 = v2;
    v += v1 += v2;
    v.wx = v1.zx = v2.yx;
    v.wx += v1.zx += v2.yx;
    mat4  m, m1, m2;
    m = m1 = m2;
    m += m1 += m2;
    m[3].wx = m1[2].zx = m2[1].yx;
    m[3].wx += m1[2].zx += m2[1].yx;
    mat4  am[4], am1[4], am2[4];
    am[3] = am1[2] = am2[1];
    am[3] += am1[2] += am2[1];
    am[3][3].wx = am1[2][2].zx = am2[1][1].yx;
    am[3][3].wx += am1[2][2].zx += am2[1][1].yx;
    am[3][3].wx += am1[2][2].zx += ++(am2[1][1].yx);
    am[3][3].wx += am1[2][2].zx += (am2[1][1].yx)++;
    gl_FragColor = vec4(am[3][3].z, m[3].w, v.w, f);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    float f, f1, f2;\n    f = f1 = f2;\n    f += f1 += f2;\n    vec4 v, v1, v2;\n    v = v1 = v2;\n    v += v1 += v2;\n    v.wx = v1.zx = v2.yx;\n    v.wx += v1.zx += v2.yx;\n    mat4  m, m1, m2;\n    m = m1 = m2;\n    m += m1 += m2;\n    m[3].wx = m1[2].zx = m2[1].yx;\n    m[3].wx += m1[2].zx += m2[1].yx;\n    mat4  am[4], am1[4], am2[4];\n    am[3] = am1[2] = am2[1];\n    am[3] += am1[2] += am2[1];\n    am[3][3].wx = am1[2][2].zx = am2[1][1].yx;\n    am[3][3].wx += am1[2][2].zx += am2[1][1].yx;\n    am[3][3].wx += am1[2][2].zx += ++(am2[1][1].yx);\n    am[3][3].wx += am1[2][2].zx += (am2[1][1].yx)++;\n    gl_FragColor = vec4(am[3][3].z, m[3].w, v.w, f);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float f, f1, f2;
  f = f1 = f2;
  (f += (f1 += f2));
  vec4 v, v1, v2;
  v = v1 = v2;
  (v += (v1 += v2));
  v.wx = v1.zx = v2.yx;
  (v.wx += (v1.zx += v2.yx));
  mat4 m, m1, m2;
  m = m1 = m2;
  (m += (m1 += m2));
  m[3].wx = m1[2].zx = m2[1].yx;
  (m[3].wx += (m1[2].zx += m2[1].yx));
  mat4 am[4], am1[4], am2[4];
  am[3] = am1[2] = am2[1];
  (am[2] += (am1[2] += am2[1]));
  am[3][3].wx = am1[2][2].zx = am2[1][1].yx;
  (am[3][3].wx += (am1[2][2].zx += am2[1][1].yx));
  (am[3][3].wx += (am1[2][2].zx += ++am2[1][1].yx));
  (am[3][3].wx += (am1[2][2].zx += am2[1][1].yx++));
  gl_FragColor = vec4(am[3][3].z , m[3].w , v.w , f);
}


As vertex? : False
SUCCESS!
59.90338164251207
Processing this: /home/oof/webgl_cleaned/degrees_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 2.0, 0.0, (0.0 - -1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((2.0 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.967845659163984
Processing this: /home/oof/webgl_cleaned/ivec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform int vuni1;
uniform ivec2 vuni2;
uniform ivec3 vuni3;
uniform ivec4 vuni4;
varying vec4 color;
void main ()
{
	color = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform int vuni1;\nuniform ivec2 vuni2;\nuniform ivec3 vuni3;\nuniform ivec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.5, 2.0, ((true ? 0.0 : (false ? 2.0 : 0.0)) / 0.5), (+2.0 + -(0.5 - 2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform int vuni1;

uniform ivec2 vuni2;

uniform ivec3 vuni3;

uniform ivec4 vuni4;

vec4 color;

void main()
{
  color = vec4(float(vuni1) , float((vuni2[0] + vuni2[1])) , float(((vuni3[0] + vuni3[1]) + vuni3[2])) , float((((vuni4[0] + vuni4[1]) + vuni4[2]) + vuni4[3])));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.03210272873194
Processing this: /home/oof/webgl_cleaned/clamp_vec2_vert_xvary_yconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec2 c = gtf_Color.rg;
	color = vec4(clamp(c, min_c, max_c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(clamp(c, min_c, max_c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, +1.0, -1.0, (((false ? false : false) && (false ? false : false)) ? 2.0 : (2.0 - -1.0)));

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  color = vec4(clamp(c , min_c , max_c) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.09615384615385
Processing this: /home/oof/webgl_cleaned/cross_vec3_frag_xvaryyconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = vec3(1.0, 0.0, 0.0);
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	gl_FragColor = vec4((cross(v1, v2) + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = vec3(1.0, 0.0, 0.0);\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tgl_FragColor = vec4((cross(v1, v2) + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? +2.0 : 0.0), (false ? 1.0 : 2.0), 1.0, 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = vec3(1.0 , 0.0 , 0.0);
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  gl_FragColor = vec4(((cross(v1 , v2) + 1.0) / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
60.160000000000004
Processing this: /home/oof/webgl_cleaned/equal_bvec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 eq(in bvec2 a, in bvec2 b)
{
	bvec2 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	vec2 result = vec2(eq(bvec2(c), bvec2(true)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 eq(in bvec2 a, in bvec2 b)\n{\n\tbvec2 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tvec2 result = vec2(eq(bvec2(c), bvec2(true)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.5, 1.0, -1.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 eq(in bvec2 a, in bvec2 b)
{
  bvec2 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  vec2 result = vec2(eq(bvec2(c) , bvec2(true)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.22364217252396
Processing this: /home/oof/webgl_cleaned/bool_empty_in_bool_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool function(in bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(par && ret)
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bool function(in bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool function(in bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbool function(in bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
60.22364217252396
Processing this: /home/oof/webgl_cleaned/array_const_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
		             5.0,  6.0,  7.0,  8.0,
			     9.0, 10.0, 11.0, 12.0,
			    13.0, 14.0, 15.0, 16.0);
	const mat4 b = mat4(17.0, 18.0, 19.0, 20.0,
		            21.0, 22.0, 23.0, 24.0,
			    25.0, 26.0, 27.0, 28.0,
			    29.0, 30.0, 31.0, 32.0);
	mat4 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t\t             5.0,  6.0,  7.0,  8.0,\n\t\t\t     9.0, 10.0, 11.0, 12.0,\n\t\t\t    13.0, 14.0, 15.0, 16.0);\n\tconst mat4 b = mat4(17.0, 18.0, 19.0, 20.0,\n\t\t            21.0, 22.0, 23.0, 24.0,\n\t\t\t    25.0, 26.0, 27.0, 28.0,\n\t\t\t    29.0, 30.0, 31.0, 32.0);\n\tmat4 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  a = array[0];
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  a = array[0];
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
60.12759170653907
Processing this: /home/oof/webgl_cleaned/vec4_br_ag_2vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec2 m = al.br;
	vec2 n = al.ag;
	vec4 a = vec4(m.g, n.g, m.r, n.r);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec2 m = al.br;\n\tvec2 n = al.ag;\n\tvec4 a = vec4(m.g, n.g, m.r, n.r);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec2 m = al.br;
  vec2 n = al.ag;
  vec4 a = vec4(m.g , n.g , m.r , n.r);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
60.19108280254777
Mutations attempted: 628
Valid mutations:     378
Success rate:        60.19%
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 gte(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] >= b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(gte(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 gte(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] >= b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(gte(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 gte(in vec3 a, in vec3 b)
{
  bvec3 result = bvec3(1.0, 1.0, ((false ? (true && false) : !false) ? -(2.0 - -1.0) : 2.0));
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] >= b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(gte(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.254372019077906
Processing this: /home/oof/webgl_cleaned/radians_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 360.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((c * M_PI / 180.0) / (4.0 * M_PI) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 360.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((c * M_PI / 180.0) / (4.0 * M_PI) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * M_PI) / 180.0) / (4.0 * M_PI)) + 0.5) , 0.0);
  vec4(+(+0.5 + (0.5 + -1.0)), ---1.0, (true ? 2.0 : -1.0), (((false ? true : false) && !false) ? -1.0 : 0.5));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction
ERROR: 0:11: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * M_PI) / 180.0) / (4.0 * M_PI)) + 0.5) , 0.0);
  vec4(+(+0.5 + (0.5 + -1.0)), ---1.0, (true ? 2.0 : -1.0), (((false ? true : false) && !false) ? -1.0 : 0.5));
}


==============================
60.15873015873016
Processing this: /home/oof/webgl_cleaned/min_float_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float min_c = 0.5;
	float c = color.r;
	gl_FragColor = vec4(min(c, min_c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.5;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(min(c, min_c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 1.0, 2.0, 0.0);

void main()
{
  const float min_c = 0.5;
  float c = color.r;
  gl_FragColor = vec4(min(c , min_c) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.22187004754358
Processing this: /home/oof/webgl_cleaned/cos_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * cos(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * cos(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!(true ? true : false) ? 1.0 : (false ? 0.5 : 2.0)), 0.5, 0.5, (((false ? 1.0 : 0.5) / 1.0) * 0.5));

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * cos(((2.0 * M_PI) * color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.28481012658228
Processing this: /home/oof/webgl_cleaned/exp_vec2_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	vec2 c = color.rg;
	gl_FragColor = vec4(1.0 / pow(vec2(exp1), 3.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(1.0 / pow(vec2(exp1), 3.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((0.0 - (1.0 * -1.0)), (false ? 2.0 : 1.0), 0.0, (!true ? -(true ? 1.0 : 2.0) : 0.5));

void main()
{
  const float exp1 = 2.7183;
  vec2 c = color.rg;
  gl_FragColor = vec4((1.0 / pow(vec2(exp1) , (3.0 * c))) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.34755134281201
Processing this: /home/oof/webgl_cleaned/prefixincrement_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 23;
	int k = ++m;
	float gray;
	if( ( k == 24 ) && ( m == 24 ) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 23;\n\tint k = ++m;\n\tfloat gray;\n\tif( ( k == 24 ) && ( m == 24 ) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct47616 {
  vec4 f_373;
  bool f_1663;
};

vec4 color;

void main()
{
  int m = (false ? (true ? 2 : 0) : 7);
  int k = ++m;
  float gray;
  if (((k == 24) && (m == 24)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.41009463722398
Processing this: /home/oof/webgl_cleaned/matrix_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    mat3 m;
    mat4 m1 = mat4(m);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    mat3 m;\n    mat4 m1 = mat4(m);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  mat3 m;
  mat4 m1 = mat4(m);
}


As vertex? : False
SUCCESS!
60.47244094488189
Processing this: /home/oof/webgl_cleaned/max_vec3_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 max_c = vec3(0.5, 0.5, 0.5);
	vec3 c = gtf_Color.rgb;
	if(c[0] < max_c[0]) c[0] = max_c[0];
	if(c[1] < max_c[1]) c[1] = max_c[1];
	if(c[2] < max_c[2]) c[2] = max_c[2];
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 max_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = gtf_Color.rgb;\n\tif(c[0] < max_c[0]) c[0] = max_c[0];\n\tif(c[1] < max_c[1]) c[1] = max_c[1];\n\tif(c[2] < max_c[2]) c[2] = max_c[2];\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, +++1.0, 0.0, 1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 max_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  if ((c[1] < max_c[1]))
    c[1] = max_c[1];
  if ((c[2] < max_c[2]))
    c[2] = max_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '++' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, +++1.0, 0.0, 1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 max_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  if ((c[1] < max_c[1]))
    c[1] = max_c[1];
  if ((c[2] < max_c[2]))
    c[2] = max_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.37735849056604
Processing this: /home/oof/webgl_cleaned/step_vec2_frag_xvary_edgeconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 edge = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] >= edge[0])
	{
		c[0] = 1.0;
	}
	else
	{
		c[0] = 0.0;
	}
	if(c[1] >= edge[1])
	{
		c[1] = 1.0;
	}
	else
	{
		c[1] = 0.0;
	}
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] >= edge[0])\n\t{\n\t\tc[0] = 1.0;\n\t}\n\telse\n\t{\n\t\tc[0] = 0.0;\n\t}\n\tif(c[1] >= edge[1])\n\t{\n\t\tc[1] = 1.0;\n\t}\n\telse\n\t{\n\t\tc[1] = 0.0;\n\t}\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-(0.5 * 1.0) / +-1.0), 1.0, 0.0, +-(2.0 + 0.5));

void main()
{
  const vec2 edge = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] >= edge[0]))
  {
    c[0] = 1.0;
  }
  else
  {
    c[0] = 0.0;
  }
  if ((c[1] >= edge[1]))
  {
    c[1] = 1.0;
  }
  else
  {
    c[1] = 0.0;
  }
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.43956043956044
Processing this: /home/oof/webgl_cleaned/asin_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(asin(c) / M_PI + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(asin(c) / M_PI + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  gl_FragColor = vec4(((asin(c) / M_PI) + 0.5) , 0.0 , 1.0);
  vec4((-1.0 - (M_PI / 0.5)), (0.0 + (!false ? +0.5 : -1.0)), +(!true ? (false ? 1.0 : 2.0) : (2.0 * 2.0)), -1.0);
}


As vertex? : False
SUCCESS!
60.50156739811913
Mutations attempted: 638
Valid mutations:     386
Success rate:        60.50%
Processing this: /home/oof/webgl_cleaned/vec4_yx_wz_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.yx;
	vec2 n = lightloc.wz;
	vec4 a = vec4(m.y, m.x, n.y, n.x);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.yx;\n\tvec2 n = lightloc.wz;\n\tvec4 a = vec4(m.y, m.x, n.y, n.x);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 0.5, 0.5, (0.5 * 0.5));

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.yx;
  vec2 n = lightloc.wz;
  vec4 a = vec4(m.y , m.x , n.y , n.x);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
60.56338028169014
Processing this: /home/oof/webgl_cleaned/fract_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (color.rg - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (color.rg - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (color.rg - 0.5));
  0.5 = (abs((fract(c) - 1.5)) * 2.0);
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'mediump 2-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (color.rg - 0.5));
  0.5 = (abs((fract(c) - 1.5)) * 2.0);
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


==============================
60.46875000000001
Processing this: /home/oof/webgl_cleaned/Low_Level_Assembly_Reserved_Words_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform float MIN;
uniform float R0;
uniform float FOGC;
uniform float CUBE;
uniform float f;
uniform float o;
uniform float p;
uniform float w;
uniform float x;
uniform float y;
uniform float z;
void main()
{
	gl_FragColor = vec4(f, o, p, w);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform float MIN;\nuniform float R0;\nuniform float FOGC;\nuniform float CUBE;\nuniform float f;\nuniform float o;\nuniform float p;\nuniform float w;\nuniform float x;\nuniform float y;\nuniform float z;\nvoid main()\n{\n\tgl_FragColor = vec4(f, o, p, w);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o = p;

uniform float p;

uniform float w;

uniform float x;

uniform float y;

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'p' : undeclared identifier
ERROR: 0:14: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o = p;

uniform float p;

uniform float w;

uniform float x;

uniform float y;

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


==============================
60.37441497659907
Processing this: /home/oof/webgl_cleaned/struct_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
void main ()
{
	sabcd s = sabcd(1.0, 2.0, 4.0, 8.0);
	gl_FragColor = vec4(vec3((s.a + s.b + s.c + s.d) / 15.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(1.0, 2.0, 4.0, 8.0);\n\tgl_FragColor = vec4(vec3((s.a + s.b + s.c + s.d) / 15.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

void main()
{
  sabcd s = sabcd(1.0 , 2.0 , 4.0);
  gl_FragColor = vec4(vec3(((((s.a + s.b) + s.c) + s.d) / 15.0)) , 1.0);
  ivec2(9, 1);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: 'constructor' : Number of constructor parameters does not match the number of structure fields

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

void main()
{
  sabcd s = sabcd(1.0 , 2.0 , 4.0);
  gl_FragColor = vec4(vec3(((((s.a + s.b) + s.c) + s.d) / 15.0)) , 1.0);
  ivec2(9, 1);
}


==============================
60.280373831775705
Processing this: /home/oof/webgl_cleaned/structnest_bool_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct nestb
{
	bool b;
};
struct nesta
{
	bool a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(bool(1.0), nestb(bool(0.0))));
	float gray = 0.0;
	if( (s.nest_a.a == true) && (s.nest_a.nest_b.b == false))
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct nestb\n{\n\tbool b;\n};\nstruct nesta\n{\n\tbool a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(bool(1.0), nestb(bool(0.0))));\n\tfloat gray = 0.0;\n\tif( (s.nest_a.a == true) && (s.nest_a.nest_b.b == false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nestb {
  bool b;
};

struct nesta {
  bool a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(bool(1.0) , nestb(bool(0.0))));
  float gray = 0.0;
  if (((s.nest_a.a == true) && (s.nest_a.nest_b.b == false)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = nest(nesta(true, nestb(((true ? (true ? true : true) : false) ? false : !true))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:25: 'assign' : cannot convert from 'const structure 'nest' (symbol id 3005)' to 'FragColor mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct nestb {
  bool b;
};

struct nesta {
  bool a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(bool(1.0) , nestb(bool(0.0))));
  float gray = 0.0;
  if (((s.nest_a.a == true) && (s.nest_a.nest_b.b == false)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = nest(nesta(true, nestb(((true ? (true ? true : true) : false) ? false : !true))));
}


==============================
60.186625194401245
Processing this: /home/oof/webgl_cleaned/fract_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((false ? 0.0 : (-1.0 - 0.5)), --1.0, +(!false ? 2.0 : -1.0), (true ? 0.5 : 0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((false ? 0.0 : (-1.0 - 0.5)), --1.0, +(!false ? 2.0 : -1.0), (true ? 0.5 : 0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.09316770186336
Processing this: /home/oof/webgl_cleaned/vec4_rgb_a_1vec3_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	float a = lightloc.a;
	vec4 b = vec4(m, a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * b;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tfloat a = lightloc.a;\n\tvec4 b = vec4(m, a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * b;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.0, 0.0, (-1.0 + (!false ? -1.0 : (true ? -1.0 : 1.0))), +((2.0 - 1.0) * (false ? 0.0 : -1.0)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  float a = lightloc.a;
  vec4 b = vec4(m , a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * b);
}


As vertex? : True
SUCCESS!
60.15503875968993
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
60.15503875968993
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float s = al.s;
	float t = al.t;
	float p = al.p;
	float q = al.q;
	vec4 m = vec4(s,t,p,q);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat s = al.s;\n\tfloat t = al.t;\n\tfloat p = al.p;\n\tfloat q = al.q;\n\tvec4 m = vec4(s,t,p,q);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  float s = al.s;
  float t = al.t;
  float p = al.p;
  float q = al.q;
  vec4 m = vec4(s , t , p , q);
  gl_FragColor = m;
}


As vertex? : False
SUCCESS!
60.216718266253864
Processing this: /home/oof/webgl_cleaned/vec4_st_pq_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.st;
	vec2 n = lightloc.pq;
	vec4 a = vec4(m,n);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.st;\n\tvec2 n = lightloc.pq;\n\tvec4 a = vec4(m,n);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.st;
  vec2 n = lightloc.pq;
  vec4 a = vec4(m , n);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, (!true ? +1.0 : 0.0), (true ? -0.5 : (0.0 + +2.0)), --0.5, (false ? -1.0 : 2.0), 0.0, -(+0.5 - 1.0), 0.5, 0.5, 0.0, +(0.0 + 0.5), +1.0, --1.0, 1.0, 2.0, (!false ? ((false ? true : false) ? -1.0 : 0.5) : (true ? 2.0 : (true ? -1.0 : 2.0))));


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_Vertex' : undeclared identifier
ERROR: 0:6: '=' : dimension mismatch
ERROR: 0:6: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'
ERROR: 0:10: 'color' : undeclared identifier
ERROR: 0:10: 'gtf_Color' : undeclared identifier
ERROR: 0:10: 'assign' : l-value required (can't modify a const)
ERROR: 0:11: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:20: '--' : l-value required (can't modify a const)
ERROR: 0:20: '--' : l-value required (can't modify a const)
ERROR: 0:20: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.st;
  vec2 n = lightloc.pq;
  vec4 a = vec4(m , n);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, (!true ? +1.0 : 0.0), (true ? -0.5 : (0.0 + +2.0)), --0.5, (false ? -1.0 : 2.0), 0.0, -(+0.5 - 1.0), 0.5, 0.5, 0.0, +(0.0 + 0.5), +1.0, --1.0, 1.0, 2.0, (!false ? ((false ? true : false) ? -1.0 : 0.5) : (true ? 2.0 : (true ? -1.0 : 2.0))));


==============================
60.123647604327665
Mutations attempted: 647
Valid mutations:     389
Success rate:        60.12%
Processing this: /home/oof/webgl_cleaned/vec4_ivec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	ivec4 init = ivec4(2,3,5,9);
	vec4 a = vec4(init);
	float gray;
	if( (a[0] == 2.0) && (a[1] == 3.0) && (a[2] == 5.0) && (a[3] == 9.0) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tivec4 init = ivec4(2,3,5,9);\n\tvec4 a = vec4(init);\n\tfloat gray;\n\tif( (a[0] == 2.0) && (a[1] == 3.0) && (a[2] == 5.0) && (a[3] == 9.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  ivec4 init = ivec4(2 , 3 , 5 , 9);
  vec4 a = vec4(init);
  float gray;
  if (false)
    1.0 = gray;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  ivec4 init = ivec4(2 , 3 , 5 , 9);
  vec4 a = vec4(init);
  float gray;
  if (false)
    1.0 = gray;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
60.03086419753087
Processing this: /home/oof/webgl_cleaned/smoothstep_vec2_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 edge0 = vec2(0.25, 0.25);
	const vec2 edge1 = vec2(0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rg), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge0 = vec2(0.25, 0.25);\n\tconst vec2 edge1 = vec2(0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rg), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((1.0 * 2.0) / 0.0) / -(0.0 * -1.0)), 2.0, -1.0, ((0.5 * 1.0) + ((true || false) ? (-1.0 / 0.5) : (0.0 / 2.0))));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge0 = vec2(0.25 , 0.25);
  const vec2 edge1 = vec2(0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rg) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.0924499229584
Processing this: /home/oof/webgl_cleaned/qualifiers_struct_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,
sabcd e)
{
        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
        b = a;
        c.a += d.a;
        c.b += d.b;
        c.c += d.c;
        c.d += d.d;
        a.a += one.a;
        a.b += one.b;
        a.c += one.c;
        a.d += one.d;
        return e;
}
void main ()
{
	sabcd a = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd b = sabcd(2.0, 2.0, 2.0, 2.0);
	sabcd c = sabcd(3.0, 3.0, 3.0, 3.0);
	sabcd d = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd e = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd f = sabcd(0.0, 0.0, 0.0, 0.0);
	sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd four = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == one) q += 1.0;
	if(b == one) q += 2.0;
	if(c == seven) q += 4.0;
	if(d == four) q2 += 1.0;
	if(e == one) q2 += 2.0;
	if(f == one) q2 += 4.0;
	color = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nsabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,\nsabcd e)\n{\n        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n        b = a;\n        c.a += d.a;\n        c.b += d.b;\n        c.c += d.c;\n        c.d += d.d;\n        a.a += one.a;\n        a.b += one.b;\n        a.c += one.c;\n        a.d += one.d;\n        return e;\n}\nvoid main ()\n{\n\tsabcd a = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd b = sabcd(2.0, 2.0, 2.0, 2.0);\n\tsabcd c = sabcd(3.0, 3.0, 3.0, 3.0);\n\tsabcd d = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd e = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd f = sabcd(0.0, 0.0, 0.0, 0.0);\n\tsabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd four = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == one) q += 1.0;\n\tif(b == one) q += 2.0;\n\tif(c == seven) q += 4.0;\n\tif(d == four) q2 += 1.0;\n\tif(e == one) q2 += 2.0;\n\tif(f == one) q2 += 4.0;\n\tcolor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d, sabcd e)
{
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  b = a;
  (c.a += d.a);
  (c.b += d.b);
  (c.c += d.c);
  (c.d += d.d);
  (a.a += one.a);
  (a.b += one.b);
  (a.c += one.c);
  (a.d += one.d);
  return e;
  ivec2((((false ? true : false) ? d.c : (true ? true : false)) ? -(1 - 9) : (false ? (true ? 4 : 3) : (false ? 9 : 6))), c.a);
}

void main()
{
  sabcd a = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd b = sabcd(2.0 , 2.0 , 2.0 , 2.0);
  sabcd c = sabcd(3.0 , 3.0 , 3.0 , 3.0);
  sabcd d = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd e = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd f = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd four = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd seven = sabcd(7.0 , 7.0 , 7.0 , 7.0);
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == one))
    (q += 1.0);
  if ((b == one))
    (q += 2.0);
  if ((c == seven))
    (q += 4.0);
  if ((d == four))
    (q2 += 1.0);
  if ((e == one))
    (q2 += 2.0);
  if ((f == one))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:30: '?:' : mismatching ternary operator operand types 'mediump float and 'const bool'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d, sabcd e)
{
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  b = a;
  (c.a += d.a);
  (c.b += d.b);
  (c.c += d.c);
  (c.d += d.d);
  (a.a += one.a);
  (a.b += one.b);
  (a.c += one.c);
  (a.d += one.d);
  return e;
  ivec2((((false ? true : false) ? d.c : (true ? true : false)) ? -(1 - 9) : (false ? (true ? 4 : 3) : (false ? 9 : 6))), c.a);
}

void main()
{
  sabcd a = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd b = sabcd(2.0 , 2.0 , 2.0 , 2.0);
  sabcd c = sabcd(3.0 , 3.0 , 3.0 , 3.0);
  sabcd d = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd e = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd f = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd four = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd seven = sabcd(7.0 , 7.0 , 7.0 , 7.0);
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == one))
    (q += 1.0);
  if ((b == one))
    (q += 2.0);
  if ((c == seven))
    (q += 4.0);
  if ((d == four))
    (q2 += 1.0);
  if ((e == one))
    (q2 += 2.0);
  if ((f == one))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/empty_uniform_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const int array_size = 2;
uniform float new_mad2[array_size];
void main ()
{
	int i=0;
	float new_mad[array_size];
	float gray = 0.0;
	new_mad[0] = new_mad2[0];
	new_mad[1] = new_mad2[1];
	if( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst int array_size = 2;\nuniform float new_mad2[array_size];\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[array_size];\n\tfloat gray = 0.0;\n\tnew_mad[0] = new_mad2[0];\n\tnew_mad[1] = new_mad2[1];\n\tif( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((true ? (+1.0 - (1.0 / new_mad2)) : new_mad2), -1.0, (0.5 + +-1.0), new_mad2);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const int array_size = 2;

uniform float new_mad2[array_size];

void main()
{
  int i = 0;
  float new_mad[array_size];
  float gray = 0.0;
  new_mad[0] = new_mad2[0];
  new_mad[1] = new_mad2[1];
  if (((new_mad[0] == 45.0) && (new_mad[1] == 14.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'new_mad2' : undeclared identifier
WARNING: 0:4: '/' : Divide by zero during constant folding
ERROR: 0:4: 'new_mad2' : undeclared identifier
ERROR: 0:4: 'new_mad2' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((true ? (+1.0 - (1.0 / new_mad2)) : new_mad2), -1.0, (0.5 + +-1.0), new_mad2);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const int array_size = 2;

uniform float new_mad2[array_size];

void main()
{
  int i = 0;
  float new_mad[array_size];
  float gray = 0.0;
  new_mad[0] = new_mad2[0];
  new_mad[1] = new_mad2[1];
  if (((new_mad[0] == 45.0) && (new_mad[1] == 14.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.907834101382484
Processing this: /home/oof/webgl_cleaned/CorrectConstruct_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

struct s {
    float f;
} s1 = s(1.0);
struct s3 {
   int i;
} s3Inst;
struct s2 {
    float f;
    s3 s3Inst;
} s2Inst = s2(1.0, s3(1));
void main()
{
    vec3 i = vec3(5.0, 4.0, ivec2(2.0, 1.0));
    ivec4 v2 = ivec4(1.0);
    vec4 v4 = vec4(v2);
    bvec4 v5 = bvec4(v2);
    vec3 v6 = vec3(v5);
    vec3 v = vec3(2, 2.0, 1);
    vec3 v1 = vec3(1.2, v);
    mat3 m1 = mat3(v,v,v);
    mat2 m2 = mat2(v, v6.x);
    gl_Position = vec4(1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nstruct s {\n    float f;\n} s1 = s(1.0);\nstruct s3 {\n   int i;\n} s3Inst;\nstruct s2 {\n    float f;\n    s3 s3Inst;\n} s2Inst = s2(1.0, s3(1));\nvoid main()\n{\n    vec3 i = vec3(5.0, 4.0, ivec2(2.0, 1.0));\n    ivec4 v2 = ivec4(1.0);\n    vec4 v4 = vec4(v2);\n    bvec4 v5 = bvec4(v2);\n    vec3 v6 = vec3(v5);\n    vec3 v = vec3(2, 2.0, 1);\n    vec3 v1 = vec3(1.2, v);\n    mat3 m1 = mat3(v,v,v);\n    mat2 m2 = mat2(v, v6.x);\n    gl_Position = vec4(1.0);\n}\n\x00')
59.907834101382484
Processing this: /home/oof/webgl_cleaned/acos_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(acos(c) / M_PI, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(acos(c) / M_PI, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!!false ? (-1.0 / (true ? 0.0 : -1.0)) : +2.0), 1.0, 2.0, (!(false ? false : true) ? (false ? (false ? 0.0 : 0.5) : 2.0) : -1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  gl_FragColor = vec4((acos(c) / M_PI) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.96932515337423
Processing this: /home/oof/webgl_cleaned/pow_vec3_vert_xconsthalf_yvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = -2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (gtf_Color.rgb - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (gtf_Color.rgb - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.87748851454824
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat3 m1 = mat3(color.rgb, color.rgb, color.rgb);
	mat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);
	mat3 m3 = mat3(0.0);
	vec3 result = vec3(0.0, 0.0, 0.0);
	m3 = matrixCompMult(m1, m2);
	result[0] += m3[0][0];
	result[0] += m3[0][1];
	result[0] += m3[0][2];
	result[1] += m3[1][0];
	result[1] += m3[1][1];
	result[1] += m3[1][2];
	result[2] += m3[2][0];
	result[2] += m3[2][1];
	result[2] += m3[2][2];
	gl_FragColor = vec4(result / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m1 = mat3(color.rgb, color.rgb, color.rgb);\n\tmat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);\n\tmat3 m3 = mat3(0.0);\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tm3 = matrixCompMult(m1, m2);\n\tresult[0] += m3[0][0];\n\tresult[0] += m3[0][1];\n\tresult[0] += m3[0][2];\n\tresult[1] += m3[1][0];\n\tresult[1] += m3[1][1];\n\tresult[1] += m3[1][2];\n\tresult[2] += m3[2][0];\n\tresult[2] += m3[2][1];\n\tresult[2] += m3[2][2];\n\tgl_FragColor = vec4(result / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  mat3 m1 = mat3(color.rgb , color.rgb , color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3 = matrixCompMult(m1 , m2);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  gl_FragColor = vec4((result / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.9388379204893
Processing this: /home/oof/webgl_cleaned/dFdx_frag.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  gtf_Vertex.xy = vertXY;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/distance_float_frag_xvaryyhalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(distance(color.r, 0.5)), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(distance(color.r, 0.5)), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(distance(color.r , 0.5)));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(distance(color.r , 0.5)));
}


==============================
59.90853658536586
Mutations attempted: 656
Valid mutations:     393
Success rate:        59.91%
Processing this: /home/oof/webgl_cleaned/matrixVSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, +1.0, -0.5, -(1.0 / -1.0));

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
59.96955859969558
Processing this: /home/oof/webgl_cleaned/noopUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(0.0 , 0.0 , 0.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(0.0 , 0.0 , 0.0);
}


==============================
59.87841945288754
Processing this: /home/oof/webgl_cleaned/ivec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform int vuni1;
uniform ivec2 vuni2;
uniform ivec3 vuni3;
uniform ivec4 vuni4;
varying vec4 color;
void main ()
{
	color = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform int vuni1;\nuniform ivec2 vuni2;\nuniform ivec3 vuni3;\nuniform ivec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform int vuni1;

uniform ivec2 vuni2 = ivec2(vuni1, vuni1);

uniform ivec3 vuni3;

uniform ivec4 vuni4;

vec4 color;

void main()
{
  color = vec4(float(vuni1) , float((vuni2[0] + vuni2[1])) , float(((vuni3[0] + vuni3[1]) + vuni3[2])) , float((((vuni4[0] + vuni4[1]) + vuni4[2]) + vuni4[3])));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform int vuni1;

uniform ivec2 vuni2 = ivec2(vuni1, vuni1);

uniform ivec3 vuni3;

uniform ivec4 vuni4;

vec4 color;

void main()
{
  color = vec4(float(vuni1) , float((vuni2[0] + vuni2[1])) , float(((vuni3[0] + vuni3[1]) + vuni3[2])) , float((((vuni4[0] + vuni4[1]) + vuni4[2]) + vuni4[3])));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.78755690440061
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(greaterThanEqual(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(greaterThanEqual(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-0.5, -1.0, -0.5, 0.0);

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThanEqual(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.84848484848485
Processing this: /home/oof/webgl_cleaned/all_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool _all(in bvec3 a)
{
	bool temp = true;
	if(!a[0]) temp = false;
	if(!a[1]) temp = false;
	if(!a[2]) temp = false;
	return temp;
}
void main ()
{
	vec3 c = floor(4.0 * gtf_Color.rgb);
	color = vec4(vec3(_all(bvec3(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool _all(in bvec3 a)\n{\n\tbool temp = true;\n\tif(!a[0]) temp = false;\n\tif(!a[1]) temp = false;\n\tif(!a[2]) temp = false;\n\treturn temp;\n}\nvoid main ()\n{\n\tvec3 c = floor(4.0 * gtf_Color.rgb);\n\tcolor = vec4(vec3(_all(bvec3(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4(1.0, 0.5, -0.5, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bool _all(in bvec3 a)
{
  bool temp = true;
  if (!a[0])
    temp = false;
  if (!a[1])
    temp = false;
  if (!a[2])
    temp = false;
  return temp;
}

void main()
{
  vec3 c = floor((4.0 * gtf_Color.rgb));
  color = vec4(vec3(_all(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.90922844175491
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconst2_yvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4((pow(vec3(2.0) , (2.0 * c)) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.969788519637454
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, 0.5, -0.5, 0.0, -1.0, -0.5, -1.0, 2.0, -1.0, 0.0, 2.0, 0.5, 1.0, 0.0, -0.5, 0.5);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, 0.5, -0.5, 0.0, -1.0, -0.5, -1.0, 2.0, -1.0, 0.0, 2.0, 0.5, 1.0, 0.0, -0.5, 0.5);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.879336349924586
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(inout vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(inout vec4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(inout vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(inout vec4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
59.879336349924586
Processing this: /home/oof/webgl_cleaned/refract_float_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (color.g + 1.0) / 2.0;
	float v2 = (color.b + 1.0) / 2.0;
	gl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (color.g + 1.0) / 2.0;\n\tfloat v2 = (color.b + 1.0) / 2.0;\n\tgl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+2.0, 2.0, +0.0, (!(true ? false : false) ? (+0.0 / -1.0) : ((false ? false : true) ? (0.5 - 1.0) : 1.0)));

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g + 1.0) / 2.0);
  float v2 = ((color.b + 1.0) / 2.0);
  gl_FragColor = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.93975903614458
Processing this: /home/oof/webgl_cleaned/mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat2 a = mat2(1.0, 2.0,
	              4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat2 a = mat2(1.0, 2.0,\n\t              4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 1.0, 0.0, -0.5);

void main()
{
  float x;
  mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.0
Mutations attempted: 665
Valid mutations:     399
Success rate:        60.00%
Processing this: /home/oof/webgl_cleaned/buffer_objects_multitexturing.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform sampler2D gtf_Texture0;
uniform sampler2D gtf_Texture1;
varying vec4 color;
varying vec4 gtf_TexCoord[2];
void main ()
{
	gl_FragColor = texture2D(gtf_Texture0, gtf_TexCoord[0].st, 1.0);
	gl_FragColor += texture2D(gtf_Texture1, gtf_TexCoord[1].st, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform sampler2D gtf_Texture0;\nuniform sampler2D gtf_Texture1;\nvarying vec4 color;\nvarying vec4 gtf_TexCoord[2];\nvoid main ()\n{\n\tgl_FragColor = texture2D(gtf_Texture0, gtf_TexCoord[0].st, 1.0);\n\tgl_FragColor += texture2D(gtf_Texture1, gtf_TexCoord[1].st, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform sampler2D gtf_Texture0;

uniform sampler2D gtf_Texture1;

vec4 color = vec4(-1.0, (2.0 + 1.0), (2.0 - (false ? (false ? -1.0 : -1.0) : 0.5)), 0.5);

vec4 gtf_TexCoord[2];

void main()
{
  gl_FragColor = texture2D(gtf_Texture0 , gtf_TexCoord[0].st , 1.0);
  (gl_FragColor += texture2D(gtf_Texture1 , gtf_TexCoord[1].st , 1.0));
}


As vertex? : False
SUCCESS!
60.06006006006006
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 gte(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] >= b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(gte(c, vec3(0.0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 gte(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] >= b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(gte(c, vec3(0.0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 gte(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[-1] >= b[1]))
    result[0] = true;
  else
    0.0;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] >= b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(gte(c , vec3(0.0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: '[]' : index expression is negative

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec3 gte(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[-1] >= b[1]))
    result[0] = true;
  else
    0.0;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] >= b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(gte(c , vec3(0.0)));
  gl_FragColor = vec4(result , 1.0);
}


==============================
59.97001499250375
Processing this: /home/oof/webgl_cleaned/CorrectModule_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
vec4 test_function4(float);
vec4 test_function1(float);
vec4 test_function2(float);
vec4 test_function3(float);
float f = 2.6;
vec4 test_function1(float ff)
{
    vec4 func_vec4 = vec4(ff+f);
    return func_vec4;
}
float f1 = 1.5;
vec4 test_function4(float ff)
{
    vec4 func_vec4 = vec4(f1);
    return func_vec4;
}
float f2 = 3.5;
void main()
{
    vec4 v1 = test_function4(f2);
    vec4 v2 = test_function1(f2);
    vec4 v3 = test_function2(f2);
    vec4 v4 = test_function3(f2);
    if (f1 > f2) {
        gl_FragColor = v1 + v2 + v3 + v4;
    } else
        gl_FragColor = v1 + v2 + v3 + v4;
}
float f4 = 5.5;
vec4 test_function3(float ff)
{
    if (ff > f4)
	return vec4(ff);
    else
        return vec4(f4);
}
float f3 = 4.5;
vec4 test_function2(float ff)
{
    vec4 func_vec4 = vec4(ff+f3);
    return func_vec4;
}
float f5 = 6.5;

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvec4 test_function4(float);\nvec4 test_function1(float);\nvec4 test_function2(float);\nvec4 test_function3(float);\nfloat f = 2.6;\nvec4 test_function1(float ff)\n{\n    vec4 func_vec4 = vec4(ff+f);\n    return func_vec4;\n}\nfloat f1 = 1.5;\nvec4 test_function4(float ff)\n{\n    vec4 func_vec4 = vec4(f1);\n    return func_vec4;\n}\nfloat f2 = 3.5;\nvoid main()\n{\n    vec4 v1 = test_function4(f2);\n    vec4 v2 = test_function1(f2);\n    vec4 v3 = test_function2(f2);\n    vec4 v4 = test_function3(f2);\n    if (f1 > f2) {\n        gl_FragColor = v1 + v2 + v3 + v4;\n    } else\n        gl_FragColor = v1 + v2 + v3 + v4;\n}\nfloat f4 = 5.5;\nvec4 test_function3(float ff)\n{\n    if (ff > f4)\n\treturn vec4(ff);\n    else\n        return vec4(f4);\n}\nfloat f3 = 4.5;\nvec4 test_function2(float ff)\n{\n    vec4 func_vec4 = vec4(ff+f3);\n    return func_vec4;\n}\nfloat f5 = 6.5;\n\x00')
59.97001499250375
Processing this: /home/oof/webgl_cleaned/vec4_arb_g_1vec3_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.arb;
	float g = lightloc.g;
	vec4 a = vec4(m.g, g, m.b, m.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.arb;\n\tfloat g = lightloc.g;\n\tvec4 a = vec4(m.g, g, m.b, m.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, +(true ? +2.0 : (true ? 0.5 : -1.0)), 1.0, +0.5, -1.0, (((true || false) ? (false || false) : false) ? +0.0 : 2.0), 0.0, -1.0, (!false ? 0.5 : -1.0), -0.0, (+-1.0 / 0.5), 2.0, 0.0, 1.0, 2.0, 0.5);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.arb;
  float g = lightloc.g;
  vec4 a = vec4(m.g , g , m.b , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, +(true ? +2.0 : (true ? 0.5 : -1.0)), 1.0, +0.5, -1.0, (((true || false) ? (false || false) : false) ? +0.0 : 2.0), 0.0, -1.0, (!false ? 0.5 : -1.0), -0.0, (+-1.0 / 0.5), 2.0, 0.0, 1.0, 2.0, 0.5);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.arb;
  float g = lightloc.g;
  vec4 a = vec4(m.g , g , m.b , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
59.88023952095808
Processing this: /home/oof/webgl_cleaned/brick_mat3.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec3 gtf_Normal;
attribute mat3 myAttrib3m;
uniform mat3 gtf_NormalMatrix;
varying float lightIntensity;
varying vec3  Position;
uniform vec3  LightPosition;
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
const float specularContribution = 0.7;
const float diffuseContribution  = (1.0 - specularContribution);
void main() {
    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;
    Position        = vec3(gtf_Vertex);
    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);
    vec3 lightVec   = normalize(LightPosition - vec3(pos));
    vec3 reflectVec = reflect(lightVec, tnorm);
    vec3 viewVec    = normalize(vec3(pos));
	float f = myAttrib3m[0][0];
	float spec = clamp(dot(reflectVec, viewVec), f, 1.0);
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +
                     specularContribution * spec;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec3 gtf_Normal;\nattribute mat3 myAttrib3m;\nuniform mat3 gtf_NormalMatrix;\nvarying float lightIntensity;\nvarying vec3  Position;\nuniform vec3  LightPosition;\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nconst float specularContribution = 0.7;\nconst float diffuseContribution  = (1.0 - specularContribution);\nvoid main() {\n    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;\n    Position        = vec3(gtf_Vertex);\n    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);\n    vec3 lightVec   = normalize(LightPosition - vec3(pos));\n    vec3 reflectVec = reflect(lightVec, tnorm);\n    vec3 viewVec    = normalize(vec3(pos));\n\tfloat f = myAttrib3m[0][0];\n\tfloat spec = clamp(dot(reflectVec, viewVec), f, 1.0);\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +\n                     specularContribution * spec;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec3 gtf_Normal;

mat3 myAttrib3m;

uniform mat3 gtf_NormalMatrix;

float lightIntensity;

vec3 Position;

uniform vec3 LightPosition;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

const float specularContribution = 0.7;

const float diffuseContribution[4] = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float f = myAttrib3m[0][0];
  float spec = clamp(dot(reflectVec , viewVec) , f , 1.0);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:24: 'const' : cannot declare arrays of this qualifier
ERROR: 0:24: '=' : array / non-array mismatch
ERROR: 0:24: '=' : cannot convert from 'const mediump float' to 'const mediump array[4] of float'
ERROR: 0:40: '*' : array / non-array mismatch
ERROR: 0:40: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'const mediump array[4] of float' and a right operand of type 'mediump float' (or there is no acceptable conversion)
ERROR: 0:40: '+' : array / non-array mismatch
ERROR: 0:40: '+' : wrong operand types - no operation '+' exists that takes a left-hand operand of type 'const mediump array[4] of float' and a right operand of type 'mediump float' (or there is no acceptable conversion)
ERROR: 0:40: '=' : array / non-array mismatch
ERROR: 0:40: 'assign' : cannot convert from 'const mediump array[4] of float' to 'mediump float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec3 gtf_Normal;

mat3 myAttrib3m;

uniform mat3 gtf_NormalMatrix;

float lightIntensity;

vec3 Position;

uniform vec3 LightPosition;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

const float specularContribution = 0.7;

const float diffuseContribution[4] = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float f = myAttrib3m[0][0];
  float spec = clamp(dot(reflectVec , viewVec) , f , 1.0);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.79073243647235
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.85074626865672
Processing this: /home/oof/webgl_cleaned/log2_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 31.0 * gtf_Color.rgb + 1.0;
	color = vec4(log2(c) / 5.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 31.0 * gtf_Color.rgb + 1.0;\n\tcolor = vec4(log2(c) / 5.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.5, 1.0, 0.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((31.0 * gtf_Color.rgb) + 1.0);
  color = vec4((log2(c) / 5.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.910581222056635
Processing this: /home/oof/webgl_cleaned/abs_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (color.rg - 0.5);
	if((c[0] < 0.0)) c[0] *= -1.0;
	if((c[1] < 0.0)) c[1] *= -1.0;
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tif((c[0] < 0.0)) c[0] *= -1.0;\n\tif((c[1] < 0.0)) c[1] *= -1.0;\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  gl_FragColor = vec4(c , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  gl_FragColor = vec4(c , 0.0);
}


==============================
59.82142857142857
Processing this: /home/oof/webgl_cleaned/vec3_vec2_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 b = vec2(13.0, 53.0);
	vec3 a = vec3(b,139.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 b = vec2(13.0, 53.0);\n\tvec3 a = vec3(b,139.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((-1.0 * +(false ? 2.0 : 0.0)), 0.5, ((!false ? (true ? true : true) : false) ? ((-1.0 - 1.0) / 0.5) : (+-1.0 + -0.5)), (+1.0 * -1.0));

void main()
{
  vec2 b = vec2(13.0 , 53.0);
  vec3 a = vec3(b , 139.0);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.88112927191679
Processing this: /home/oof/webgl_cleaned/vec4_zwxy_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.zwxy;
	vec4 a = vec4(m.z, m.w, m.x, m.y);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.zwxy;\n\tvec4 a = vec4(m.z, m.w, m.x, m.y);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.zwxy;
  vec4 a = vec4(m.z , m.w , m.x , m.y);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.940652818991104
Mutations attempted: 674
Valid mutations:     404
Success rate:        59.94%
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 4.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4(atan(c) / M_PI + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 4.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(atan(c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color[8] = (false ? ((false ? false : false) ? vec4(((false || true) ? (2.0 + (true ? 1.0 : 0.5)) : -1.0), (0.0 + -1.0), -1.0, (2.0 - 0.5)) : vec4(0.5, (((false || true) ? true : !false) ? (1.0 * -1.0) : (true ? 1.0 : -1.0)), (0.5 + -0.5), 2.0)) : vec4((!(false && true) ? (!false ? +0.5 : 2.0) : +(2.0 + 1.0)), ((true ? --1.0 : 0.0) / 2.0), 2.0, 0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((atan(c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : global variable initializers must be constant expressions
ERROR: 0:15: '.' : cannot apply dot operator to an array
ERROR: 0:15: '-' : array / non-array mismatch
ERROR: 0:15: '-' : wrong operand types - no operation '-' exists that takes a left-hand operand of type 'mediump array[8] of 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:15: '*' : array / non-array mismatch
ERROR: 0:15: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'const float' and a right operand of type 'mediump array[8] of 4-component vector of float' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color[8] = (false ? ((false ? false : false) ? vec4(((false || true) ? (2.0 + (true ? 1.0 : 0.5)) : -1.0), (0.0 + -1.0), -1.0, (2.0 - 0.5)) : vec4(0.5, (((false || true) ? true : !false) ? (1.0 * -1.0) : (true ? 1.0 : -1.0)), (0.5 + -0.5), 2.0)) : vec4((!(false && true) ? (!false ? +0.5 : 2.0) : +(2.0 + 1.0)), ((true ? --1.0 : 0.0) / 2.0), 2.0, 0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((atan(c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.851851851851855
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 4.0 * 2.0 * (gtf_Color.r - 0.5);
	float atan_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	vec4 result;
	if(c < 0.0)
	{
		sign = -1.0;
		c *= -1.0;
	}
	if(c <= 1.0)
	{
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	else
	{
		c = 1.0 / c;
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 4.0 * 2.0 * (gtf_Color.r - 0.5);\n\tfloat atan_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tvec4 result;\n\tif(c < 0.0)\n\t{\n\t\tsign = -1.0;\n\t\tc *= -1.0;\n\t}\n\tif(c <= 1.0)\n\t{\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tc = 1.0 / c;\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 2.0, 0.5, +1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  float atan_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  vec4 result;
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  if ((c <= 1.0))
  {
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * atan_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  else
  {
    c = (1.0 / c);
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.9112426035503
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xconst2_yvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 2.0, 2.0, (((true ? false : true) ? (1.0 - -1.0) : (false ? 2.0 : -1.0)) * 2.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((pow(vec2(2.0) , (2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.97045790251108
Processing this: /home/oof/webgl_cleaned/notEqual_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(notEqual(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(notEqual(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((2.0 - 2.0), -2.0, (true ? -1.0 : -1.0), +(false ? 1.0 : (0.0 - 1.0)));

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.02949852507374
Processing this: /home/oof/webgl_cleaned/distance_vec3_vert_xvaryyhalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(distance(gtf_Color.rgb, vec3(0.5))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(distance(gtf_Color.rgb, vec3(0.5))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = (((true && true) ? (false && true) : !true) ? vec4((+(true ? -1.0 : 0.5) / (true ? (2.0 - 2.0) : 1.0)), -0.0, 0.0, (-1.0 - ((2.0 - 0.5) * 0.5))) : vec4(-1.0, (0.0 * 1.0), (0.0 * (2.0 / --1.0)), 1.0));

void main()
{
  color = vec4(vec3(distance(gtf_Color.rgb , vec3(0.5))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:10: '/' : Divide by zero during constant folding
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = (((true && true) ? (false && true) : !true) ? vec4((+(true ? -1.0 : 0.5) / (true ? (2.0 - 2.0) : 1.0)), -0.0, 0.0, (-1.0 - ((2.0 - 0.5) * 0.5))) : vec4(-1.0, (0.0 * 1.0), (0.0 * (2.0 / --1.0)), 1.0));

void main()
{
  color = vec4(vec3(distance(gtf_Color.rgb , vec3(0.5))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.941089837997055
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, ((2.0 + (false ? -1.0 : -1.0)) * 0.0), 0.0, 0.0, 1.0, +((true ? true : true) ? 0.0 : 0.5), 1.0, 1.0, 1.0, (false ? +0.5 : ((true ? -1.0 : 2.0) / +1.0)), +0.0, 1.0, 0.0, ((2.0 - (-1.0 - 1.0)) - -1.0), 0.0, -1.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, ((2.0 + (false ? -1.0 : -1.0)) * 0.0), 0.0, 0.0, 1.0, +((true ? true : true) ? 0.0 : 0.5), 1.0, 1.0, 1.0, (false ? +0.5 : ((true ? -1.0 : 2.0) / +1.0)), +0.0, 1.0, 0.0, ((2.0 - (-1.0 - 1.0)) - -1.0), 0.0, -1.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.85294117647059
Processing this: /home/oof/webgl_cleaned/equal_ivec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(equal(ivec3(c), ivec3(0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(equal(ivec3(c), ivec3(0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 2.0, 2.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(equal(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.91189427312775
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((vec4(1.0, (!(true || false) ? --1.0 : 1.0), +((true && false) ? (false ? 2.0 : 1.0) : (false ? 0.0 : 2.0)), 2.0) > min_c[1]))
    color[-9] = min_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: '--' : l-value required (can't modify a const)
ERROR: 0:12: '>' : comparison operator only defined for scalars
ERROR: 0:12: '>' : wrong operand types - no operation '>' exists that takes a left-hand operand of type 'const 4-component vector of float' and a right operand of type 'const mediump float' (or there is no acceptable conversion)
ERROR: 0:13: '[]' : index expression is negative

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((vec4(1.0, (!(true || false) ? --1.0 : 1.0), +((true && false) ? (false ? 2.0 : 1.0) : (false ? 0.0 : 2.0)), 2.0) > min_c[1]))
    color[-9] = min_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


==============================
59.82404692082112
Processing this: /home/oof/webgl_cleaned/fract_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false ? --1.0 : 0.5) + (true ? (true ? 0.0 : 1.0) : (true ? -1.0 : 0.0))), 1.0, (((false ? true : true) || (false ? false : false)) ? ((-1.0 + 0.5) * 2.0) : 0.0), -1.0);

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((false ? --1.0 : 0.5) + (true ? (true ? 0.0 : 1.0) : (true ? -1.0 : 0.0))), 1.0, (((false ? true : true) || (false ? false : false)) ? ((-1.0 + 0.5) * 2.0) : 0.0), -1.0);

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  gl_FragColor = vec4(c , 1.0);
}


==============================
59.73645680819912
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xconsthalf_yvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = -2.0 * (gtf_Color.r - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = -2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(exp2(2.0 * c) / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (-2.0 * (gtf_Color.r - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0) , 0.0 , 0.0 , 1.0);
  -(false ? 0.0 : 2.0);
}


As vertex? : True
SUCCESS!
59.7953216374269
Mutations attempted: 684
Valid mutations:     409
Success rate:        59.80%
Processing this: /home/oof/webgl_cleaned/max_float_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = color.r;
	if(c < max_c) c = max_c;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = color.r;\n\tif(c < max_c) c = max_c;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((0.5 / 0.0), 0.5, (false ? +-1.0 : (0.5 + (true ? 1.0 : 2.0))), ((true ? (false ? true : false) : false) ? 0.5 : -1.0));

void main()
{
  const float max_c = 0.5;
  float c = color.r;
  if ((c < max_c))
    c = max_c;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.854014598540154
Processing this: /home/oof/webgl_cleaned/floor_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float floor_ref(float x)
{
	if(x >= 0.0)
		x = float(int(x));
	else
		x = float(int(x) - 1);
	return x;
}
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((floor_ref(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat floor_ref(float x)\n{\n\tif(x >= 0.0)\n\t\tx = float(int(x));\n\telse\n\t\tx = float(int(x) - 1);\n\treturn x;\n}\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((floor_ref(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(2.0, -1.0, -0.5, 1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float floor_ref(float x)
{
  if ((x >= 0.0))
    x = float(int(x));
  else
    x = float((int(x) - 1));
  return x;
}

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((floor_ref(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.91253644314869
Processing this: /home/oof/webgl_cleaned/ceil_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float ceil_ref(float x)
{
	if(x != floor(x)) x = floor(x) + 1.0;
	return x;
}
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	gl_FragColor = vec4((ceil_ref(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat ceil_ref(float x)\n{\n\tif(x != floor(x)) x = floor(x) + 1.0;\n\treturn x;\n}\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4((ceil_ref(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float ceil_ref(float x)
{
  if ((x != floor(x)))
    x = (floor(x) + 1.0);
  return x;
}

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 0.5));
  gl_FragColor = vec4(((ceil_ref(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.97088791848617
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = (gtf_Color.rg * 99.0) + 1.0;
	color = vec4(1.0 / sqrt(c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (gtf_Color.rg * 99.0) + 1.0;\n\tcolor = vec4(1.0 / sqrt(c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(+(!false ? 1.0 : 2.0), 0.0, +(-0.5 * (0.5 + 2.0)), (!false ? -(2.0 + 2.0) : 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((gtf_Color.rg * 99.0) + 1.0);
  color = vec4((1.0 / sqrt(c)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.029069767441854
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_frag_xvary_edgeconstquarter_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	vec3 c = clamp((color.rgb - edge0) / (edge1 - edge0), 0.0, 1.0);
	gl_FragColor = vec4(c * c * (3.0 - 2.0 * c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tvec3 c = clamp((color.rgb - edge0) / (edge1 - edge0), 0.0, 1.0);\n\tgl_FragColor = vec4(c * c * (3.0 - 2.0 * c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  vec3 c = clamp(((color.rgb - edge0) / (edge1 - edge0)) , 0.0 , 1.0);
  gl_FragColor = vec4(((c * c) * (3.0 - (2.0 * c))) , 1.0);
}


As vertex? : False
SUCCESS!
60.087082728592165
Processing this: /home/oof/webgl_cleaned/radians_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 360.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((c * M_PI / 180.0) / (4.0 * M_PI) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 360.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((c * M_PI / 180.0) / (4.0 * M_PI) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * M_PI) / 180.0) / (4.0 * M_PI)) + 0.5) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * M_PI) / 180.0) / (4.0 * M_PI)) + 0.5) , 0.0);
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/2m_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform mat2 color;
void main ()
{
	gl_FragColor = vec4 (color[0][0] + color[0][1], color[1][0] + color[1][1], 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform mat2 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0] + color[0][1], color[1][0] + color[1][1], 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat2 color = mat2(2.0, -0.5, 0.0, 0.5);

void main()
{
  gl_FragColor = vec4((color[0][0] + color[0][1]) , (color[1][0] + color[1][1]) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat2 color = mat2(2.0, -0.5, 0.0, 0.5);

void main()
{
  gl_FragColor = vec4((color[0][0] + color[0][1]) , (color[1][0] + color[1][1]) , 0.0 , 1.0);
}


==============================
59.913169319826345
Processing this: /home/oof/webgl_cleaned/ceil_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	gl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+-1.0, 0.0, (((true ? 1.0 : 0.5) + (true ? 0.5 : 0.5)) * 0.5), 0.5);

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.97109826589595
Processing this: /home/oof/webgl_cleaned/precision_specifiers.frag
Original source code: 
precision mediump float;
precision mediump int;

varying mediump vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvarying mediump vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

mediump vec4 color;

void main()
{
  color = color;
}


As vertex? : False
SUCCESS!
60.02886002886003
Processing this: /home/oof/webgl_cleaned/reflect_vec3_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	gl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tgl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (color(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  gl_FragColor = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: 'color' : function name expected

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (color(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  gl_FragColor = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
}


==============================
59.94236311239193
Mutations attempted: 694
Valid mutations:     416
Success rate:        59.94%
Processing this: /home/oof/webgl_cleaned/samplerUniformShader.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform sampler2D s2D;
uniform samplerCube sCube;
void main()
{
    gl_FragColor = texture2D(s2D, vec2(0.5, 0.5)) +
                   textureCube(sCube, vec3(0.5, 0.5, 0.5));
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform sampler2D s2D;\nuniform samplerCube sCube;\nvoid main()\n{\n    gl_FragColor = texture2D(s2D, vec2(0.5, 0.5)) +\n                   textureCube(sCube, vec3(0.5, 0.5, 0.5));\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform sampler2D s2D;

uniform samplerCube sCube;

void main()
{
  gl_FragColor = (texture2D(s2D) * s2D(sCube));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gl_FragColor' : undeclared identifier
ERROR: 0:10: 'texture2D' : no matching overloaded function found
ERROR: 0:10: 's2D' : function name expected
ERROR: 0:10: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform sampler2D s2D;

uniform samplerCube sCube;

void main()
{
  gl_FragColor = (texture2D(s2D) * s2D(sCube));
}


==============================
59.856115107913666
Processing this: /home/oof/webgl_cleaned/asin_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (gtf_Color.r - 0.5);
	float asin_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	if(c < 0.0)
	{
		sign = -1.0;
		c *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		asin_c += scale * pow(c, float(i)) / float(i);
		scale *= float(i) / float(i + 1);
	}
	color = vec4(sign * asin_c / M_PI + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tfloat asin_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tif(c < 0.0)\n\t{\n\t\tsign = -1.0;\n\t\tc *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tasin_c += scale * pow(c, float(i)) / float(i);\n\t\tscale *= float(i) / float(i + 1);\n\t}\n\tcolor = vec4(sign * asin_c / M_PI + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  float asin_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (asin_c += ((scale * pow(c , float(i))) / float(i)));
    (scale *= (float(i) / float((i + 1))));
  }
  color = vec4((((sign * asin_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.91379310344828
Processing this: /home/oof/webgl_cleaned/const_mat3_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0,   2.0,   4.0,
	                     8.0,  16.0,  32.0,
	                    64.0, 128.0, 256.0);
	mat3 b = a;
	bool elms = true;
	if(b[0][0] !=   1.0) elms = false;
	if(b[0][1] !=   2.0) elms = false;
	if(b[0][2] !=   4.0) elms = false;
	if(b[1][0] !=   8.0) elms = false;
	if(b[1][1] !=  16.0) elms = false;
	if(b[1][2] !=  32.0) elms = false;
	if(b[2][0] !=  64.0) elms = false;
	if(b[2][1] != 128.0) elms = false;
	if(b[2][2] != 256.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0];
	x = b[0][0] + b[1][0] + b[2][0];
	if( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;
	x = b[0][1] + b[1][1] + b[2][1];
	if(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;
	x = b[0][2] + b[1][2] + b[2][2];
	if(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2];
	if( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;
	x = b[1][0] + b[1][1] + b[1][2];
	if(x < 56.0-0.1 || x > 56.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2];
	if(x < 448.0-0.1 || x > 448.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0,   2.0,   4.0,\n\t                     8.0,  16.0,  32.0,\n\t                    64.0, 128.0, 256.0);\n\tmat3 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=   1.0) elms = false;\n\tif(b[0][1] !=   2.0) elms = false;\n\tif(b[0][2] !=   4.0) elms = false;\n\tif(b[1][0] !=   8.0) elms = false;\n\tif(b[1][1] !=  16.0) elms = false;\n\tif(b[1][2] !=  32.0) elms = false;\n\tif(b[2][0] !=  64.0) elms = false;\n\tif(b[2][1] != 128.0) elms = false;\n\tif(b[2][2] != 256.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tif( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1];\n\tif(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2];\n\tif(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2];\n\tif( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2];\n\tif(x < 56.0-0.1 || x > 56.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2];\n\tif(x < 448.0-0.1 || x > 448.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(((false ? true : false) ? ((false || false) ? -1.0 : -1.0) : (false ? -2.0 : 0.0)), 0.5, ((true ? !false : false) ? 0.0 : (1.0 + (-1.0 / 2.0))), (-(true ? 1.0 : 1.0) * (true ? (true ? 1.0 : 0.5) : -2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  mat3 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[1][0] != 8.0))
    elms = false;
  if ((b[1][1] != 16.0))
    elms = false;
  if ((b[1][2] != 32.0))
    elms = false;
  if ((b[2][0] != 64.0))
    elms = false;
  if ((b[2][1] != 128.0))
    elms = false;
  if ((b[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((b[0][1] + b[1][1]) + b[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((b[0][2] + b[1][2]) + b[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((b[0][0] + b[0][1]) + b[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((b[1][0] + b[1][1]) + b[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((b[2][0] + b[2][1]) + b[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.9713055954089
Processing this: /home/oof/webgl_cleaned/CorrectConstFolding1_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
   const struct s2 {
       int i;
       vec3 v3;
       bvec4 bv4;
   } s22  = s2(8, vec3(9, 10, 11), bvec4(true, false, true, false));
   struct s4 {
       int ii;
       vec4 v4;
      };
   const struct s1 {
      s2 ss;
      int i;
      float f;
      mat4 m;
 	s4 s44;
   } s11 = s1(s22, 2, 4.0, mat4(5), s4(6, vec4(7, 8, 9, 10))) ;
  const int field3 = s11.i * s11.ss.i;
  const vec4 field4 = s11.s44.v4 * s11.s44.v4;
  const vec4 v4 = vec4(s11.ss.v3.y, s11.m[3][3], field3, field4[2]);
  gl_Position = v4;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n   const struct s2 {\n       int i;\n       vec3 v3;\n       bvec4 bv4;\n   } s22  = s2(8, vec3(9, 10, 11), bvec4(true, false, true, false));\n   struct s4 {\n       int ii;\n       vec4 v4;\n      };\n   const struct s1 {\n      s2 ss;\n      int i;\n      float f;\n      mat4 m;\n \ts4 s44;\n   } s11 = s1(s22, 2, 4.0, mat4(5), s4(6, vec4(7, 8, 9, 10))) ;\n  const int field3 = s11.i * s11.ss.i;\n  const vec4 field4 = s11.s44.v4 * s11.s44.v4;\n  const vec4 v4 = vec4(s11.ss.v3.y, s11.m[3][3], field3, field4[2]);\n  gl_Position = v4;\n}\n\x00')
59.9713055954089
Processing this: /home/oof/webgl_cleaned/cos_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.rgb) + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.rgb) + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, 2.0, 2.0, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.rgb))) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.02865329512894
Processing this: /home/oof/webgl_cleaned/cos_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(+2.0, 2.0, +0.0, (true ? 0.0 : ((0.5 / 2.0) - -2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.08583690987125
Processing this: /home/oof/webgl_cleaned/log2_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 31.0 * gtf_Color.r + 1.0;
	color = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 31.0 * gtf_Color.r + 1.0;\n\tcolor = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((gtf_Color.r * 31.0) + 1.0);
  color = vec4((log2(c) / 5.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.14285714285714
Processing this: /home/oof/webgl_cleaned/atan_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 4.0 * 2.0 * (gtf_Color.rgb - 0.5);
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	if(c[0] < 0.0)
	{
		sign[0] = -1.0;
		c[0] *= -1.0;
	}
	if(c[0] <= 1.0)
	{
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * atan_c[0] / M_PI + 0.5;
	}
	else
	{
		c[0] = 1.0 / c[0];
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;
	}
	if(c[1] < 0.0)
	{
		sign[1] = -1.0;
		c[1] *= -1.0;
	}
	if(c[1] <= 1.0)
	{
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * atan_c[1] / M_PI + 0.5;
	}
	else
	{
		c[1] = 1.0 / c[1];
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;
	}
	if(c[2] < 0.0)
	{
		sign[2] = -1.0;
		c[2] *= -1.0;
	}
	if(c[2] <= 1.0)
	{
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * atan_c[2] / M_PI + 0.5;
	}
	else
	{
		c[2] = 1.0 / c[2];
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 4.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(c[0] < 0.0)\n\t{\n\t\tsign[0] = -1.0;\n\t\tc[0] *= -1.0;\n\t}\n\tif(c[0] <= 1.0)\n\t{\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * atan_c[0] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[0] = 1.0 / c[0];\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;\n\t}\n\tif(c[1] < 0.0)\n\t{\n\t\tsign[1] = -1.0;\n\t\tc[1] *= -1.0;\n\t}\n\tif(c[1] <= 1.0)\n\t{\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * atan_c[1] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[1] = 1.0 / c[1];\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;\n\t}\n\tif(c[2] < 0.0)\n\t{\n\t\tsign[2] = -1.0;\n\t\tc[2] *= -1.0;\n\t}\n\tif(c[2] <= 1.0)\n\t{\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * atan_c[2] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[2] = 1.0 / c[2];\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((!true ? 2.0 : 0.0), 0.0, 1.0, (!true ? ((-1.0 * 0.0) + 1.0) : 0.0));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (gtf_Color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.19971469329529
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat3 m1 = mat3(gtf_Color.rgb, gtf_Color.rgb, gtf_Color.rgb);
	mat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);
	mat3 m3 = mat3(0.0);
	vec3 result = vec3(0.0, 0.0, 0.0);
	m3[0][0] = m1[0][0] * m2[0][0];
	m3[0][1] = m1[0][1] * m2[0][1];
	m3[0][2] = m1[0][2] * m2[0][2];
	m3[1][0] = m1[1][0] * m2[1][0];
	m3[1][1] = m1[1][1] * m2[1][1];
	m3[1][2] = m1[1][2] * m2[1][2];
	m3[2][0] = m1[2][0] * m2[2][0];
	m3[2][1] = m1[2][1] * m2[2][1];
	m3[2][2] = m1[2][2] * m2[2][2];
	result[0] += m3[0][0];
	result[0] += m3[0][1];
	result[0] += m3[0][2];
	result[1] += m3[1][0];
	result[1] += m3[1][1];
	result[1] += m3[1][2];
	result[2] += m3[2][0];
	result[2] += m3[2][1];
	result[2] += m3[2][2];
	color = vec4(result / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m1 = mat3(gtf_Color.rgb, gtf_Color.rgb, gtf_Color.rgb);\n\tmat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);\n\tmat3 m3 = mat3(0.0);\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tm3[0][0] = m1[0][0] * m2[0][0];\n\tm3[0][1] = m1[0][1] * m2[0][1];\n\tm3[0][2] = m1[0][2] * m2[0][2];\n\tm3[1][0] = m1[1][0] * m2[1][0];\n\tm3[1][1] = m1[1][1] * m2[1][1];\n\tm3[1][2] = m1[1][2] * m2[1][2];\n\tm3[2][0] = m1[2][0] * m2[2][0];\n\tm3[2][1] = m1[2][1] * m2[2][1];\n\tm3[2][2] = m1[2][2] * m2[2][2];\n\tresult[0] += m3[0][0];\n\tresult[0] += m3[0][1];\n\tresult[0] += m3[0][2];\n\tresult[1] += m3[1][0];\n\tresult[1] += m3[1][1];\n\tresult[1] += m3[1][2];\n\tresult[2] += m3[2][0];\n\tresult[2] += m3[2][1];\n\tresult[2] += m3[2][2];\n\tcolor = vec4(result / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat3 m1 = mat3(gtf_Color.rgb , gtf_Color.rgb , gtf_Color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3[0][0] = (m1[0][0] * m2[0][0]);
  color[1][1] = (m1[1][1] * gtf_ModelViewProjectionMatrix[0][1]);
  m3[0][2] = (m1[0][2] * m2[0][2]);
  m3[1][0] = (m1[1][0] * m2[1][0]);
  m3[1][1] = (m1[1][1] * m2[1][1]);
  m3[1][2] = (m1[1][2] * m2[1][2]);
  m3[2][0] = (m1[2][0] * m2[2][0]);
  m3[2][1] = (m1[2][1] * m2[2][1]);
  m3[2][2] = (m1[2][2] * m2[2][2]);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  color = vec4((result / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:19: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:19: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat3 m1 = mat3(gtf_Color.rgb , gtf_Color.rgb , gtf_Color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3[0][0] = (m1[0][0] * m2[0][0]);
  color[1][1] = (m1[1][1] * gtf_ModelViewProjectionMatrix[0][1]);
  m3[0][2] = (m1[0][2] * m2[0][2]);
  m3[1][0] = (m1[1][0] * m2[1][0]);
  m3[1][1] = (m1[1][1] * m2[1][1]);
  m3[1][2] = (m1[1][2] * m2[1][2]);
  m3[2][0] = (m1[2][0] * m2[2][0]);
  m3[2][1] = (m1[2][1] * m2[2][1]);
  m3[2][2] = (m1[2][2] * m2[2][2]);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  color = vec4((result / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.11396011396012
Processing this: /home/oof/webgl_cleaned/lighting_diffuse.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat3 gtf_NormalMatrix;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
attribute vec3 gtf_Normal;
varying vec4 color;
vec4 Ambient;
vec4 Diffuse;
vec4 Specular;
const vec3 lightPosition = vec3(0.0, 0.0, 10.0);
const float lightAttenuationConstant = 1.0;
const float lightAttenuationLinear = 0.0;
const float lightAttenuationQuadratic = 0.0;
const vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 0.0);
vec4 lightDiffuse = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 materialAmbient = vec4(0.0, 0.0, 0.0, 1.0);
const vec4 materialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);
const vec4 materialSpecular = vec4(0.0, 0.0, 0.0, 0.0);
const float materialShininess = 20.0;
const vec4 sceneColor = vec4(0.0, 0.0, 0.0, 0.0);
void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
   float nDotVP;
   float nDotHV;
   float pf;
   float attenuation;
   float d;
   vec3  VP;
   vec3  halfVector;
   VP = lightPosition - ecPosition3;
   d = length(VP);
   VP = normalize(VP);
   attenuation = 1.0 / (lightAttenuationConstant +
       lightAttenuationLinear * d +
       lightAttenuationQuadratic * d * d);
   halfVector = normalize(VP + eye);
   nDotVP = max(0.0, dot(normal, VP));
   nDotHV = max(0.0, dot(normal, halfVector));
   if (nDotVP == 0.0)
   {
       pf = 0.0;
   }
   else
   {
       pf = pow(nDotHV, materialShininess);
   }
   Ambient  += lightAmbient * attenuation;
   Diffuse  += lightDiffuse * nDotVP * attenuation;
}
vec3 fnormal()
{
    vec3 normal = gtf_Normal * gtf_NormalMatrix;
    normal = normalize(normal);
    return vec3(0.0, 0.0, 1.0);
}
void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
    vec3 ecPosition3;
    vec3 eye;
    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;
    eye = vec3 (0.0, 0.0, 1.0);
    Ambient  = vec4 (0.0);
    Diffuse  = vec4 (0.0);
    Specular = vec4 (0.0);
	lightDiffuse = gtf_Color;
    pointLight(0, normal, eye, ecPosition3);
    color = sceneColor +
      Ambient  * materialAmbient +
      Diffuse  * materialDiffuse;
    color += Specular * materialSpecular;
    color = clamp( color, 0.0, 1.0 );
    color.a *= alphaFade;
}
void main ()
{
    vec3  transformedNormal;
    float alphaFade = 1.0;
    vec4 ecPosition = gtf_ModelViewMatrix * gtf_Vertex;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
    transformedNormal = fnormal();
    flight(transformedNormal, ecPosition, alphaFade);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat3 gtf_NormalMatrix;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nattribute vec3 gtf_Normal;\nvarying vec4 color;\nvec4 Ambient;\nvec4 Diffuse;\nvec4 Specular;\nconst vec3 lightPosition = vec3(0.0, 0.0, 10.0);\nconst float lightAttenuationConstant = 1.0;\nconst float lightAttenuationLinear = 0.0;\nconst float lightAttenuationQuadratic = 0.0;\nconst vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 0.0);\nvec4 lightDiffuse = vec4(1.0, 0.0, 0.0, 1.0);\nconst vec4 materialAmbient = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 materialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 materialSpecular = vec4(0.0, 0.0, 0.0, 0.0);\nconst float materialShininess = 20.0;\nconst vec4 sceneColor = vec4(0.0, 0.0, 0.0, 0.0);\nvoid pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)\n{\n   float nDotVP;\n   float nDotHV;\n   float pf;\n   float attenuation;\n   float d;\n   vec3  VP;\n   vec3  halfVector;\n   VP = lightPosition - ecPosition3;\n   d = length(VP);\n   VP = normalize(VP);\n   attenuation = 1.0 / (lightAttenuationConstant +\n       lightAttenuationLinear * d +\n       lightAttenuationQuadratic * d * d);\n   halfVector = normalize(VP + eye);\n   nDotVP = max(0.0, dot(normal, VP));\n   nDotHV = max(0.0, dot(normal, halfVector));\n   if (nDotVP == 0.0)\n   {\n       pf = 0.0;\n   }\n   else\n   {\n       pf = pow(nDotHV, materialShininess);\n   }\n   Ambient  += lightAmbient * attenuation;\n   Diffuse  += lightDiffuse * nDotVP * attenuation;\n}\nvec3 fnormal()\n{\n    vec3 normal = gtf_Normal * gtf_NormalMatrix;\n    normal = normalize(normal);\n    return vec3(0.0, 0.0, 1.0);\n}\nvoid flight(in vec3 normal, in vec4 ecPosition, float alphaFade)\n{\n    vec3 ecPosition3;\n    vec3 eye;\n    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;\n    eye = vec3 (0.0, 0.0, 1.0);\n    Ambient  = vec4 (0.0);\n    Diffuse  = vec4 (0.0);\n    Specular = vec4 (0.0);\n\tlightDiffuse = gtf_Color;\n    pointLight(0, normal, eye, ecPosition3);\n    color = sceneColor +\n      Ambient  * materialAmbient +\n      Diffuse  * materialDiffuse;\n    color += Specular * materialSpecular;\n    color = clamp( color, 0.0, 1.0 );\n    color.a *= alphaFade;\n}\nvoid main ()\n{\n    vec3  transformedNormal;\n    float alphaFade = 1.0;\n    vec4 ecPosition = gtf_ModelViewMatrix * gtf_Vertex;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n    transformedNormal = fnormal();\n    flight(transformedNormal, ecPosition, alphaFade);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat3 gtf_NormalMatrix = mat3(0.0, -1.0, +-1.0, (true ? (false ? (2.0 * 1.0) : +2.0) : +1.0), lightAttenuationQuadratic, ((false ? (true ? true : false) : (true ? false : false)) ? (materialShininess / 1.0) : 1.0), (!(true ? true : true) ? (!true ? (-1.0 / lightAttenuationLinear) : 0.5) : 2.0), (0.0 / (true ? -1.0 : 1.0)), 2.0);

vec4 gtf_Vertex;

vec4 gtf_Color;

vec3 gtf_Normal;

vec4 color;

vec4 Ambient;

vec4 Diffuse;

vec4 Specular;

const vec3 lightPosition = vec3(0.0 , 0.0 , 10.0);

const float lightAttenuationConstant = 1.0;

const float lightAttenuationLinear = 0.0;

const float lightAttenuationQuadratic = 0.0;

const vec4 lightAmbient = vec4(0.0 , 0.0 , 0.0 , 0.0);

vec4 lightDiffuse = vec4(1.0 , 0.0 , 0.0 , 1.0);

const vec4 materialAmbient = vec4(0.0 , 0.0 , 0.0 , 1.0);

const vec4 materialDiffuse = vec4(1.0 , 1.0 , 1.0 , 1.0);

const vec4 materialSpecular = vec4(0.0 , 0.0 , 0.0 , 0.0);

const float materialShininess = 20.0;

const vec4 sceneColor = vec4(0.0 , 0.0 , 0.0 , 0.0);

void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
  float nDotVP;
  float nDotHV;
  float pf;
  float attenuation;
  float d;
  vec3 VP;
  vec3 halfVector;
  VP = (lightPosition - ecPosition3);
  d = length(VP);
  VP = normalize(VP);
  attenuation = (1.0 / ((lightAttenuationConstant + (lightAttenuationLinear * d)) + ((lightAttenuationQuadratic * d) * d)));
  halfVector = normalize((VP + eye));
  nDotVP = max(0.0 , dot(normal , VP));
  nDotHV = max(0.0 , dot(normal , halfVector));
  if ((nDotVP == 0.0))
  {
    pf = 0.0;
  }
  else
  {
    pf = pow(nDotHV , materialShininess);
  }
  (Ambient += (lightAmbient * attenuation));
  (Diffuse += ((lightDiffuse * nDotVP) * attenuation));
}

vec3 fnormal()
{
  vec3 normal = (gtf_Normal * gtf_NormalMatrix);
  normal = normalize(normal);
  return vec3(0.0 , 0.0 , 1.0);
}

void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
  vec3 ecPosition3;
  vec3 eye;
  ecPosition3 = (vec3(ecPosition) / ecPosition.w);
  eye = vec3(0.0 , 0.0 , 1.0);
  Ambient = vec4(0.0);
  Diffuse = vec4(0.0);
  Specular = vec4(0.0);
  lightDiffuse = gtf_Color;
  pointLight(0 , normal , eye , ecPosition3);
  color = ((sceneColor + (Ambient * materialAmbient)) + (Diffuse * materialDiffuse));
  (color += (Specular * materialSpecular));
  color = clamp(color , 0.0 , 1.0);
  (color.a *= alphaFade);
}

void main()
{
  vec3 transformedNormal;
  float alphaFade = 1.0;
  vec4 ecPosition = (gtf_ModelViewMatrix * gtf_Vertex);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  transformedNormal = fnormal();
  flight(transformedNormal , ecPosition , alphaFade);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'lightAttenuationQuadratic' : undeclared identifier
ERROR: 0:8: 'materialShininess' : undeclared identifier
ERROR: 0:8: 'lightAttenuationLinear' : undeclared identifier
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat3 gtf_NormalMatrix = mat3(0.0, -1.0, +-1.0, (true ? (false ? (2.0 * 1.0) : +2.0) : +1.0), lightAttenuationQuadratic, ((false ? (true ? true : false) : (true ? false : false)) ? (materialShininess / 1.0) : 1.0), (!(true ? true : true) ? (!true ? (-1.0 / lightAttenuationLinear) : 0.5) : 2.0), (0.0 / (true ? -1.0 : 1.0)), 2.0);

vec4 gtf_Vertex;

vec4 gtf_Color;

vec3 gtf_Normal;

vec4 color;

vec4 Ambient;

vec4 Diffuse;

vec4 Specular;

const vec3 lightPosition = vec3(0.0 , 0.0 , 10.0);

const float lightAttenuationConstant = 1.0;

const float lightAttenuationLinear = 0.0;

const float lightAttenuationQuadratic = 0.0;

const vec4 lightAmbient = vec4(0.0 , 0.0 , 0.0 , 0.0);

vec4 lightDiffuse = vec4(1.0 , 0.0 , 0.0 , 1.0);

const vec4 materialAmbient = vec4(0.0 , 0.0 , 0.0 , 1.0);

const vec4 materialDiffuse = vec4(1.0 , 1.0 , 1.0 , 1.0);

const vec4 materialSpecular = vec4(0.0 , 0.0 , 0.0 , 0.0);

const float materialShininess = 20.0;

const vec4 sceneColor = vec4(0.0 , 0.0 , 0.0 , 0.0);

void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
  float nDotVP;
  float nDotHV;
  float pf;
  float attenuation;
  float d;
  vec3 VP;
  vec3 halfVector;
  VP = (lightPosition - ecPosition3);
  d = length(VP);
  VP = normalize(VP);
  attenuation = (1.0 / ((lightAttenuationConstant + (lightAttenuationLinear * d)) + ((lightAttenuationQuadratic * d) * d)));
  halfVector = normalize((VP + eye));
  nDotVP = max(0.0 , dot(normal , VP));
  nDotHV = max(0.0 , dot(normal , halfVector));
  if ((nDotVP == 0.0))
  {
    pf = 0.0;
  }
  else
  {
    pf = pow(nDotHV , materialShininess);
  }
  (Ambient += (lightAmbient * attenuation));
  (Diffuse += ((lightDiffuse * nDotVP) * attenuation));
}

vec3 fnormal()
{
  vec3 normal = (gtf_Normal * gtf_NormalMatrix);
  normal = normalize(normal);
  return vec3(0.0 , 0.0 , 1.0);
}

void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
  vec3 ecPosition3;
  vec3 eye;
  ecPosition3 = (vec3(ecPosition) / ecPosition.w);
  eye = vec3(0.0 , 0.0 , 1.0);
  Ambient = vec4(0.0);
  Diffuse = vec4(0.0);
  Specular = vec4(0.0);
  lightDiffuse = gtf_Color;
  pointLight(0 , normal , eye , ecPosition3);
  color = ((sceneColor + (Ambient * materialAmbient)) + (Diffuse * materialDiffuse));
  (color += (Specular * materialSpecular));
  color = clamp(color , 0.0 , 1.0);
  (color.a *= alphaFade);
}

void main()
{
  vec3 transformedNormal;
  float alphaFade = 1.0;
  vec4 ecPosition = (gtf_ModelViewMatrix * gtf_Vertex);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  transformedNormal = fnormal();
  flight(transformedNormal , ecPosition , alphaFade);
}


==============================
60.02844950213371
Mutations attempted: 703
Valid mutations:     422
Success rate:        60.03%
Processing this: /home/oof/webgl_cleaned/vec3single_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec3 lightPosition;
varying vec4  color;
void main()
{
     gl_FragColor = vec4(lightPosition, 0.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec3 lightPosition;\nvarying vec4  color;\nvoid main()\n{\n     gl_FragColor = vec4(lightPosition, 0.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec3 lightPosition;

vec4 color = vec4(0.0, 0.0, 0.5, 0.0);

void main()
{
  gl_FragColor = vec4(lightPosition , 0.0);
}


As vertex? : False
SUCCESS!
60.08522727272727
Processing this: /home/oof/webgl_cleaned/equality_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool equalto = (m == 102);
	bool notequalto = (k != 102);
	float gray;
	if( equalto && notequalto )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool equalto = (m == 102);\n\tbool notequalto = (k != 102);\n\tfloat gray;\n\tif( equalto && notequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool equalto = (m == 102);
  bool notequalto = (k != 102);
  float gray;
  if ((equalto && notequalto))
    gray = 1.0;
  else
    gray = 0.0;
  color = color(2.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:21: 'color' : function name expected
ERROR: 0:21: '=' : dimension mismatch
ERROR: 0:21: 'assign' : cannot convert from 'const mediump float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool equalto = (m == 102);
  bool notequalto = (k != 102);
  float gray;
  if ((equalto && notequalto))
    gray = 1.0;
  else
    gray = 0.0;
  color = color(2.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/float_empty_empty_float_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
60.0
Processing this: /home/oof/webgl_cleaned/sin_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, ((true ? 0.5 : (false ? 1.0 : 1.0)) + --2.0), +2.0, 0.0);

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.rg))) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, ((true ? 0.5 : (false ? 1.0 : 1.0)) + --2.0), +2.0, 0.0);

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.rg))) + 0.5) , 0.0 , 1.0);
}


==============================
59.915014164305944
Processing this: /home/oof/webgl_cleaned/sin_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * gtf_Color.rg;
	float sign = 1.0;
	vec2 sin_c = vec2(0.0);
	float fact;
	float fact_of;
	for(int i = 0; i < 12; i++)
	{
		fact = 1.0;
		for(int j = 2; j <= 23; j++)
			if (j <= 2 * i + 1)
				fact *= float(j);
		sin_c += sign * pow(c, vec2(2.0 * float(i) + 1.0)) / fact;
		sign *= -1.0;
	}
	color = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * gtf_Color.rg;\n\tfloat sign = 1.0;\n\tvec2 sin_c = vec2(0.0);\n\tfloat fact;\n\tfloat fact_of;\n\tfor(int i = 0; i < 12; i++)\n\t{\n\t\tfact = 1.0;\n\t\tfor(int j = 2; j <= 23; j++)\n\t\t\tif (j <= 2 * i + 1)\n\t\t\t\tfact *= float(j);\n\t\tsin_c += sign * pow(c, vec2(2.0 * float(i) + 1.0)) / fact;\n\t\tsign *= -1.0;\n\t}\n\tcolor = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  vec2 c = ((2.0 * M_PI) * gtf_Color.rg);
  float sign = 1.0;
  vec2 sin_c = vec2(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec2(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;

vec4 color = vec4(1.0, -0.5, 1.0, 0.5);


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:25: 'gtf_Color' : undeclared identifier
ERROR: 0:25: 'rg' :  field selection requires structure or vector on left hand side
ERROR: 0:25: '=' : dimension mismatch
ERROR: 0:25: '=' : cannot convert from 'const highp float' to 'mediump 2-component vector of float'
ERROR: 0:39: 'color' : undeclared identifier
ERROR: 0:39: 'assign' : l-value required (can't modify a const)
ERROR: 0:39: '=' : dimension mismatch
ERROR: 0:39: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const highp float'
ERROR: 0:40: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:40: 'gtf_Vertex' : undeclared identifier
ERROR: 0:40: '=' : dimension mismatch
ERROR: 0:40: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  vec2 c = ((2.0 * M_PI) * gtf_Color.rg);
  float sign = 1.0;
  vec2 sin_c = vec2(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec2(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;

vec4 color = vec4(1.0, -0.5, 1.0, 0.5);


==============================
59.830268741159834
Processing this: /home/oof/webgl_cleaned/noopUniformShaderES3.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(0.0 , 0.0 , 0.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(0.0 , 0.0 , 0.0);
}


==============================
59.7457627118644
Processing this: /home/oof/webgl_cleaned/selection_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int j = 30;
	int k = 37;
	int y = 10;
	int n = 12;
	bool result1 = false;
	bool result2 = false;
	(j>k)?( result1 = true ):( result1 = false );
	(y<n)?( result2 = true ):( result2 = false );
	float gray;
	if( !result1 && result2 )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint j = 30;\n\tint k = 37;\n\tint y = 10;\n\tint n = 12;\n\tbool result1 = false;\n\tbool result2 = false;\n\t(j>k)?( result1 = true ):( result1 = false );\n\t(y<n)?( result2 = true ):( result2 = false );\n\tfloat gray;\n\tif( !result1 && result2 )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 1.0, 1.0, 0.0);

void main()
{
  int j = 30;
  int k = 37;
  int y = 10;
  int n = 12;
  bool result1 = false;
  bool result2 = false;
  ((j > k) ? result1 = true : result1 = false);
  ((y < n) ? result2 = true : result2 = false);
  float gray;
  if ((!result1 && result2))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.80253878702398
Processing this: /home/oof/webgl_cleaned/cos_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * gtf_Color.r;
	float sign = -1.0;
	float cos_c = 1.0;
	float fact = 1.0;
	for(int i = 2; i <= 20; i += 2)
	{
		fact *= float(i)*float(i-1);
		cos_c += sign*pow(c, float(i))/fact;
		sign = -sign;
	}
	color = vec4(0.5 * cos_c + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * gtf_Color.r;\n\tfloat sign = -1.0;\n\tfloat cos_c = 1.0;\n\tfloat fact = 1.0;\n\tfor(int i = 2; i <= 20; i += 2)\n\t{\n\t\tfact *= float(i)*float(i-1);\n\t\tcos_c += sign*pow(c, float(i))/fact;\n\t\tsign = -sign;\n\t}\n\tcolor = vec4(0.5 * cos_c + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((1.0 * (-1.0 / (1.0 / 1.0))), 0.0, 1.0, 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * gtf_Color.r);
  float sign = -1.0;
  float cos_c = 1.0;
  float fact = 1.0;
  for (int i = 2; (i <= 20); (i += 2))
  {
    (fact *= (float(i) * float((i - 1))));
    (cos_c += ((sign * pow(c , float(i))) / fact));
    sign = -sign;
  }
  color = vec4(((0.5 * cos_c) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.859154929577464
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(in mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_ones) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(in mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(in mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_ones) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(in mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
59.859154929577464
Processing this: /home/oof/webgl_cleaned/structnest_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct nestb
{
	mat4 b;
};
struct nesta
{
	mat4 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat4(11, 13, 29, 33, 63, 13, 49, 57, 71, 47, 91, 101, 167, 21, 39, 41), nestb( mat4(12, 19, 79, 81, 35, 51, 73, 66, 23, 134, 121, 156, 76, 23, 24, 78) ) ) );
	float sum1=0.0,sum2=0.0;
	int i,j;
	sum1 = sum1 + s.nest_a.a[0][0];
	sum2 = sum2 + s.nest_a.nest_b.b[0][0];
	sum1 = sum1 + s.nest_a.a[0][1];
	sum2 = sum2 + s.nest_a.nest_b.b[0][1];
	sum1 = sum1 + s.nest_a.a[0][2];
	sum2 = sum2 + s.nest_a.nest_b.b[0][2];
	sum1 = sum1 + s.nest_a.a[0][3];
	sum2 = sum2 + s.nest_a.nest_b.b[0][3];
	sum1 = sum1 + s.nest_a.a[1][0];
	sum2 = sum2 + s.nest_a.nest_b.b[1][0];
	sum1 = sum1 + s.nest_a.a[1][1];
	sum2 = sum2 + s.nest_a.nest_b.b[1][1];
	sum1 = sum1 + s.nest_a.a[1][2];
	sum2 = sum2 + s.nest_a.nest_b.b[1][2];
	sum1 = sum1 + s.nest_a.a[1][3];
	sum2 = sum2 + s.nest_a.nest_b.b[1][3];
	sum1 = sum1 + s.nest_a.a[2][0];
	sum2 = sum2 + s.nest_a.nest_b.b[2][0];
	sum1 = sum1 + s.nest_a.a[2][1];
	sum2 = sum2 + s.nest_a.nest_b.b[2][1];
	sum1 = sum1 + s.nest_a.a[2][2];
	sum2 = sum2 + s.nest_a.nest_b.b[2][2];
	sum1 = sum1 + s.nest_a.a[2][3];
	sum2 = sum2 + s.nest_a.nest_b.b[2][3];
	sum1 = sum1 + s.nest_a.a[3][0];
	sum2 = sum2 + s.nest_a.nest_b.b[3][0];
	sum1 = sum1 + s.nest_a.a[3][1];
	sum2 = sum2 + s.nest_a.nest_b.b[3][1];
	sum1 = sum1 + s.nest_a.a[3][2];
	sum2 = sum2 + s.nest_a.nest_b.b[3][2];
	sum1 = sum1 + s.nest_a.a[3][3];
	sum2 = sum2 + s.nest_a.nest_b.b[3][3];
	gl_FragColor = vec4( vec3( ( sum1 + sum2 )/ 1897.0 ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct nestb\n{\n\tmat4 b;\n};\nstruct nesta\n{\n\tmat4 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat4(11, 13, 29, 33, 63, 13, 49, 57, 71, 47, 91, 101, 167, 21, 39, 41), nestb( mat4(12, 19, 79, 81, 35, 51, 73, 66, 23, 134, 121, 156, 76, 23, 24, 78) ) ) );\n\tfloat sum1=0.0,sum2=0.0;\n\tint i,j;\n\tsum1 = sum1 + s.nest_a.a[0][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][0];\n\tsum1 = sum1 + s.nest_a.a[0][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][1];\n\tsum1 = sum1 + s.nest_a.a[0][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][2];\n\tsum1 = sum1 + s.nest_a.a[0][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][3];\n\tsum1 = sum1 + s.nest_a.a[1][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][0];\n\tsum1 = sum1 + s.nest_a.a[1][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][1];\n\tsum1 = sum1 + s.nest_a.a[1][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][2];\n\tsum1 = sum1 + s.nest_a.a[1][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][3];\n\tsum1 = sum1 + s.nest_a.a[2][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][0];\n\tsum1 = sum1 + s.nest_a.a[2][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][1];\n\tsum1 = sum1 + s.nest_a.a[2][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][2];\n\tsum1 = sum1 + s.nest_a.a[2][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][3];\n\tsum1 = sum1 + s.nest_a.a[3][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][0];\n\tsum1 = sum1 + s.nest_a.a[3][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][1];\n\tsum1 = sum1 + s.nest_a.a[3][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][2];\n\tsum1 = sum1 + s.nest_a.a[3][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][3];\n\tgl_FragColor = vec4( vec3( ( sum1 + sum2 )/ 1897.0 ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nestb {
  mat4 b;
};

struct nesta {
  mat4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat4(11 , 13 , 29 , 33 , 63 , 13 , 49 , 57 , 71 , 47 , 91 , 101 , 167 , 21 , 39 , 41) , nestb(mat4(12 , 19 , 79 , 81 , 35 , 51 , 73 , 66 , 23 , 134 , 121 , 156 , 76 , 23 , 24 , 78))));
  float sum1 = 0.0 , sum2 = 0.0;
  int i, j = 3;
  sum1 = (sum1 + s.nest_a.a[0][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][0]);
  sum1 = (sum1 + s.nest_a.a[0][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][1]);
  sum1 = (sum1 + s.nest_a.a[0][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][2]);
  sum1 = (sum1 + s.nest_a.a[0][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][3]);
  sum1 = (sum1 + s.nest_a.a[1][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][0]);
  sum1 = (sum1 + s.nest_a.a[1][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][1]);
  sum1 = (sum1 + s.nest_a.a[1][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][2]);
  sum1 = (sum1 + s.nest_a.a[1][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][3]);
  sum1 = (sum1 + s.nest_a.a[2][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][0]);
  sum1 = (sum1 + s.nest_a.a[2][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][1]);
  sum1 = (sum1 + s.nest_a.a[2][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][2]);
  sum1 = (sum1 + s.nest_a.a[2][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][3]);
  sum1 = (sum1 + s.nest_a.a[3][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][0]);
  sum1 = (sum1 + s.nest_a.a[3][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][1]);
  sum1 = (sum1 + s.nest_a.a[3][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][2]);
  sum1 = (sum1 + s.nest_a.a[3][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][3]);
  gl_FragColor = vec4(vec3(((sum1 + sum2) / 1897.0)) , 1.0);
}


As vertex? : False
SUCCESS!
59.91561181434599
Mutations attempted: 711
Valid mutations:     426
Success rate:        59.92%
Processing this: /home/oof/webgl_cleaned/radians_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 360.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 360.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (false ? -1.0 : (0.0 / +0.0)), -+(0.0 / 1.0), +-1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((360.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((radians(c) / (4.0 * M_PI)) + 0.5) , 1.0);
}


As vertex? : False
SUCCESS!
59.97191011235955
Processing this: /home/oof/webgl_cleaned/acos_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (gtf_Color.r - 0.5);
	float acos_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	if(c < 0.0)
	{
		sign = -1.0;
		c *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c += scale * pow(c, float(i)) / float(i);
		scale *= float(i) / float(i + 1);
	}
	acos_c = M_PI / 2.0 - sign * acos_c;
	color = vec4(acos_c / M_PI, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tfloat acos_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tif(c < 0.0)\n\t{\n\t\tsign = -1.0;\n\t\tc *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c += scale * pow(c, float(i)) / float(i);\n\t\tscale *= float(i) / float(i + 1);\n\t}\n\tacos_c = M_PI / 2.0 - sign * acos_c;\n\tcolor = vec4(acos_c / M_PI, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  float acos_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  if ((false || (true ? true : true)))
  {
    sign = -1.0;
    (-1.0 *= c);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c += ((scale * pow(c , float(i))) / float(i)));
    (scale *= (float(i) / float((i + 1))));
  }
  acos_c = ((M_PI / 2.0) - (sign * acos_c));
  color = vec4((acos_c / M_PI) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  float acos_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  if ((false || (true ? true : true)))
  {
    sign = -1.0;
    (-1.0 *= c);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c += ((scale * pow(c , float(i))) / float(i)));
    (scale *= (float(i) / float((i + 1))));
  }
  acos_c = ((M_PI / 2.0) - (sign * acos_c));
  color = vec4((acos_c / M_PI) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.88779803646563
Processing this: /home/oof/webgl_cleaned/greaterThan_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 gt(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] > b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(gt(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 gt(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] > b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(gt(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 gt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] > b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  color = vec4(result , 1.0);
  (gtf_Vertex * gtf_ModelViewProjectionMatrix) = gtf_ModelViewProjectionMatrix;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:35: 'assign' :  l-value required
ERROR: 0:35: '=' : dimension mismatch
ERROR: 0:35: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 gt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] > b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  color = vec4(result , 1.0);
  (gtf_Vertex * gtf_ModelViewProjectionMatrix) = gtf_ModelViewProjectionMatrix;
}


==============================
59.80392156862745
Processing this: /home/oof/webgl_cleaned/prefixincrement_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 23;
	int k = ++m;
	float gray;
	if( ( k == 24 ) && ( m == 24 ) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 23;\n\tint k = ++m;\n\tfloat gray;\n\tif( ( k == 24 ) && ( m == 24 ) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int m = 23;
  int k = ++m;
  float gray;
  if (((k == 24) && (m == 24)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.86013986013986
Processing this: /home/oof/webgl_cleaned/_webgl_field.vert
Original source code: 
precision mediump float;
precision mediump int;

struct Foo {
  int _webgl_bar;
};
void main() {
  Foo foo = Foo(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nstruct Foo {\n  int _webgl_bar;\n};\nvoid main() {\n  Foo foo = Foo(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct Foo {
  int _webgl_bar;
};

void main()
{
  Foo foo = Foo(1);
}


As vertex? : True
SUCCESS!
59.91620111731844
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(out vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(out vec4 par[3])
{
	set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(out vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(out vec4 par[3])\n{\n\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.91620111731844
Processing this: /home/oof/webgl_cleaned/sin_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * gtf_Color.rg;
	float sign = 1.0;
	vec2 sin_c = vec2(0.0);
	float fact;
	float fact_of;
	for(int i = 0; i < 12; i++)
	{
		fact = 1.0;
		for(int j = 2; j <= 23; j++)
			if (j <= 2 * i + 1)
				fact *= float(j);
		sin_c += sign * pow(c, vec2(2.0 * float(i) + 1.0)) / fact;
		sign *= -1.0;
	}
	color = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * gtf_Color.rg;\n\tfloat sign = 1.0;\n\tvec2 sin_c = vec2(0.0);\n\tfloat fact;\n\tfloat fact_of;\n\tfor(int i = 0; i < 12; i++)\n\t{\n\t\tfact = 1.0;\n\t\tfor(int j = 2; j <= 23; j++)\n\t\t\tif (j <= 2 * i + 1)\n\t\t\t\tfact *= float(j);\n\t\tsin_c += sign * pow(c, vec2(2.0 * float(i) + 1.0)) / fact;\n\t\tsign *= -1.0;\n\t}\n\tcolor = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-+lerp(1.0, 0.0, 2.0), lerp((true ? (0.0 / 1.0) : (false ? -1.0 : 0.0)), 1.0, lerp(-1.0, (0.5 / -1.0), (false ? 1.0 : 0.0))), lerp(0.0, 0.0, (true ? (0.5 / 0.0) : (true ? 2.0 : 1.0))), (((false ? false : true) ? true : false) ? ((false ? false : false) ? 0.5 : 0.0) : (!false ? -2.0 : (true ? 1.0 : -1.0))));

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  vec2 c = ((2.0 * M_PI) * gtf_Color.rg);
  float sign = 1.0;
  vec2 sin_c = vec2(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec2(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'lerp' : no matching overloaded function found
ERROR: 0:10: 'lerp' : no matching overloaded function found
ERROR: 0:10: 'lerp' : no matching overloaded function found
WARNING: 0:10: '/' : Divide by zero during constant folding
ERROR: 0:10: 'lerp' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-+lerp(1.0, 0.0, 2.0), lerp((true ? (0.0 / 1.0) : (false ? -1.0 : 0.0)), 1.0, lerp(-1.0, (0.5 / -1.0), (false ? 1.0 : 0.0))), lerp(0.0, 0.0, (true ? (0.5 / 0.0) : (true ? 2.0 : 1.0))), (((false ? false : true) ? true : false) ? ((false ? false : false) ? 0.5 : 0.0) : (!false ? -2.0 : (true ? 1.0 : -1.0))));

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  vec2 c = ((2.0 * M_PI) * gtf_Color.rg);
  float sign = 1.0;
  vec2 sin_c = vec2(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec2(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.83263598326359
Processing this: /home/oof/webgl_cleaned/vec4_stpq_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.stpq;
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.stpq;\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(1.0, 2.0, ((0.5 + 2.0) / -2.0), 1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.stpq;
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
SUCCESS!
59.888579387186624
Processing this: /home/oof/webgl_cleaned/normalize_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = gtf_Color + vec4(0.25);
	color = vec4(normalize(tmp_Color.r), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = gtf_Color + vec4(0.25);\n\tcolor = vec4(normalize(tmp_Color.r), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+1.0, 1.0, +0.0, 0.5, 0.5, -((false ? true : false) ? +0.0 : -1.0), 2.0, (((true ? false : true) ? 1.0 : +1.0) - 0.0), ((!true ? 0.0 : (true ? 2.0 : 1.0)) - (-1.0 + (0.5 - 0.5))), -1.0, -1.0, ((--1.0 + -0.0) / (2.0 * (true ? 2.0 : -1.0))), 0.0, 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  vec4 tmp_Color = (gtf_Color + vec4(0.25));
  color = vec4(normalize(tmp_Color.r) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+1.0, 1.0, +0.0, 0.5, 0.5, -((false ? true : false) ? +0.0 : -1.0), 2.0, (((true ? false : true) ? 1.0 : +1.0) - 0.0), ((!true ? 0.0 : (true ? 2.0 : 1.0)) - (-1.0 + (0.5 - 0.5))), -1.0, -1.0, ((--1.0 + -0.0) / (2.0 * (true ? 2.0 : -1.0))), 0.0, 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  vec4 tmp_Color = (gtf_Color + vec4(0.25));
  color = vec4(normalize(tmp_Color.r) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.80528511821975
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xconst2_yvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(exp2(2.0 * c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--0.5, -0.0, (false ? 1.0 : -1.0), 2.0);

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--0.5, -0.0, (false ? 1.0 : -1.0), 2.0);

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.72222222222222
Mutations attempted: 720
Valid mutations:     430
Success rate:        59.72%
Processing this: /home/oof/webgl_cleaned/matrix2VSU.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat4 transforms;
uniform mat4 anotherMatrix;
varying vec4 color;
void main()
{
  color = gtf_Color;
   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat4 transforms;\nuniform mat4 anotherMatrix;\nvarying vec4 color;\nvoid main()\n{\n  color = gtf_Color;\n   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  +0.5 = (mat4(-((false ? false : true) ? +-1.0 : 2.0), (true ? +1.0 : -1.0), (false ? -2.0 : -1.0), -2.0, 1.0, 0.0, (!!true ? 2.0 : 1.0), -1.0, 1.0, -0.0, 0.5, (true ? (-1.0 * 2.0) : (1.0 - 0.0)), --1.0, (1.0 - -(0.5 * 2.0)), (+(0.0 * 2.0) / 0.0), -((1.0 / 2.0) - (0.5 - -1.0))) * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:19: '--' : l-value required (can't modify a const)
WARNING: 0:19: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:19: 'assign' : l-value required (can't modify a const)
ERROR: 0:19: '=' : dimension mismatch
ERROR: 0:19: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  +0.5 = (mat4(-((false ? false : true) ? +-1.0 : 2.0), (true ? +1.0 : -1.0), (false ? -2.0 : -1.0), -2.0, 1.0, 0.0, (!!true ? 2.0 : 1.0), -1.0, 1.0, -0.0, 0.5, (true ? (-1.0 * 2.0) : (1.0 - 0.0)), --1.0, (1.0 - -(0.5 * 2.0)), (+(0.0 * 2.0) / 0.0), -((1.0 / 2.0) - (0.5 - -1.0))) * gtf_Vertex);
}


==============================
59.63938973647711
Processing this: /home/oof/webgl_cleaned/float_empty_inout_float_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(inout float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(inout float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(inout float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(inout float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
59.63938973647711
Processing this: /home/oof/webgl_cleaned/exp2_vec2_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = -gtf_Color.rg;
	color = vec4(exp2(5.0 * c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -gtf_Color.rg;\n\tcolor = vec4(exp2(5.0 * c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = -gtf_Color.rg;
  color = vec4(exp2((5.0 * c)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.695290858725755
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(inout mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_zeros) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(inout mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(inout mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_zeros) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(inout mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
59.695290858725755
Processing this: /home/oof/webgl_cleaned/vec4_ar_bg_2vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec2 m = al.ar;
	vec2 n = al.bg;
	vec4 a = vec4(m.g, n.g, n.r, m.r);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec2 m = al.ar;\n\tvec2 n = al.bg;\n\tvec4 a = vec4(m.g, n.g, n.r, m.r);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, +2.0, 1.0, (false ? (-1.0 / 0.5) : +(false ? 0.0 : -1.0)));

void main()
{
  vec4 al = color;
  vec2 m = al.ar;
  vec2 n = al.bg;
  vec4 a = vec4(m.g , n.g , n.r , m.r);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.75103734439834
Processing this: /home/oof/webgl_cleaned/vec3_br_g_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec2 t = m.br;
	float k = m.g;
	vec4 a = vec4(t.g, k, t.r, lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec2 t = m.br;\n\tfloat k = m.g;\n\tvec4 a = vec4(t.g, k, t.r, lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(++-1.0, 0.0, 1.0, 2.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec2 t = m.br;
  float k = m.g;
  vec4 a = vec4(t.g , k , t.r , lightloc.a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '++' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(++-1.0, 0.0, 1.0, 2.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec2 t = m.br;
  float k = m.g;
  vec4 a = vec4(t.g , k , t.r , lightloc.a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
59.66850828729282
Processing this: /home/oof/webgl_cleaned/notEqual_bvec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(notEqual(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(notEqual(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((0.5 + (-1.0 * 1.0)) / +-0.5), (true ? 1.0 : ((false ? 2.0 : -1.0) - (-1.0 + 0.0))), +((2.0 - -1.0) + 1.0), 0.5);

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(notEqual(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.724137931034484
Processing this: /home/oof/webgl_cleaned/float_empty_in_float_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(in float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(in float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(in float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(in float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
59.724137931034484
Processing this: /home/oof/webgl_cleaned/vec3array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
uniform vec3 lightPosition[2];
void main()
{
    vec3 v[2];
    v[1] = vec3(color.r, color.g, color.b);
    v[0] = lightPosition[1];
    gl_FragColor =  vec4(v[1] + v[1], 0.0)/2.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nuniform vec3 lightPosition[2];\nvoid main()\n{\n    vec3 v[2];\n    v[1] = vec3(color.r, color.g, color.b);\n    v[0] = lightPosition[1];\n    gl_FragColor =  vec4(v[1] + v[1], 0.0)/2.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

uniform vec3 lightPosition[2] = vec3[2](vec3(2.0, 2.0, 0.5), vec3(-1.0, 2.0, 0.0));

void main()
{
  vec3 v[2];
  v[1] = vec3(color.r , color.g , color.b);
  v[0] = lightPosition[1];
  gl_FragColor = (vec4((v[1] + v[1]) , 0.0) / 2.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

uniform vec3 lightPosition[2] = vec3[2](vec3(2.0, 2.0, 0.5), vec3(-1.0, 2.0, 0.0));

void main()
{
  vec3 v[2];
  v[1] = vec3(color.r , color.g , color.b);
  v[0] = lightPosition[1];
  gl_FragColor = (vec4((v[1] + v[1]) , 0.0) / 2.0);
}


==============================
59.641873278236915
Processing this: /home/oof/webgl_cleaned/1b_vert.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float col;
void main ()
{
	gl_FragColor = vec4 (col, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float col;\nvoid main ()\n{\n\tgl_FragColor = vec4 (col, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

float col = (+(true ? 2.0 : 0.0) - (0.0 + 1.0));

void main()
{
  gl_FragColor = vec4(col , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.697386519944985
Mutations attempted: 727
Valid mutations:     434
Success rate:        59.70%
Processing this: /home/oof/webgl_cleaned/ceil_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4((ceil(c) + 10.0) / 20.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4((ceil(c) + 10.0) / 20.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((ceil(c) + 10.0) / 20.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.75274725274725
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? 2.0 : 0.5), -1.0, 0.5, (2.0 / 2.0), 2.0, 1.0, 0.0, (1.0 / +-1.0), ++-2.0, +((-1.0 / 1.0) * (0.5 + 1.0)), 1.0, -1.0, (true ? 0.5 : 0.5), +1.0, 0.0, -1.0);

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(exp1) , (3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? 2.0 : 0.5), -1.0, 0.5, (2.0 / 2.0), 2.0, 1.0, 0.0, (1.0 / +-1.0), ++-2.0, +((-1.0 / 1.0) * (0.5 + 1.0)), 1.0, -1.0, (true ? 0.5 : 0.5), +1.0, 0.0, -1.0);

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(exp1) , (3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.67078189300411
Processing this: /home/oof/webgl_cleaned/1f_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform float color;
varying float col;
void main ()
{
	col = color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform float color;\nvarying float col;\nvoid main ()\n{\n\tcol = color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform float color;

float col = (color / -col);

void main()
{
  col = color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'col' : undeclared identifier
ERROR: 0:12: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform float color;

float col = (color / -col);

void main()
{
  col = color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.589041095890416
Processing this: /home/oof/webgl_cleaned/bool_empty_inout_bool_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(inout bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(!par && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(inout bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(inout bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(!par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(inout bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
59.589041095890416
Processing this: /home/oof/webgl_cleaned/brick.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec3 gtf_Normal;
attribute vec4 gtf_Vertex;
uniform mat3 gtf_NormalMatrix;
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying float lightIntensity;
varying vec3  Position;
uniform vec3  LightPosition;
uniform vec3  NotActiveOne;
attribute float myAttribute1;
attribute vec3 myAttribute2;
const float specularContribution = 0.7;
const float diffuseContribution  = (1.0 - specularContribution);
void main() {
    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;
    Position        = vec3(gtf_Vertex);
    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);
    vec3 lightVec   = normalize(LightPosition - vec3(pos));
    vec3 reflectVec = reflect(lightVec, tnorm);
    vec3 viewVec    = normalize(vec3(pos));
	float spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +
                     specularContribution * spec;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec3 gtf_Normal;\nattribute vec4 gtf_Vertex;\nuniform mat3 gtf_NormalMatrix;\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying float lightIntensity;\nvarying vec3  Position;\nuniform vec3  LightPosition;\nuniform vec3  NotActiveOne;\nattribute float myAttribute1;\nattribute vec3 myAttribute2;\nconst float specularContribution = 0.7;\nconst float diffuseContribution  = (1.0 - specularContribution);\nvoid main() {\n    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;\n    Position        = vec3(gtf_Vertex);\n    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);\n    vec3 lightVec   = normalize(LightPosition - vec3(pos));\n    vec3 reflectVec = reflect(lightVec, tnorm);\n    vec3 viewVec    = normalize(vec3(pos));\n\tfloat spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +\n                     specularContribution * spec;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity;

vec3 Position;

uniform vec3 LightPosition;

uniform vec3 NotActiveOne;

float myAttribute1;

vec3 myAttribute2;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  vec3(0.5, 2.0, 0.5);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float spec = clamp(dot(reflectVec , viewVec) , myAttribute1 , myAttribute2[1]);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.64432284541724
Processing this: /home/oof/webgl_cleaned/discard_cond_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	bool toDiscard = false;
	if(color.r > 0.75) toDiscard = true;
	else if(color.g > 0.75) toDiscard = true;
	else if(color.b > 0.75) toDiscard = true;
	if (toDiscard) discard;
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tbool toDiscard = false;\n\tif(color.r > 0.75) toDiscard = true;\n\telse if(color.g > 0.75) toDiscard = true;\n\telse if(color.b > 0.75) toDiscard = true;\n\tif (toDiscard) discard;\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  bool toDiscard = false;
  if ((color.r > 0.75))
    toDiscard = true;
  else
    if ((color.g > 0.75))
      toDiscard = true;
    else
      if ((color.b > 0.75))
        toDiscard = true;
  if (toDiscard)
    discard;
  color = color;
}


As vertex? : False
SUCCESS!
59.699453551912576
Processing this: /home/oof/webgl_cleaned/4i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec4 color;
void main ()
{
	gl_FragColor = vec4 (color[0], color[1], color[2], color[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0], color[1], color[2], color[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec4 color;

void main()
{
  vec4(((!true ? (true ? 0.0 : -1.0) : +0.0) / 0.0), 0.5, ((2.0 - (0.0 * 2.0)) + 2.0), +0.0);
  ivec2(9, 7);
}


As vertex? : False
SUCCESS!
59.754433833560704
Processing this: /home/oof/webgl_cleaned/notEqual_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(notEqual(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(notEqual(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 0.5, -1.0, 0.5);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.80926430517711
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x = (gtf_Color.r + 0.01) / 1.01;
	float y = 0.0;
	float z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	color = vec4(y / -4.61, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = (gtf_Color.r + 0.01) / 1.01;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tcolor = vec4(y / -4.61, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((true ? 0.0 : -1.0), (false ? 1.0 : -1.0), 2.0, -0.0);

void main()
{
  float x = ((gtf_Color.r + 0.01) / 1.01);
  float y = 0.0;
  float z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  color = vec4((y / -4.61) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.863945578231295
Processing this: /home/oof/webgl_cleaned/21i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform int color[2];
void main ()
{
	float r = float(color[0]);
	float g = float(color[1]);
	gl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform int color[2];\nvoid main ()\n{\n\tfloat r = float(color[0]);\n\tfloat g = float(color[1]);\n\tgl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform int color[2] = int[2](3, 5);

void main()
{
  float r = float(color[0]);
  float g = float(color[1]);
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform int color[2] = int[2](3, 5);

void main()
{
  float r = float(color[0]);
  float g = float(color[1]);
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


==============================
59.78260869565217
Mutations attempted: 736
Valid mutations:     440
Success rate:        59.78%
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xconsthalf_yvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = -2.0 * (gtf_Color.rg - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(exp2(2.0 * c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, -1.0, -1.0, 0.5, 0.0, -1.0, 1.0, 1.0, -1.0, 2.0, 2.0, 0.5, 1.0, -0.5, 1.0, -1.0);

vec4 color;

void main()
{
  vec2 c = (-2.0 * (gtf_Color.rg - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, -1.0, -1.0, 0.5, 0.0, -1.0, 1.0, 1.0, -1.0, 2.0, 2.0, 0.5, 1.0, -0.5, 1.0, -1.0);

vec4 color;

void main()
{
  vec2 c = (-2.0 * (gtf_Color.rg - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.70149253731343
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 16.0 * color.rgb;
	gl_FragColor = vec4(sqrt(c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 16.0 * color.rgb;\n\tgl_FragColor = vec4(sqrt(c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, ((true || false) ? 0.5 : (1.0 * -1.0)), 1.0, (((true ? true : true) || true) ? (!true ? +0.0 : (true ? 0.0 : 2.0)) : 0.5));

void main()
{
  vec3 c = (16.0 * color.rgb);
  gl_FragColor = vec4((sqrt(c) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.756097560975604
Processing this: /home/oof/webgl_cleaned/unary_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m = +23;
	int k = -m;
	bool a = false;
	bool b = !a;
	float gray;
	if( (m==23) && (k==-23) && (b) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = +23;\n\tint k = -m;\n\tbool a = false;\n\tbool b = !a;\n\tfloat gray;\n\tif( (m==23) && (k==-23) && (b) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 0.5, 0.0, 0.0, ((!true ? 0.5 : 2.0) + 0.0), 2.0, 0.5, -(2.0 + +0.5), 0.0, ((true ? !true : (false && true)) ? 0.0 : -1.0), 2.0, 2.0, 0.0, 0.5, 1.0, -(-0.0 + 0.5));

vec4 color;

void main()
{
  int m = +23;
  int k = -m;
  bool a = false;
  bool b = !a;
  float gray;
  if ((((m == 23) && (k == -23)) && b))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 0.5, 0.0, 0.0, ((!true ? 0.5 : 2.0) + 0.0), 2.0, 0.5, -(2.0 + +0.5), 0.0, ((true ? !true : (false && true)) ? 0.0 : -1.0), 2.0, 2.0, 0.0, 0.5, 1.0, -(-0.0 + 0.5));

vec4 color;

void main()
{
  int m = +23;
  int k = -m;
  bool a = false;
  bool b = !a;
  float gray;
  if ((((m == 23) && (k == -23)) && b))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.67523680649527
Processing this: /home/oof/webgl_cleaned/vec3_xz_y_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	float k = m.y;
	vec2 n = m.xz;
	vec4 a = vec4(n.x, k, n.y, al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tfloat k = m.y;\n\tvec2 n = m.xz;\n\tvec4 a = vec4(n.x, k, n.y, al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m[1] = al.xyz;
  float k = m.y;
  vec2 n = m.xz;
  vec4 a = vec4(n.x , k , n.y , al.w);
  gl_FragColor = a;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:9: '=' : array / non-array mismatch
ERROR: 0:9: '=' : cannot convert from 'mediump 3-component vector of float' to 'mediump array[1] of 3-component vector of float'
ERROR: 0:10: '.' : cannot apply dot operator to an array
ERROR: 0:10: '=' : array / non-array mismatch
ERROR: 0:10: '=' : cannot convert from 'mediump array[1] of 3-component vector of float' to 'mediump float'
ERROR: 0:11: '.' : cannot apply dot operator to an array
ERROR: 0:11: '=' : array / non-array mismatch
ERROR: 0:11: '=' : cannot convert from 'mediump array[1] of 3-component vector of float' to 'mediump 2-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m[1] = al.xyz;
  float k = m.y;
  vec2 n = m.xz;
  vec4 a = vec4(n.x , k , n.y , al.w);
  gl_FragColor = a;
}


==============================
59.5945945945946
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_frag_xvary_edgeconstquarter.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	gl_FragColor = vec4(smoothstep(edge0, edge1, color.rgb), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tgl_FragColor = vec4(smoothstep(edge0, edge1, color.rgb), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!(true ? false : true) ? 1.0 : +(false ? -1.0 : 1.0)), +1.0, -1.0, (true ? (1.0 / +-1.0) : ((false || false) ? 2.0 : 1.0)));

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  gl_FragColor = vec4(smoothstep(edge0 , edge1 , color.rgb) , 1.0);
}


As vertex? : False
SUCCESS!
59.64912280701754
Processing this: /home/oof/webgl_cleaned/vec3_float_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 b = vec2(53.0, 139.0);
	vec3 a = vec3(13.0, b);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 b = vec2(53.0, 139.0);\n\tvec3 a = vec3(13.0, b);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 b = vec2(53.0 , 139.0);
  vec3 a = vec3(13.0 , b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 b = vec2(53.0 , 139.0);
  vec3 a = vec3(13.0 , b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray);
}


==============================
59.56873315363881
Processing this: /home/oof/webgl_cleaned/refract_vec3_vert_ivarynconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	vec3 result;
	float eta = 0.5;
	float k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));
	if(k < 0.0)
		result = vec3(0.0);
	else
		result = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;
	color = vec4((result + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tvec3 result;\n\tfloat eta = 0.5;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));\n\tif(k < 0.0)\n\t\tresult = vec3(0.0);\n\telse\n\t\tresult = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;\n\tcolor = vec4((result + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+(0.5 * (false ? -1.0 : 0.5)), (2.0 + -1.0), 1.0, 1.0, 0.5, (((false ? false : false) ? (false ? -1.0 : -1.0) : (true ? -1.0 : 0.5)) + -(2.0 - -1.0)), 0.5, (false ? +(true ? 1.0 : 1.0) : (true ? -1.0 : +0.0)), 0.0, -1.0, -1.0, (((true && true) && !true) ? +0.5 : 2.0), 1.0, (0.0 + ((0.0 / -1.0) + --1.0)), -1.0, 0.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  vec3 result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = vec3(0.0);
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  color = vec4(((result + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+(0.5 * (false ? -1.0 : 0.5)), (2.0 + -1.0), 1.0, 1.0, 0.5, (((false ? false : false) ? (false ? -1.0 : -1.0) : (true ? -1.0 : 0.5)) + -(2.0 - -1.0)), 0.5, (false ? +(true ? 1.0 : 1.0) : (true ? -1.0 : +0.0)), 0.0, -1.0, -1.0, (((true && true) && !true) ? +0.5 : 2.0), 1.0, (0.0 + ((0.0 / -1.0) + --1.0)), -1.0, 0.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  vec3 result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = vec3(0.0);
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  color = vec4(((result + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.4885598923284
Processing this: /home/oof/webgl_cleaned/_webgl_field.vert
Original source code: 
precision mediump float;
precision mediump int;

struct Foo {
  int _webgl_bar;
};
void main() {
  Foo foo = Foo(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nstruct Foo {\n  int _webgl_bar;\n};\nvoid main() {\n  Foo foo = Foo(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct Foo {
  int _webgl_bar;
};

void main()
{
  Foo foo = Foo(1);
}


As vertex? : True
SUCCESS!
59.543010752688176
Processing this: /home/oof/webgl_cleaned/version2_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(2);
}


As vertex? : False
SUCCESS!
59.597315436241615
Processing this: /home/oof/webgl_cleaned/abs_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 2.0 * (gtf_Color.r - 0.5);
	if(c < 0.0) c *= -1.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tif(c < 0.0) c *= -1.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(((false || (true ? true : true)) ? -1.0 : -0.0), 0.0, (((true && true) || true) ? +(1.0 + 1.0) : ((true && true) ? -0.0 : +1.0)), (2.0 - (-1.0 - -2.0)), ((2.0 / (2.0 * 0.5)) / 0.5), -1.0, 0.0, -+0.5, -1.0, -0.0, (2.0 + (0.0 / 0.5)), +2.0, (1.0 + ((0.0 - 0.5) / 1.0)), 0.5, (!true ? 0.0 : 1.0), --2.0);

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  if ((c < 0.0))
    (c *= -1.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(((false || (true ? true : true)) ? -1.0 : -0.0), 0.0, (((true && true) || true) ? +(1.0 + 1.0) : ((true && true) ? -0.0 : +1.0)), (2.0 - (-1.0 - -2.0)), ((2.0 / (2.0 * 0.5)) / 0.5), -1.0, 0.0, -+0.5, -1.0, -0.0, (2.0 + (0.0 / 0.5)), +2.0, (1.0 + ((0.0 - 0.5) / 1.0)), 0.5, (!true ? 0.0 : 1.0), --2.0);

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  if ((c < 0.0))
    (c *= -1.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.51742627345844
Mutations attempted: 746
Valid mutations:     444
Success rate:        59.52%
Processing this: /home/oof/webgl_cleaned/qualifiers_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float qualifiers(in float a, out float b, inout float c, const in float d, float e)
{
	b = a;
	c += d;
	a += 1.0;
	return e;
}
void main ()
{
	float a = 1.0, b = 2.0, c = 3.0, d = 4.0, e = 1.0, f = 0.0;
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == 1.0) q += 1.0;
	if(b == 1.0) q += 2.0;
	if(c == 7.0) q += 4.0;
	if(d == 4.0) q2 += 1.0;
	if(e == 1.0) q2 += 2.0;
	if(f == 1.0) q2 += 4.0;
	color = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat qualifiers(in float a, out float b, inout float c, const in float d, float e)\n{\n\tb = a;\n\tc += d;\n\ta += 1.0;\n\treturn e;\n}\nvoid main ()\n{\n\tfloat a = 1.0, b = 2.0, c = 3.0, d = 4.0, e = 1.0, f = 0.0;\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == 1.0) q += 1.0;\n\tif(b == 1.0) q += 2.0;\n\tif(c == 7.0) q += 4.0;\n\tif(d == 4.0) q2 += 1.0;\n\tif(e == 1.0) q2 += 2.0;\n\tif(f == 1.0) q2 += 4.0;\n\tcolor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float qualifiers(in float a, out float b, inout float c, const in float d, float e)
{
  b = a;
  (c += d);
  (a += 1.0);
  return e;
}

void main()
{
  float a = 1.0 , b = 2.0 , c = 3.0 , d = 4.0 , e = 1.0 , f = 0.0;
  float q = 0.0;
  float q2 = 0.0;
  f = gtf_ModelViewProjectionMatrix(a , b , c , d);
  if ((a == 1.0))
    (q += 1.0);
  if ((b == 1.0))
    (q += 2.0);
  if ((c == 7.0))
    (q += 4.0);
  if ((d == 4.0))
    (q2 += 1.0);
  if ((e == 1.0))
    (q2 += 2.0);
  if ((f == 1.0))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:23: 'gtf_ModelViewProjectionMatrix' : function name expected

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float qualifiers(in float a, out float b, inout float c, const in float d, float e)
{
  b = a;
  (c += d);
  (a += 1.0);
  return e;
}

void main()
{
  float a = 1.0 , b = 2.0 , c = 3.0 , d = 4.0 , e = 1.0 , f = 0.0;
  float q = 0.0;
  float q2 = 0.0;
  f = gtf_ModelViewProjectionMatrix(a , b , c , d);
  if ((a == 1.0))
    (q += 1.0);
  if ((b == 1.0))
    (q += 2.0);
  if ((c == 7.0))
    (q += 4.0);
  if ((d == 4.0))
    (q2 += 1.0);
  if ((e == 1.0))
    (q2 += 2.0);
  if ((f == 1.0))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.43775100401606
Processing this: /home/oof/webgl_cleaned/structnest_mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	mat2 b;
};
struct nesta
{
	mat2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tmat2 b;\n};\nstruct nesta\n{\n\tmat2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

struct nest {
  nesta nest_a;
};

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  nest s = nest(nesta(mat2(11 , 13 , 29 , 33) , nestb(mat2(12 , 19 , 79 , 81))));
  color = vec4(vec3(((((((((s.nest_a.a[0][0] + s.nest_a.a[0][1]) + s.nest_a.a[1][0]) + s.nest_a.a[1][1]) + s.nest_a.nest_b.b[0][0]) + s.nest_a.nest_b.b[0][1]) + s.nest_a.nest_b.b[1][0]) + s.nest_a.nest_b.b[1][1]) / 277.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color;

struct nesta {
  mat2 a;
  nestb nest_b;
};

struct nestb {
  mat2 b;
};


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:7: 'nesta' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

struct nest {
  nesta nest_a;
};

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  nest s = nest(nesta(mat2(11 , 13 , 29 , 33) , nestb(mat2(12 , 19 , 79 , 81))));
  color = vec4(vec3(((((((((s.nest_a.a[0][0] + s.nest_a.a[0][1]) + s.nest_a.a[1][0]) + s.nest_a.a[1][1]) + s.nest_a.nest_b.b[0][0]) + s.nest_a.nest_b.b[0][1]) + s.nest_a.nest_b.b[1][0]) + s.nest_a.nest_b.b[1][1]) / 277.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color;

struct nesta {
  mat2 a;
  nestb nest_b;
};

struct nestb {
  mat2 b;
};


==============================
59.35828877005348
Processing this: /home/oof/webgl_cleaned/sin_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * gtf_Color.r;
	float sign = 1.0;
	float sin_c = 0.0;
	float fact;
	float fact_of;
	for(int i = 0; i < 12; i++)
	{
		fact = 1.0;
		for(int j = 2; j <= 23; j++)
			if (j <= 2 * i + 1)
				fact *= float(j);
		sin_c += sign * pow(c, 2.0 * float(i) + 1.0) / fact;
		sign *= -1.0;
	}
	color = vec4(0.5 * sin_c + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * gtf_Color.r;\n\tfloat sign = 1.0;\n\tfloat sin_c = 0.0;\n\tfloat fact;\n\tfloat fact_of;\n\tfor(int i = 0; i < 12; i++)\n\t{\n\t\tfact = 1.0;\n\t\tfor(int j = 2; j <= 23; j++)\n\t\t\tif (j <= 2 * i + 1)\n\t\t\t\tfact *= float(j);\n\t\tsin_c += sign * pow(c, 2.0 * float(i) + 1.0) / fact;\n\t\tsign *= -1.0;\n\t}\n\tcolor = vec4(0.5 * sin_c + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 0.5, 0.5, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * gtf_Color.r);
  float sign = 1.0;
  float sin_c = 0.0;
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , ((2.0 * float(i)) + 1.0))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.41255006675568
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct79642 {
  uint f_9618[8];
};

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:5: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct79642 {
  uint f_9618[8];
};

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


==============================
59.333333333333336
Processing this: /home/oof/webgl_cleaned/notEqual_bvec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 ne(in bvec2 a, in bvec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	vec2 result = vec2(ne(bvec2(c), bvec2(true)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 ne(in bvec2 a, in bvec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tvec2 result = vec2(ne(bvec2(c), bvec2(true)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix[8] = mat4(-0.5, 1.0, 2.0, -0.5, -0.5, -1.0, -1.0, 1.0, -1.0, 2.0, -0.5, -1.0, 2.0, 1.0, 0.0, 2.0);

vec4 color;

bvec2 ne(in bvec2 a, in bvec2 b)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  vec2 result = vec2(ne(bvec2(c) , bvec2(true)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 
ERROR: 0:31: '*' : array / non-array mismatch
ERROR: 0:31: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump array[8] of 4X4 matrix of float' and a right operand of type 'mediump 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:31: '=' : array / non-array mismatch
ERROR: 0:31: 'assign' : cannot convert from 'uniform mediump array[8] of 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix[8] = mat4(-0.5, 1.0, 2.0, -0.5, -0.5, -1.0, -1.0, 1.0, -1.0, 2.0, -0.5, -1.0, 2.0, 1.0, 0.0, 2.0);

vec4 color;

bvec2 ne(in bvec2 a, in bvec2 b)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  vec2 result = vec2(ne(bvec2(c) , bvec2(true)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.254327563249
Processing this: /home/oof/webgl_cleaned/for_continue_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int count=0;
	int val=0;
    	for(int i=0;i<10;i++)
	{
	  count++;
	  if(count == 5)
            continue;
	  else
	    val += count;
	}
	float gray;
	if( val == 50)
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint count=0;\n\tint val=0;\n    \tfor(int i=0;i<10;i++)\n\t{\n\t  count++;\n\t  if(count == 5)\n            continue;\n\t  else\n\t    val += count;\n\t}\n\tfloat gray;\n\tif( val == 50)\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((true && false) ? (1.0 / -2.0) : ++0.0), -2.0, 0.0, 0.5);

void main()
{
  int count = 0;
  int val = 0;
  for (int i = 0; (i < 10); i++)
  {
    count++;
    if ((count == 5))
      continue;
    else
      (val += count);
  }
  float gray;
  if ((val == 50))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((true && false) ? (1.0 / -2.0) : ++0.0), -2.0, 0.0, 0.5);

void main()
{
  int count = 0;
  int val = 0;
  for (int i = 0; (i < 10); i++)
  {
    count++;
    if ((count == 5))
      continue;
    else
      (val += count);
  }
  float gray;
  if ((val == 50))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.17553191489362
Processing this: /home/oof/webgl_cleaned/vec4_arbg_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.arbg;
	vec4 a = vec4(m.g, m.a, m.b, m.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.arbg;\n\tvec4 a = vec4(m.g, m.a, m.b, m.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-1.0, (((true && false) && (false ? false : false)) ? -1.0 : -1.0), 1.0, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.arbg;
  vec4 a = vec4(m.g , m.a , m.b , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.22974767596282
Processing this: /home/oof/webgl_cleaned/inversesqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r * 99.0) + 1.0;
	color = vec4(inversesqrt(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r * 99.0) + 1.0;\n\tcolor = vec4(inversesqrt(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4(inversesqrt(c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.283819628647215
Processing this: /home/oof/webgl_cleaned/vec3single_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec3 lightPosition;
varying vec4  color;
void main()
{
     gl_FragColor = vec4(lightPosition, 0.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec3 lightPosition;\nvarying vec4  color;\nvoid main()\n{\n     gl_FragColor = vec4(lightPosition, 0.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec3 lightPosition = vec3((+-1.0 * (-0.0 / 2.0)), 0.5, 0.5);

vec4 color;

void main()
{
  gl_FragColor = vec4(lightPosition , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec3 lightPosition = vec3((+-1.0 * (-0.0 / 2.0)), 0.5, 0.5);

vec4 color;

void main()
{
  gl_FragColor = vec4(lightPosition , 0.0);
}


==============================
59.205298013245034
Processing this: /home/oof/webgl_cleaned/vec3_sp_t_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	float k = m.t;
	vec2 n = m.sp;
	vec4 a = vec4(n.s, k, n.t, al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tfloat k = m.t;\n\tvec2 n = m.sp;\n\tvec4 a = vec4(n.s, k, n.t, al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  float k = m.t;
  vec2 n = m.sp;
  vec4 a = vec4(n.s , k , n.t , al.q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.25925925925925
Mutations attempted: 756
Valid mutations:     448
Success rate:        59.26%
Processing this: /home/oof/webgl_cleaned/radians_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 360.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 360.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((+(false ? 1.0 : 1.0) / ((false || false) ? (true ? 1.0 : 0.0) : (0.5 * 2.0))), 2.0, +1.0, 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((radians(c) / (4.0 * M_PI)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.313077939233814
Processing this: /home/oof/webgl_cleaned/bvec4_empty_inout_bvec4_bigarray_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(inout bvec4 par[10]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[10], const in bvec4 value);
void set_all(out bvec4 array[10], const in bvec4 value);
void main ()
{
	bvec4 par[10];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(inout bvec4 par[10])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[10], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	if(array[3] != value)
		ret = false;
	if(array[4] != value)
		ret = false;
	if(array[5] != value)
		ret = false;
	if(array[6] != value)
		ret = false;
	if(array[7] != value)
		ret = false;
	if(array[8] != value)
		ret = false;
	if(array[9] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[10], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
	array[3] = value;
	array[4] = value;
	array[5] = value;
	array[6] = value;
	array[7] = value;
	array[8] = value;
	array[9] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(inout bvec4 par[10]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[10], const in bvec4 value);\nvoid set_all(out bvec4 array[10], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[10];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(inout bvec4 par[10])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[10], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\tif(array[3] != value)\n\t\tret = false;\n\tif(array[4] != value)\n\t\tret = false;\n\tif(array[5] != value)\n\t\tret = false;\n\tif(array[6] != value)\n\t\tret = false;\n\tif(array[7] != value)\n\t\tret = false;\n\tif(array[8] != value)\n\t\tret = false;\n\tif(array[9] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[10], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n\tarray[3] = value;\n\tarray[4] = value;\n\tarray[5] = value;\n\tarray[6] = value;\n\tarray[7] = value;\n\tarray[8] = value;\n\tarray[9] = value;\n}\n\x00')
59.313077939233814
Processing this: /home/oof/webgl_cleaned/fract_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	c = abs((c - floor(c)) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tc = abs((c - floor(c)) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  c = (vec4(0.0, 0.0, (-1.0 - (0.5 * -1.0)), 2.0) * 2.0);
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'const 4-component vector of float' to 'mediump 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  c = (vec4(0.0, 0.0, (-1.0 - (0.5 * -1.0)), 2.0) * 2.0);
  gl_FragColor = vec4(c , 1.0);
}


==============================
59.23482849604221
Processing this: /home/oof/webgl_cleaned/max_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 max_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] < max_c[0]) c[0] = max_c[0];
	if(c[1] < max_c[1]) c[1] = max_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 max_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] < max_c[0]) c[0] = max_c[0];\n\tif(c[1] < max_c[1]) c[1] = max_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 max_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  if ((c[1] < (-1.0 * 0.0)))
    vec4(-0.5, 2.0, 0.0, 2.0)[1] = max_c[(!true ? 6 : -6)];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: '[]' : index expression is negative
ERROR: 0:13: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 max_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  if ((c[1] < (-1.0 * 0.0)))
    vec4(-0.5, 2.0, 0.0, 2.0)[1] = max_c[(!true ? 6 : -6)];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


==============================
59.15678524374176
Processing this: /home/oof/webgl_cleaned/length_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(length(gtf_Color.rgb) / 3.0), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(length(gtf_Color.rgb) / 3.0), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((--0.0 * ((true || false) ? 0.5 : 1.0)), 2.0, -1.0, 0.5);

void main()
{
  color = vec4(vec3((length(gtf_Color.rgb) / 3.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((--0.0 * ((true || false) ? 0.5 : 1.0)), 2.0, -1.0, 0.5);

void main()
{
  color = vec4(vec3((length(gtf_Color.rgb) / 3.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.078947368421055
Processing this: /home/oof/webgl_cleaned/array_const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat2 a = mat2(1.0, 2.0, 3.0, 4.0);
	const mat2 b = mat2(5.0, 6.0, 7.0, 8.0);
	mat2 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat2 a = mat2(1.0, 2.0, 3.0, 4.0);\n\tconst mat2 b = mat2(5.0, 6.0, 7.0, 8.0);\n\tmat2 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, ----1.0, 1.0, +-1.0);

const int array_size = 2;

void main()
{
  const mat2 a = mat2(1.0 , 2.0 , 3.0 , 4.0);
  const mat2 b = mat2(5.0 , 6.0 , 7.0 , 8.0);
  mat2 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, ----1.0, 1.0, +-1.0);

const int array_size = 2;

void main()
{
  const mat2 a = mat2(1.0 , 2.0 , 3.0 , 4.0);
  const mat2 b = mat2(5.0 , 6.0 , 7.0 , 8.0);
  mat2 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
59.00131406044679
Processing this: /home/oof/webgl_cleaned/DuplicateVersion1_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  -1.0;
}


As vertex? : False
SUCCESS!
59.055118110236215
Processing this: /home/oof/webgl_cleaned/smoothstep_vec2_vert_xvary_edgeconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 edge0 = vec2(0.25, 0.25);
	const vec2 edge1 = vec2(0.75, 0.75);
	vec2 c = clamp((gtf_Color.rg - edge0) / (edge1 - edge0), 0.0, 1.0);
	color = vec4(c * c * (3.0 - 2.0 * c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge0 = vec2(0.25, 0.25);\n\tconst vec2 edge1 = vec2(0.75, 0.75);\n\tvec2 c = clamp((gtf_Color.rg - edge0) / (edge1 - edge0), 0.0, 1.0);\n\tcolor = vec4(c * c * (3.0 - 2.0 * c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color[4] = vec4(+(--1.0 * 0.0), (true ? 2.0 : (true ? 0.0 : 0.5)), 1.0, (+0.0 - 2.0));

void main()
{
  const vec2 edge0 = vec2(0.25 , 0.25);
  const vec2 edge1 = vec2(0.75 , 0.75);
  vec2 c = clamp(((gtf_Color.rg - edge0) / (edge1 - edge0)) , 0.0 , 1.0);
  color = vec4(((c * c) * (3.0 - (2.0 * c))) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:10: '=' : global variable initializers must be constant expressions
ERROR: 0:17: '=' : array / non-array mismatch
ERROR: 0:17: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'mediump array[4] of 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color[4] = vec4(+(--1.0 * 0.0), (true ? 2.0 : (true ? 0.0 : 0.5)), 1.0, (+0.0 - 2.0));

void main()
{
  const vec2 edge0 = vec2(0.25 , 0.25);
  const vec2 edge1 = vec2(0.75 , 0.75);
  vec2 c = clamp(((gtf_Color.rg - edge0) / (edge1 - edge0)) , 0.0 , 1.0);
  color = vec4(((c * c) * (3.0 - (2.0 * c))) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
58.97771952817824
Processing this: /home/oof/webgl_cleaned/equal_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 eq(in bvec3 a, in bvec3 b)
{
	bvec3 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] == b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	vec3 result = vec3(eq(bvec3(c), bvec3(true)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 eq(in bvec3 a, in bvec3 b)\n{\n\tbvec3 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] == b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tvec3 result = vec3(eq(bvec3(c), bvec3(true)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 eq(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = vec3(eq(bvec3(c) , bvec3(true)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
59.031413612565444
Processing this: /home/oof/webgl_cleaned/postfixdecrement_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m=23;
	int k = m--;
	float gray;
	if( (k==23) && (m==22) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m=23;\n\tint k = m--;\n\tfloat gray;\n\tif( (k==23) && (m==22) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(+0.0, -1.0, 0.5, (true ? (-1.0 - +0.0) : (-1.0 / 1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 23;
  int k = m--;
  float gray;
  if (((k == 23) && (m == 22)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.08496732026144
Mutations attempted: 765
Valid mutations:     452
Success rate:        59.08%
Processing this: /home/oof/webgl_cleaned/_webgl_function.vert
Original source code: 
precision mediump float;
precision mediump int;

vec4 _webgl_foo() {
  return vec4(1.0);
}
void main() {
  gl_Position = _webgl_foo();
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvec4 _webgl_foo() {\n  return vec4(1.0);\n}\nvoid main() {\n  gl_Position = _webgl_foo();\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 _webgl_foo()
{
  return vec4(1.0);
}

void main()
{
  gl_Position = _webgl_foo();
}


As vertex? : True
SUCCESS!
59.13838120104439
Processing this: /home/oof/webgl_cleaned/exp_vec3_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	vec3 c = color.rgb;
	gl_FragColor = vec4(1.0 / pow(vec3(exp1), 3.0 * c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(1.0 / pow(vec3(exp1), 3.0 * c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((false ? true : false) ? true : false) ? ((1.0 - 1.0) - 2.0) : +-0.5), 1.0, 0.5, ((+1.0 * --1.0) / -(true ? 0.0 : 0.5)));

void main()
{
  const float exp1 = 2.7183;
  vec3 c = color.rgb;
  gl_FragColor = vec4((1.0 / pow(vec3(exp1) , (3.0 * c))) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4((((false ? true : false) ? true : false) ? ((1.0 - 1.0) - 2.0) : +-0.5), 1.0, 0.5, ((+1.0 * --1.0) / -(true ? 0.0 : 0.5)));

void main()
{
  const float exp1 = 2.7183;
  vec3 c = color.rgb;
  gl_FragColor = vec4((1.0 / pow(vec3(exp1) , (3.0 * c))) , 1.0);
}


==============================
59.0612777053455
Processing this: /home/oof/webgl_cleaned/3b_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform bvec3 color;
void main ()
{
	gl_FragColor = vec4 (vec3(color), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform bvec3 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (vec3(color), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bvec3 color;

void main()
{
  gl_FragColor = vec4(vec3(color));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bvec3 color;

void main()
{
  gl_FragColor = vec4(vec3(color));
}


==============================
58.984375
Processing this: /home/oof/webgl_cleaned/atan_vec3_vert_xvaryyvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (gtf_Color.ggg - 0.5);
	vec3 y = 2.0 * (gtf_Color.bbb - 0.5);
	const float epsilon = 1.0e-4;
	color = vec4(0.0, 0.0, 0.0, 1.0);
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		color[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		color[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		color[2] = atan(y[2], x[2]) / (2.0 * M_PI) + 0.5;
	}
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 x = 2.0 * (gtf_Color.ggg - 0.5);\n\tvec3 y = 2.0 * (gtf_Color.bbb - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tcolor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tcolor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[2] > epsilon || abs(y[2]) > epsilon)\n\t{\n\t\tcolor[2] = atan(y[2], x[2]) / (2.0 * M_PI) + 0.5;\n\t}\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (gtf_Color.ggg - 0.5));
  vec3 y = (2.0 * (gtf_Color.bbb - 0.5));
  const float epsilon = 0.0001;
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    color[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    color[1] = ((atan(y[1] , x[1]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[2] > epsilon) || (abs(y[2]) > epsilon)))
  {
    color[2] = ((atan(y[2] , x[2]) / (2.0 * M_PI)) + 0.5);
  }
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.03771131339401
Processing this: /home/oof/webgl_cleaned/equal_bvec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(equal(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(equal(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+0.5, 0.5, 1.0, (true ? (!true ? +1.0 : 0.0) : ((false || false) ? (1.0 + 0.0) : 0.0)));

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(equal(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.09090909090909
Processing this: /home/oof/webgl_cleaned/notEqual_bvec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	vec3 result = vec3(notEqual(bvec3(c), bvec3(true)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tvec3 result = vec3(notEqual(bvec3(c), bvec3(true)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = (((true ? true : true) && (true ? false : true)) ? vec4(-1.0, (((true && false) ? false : (false ? false : true)) ? -(true ? 0.0 : 0.5) : (-1.0 * +0.0)), -((true || true) ? 0.5 : -1.0), -+(false ? 2.0 : -1.0)) : vec4((1.0 - 1.0), (true ? 2.0 : (+2.0 / (0.5 - 1.0))), 1.0, 0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  vec3 result = vec3(notEqual(bvec3(c) , bvec3(true)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.143968871595334
Processing this: /home/oof/webgl_cleaned/mat_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat2 vuni2;
uniform mat3 vuni3;
uniform mat4 vuni4;
varying vec4 color;
void main ()
{
	color = vec4( vuni2[0][0] + vuni2[0][1] + vuni2[1][0] + vuni2[1][1],
		      vuni3[0][0] + vuni3[0][1] + vuni3[0][2] + vuni3[1][0] + vuni3[1][1] + vuni3[1][2] + vuni3[2][0] + vuni3[2][1] + vuni3[2][2],
                     vuni4[0][0] + vuni4[0][1] + vuni4[0][2] + vuni4[0][3] + vuni4[1][0] + vuni4[1][1] + vuni4[1][2] + vuni4[1][3] + vuni4[2][0] + vuni4[2][1] + vuni4[2][2] + vuni4[2][3] + vuni4[3][0] + vuni4[3][1] + vuni4[3][2] + vuni4[3][3], 1.0 );
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat2 vuni2;\nuniform mat3 vuni3;\nuniform mat4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4( vuni2[0][0] + vuni2[0][1] + vuni2[1][0] + vuni2[1][1],\n\t\t      vuni3[0][0] + vuni3[0][1] + vuni3[0][2] + vuni3[1][0] + vuni3[1][1] + vuni3[1][2] + vuni3[2][0] + vuni3[2][1] + vuni3[2][2],\n                     vuni4[0][0] + vuni4[0][1] + vuni4[0][2] + vuni4[0][3] + vuni4[1][0] + vuni4[1][1] + vuni4[1][2] + vuni4[1][3] + vuni4[2][0] + vuni4[2][1] + vuni4[2][2] + vuni4[2][3] + vuni4[3][0] + vuni4[3][1] + vuni4[3][2] + vuni4[3][3], 1.0 );\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat2 vuni2;

uniform mat3 vuni3;

uniform mat4 vuni4;

vec4 color = vec4(0.5, 1.0, 2.0, ((2.0 / 0.0) + -(true ? 2.0 : 2.0)));

void main()
{
  color = vec4((((vuni2[0][0] + vuni2[0][1]) + vuni2[1][0]) + vuni2[1][1]) , ((((((((vuni3[0][0] + vuni3[0][1]) + vuni3[0][2]) + vuni3[1][0]) + vuni3[1][1]) + vuni3[1][2]) + vuni3[2][0]) + vuni3[2][1]) + vuni3[2][2]) , (((((((((((((((vuni4[0][0] + vuni4[0][1]) + vuni4[0][2]) + vuni4[0][3]) + vuni4[1][0]) + vuni4[1][1]) + vuni4[1][2]) + vuni4[1][3]) + vuni4[2][0]) + vuni4[2][1]) + vuni4[2][2]) + vuni4[2][3]) + vuni4[3][0]) + vuni4[3][1]) + vuni4[3][2]) + vuni4[3][3]) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.196891191709845
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (2.0 / (0.0 / (-1.0 - 0.0))), 1.0, --+0.5);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:4: '/' : Divide by zero during constant folding
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (2.0 / (0.0 / (-1.0 - 0.0))), 1.0, --+0.5);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


==============================
59.120310478654595
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.17312661498708
Processing this: /home/oof/webgl_cleaned/fwidth_frag_ref_dy.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((0.5 * (!true ? -2.0 : (1.0 * 2.0))), 0.5, 1.0, (true ? 1.0 : +0.5));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.225806451612904
Mutations attempted: 775
Valid mutations:     459
Success rate:        59.23%
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 4.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4(atan(c) / M_PI + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 4.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(atan(c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.0, -0.5, 0.5, 0.5);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((atan(c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.27835051546392
Processing this: /home/oof/webgl_cleaned/CorrectConstruct_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

struct s {
    float f;
} s1 = s(1.0);
struct s3 {
   int i;
} s3Inst;
struct s2 {
    float f;
    s3 s3Inst;
} s2Inst = s2(1.0, s3(1));
void main()
{
    vec3 i = vec3(5.0, 4.0, ivec2(2.0, 1.0));
    ivec4 v2 = ivec4(1.0);
    vec4 v4 = vec4(v2);
    bvec4 v5 = bvec4(v2);
    vec3 v6 = vec3(v5);
    vec3 v = vec3(2, 2.0, 1);
    vec3 v1 = vec3(1.2, v);
    mat3 m1 = mat3(v,v,v);
    mat2 m2 = mat2(v, v6.x);
    gl_Position = vec4(1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nstruct s {\n    float f;\n} s1 = s(1.0);\nstruct s3 {\n   int i;\n} s3Inst;\nstruct s2 {\n    float f;\n    s3 s3Inst;\n} s2Inst = s2(1.0, s3(1));\nvoid main()\n{\n    vec3 i = vec3(5.0, 4.0, ivec2(2.0, 1.0));\n    ivec4 v2 = ivec4(1.0);\n    vec4 v4 = vec4(v2);\n    bvec4 v5 = bvec4(v2);\n    vec3 v6 = vec3(v5);\n    vec3 v = vec3(2, 2.0, 1);\n    vec3 v1 = vec3(1.2, v);\n    mat3 m1 = mat3(v,v,v);\n    mat2 m2 = mat2(v, v6.x);\n    gl_Position = vec4(1.0);\n}\n\x00')
59.27835051546392
Processing this: /home/oof/webgl_cleaned/clamp_float_frag_xvary_yconstquarter.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = color.r;
	gl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  gl_FragColor = vec4(clamp(c , min_c , max_c) , 0.0 , 0.0 , 1.0);
  float c = color.r;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'c' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  gl_FragColor = vec4(clamp(c , min_c , max_c) , 0.0 , 0.0 , 1.0);
  float c = color.r;
}


==============================
59.202059202059196
Processing this: /home/oof/webgl_cleaned/exp2_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = color.rgb;
	gl_FragColor = vec4(pow(vec3(2.0), 5.0 * c) / 32.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(pow(vec3(2.0), 5.0 * c) / 32.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4((pow(vec3(2.0) , (5.0 * c)) / 32.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4((pow(vec3(2.0) , (5.0 * c)) / 32.0));
}


==============================
59.12596401028277
Processing this: /home/oof/webgl_cleaned/discard_cond_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	if(color.r > 0.75 || color.g > 0.75 || color.b > 0.75)
	{
		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
	}
	else
	{
		gl_FragColor = color;
	}
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tif(color.r > 0.75 || color.g > 0.75 || color.b > 0.75)\n\t{\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t}\n\telse\n\t{\n\t\tgl_FragColor = color;\n\t}\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((((color.r > 0.75) || (color.g > 0.75)) || (color.b > 0.75)))
  {
    0.0 = vec4(0.0 , 0.0 , 0.0);
  }
  else
  {
    gl_FragColor = color;
  }
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction
ERROR: 0:10: 'assign' : l-value required (can't modify a const)
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((((color.r > 0.75) || (color.g > 0.75)) || (color.b > 0.75)))
  {
    0.0 = vec4(0.0 , 0.0 , 0.0);
  }
  else
  {
    gl_FragColor = color;
  }
}


==============================
59.05006418485238
Processing this: /home/oof/webgl_cleaned/matrix2arrayVSU.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat4 transforms[2];
varying vec4 color;
void main()
{
  color = gtf_Color;
   gl_Position = gtf_ModelViewProjectionMatrix* transforms[0] * transforms[1] * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat4 transforms[2];\nvarying vec4 color;\nvoid main()\n{\n  color = gtf_Color;\n   gl_Position = gtf_ModelViewProjectionMatrix* transforms[0] * transforms[1] * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((1.0 / (0.0 * (2.0 - 0.5))), -0.0, (2.0 / +(-1.0 - 0.0)), 2.0);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat4 transforms[2];

vec4 color;

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms[0]) * transforms[1]) * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.1025641025641
Processing this: /home/oof/webgl_cleaned/min_vec3_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 min_c = vec3(0.5, 0.5, 0.5);
	vec3 c = gtf_Color.rgb;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	if(c[2] > min_c[2]) c[2] = min_c[2];
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 min_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = gtf_Color.rgb;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tif(c[2] > min_c[2]) c[2] = min_c[2];\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+1.0, (true ? 1.0 : 0.5), ++0.0, 0.5, 1.0, (false ? +-0.5 : 2.0), 1.0, -1.0, ((true || true) ? 0.5 : 0.0), -1.0, 0.0, 0.0, +0.0, 0.0, -(true ? 2.0 : -1.0), 0.5);

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  if ((c[2] > min_c[2]))
    c[2] = min_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+1.0, (true ? 1.0 : 0.5), ++0.0, 0.5, 1.0, (false ? +-0.5 : 2.0), 1.0, -1.0, ((true || true) ? 0.5 : 0.0), -1.0, 0.0, 0.0, +0.0, 0.0, -(true ? 2.0 : -1.0), 0.5);

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  if ((c[2] > min_c[2]))
    c[2] = min_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.02688860435339
Processing this: /home/oof/webgl_cleaned/vec4_grab_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.grab;
	vec4 a = vec4(m.g, m.r, m.a, m.b);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.grab;\n\tvec4 a = vec4(m.g, m.r, m.a, m.b);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, -1.0, 0.5, 2.0);

void main()
{
  vec4 al = color;
  vec4 m = al.grab;
  vec4 a = vec4(m.g , m.r , m.a , m.b);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.07928388746802
Processing this: /home/oof/webgl_cleaned/vec4_tsqp_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.tsqp;
	vec4 a = vec4(m.t, m.s, m.q, m.p);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.tsqp;\n\tvec4 a = vec4(m.t, m.s, m.q, m.p);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-(1.0 / 0.5), -1.0, -(0.5 * +2.0), (1.0 - 1.0));

void main()
{
  vec4 al = color;
  vec4 m = al.tsqp;
  vec4 a = vec4(m.t , m.s , m.q , m.p);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.131545338441896
Processing this: /home/oof/webgl_cleaned/struct_mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
 mat4 a;
};
void main ()
{
	sabcd s = sabcd(mat4(12.0, 29.0, 13.0, 26.0,
			     71.0, 63.0, 90.0, 118.0,
			     128.0, 44.0, 57.0, 143.0,
			     151.0, 14.0, 15.0, 21.0 ) );
	float sum=0.0;
	sum = sum + s.a[0][0];
	sum = sum + s.a[0][1];
	sum = sum + s.a[0][2];
	sum = sum + s.a[0][3];
	sum = sum + s.a[1][0];
	sum = sum + s.a[1][1];
	sum = sum + s.a[1][2];
	sum = sum + s.a[1][3];
	sum = sum + s.a[2][0];
	sum = sum + s.a[2][1];
	sum = sum + s.a[2][2];
	sum = sum + s.a[2][3];
	sum = sum + s.a[3][0];
	sum = sum + s.a[3][1];
	sum = sum + s.a[3][2];
	sum = sum + s.a[3][3];
	color = vec4( vec3(  sum / 995.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n mat4 a;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(mat4(12.0, 29.0, 13.0, 26.0,\n\t\t\t     71.0, 63.0, 90.0, 118.0,\n\t\t\t     128.0, 44.0, 57.0, 143.0,\n\t\t\t     151.0, 14.0, 15.0, 21.0 ) );\n\tfloat sum=0.0;\n\tsum = sum + s.a[0][0];\n\tsum = sum + s.a[0][1];\n\tsum = sum + s.a[0][2];\n\tsum = sum + s.a[0][3];\n\tsum = sum + s.a[1][0];\n\tsum = sum + s.a[1][1];\n\tsum = sum + s.a[1][2];\n\tsum = sum + s.a[1][3];\n\tsum = sum + s.a[2][0];\n\tsum = sum + s.a[2][1];\n\tsum = sum + s.a[2][2];\n\tsum = sum + s.a[2][3];\n\tsum = sum + s.a[3][0];\n\tsum = sum + s.a[3][1];\n\tsum = sum + s.a[3][2];\n\tsum = sum + s.a[3][3];\n\tcolor = vec4( vec3(  sum / 995.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((-(1.0 + 2.0) / -1.0), 2.0, ((!true ? (true ? 2.0 : -1.0) : (true ? 0.5 : 0.5)) - 0.5), ((!true ? 0.5 : 0.5) + 2.0));

struct sabcd {
  mat4 a;
};

void main()
{
  sabcd s = sabcd(mat4(12.0 , 29.0 , 13.0 , 26.0 , 71.0 , 63.0 , 90.0 , 118.0 , 128.0 , 44.0 , 57.0 , 143.0 , 151.0 , 14.0 , 15.0 , 21.0));
  float sum = 0.0;
  sum = (sum + s.a[0][0]);
  sum = (sum + s.a[0][1]);
  sum = (sum + s.a[0][2]);
  sum = (sum + s.a[0][3]);
  sum = (sum + s.a[1][0]);
  sum = (sum + s.a[1][1]);
  sum = (sum + s.a[1][2]);
  sum = (sum + s.a[1][3]);
  sum = (sum + s.a[2][0]);
  sum = (sum + s.a[2][1]);
  sum = (sum + s.a[2][2]);
  sum = (sum + s.a[2][3]);
  sum = (sum + s.a[3][0]);
  sum = (sum + s.a[3][1]);
  sum = (sum + s.a[3][2]);
  sum = (sum + s.a[3][3]);
  color = vec4(vec3((sum / 995.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.183673469387756
Mutations attempted: 784
Valid mutations:     464
Success rate:        59.18%
Processing this: /home/oof/webgl_cleaned/exp2_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = gtf_Color.rgb;
	color = vec4(exp2(5.0 * c) / 32.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(exp2(5.0 * c) / 32.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((2.0 + ((1.0 + -1.0) * 1.0)), 0.5, -1.0, +0.5);

void main()
{
  vec3 c = gtf_Color.rgb;
  color = vec4((exp2((5.0 * c)) / 32.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.23566878980891
Processing this: /home/oof/webgl_cleaned/CorrectSwizzle1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    vec2 v = vec2(1,5);
    v.xy += v.yx += v.xy;
    vec2 v1 = v, v2 = v;
    v1.xy += v2.yx += ++(v.xy);
    v1.xy += v2.yx += (v.xy)++;
    gl_FragColor = vec4(v1,v2);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    vec2 v = vec2(1,5);\n    v.xy += v.yx += v.xy;\n    vec2 v1 = v, v2 = v;\n    v1.xy += v2.yx += ++(v.xy);\n    v1.xy += v2.yx += (v.xy)++;\n    gl_FragColor = vec4(v1,v2);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  vec2 v = vec2(1 , 5);
  (v.xy += (v.yx += v.xy));
  vec2 v1 = v , v2 = v;
  (v1.xy += (v2.yx += ++v.xy));
  (v1.xy += (v2.yx += v.xy++));
  gl_FragColor = vec4(v1 , v2);
}


As vertex? : False
SUCCESS!
59.28753180661578
Processing this: /home/oof/webgl_cleaned/exp_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec3 c = gtf_Color.rgb;
	color = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((-2.0 + 1.0), -0.5, 0.0, ((-1.0 * (true ? 1.0 : -1.0)) / 0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec3 c = gtf_Color.rgb;
  color = vec4((pow(vec3(exp1) , (3.0 * c)) / exp3) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.339263024142305
Processing this: /home/oof/webgl_cleaned/array_const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat2 a = mat2(1.0, 2.0, 3.0, 4.0);
	const mat2 b = mat2(5.0, 6.0, 7.0, 8.0);
	mat2 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat2 a = mat2(1.0, 2.0, 3.0, 4.0);\n\tconst mat2 b = mat2(5.0, 6.0, 7.0, 8.0);\n\tmat2 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((0.0 * 1.0), -1.0, -1.0, 0.0);

const int array_size = 2;

void main()
{
  const mat2 a = mat2(1.0 , 2.0 , 3.0 , 4.0);
  const mat2 b = mat2(5.0 , 6.0 , 7.0 , 8.0);
  mat2 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.390862944162436
Processing this: /home/oof/webgl_cleaned/log_float_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = (color.r + 0.01) / 1.01;
	gl_FragColor = vec4(log(c) / -4.61, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (color.r + 0.01) / 1.01;\n\tgl_FragColor = vec4(log(c) / -4.61, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = ((color.r + 0.01) / 0.010000000000000009);
  gl_FragColor = vec4((log(c) / -4.61) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.442332065906214
Processing this: /home/oof/webgl_cleaned/sin_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * color.rg;
	vec2 arrVal = c * 2.546478971;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 sin_c = vec2(0.0, 0.0);
	if (arr0x == 0)
		sin_c.x = lerp(sinValues[0], sinValues[1], weight.x);
	else if (arr0x == 1)
		sin_c.x = lerp(sinValues[1], sinValues[2], weight.x);
	else if (arr0x == 2)
		sin_c.x = lerp(sinValues[2], sinValues[3], weight.x);
	else if (arr0x == 3)
		sin_c.x = lerp(sinValues[3], sinValues[4], weight.x);
	else if (arr0x == 4)
		sin_c.x = lerp(sinValues[4], sinValues[5], weight.x);
	else if (arr0x == 5)
		sin_c.x = lerp(sinValues[5], sinValues[6], weight.x);
	else if (arr0x == 6)
		sin_c.x = lerp(sinValues[6], sinValues[7], weight.x);
	else if (arr0x == 7)
		sin_c.x = lerp(sinValues[7], sinValues[8], weight.x);
	else if (arr0x == 8)
		sin_c.x = lerp(sinValues[8], sinValues[9], weight.x);
	else if (arr0x == 9)
		sin_c.x = lerp(sinValues[9], sinValues[10], weight.x);
	else if (arr0x == 10)
		sin_c.x = lerp(sinValues[10], sinValues[11], weight.x);
	else if (arr0x == 11)
		sin_c.x = lerp(sinValues[11], sinValues[12], weight.x);
	else if (arr0x == 12)
		sin_c.x = lerp(sinValues[12], sinValues[13], weight.x);
	else if (arr0x == 13)
		sin_c.x = lerp(sinValues[13], sinValues[14], weight.x);
	else if (arr0x == 14)
		sin_c.x = lerp(sinValues[14], sinValues[15], weight.x);
	else if (arr0x == 15)
		sin_c.x = lerp(sinValues[15], sinValues[16], weight.x);
        else if (arr0x == 16)
                sin_c.x = sinValues[16];
	if (arr0y == 0)
		sin_c.y = lerp(sinValues[0], sinValues[1], weight.y);
	else if (arr0y == 1)
		sin_c.y = lerp(sinValues[1], sinValues[2], weight.y);
	else if (arr0y == 2)
		sin_c.y = lerp(sinValues[2], sinValues[3], weight.y);
	else if (arr0y == 3)
		sin_c.y = lerp(sinValues[3], sinValues[4], weight.y);
	else if (arr0y == 4)
		sin_c.y = lerp(sinValues[4], sinValues[5], weight.y);
	else if (arr0y == 5)
		sin_c.y = lerp(sinValues[5], sinValues[6], weight.y);
	else if (arr0y == 6)
		sin_c.y = lerp(sinValues[6], sinValues[7], weight.y);
	else if (arr0y == 7)
		sin_c.y = lerp(sinValues[7], sinValues[8], weight.y);
	else if (arr0y == 8)
		sin_c.y = lerp(sinValues[8], sinValues[9], weight.y);
	else if (arr0y == 9)
		sin_c.y = lerp(sinValues[9], sinValues[10], weight.y);
	else if (arr0y == 10)
		sin_c.y = lerp(sinValues[10], sinValues[11], weight.y);
	else if (arr0y == 11)
		sin_c.y = lerp(sinValues[11], sinValues[12], weight.y);
	else if (arr0y == 12)
		sin_c.y = lerp(sinValues[12], sinValues[13], weight.y);
	else if (arr0y == 13)
		sin_c.y = lerp(sinValues[13], sinValues[14], weight.y);
	else if (arr0y == 14)
		sin_c.y = lerp(sinValues[14], sinValues[15], weight.y);
	else if (arr0y == 15)
		sin_c.y = lerp(sinValues[15], sinValues[16], weight.y);
        else if (arr0y == 16)
                sin_c.y = sinValues[16];
	gl_FragColor = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * color.rg;\n\tvec2 arrVal = c * 2.546478971;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tvec2 weight = arrVal - floor(arrVal);\n\tvec2 sin_c = vec2(0.0, 0.0);\n\tif (arr0x == 0)\n\t\tsin_c.x = lerp(sinValues[0], sinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tsin_c.x = lerp(sinValues[1], sinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tsin_c.x = lerp(sinValues[2], sinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tsin_c.x = lerp(sinValues[3], sinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tsin_c.x = lerp(sinValues[4], sinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tsin_c.x = lerp(sinValues[5], sinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tsin_c.x = lerp(sinValues[6], sinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tsin_c.x = lerp(sinValues[7], sinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tsin_c.x = lerp(sinValues[8], sinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tsin_c.x = lerp(sinValues[9], sinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tsin_c.x = lerp(sinValues[10], sinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tsin_c.x = lerp(sinValues[11], sinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tsin_c.x = lerp(sinValues[12], sinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tsin_c.x = lerp(sinValues[13], sinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tsin_c.x = lerp(sinValues[14], sinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tsin_c.x = lerp(sinValues[15], sinValues[16], weight.x);\n        else if (arr0x == 16)\n                sin_c.x = sinValues[16];\n\tif (arr0y == 0)\n\t\tsin_c.y = lerp(sinValues[0], sinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tsin_c.y = lerp(sinValues[1], sinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tsin_c.y = lerp(sinValues[2], sinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tsin_c.y = lerp(sinValues[3], sinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tsin_c.y = lerp(sinValues[4], sinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tsin_c.y = lerp(sinValues[5], sinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tsin_c.y = lerp(sinValues[6], sinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tsin_c.y = lerp(sinValues[7], sinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tsin_c.y = lerp(sinValues[8], sinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tsin_c.y = lerp(sinValues[9], sinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tsin_c.y = lerp(sinValues[10], sinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tsin_c.y = lerp(sinValues[11], sinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tsin_c.y = lerp(sinValues[12], sinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tsin_c.y = lerp(sinValues[13], sinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tsin_c.y = lerp(sinValues[14], sinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tsin_c.y = lerp(sinValues[15], sinValues[16], weight.y);\n        else if (arr0y == 16)\n                sin_c.y = sinValues[16];\n\tgl_FragColor = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + (s * (b - a)));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  vec2 c = ((2.0 * M_PI) * color.rg);
  vec2 arrVal = (c * 2.546478971);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 sin_c = vec2(0.0 , 0.0);
  if ((arr0x == 0))
    sin_c.x = lerp(sinValues[0] , sinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      sin_c.x = lerp(sinValues[1] , sinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        sin_c.x = lerp(sinValues[2] , sinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          sin_c.x = lerp(sinValues[3] , sinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            sin_c.x = lerp(sinValues[4] , sinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              sin_c.x = lerp(sinValues[5] , sinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                sin_c.x = lerp(sinValues[6] , sinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  sin_c.x = lerp(sinValues[7] , sinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    sin_c.x = lerp(sinValues[8] , sinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      sin_c.x = lerp(sinValues[9] , sinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        sin_c.x = lerp(sinValues[10] , sinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          sin_c.x = lerp(sinValues[11] , sinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            sin_c.x = lerp(sinValues[12] , sinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              sin_c.x = lerp(sinValues[13] , sinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                sin_c.x = lerp(sinValues[14] , sinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  sin_c.x = lerp(sinValues[15] , sinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    sin_c.x = sinValues[16];
  if ((arr0y == 0))
    sin_c.y = lerp(sinValues[0] , sinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      sin_c.y = lerp(sinValues[1] , sinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        sin_c.y = lerp(sinValues[2] , sinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          sin_c.y = lerp(sinValues[3] , sinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            sin_c.y = lerp(sinValues[4] , sinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              sin_c.y = lerp(sinValues[5] , sinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                sin_c.y = lerp(sinValues[6] , sinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  sin_c.y = lerp(sinValues[7] , sinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    sin_c.y = lerp(sinValues[8] , sinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      sin_c.y = lerp(sinValues[9] , sinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        sin_c.y = lerp(sinValues[10] , sinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          sin_c.y = lerp(sinValues[11] , sinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            sin_c.y = lerp(sinValues[12] , sinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              sin_c.y = lerp(sinValues[13] , sinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                sin_c.y = lerp(sinValues[14] , sinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  sin_c.y = lerp(sinValues[15] , sinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    sin_c.y = sinValues[16];
  gl_FragColor = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.49367088607595
Processing this: /home/oof/webgl_cleaned/exp2_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_Color' : undeclared identifier
ERROR: 0:6: 'rg' :  field selection requires structure or vector on left hand side
ERROR: 0:6: '=' : dimension mismatch
ERROR: 0:6: '=' : cannot convert from 'const highp float' to 'mediump 2-component vector of float'
ERROR: 0:7: 'color' : undeclared identifier
ERROR: 0:7: 'assign' : l-value required (can't modify a const)
ERROR: 0:7: '=' : dimension mismatch
ERROR: 0:7: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const highp float'
ERROR: 0:8: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:8: 'gtf_Vertex' : undeclared identifier
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;


==============================
59.41845764854614
Processing this: /home/oof/webgl_cleaned/float_empty_inout_float_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(inout float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(inout float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(inout float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(inout float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
59.41845764854614
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * color.rg;
	gl_FragColor = vec4(c / 100.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * color.rg;\n\tgl_FragColor = vec4(c / 100.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-+2.0, +((false ? 2.0 : 0.5) * 0.5), ((0.0 + 2.0) * 0.5), 2.0);

void main()
{
  vec2 c = (100.0 * color.rg);
  gl_FragColor = vec4((c / 100.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.46969696969697
Processing this: /home/oof/webgl_cleaned/sin_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * sin(2.0 * M_PI * gtf_Color.rgb) + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * sin(2.0 * M_PI * gtf_Color.rgb) + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(+2.0, 1.0, 2.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * sin(((2.0 * M_PI) * gtf_Color.rgb))) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.52080706179067
Mutations attempted: 793
Valid mutations:     472
Success rate:        59.52%
Processing this: /home/oof/webgl_cleaned/fragmentOnly4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    discard;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    discard;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  discard;
}


As vertex? : True
SUCCESS!
59.57178841309824
Processing this: /home/oof/webgl_cleaned/reflect_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((2.0 * 0.5) * 2.0) * 1.0), ((false ? 0.0 : 1.0) + (true ? (2.0 * 0.5) : (false ? 1.0 : 1.0))), ((0.5 * (0.5 - 0.5)) * ((false ? 1.0 : 1.0) + (true ? 2.0 : -1.0))), (2.0 * +2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.62264150943396
Processing this: /home/oof/webgl_cleaned/atan_float_frag_xvaryyvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float x = 2.0 * (color.g - 0.5);
	float y = 2.0 * (color.b - 0.5);
	float atan_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x > epsilon || abs(y) > epsilon)
	{
		if(x < 0.0 ^^ y < 0.0)
		{
			sign = -1.0;
		}
		if(abs(y) <= abs(x))
		{
			float c = abs(y / x);
			for(int i = 1; i < 12; i += 2)
			{
				atan_c += scale * pow(c, float(i)) / float(i);
				scale *= -1.0;
			}
			result = vec4(sign * atan_c / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
		}
		else
		{
			float c = abs(x / y);
			for(int i = 1; i < 12; i += 2)
			{
				atan_c += scale * pow(c, float(i)) / float(i);
				scale *= -1.0;
			}
			result = vec4(sign * (M_PI / 2.0 - atan_c) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
		}
		if(x < 0.0)
			if(y < 0.0) result.r -= 0.5;
			else if(y > 0.0) result.r += 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat x = 2.0 * (color.g - 0.5);\n\tfloat y = 2.0 * (color.b - 0.5);\n\tfloat atan_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x > epsilon || abs(y) > epsilon)\n\t{\n\t\tif(x < 0.0 ^^ y < 0.0)\n\t\t{\n\t\t\tsign = -1.0;\n\t\t}\n\t\tif(abs(y) <= abs(x))\n\t\t{\n\t\t\tfloat c = abs(y / x);\n\t\t\tfor(int i = 1; i < 12; i += 2)\n\t\t\t{\n\t\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\t\tscale *= -1.0;\n\t\t\t}\n\t\t\tresult = vec4(sign * atan_c / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat c = abs(x / y);\n\t\t\tfor(int i = 1; i < 12; i += 2)\n\t\t\t{\n\t\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\t\tscale *= -1.0;\n\t\t\t}\n\t\t\tresult = vec4(sign * (M_PI / 2.0 - atan_c) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t\t}\n\t\tif(x < 0.0)\n\t\t\tif(y < 0.0) result.r -= 0.5;\n\t\t\telse if(y > 0.0) result.r += 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float epsilon = 0.0001;
  const float M_PI = 3.141592653589793;
  float sign = 1.0;
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    if (((x < 0.0) ^^ (y < 0.0)))
    {
      sign = -1.0;
    }
    if ((abs(y) <= abs(x)))
    {
      float c = abs((y / x));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * atan_c) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    else
    {
      float c = abs((x / y));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    if ((x < 0.0))
      if ((y < 0.0))
        (result.r -= 0.5);
      else
        if ((y > 0.0))
          (result.r += 0.5);
  }
  float x = (2.0 * (color.g - 0.5));
  float y = (2.0 * (color.b - 0.5));
  float atan_c = 0.0;
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  main() = result;
  float scale = 1.0;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: 'x' : undeclared identifier
ERROR: 0:11: 'y' : undeclared identifier
ERROR: 0:13: 'x' : undeclared identifier
ERROR: 0:13: 'y' : undeclared identifier
ERROR: 0:17: 'y' : undeclared identifier
ERROR: 0:17: 'x' : undeclared identifier
ERROR: 0:19: 'y' : undeclared identifier
ERROR: 0:19: 'x' : undeclared identifier
WARNING: 0:19: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:22: 'atan_c' : undeclared identifier
ERROR: 0:22: 'scale' : undeclared identifier
ERROR: 0:22: 'assign' : l-value required (can't modify a const)
ERROR: 0:23: 'scale' : undeclared identifier
ERROR: 0:23: 'assign' : l-value required (can't modify a const)
ERROR: 0:25: 'result' : undeclared identifier
ERROR: 0:25: 'atan_c' : undeclared identifier
ERROR: 0:25: 'assign' : l-value required (can't modify a const)
ERROR: 0:25: '=' : dimension mismatch
ERROR: 0:25: 'assign' : cannot convert from 'highp 4-component vector of float' to 'const highp float'
ERROR: 0:29: 'x' : undeclared identifier
ERROR: 0:29: 'y' : undeclared identifier
WARNING: 0:29: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:32: 'atan_c' : undeclared identifier
ERROR: 0:32: 'scale' : undeclared identifier
ERROR: 0:32: 'assign' : l-value required (can't modify a const)
ERROR: 0:33: 'scale' : undeclared identifier
ERROR: 0:33: 'assign' : l-value required (can't modify a const)
ERROR: 0:35: 'result' : undeclared identifier
ERROR: 0:35: 'atan_c' : undeclared identifier
ERROR: 0:35: 'assign' : l-value required (can't modify a const)
ERROR: 0:35: '=' : dimension mismatch
ERROR: 0:35: 'assign' : cannot convert from 'highp 4-component vector of float' to 'const highp float'
ERROR: 0:37: 'x' : undeclared identifier
ERROR: 0:38: 'y' : undeclared identifier
ERROR: 0:39: 'result' : undeclared identifier
ERROR: 0:39: 'r' :  field selection requires structure or vector on left hand side
ERROR: 0:39: 'assign' : l-value required (can't modify a const)
ERROR: 0:41: 'y' : undeclared identifier
ERROR: 0:42: 'result' : undeclared identifier
ERROR: 0:42: 'r' :  field selection requires structure or vector on left hand side
ERROR: 0:42: 'assign' : l-value required (can't modify a const)
ERROR: 0:48: 'assign' : l-value required (can't modify void)
ERROR: 0:48: '=' : operation with void operands
ERROR: 0:48: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'void'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float epsilon = 0.0001;
  const float M_PI = 3.141592653589793;
  float sign = 1.0;
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    if (((x < 0.0) ^^ (y < 0.0)))
    {
      sign = -1.0;
    }
    if ((abs(y) <= abs(x)))
    {
      float c = abs((y / x));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * atan_c) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    else
    {
      float c = abs((x / y));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    if ((x < 0.0))
      if ((y < 0.0))
        (result.r -= 0.5);
      else
        if ((y > 0.0))
          (result.r += 0.5);
  }
  float x = (2.0 * (color.g - 0.5));
  float y = (2.0 * (color.b - 0.5));
  float atan_c = 0.0;
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  main() = result;
  float scale = 1.0;
}


==============================
59.54773869346733
Processing this: /home/oof/webgl_cleaned/sin_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * sin(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * sin(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, -0.5, -1.0, 2.0);

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * sin(((2.0 * M_PI) * gtf_Color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.59849435382685
Processing this: /home/oof/webgl_cleaned/exp2_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = color.r;
	gl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = color.r;\n\tgl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, -1.0, 1.0, 0.0);

void main()
{
  float c = color.r;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.64912280701754
Processing this: /home/oof/webgl_cleaned/mix_vec3_vert_xvary_yconsthalf_aconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 y = vec3(0.5, 0.5, 0.5);
	const vec3 a = vec3(0.5, 0.5, 0.5);
	color = vec4(mix(gtf_Color.rgb, y, a), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 y = vec3(0.5, 0.5, 0.5);\n\tconst vec3 a = vec3(0.5, 0.5, 0.5);\n\tcolor = vec4(mix(gtf_Color.rgb, y, a), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  const vec3 y = vec3(0.5 , 0.5 , 0.5);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  color = vec4(mix(gtf_Color.rgb , y , a) , 1.0);
}


As vertex? : True
SUCCESS!
59.69962453066333
Processing this: /home/oof/webgl_cleaned/empty_uniform_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const int array_size = 2;
uniform float new_mad2[array_size];
void main ()
{
	int i=0;
	float new_mad[array_size];
	float gray = 0.0;
	new_mad[0] = new_mad2[0];
	new_mad[1] = new_mad2[1];
	if( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst int array_size = 2;\nuniform float new_mad2[array_size];\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[array_size];\n\tfloat gray = 0.0;\n\tnew_mad[0] = new_mad2[0];\n\tnew_mad[1] = new_mad2[1];\n\tif( (new_mad[0] == 45.0) && (new_mad[1] == 14.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(((false ? (true || false) : false) ? ((false ? 0.0 : 1.0) + 2.0) : 1.0), +0.0, 1.0, (false ? (true ? +-1.0 : 0.5) : (true ? +2.0 : (true ? 2.0 : new_mad2))));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const int array_size = 2;

uniform float new_mad2[array_size];

void main()
{
  int i = 0;
  float new_mad[array_size];
  float gray = 0.0;
  new_mad[0] = new_mad2[0];
  new_mad[1] = new_mad2[1];
  if (((new_mad[0] == 45.0) && (new_mad[1] == 14.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'new_mad2' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(((false ? (true || false) : false) ? ((false ? 0.0 : 1.0) + 2.0) : 1.0), +0.0, 1.0, (false ? (true ? +-1.0 : 0.5) : (true ? +2.0 : (true ? 2.0 : new_mad2))));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const int array_size = 2;

uniform float new_mad2[array_size];

void main()
{
  int i = 0;
  float new_mad[array_size];
  float gray = 0.0;
  new_mad[0] = new_mad2[0];
  new_mad[1] = new_mad2[1];
  if (((new_mad[0] == 45.0) && (new_mad[1] == 14.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.62499999999999
Processing this: /home/oof/webgl_cleaned/length_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(length(gtf_Color.r)), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(length(gtf_Color.r)), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-1.0, 0.5, 0.5, 0.5);

vec4 color;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = vec4(vec3(length(gtf_Color.r)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.675405742821475
Processing this: /home/oof/webgl_cleaned/degrees_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, -1.0, 2.0, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.725685785536164
Processing this: /home/oof/webgl_cleaned/exp_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	float c = gtf_Color.r;
	color = vec4(exp(3.0 * c) / exp3, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(exp(3.0 * c) / exp3, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, 0.0, -1.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  float c = gtf_Color.r;
  color = vec4((exp((3.0 * c)) / exp3) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.7758405977584
Mutations attempted: 803
Valid mutations:     480
Success rate:        59.78%
Processing this: /home/oof/webgl_cleaned/sign_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	if(c[0] > 0.0) c[0] = 1.0 * c[0];
	if(c[0] < 0.0) c[0] = -1.0 * c[0];
	if(c[1] > 0.0) c[1] = 1.0 * c[1];
	if(c[1] < 0.0) c[1] = -1.0 * c[1];
	if(c[2] > 0.0) c[2] = 1.0 * c[2];
	if(c[2] < 0.0) c[2] = -1.0 * c[2];
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tif(c[0] > 0.0) c[0] = 1.0 * c[0];\n\tif(c[0] < 0.0) c[0] = -1.0 * c[0];\n\tif(c[1] > 0.0) c[1] = 1.0 * c[1];\n\tif(c[1] < 0.0) c[1] = -1.0 * c[1];\n\tif(c[2] > 0.0) c[2] = 1.0 * c[2];\n\tif(c[2] < 0.0) c[2] = -1.0 * c[2];\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix[4] = mat4(1.0, +1.0, (true ? 2.0 : (0.0 - -0.0)), --1.0, +0.5, -1.0, 1.0, (+(true ? 0.0 : 2.0) / 1.0), 0.5, -1.0, 2.0, 0.5, 2.0, 2.0, 0.0, 1.0);

vec4 color;

void main()
{
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  if ((c[0] > 0.0))
    c[0] = (1.0 * c[0]);
  if ((c[0] < 0.0))
    c[0] = (-1.0 * c[0]);
  if ((c[1] > 0.0))
    c[1] = (1.0 * c[1]);
  if ((c[1] < 0.0))
    c[1] = (-1.0 * c[1]);
  if ((c[2] > 0.0))
    c[2] = (1.0 * c[2]);
  if ((c[2] < 0.0))
    c[2] = (-1.0 * c[2]);
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:8: '=' : global variable initializers must be constant expressions
ERROR: 0:28: '*' : array / non-array mismatch
ERROR: 0:28: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump array[4] of 4X4 matrix of float' and a right operand of type 'mediump 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:28: '=' : array / non-array mismatch
ERROR: 0:28: 'assign' : cannot convert from 'uniform mediump array[4] of 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix[4] = mat4(1.0, +1.0, (true ? 2.0 : (0.0 - -0.0)), --1.0, +0.5, -1.0, 1.0, (+(true ? 0.0 : 2.0) / 1.0), 0.5, -1.0, 2.0, 0.5, 2.0, 2.0, 0.0, 1.0);

vec4 color;

void main()
{
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  if ((c[0] > 0.0))
    c[0] = (1.0 * c[0]);
  if ((c[0] < 0.0))
    c[0] = (-1.0 * c[0]);
  if ((c[1] > 0.0))
    c[1] = (1.0 * c[1]);
  if ((c[1] < 0.0))
    c[1] = (-1.0 * c[1]);
  if ((c[2] > 0.0))
    c[2] = (1.0 * c[2]);
  if ((c[2] < 0.0))
    c[2] = (-1.0 * c[2]);
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.70149253731343
Processing this: /home/oof/webgl_cleaned/matrix2arrayVSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  color = gl_FragColor;
}


As vertex? : False
SUCCESS!
59.75155279503106
Processing this: /home/oof/webgl_cleaned/vec4_tsq_p_1vec3_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.tsq;
	float p = lightloc.p;
	vec4 a = vec4(m.t, m.s, p, m.p);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.tsq;\n\tfloat p = lightloc.p;\n\tvec4 a = vec4(m.t, m.s, p, m.p);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(+2.0, 0.5, 0.0, (0.5 / (!false ? 0.5 : (0.5 / 0.5))));

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.tsq;
  float p = lightloc.p;
  vec4 a = vec4(m.t , m.s , p , m.p);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
59.801488833746895
Processing this: /home/oof/webgl_cleaned/exp2_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = gtf_Color.rgb;
	color = vec4(exp2(5.0 * c) / 32.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(exp2(5.0 * c) / 32.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, -1.0, -1.0, 0.0);

void main()
{
  vec3 c = gtf_Color.rgb;
  color = vec4((exp2((5.0 * c)) / 32.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.85130111524164
Processing this: /home/oof/webgl_cleaned/24i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec4 color[2];
void main ()
{
	float r = float(color[0][0] + color[0][1] + color[0][2] + color[0][3]);
	float g = float(color[1][0] + color[1][1] + color[1][2] + color[1][3]);
	gl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec4 color[2];\nvoid main ()\n{\n\tfloat r = float(color[0][0] + color[0][1] + color[0][2] + color[0][3]);\n\tfloat g = float(color[1][0] + color[1][1] + color[1][2] + color[1][3]);\n\tgl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec4 color[2] = ivec4[2](ivec4(2.0, -1.0, 2.0, -1.0), ivec4(0.0, 2.0, 1.0, 2.0));

void main()
{
  float r = float((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]));
  float g = float((((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]));
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform ivec4 color[2] = ivec4[2](ivec4(2.0, -1.0, 2.0, -1.0), ivec4(0.0, 2.0, 1.0, 2.0));

void main()
{
  float r = float((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]));
  float g = float((((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]));
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


==============================
59.777227722772274
Processing this: /home/oof/webgl_cleaned/refract_float_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (color.g + 1.0) / 2.0;
	float v2 = (color.b + 1.0) / 2.0;
	gl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (color.g + 1.0) / 2.0;\n\tfloat v2 = (color.b + 1.0) / 2.0;\n\tgl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, -1.0, 0.0, 2.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g + 1.0) / 2.0);
  float v2 = ((color.b + 1.0) / 2.0);
  gl_FragColor = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.82694684796045
Processing this: /home/oof/webgl_cleaned/vec4_stp_q_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	float q = al.q;
	vec4 a = vec4(m, q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tfloat q = al.q;\n\tvec4 a = vec4(m, q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  float q = al.q;
  vec4 a = vec4(m , q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
59.876543209876544
Processing this: /home/oof/webgl_cleaned/CorrectFull_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

struct gtf_MaterialParameters
{
vec4 emission;
vec4 ambient;
vec4 diffuse;
vec4 specular;
float shininess;
};
struct gtf_LightSourceParameters
{
vec4 ambient;
vec4 diffuse;
vec4 specular;
vec4 position;
vec4 halfVector;
vec3 spotDirection;
float spotExponent;
float spotCutoff;
float spotCosCutoff;
float constantAttenuation;
float linearAttenuation;
float quadraticAttenuation;
};
struct gtf_PointParameters {
float size;
float sizeMin;
float sizeMax;
float fadeThresholdSize;
float distanceConstantAttenuation;
float distanceLinearAttenuation;
float distanceQuadraticAttenuation;
};
struct gtf_DepthRangeParameters {
float near;
float far;
float diff;
};
struct gtf_LightModelParameters {
vec4 ambient;
};
struct gtf_LightModelProducts {
vec4 sceneColor;
};
struct gtf_LightProducts {
vec4 ambient;
vec4 diffuse;
vec4 specular;
};
struct gtf_FogParameters {
vec4 color;
float density;
float start;
float end;
float scale;
};
uniform int gtf_MaxFragmentUniformComponents;
uniform int gtf_MaxVertexUniformComponents;
uniform int gtf_MaxVertexTextureImageUnits;
uniform int gtf_MaxLights;
uniform int gtf_MaxClipPlanes;
uniform int gtf_MaxCombinedTextureImageUnits;
uniform int gtf_MaxTextureCoords;
uniform int gtf_MaxVertexAttribs;
uniform int gtf_MaxVaryingFloats;
uniform int gtf_MaxTextureUnits;
uniform int gtf_MaxDrawBuffers;
uniform int gtf_MaxTextureImageUnits;
uniform gtf_LightProducts gtf_FrontLightProduct[8];
uniform gtf_LightModelProducts gtf_FrontLightModelProduct;
uniform gtf_DepthRangeParameters gtf_DepthRange;
uniform gtf_FogParameters gtf_Fog;
uniform gtf_PointParameters gtf_Point;
uniform gtf_LightModelParameters gtf_LightModel;
varying vec4 gtf_FogFragCoord;
varying vec4 gtf_BackColor;
varying vec4 gtf_BackSecondaryColor;
varying vec4 gtf_FrontSecondaryColor;
varying vec4 gtf_TexCoord[2];
varying vec4 gtf_FrontColor;
uniform gtf_MaterialParameters gtf_FrontMaterial;
uniform gtf_LightSourceParameters gtf_LightSource[8];
attribute vec4 gtf_MultiTexCoord1;
attribute vec4 gtf_MultiTexCoord2;
attribute vec4 gtf_SecondaryColor;
attribute vec4 gtf_Color;
attribute vec4 gtf_MultiTexCoord3;
attribute vec4 gtf_MultiTexCoord0;
attribute vec4 gtf_Normal;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_NormalMatrix;
uniform mat4 gtf_ProjectionMatrix;
uniform mat4 gtf_TextureMatrix[8];
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
void test_function(const in int in_int, inout int out_int);
int test_function1(in int in_int1, inout int in_out_int);
uniform float array_float[2];
struct nested
{
   int a;
   float f;
};
struct light1
{
   float intensity;
   vec3 position;
   int test_int[2];
   nested light2;
} lightVar;
light1 ll2;
void Assign (out light1 out1, in light1 in1)
{
    out1.intensity = in1.intensity;
     out1.position = in1.position;
  out1.test_int[0] = in1.test_int[0];
  out1.test_int[1] = in1.test_int[1];
       out1.light2 = in1.light2;
}
struct light3 {
    float i;
};
struct light4 {
    float i;
};
struct light5 {
    float i ;
    float a[2];
} light5_inst;
uniform light3 uniformLight3;
struct light6 {
    float i;
};
uniform light6 uniformLight6;
struct slight10{
     float f;
     };
struct slight9{
     slight10 light10;
     };
struct slight8{
     slight9 light9;
     };
struct light7 {
  slight8 light8;
} ;
light3 struct_var = light3(5.0);
attribute float flt_attrib;
attribute vec2 vec2_attrib;
attribute vec3 vec3_attrib;
attribute vec4 vec4_attrib;
attribute mat2 mat2_attrib;
attribute mat3 mat3_attrib;
attribute mat4 mat4_attrib;
uniform float flt_uniform;
uniform vec3 uniform_vec3;
uniform mat3 uniform_mat3;
uniform sampler2D samp[3];
uniform sampler2D samp1;
const struct light12 {
    int a;
} uniform_struct = light12(2);
varying vec3 varying_vec3;
varying vec2 varying_vec2;
varying vec4 varying_vec4;
varying mat4 varying_mat4;
varying mat2 varying_mat2;
varying mat3 varying_mat3;
varying float varying_flt;
float frequencies[2];
void test_function2(int func_int)
{
}
void test_function3(light3);
void test_function4(light5 ll20);
void test_function5(light1);
light6 test_function6(int a);
const float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;
const bool BoolConst1 = true && true || false;
const bool BoolConst2 = false || !false && false;
void main()
{
    int test_int1 = 2;
    const int const_test_int1 = 2;
    struct structMain {
        float i;
    } testStruct;
    struct {
        structMain a;
    } aStruct;
    testStruct.i = 5.0 ;
    struct_var.i = 5.0;
    structMain newStruct, newStruct1;
    testStruct = newStruct;
    newStruct = newStruct1;
    lightVar.light2.f = 1.1;
    light1 ll1;
    ll1.light2.a = 1;
     const struct const_struct {
        float i;
    } const_struct_inst = const_struct(1.0);
    Assign (ll1, ll2);
    ll1.light2 = ll2.light2;
    ll1.light2 = ll1.light2;
    ll1.light2.f = ll2.light2.f;
    ll1.light2.f = ll1.light2.f;
    Assign (lightVar, ll2);
    Assign (ll2, lightVar);
    light5 ll10;
    light7 ll7[4];
    structMain newStruct2[2];
    newStruct2[0].i = 1.1;
    ll7[0].light8.light9.light10.f = 1.1;
    bool test_bool4 = false ;
    bool test_bool5 = 1.2 > 3.0 ;
    int test_int2 =  047;
    int test_int4 =  0xa8;
    float test_float1 = 1.5;
    float test_float2 = .01;
    float test_float3 = 10.;
    float test_float4 = 10.01;
    float test_float5 = 23e+2;
    float test_float6 = 23E-3;
    float test_float8 = 23E2;
    bool test_bool6 = BoolConst1 && ! (test_int1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (test_float1 != 0.0);
    vec4 color = vec4(0.0, 1.0, 0.0, 1.0);
    vec4 color2 = vec4(0.0);
    vec3 color4 = vec3(test_float8);
    ivec4 test_int_vect1 = ivec4(1.0,1.0,1.0,1.0);
    ivec3 test_int_vec3 = ivec3(1, 1, 1) ;
    bvec4 test_bool_vect1 = bvec4(1., 1., 1. , 1. );
    vec2 test_vec2 = vec2(1., 1.);
    vec2 test_vec3 = vec2(1., 1);
    vec4 test_vec4 = vec4(test_int_vect1);
    vec2 test_vec5 = vec2(color4);
    vec3 test_vec7 = vec3(color);
    vec3 test_vec8 = vec3(test_vec2, test_float4);
    vec3 test_vec9 = vec3(test_float4, test_vec2);
    vec4 test_vec10 = vec4(test_vec9, 0.01);
    vec4 test_vec11 = vec4(0.01, test_vec9);
    vec4 test_vec12 = vec4(test_vec2, test_vec2);
    mat2 test_mat2 = mat2(test_float3);
    mat3 test_mat3 = mat3(test_float3);
    mat4 test_mat4 = mat4(test_float3);
    mat2 test_mat7 = mat2(test_vec2, test_vec2);
    mat2 test_mat8 = mat2(01.01, 2.01, 3.01, 4.01);
    mat3 test_mat9 = mat3(test_vec7, test_vec7, test_vec7);
    mat4 test_mat10 = mat4(test_vec10, test_vec10, test_vec10, test_vec10);
    test_mat10[1] = test_vec10;
    mat2 test_mat12 = mat2(test_vec2, 0.01, 0.01);
    mat2 test_mat13 = mat2(0.01, 5., test_vec2);
    mat2 test_mat15 = mat2(0.1, 5., test_vec2 );
    float freq1[2];
    float freq2[25];
    for (int i=0; i<100; i++)
    {
      if (test_float1 < 1.0)
      {
      }
      else
      {
        break;
      }
    }
    freq2[1] = 1.9 ;
    const int array_index = 2;
    freq2[const_test_int1] = 1.9 ;
    freq2[array_index] = 1.8;
    const int const_int = 5;
    test_float1 = varying_flt;
    int out_int;
    int intArray[6];
    test_function(test_int1, test_int1);
    test_function(test_int1, intArray[2]);
    vec3 vv = vec3(test_function1(test_int1, out_int));
    bool bool_var = true;
    int test_int6 = int(bool_var);
    test_float1 = float(bool_var);
    test_float1 = float(test_int6);
    test_int6 = int(test_float1);
    bool_var = bool(test_int6);
    bool_var = bool(test_float1);
    test_float1 = float(test_vec9);
    test_vec2.x = 1.2;
    test_vec2.y = 1.4;
    test_vec2.xy;
    color.zy = test_vec2;
   test_vec2[1] = 1.1;
     test_mat2[0][0] = 1.1;
    test_float1 += 1.0;
    test_float1 -= 1.0;
    test_float1 *= 1.0;
    test_float1 /= 1.0;
    test_mat12 *= test_mat13 ;
    test_mat12  *= test_float1;
    test_vec2 *= test_float1;
    test_vec2 *= test_mat12;
    test_float1++;
    test_float1--;
    --test_float1;
    ++test_float1;
    test_float1;
    test_int1++;
    test_int1--;
    test_vec2 = test_vec2 + test_float1;
    test_vec2 = test_float1 + test_vec2;
    test_mat12 = test_mat12 * test_mat13;
    test_vec2 = test_vec2 * test_vec5;
    test_vec2++;
    test_mat2++;
    bool test_bool2 = test_float2 > test_float3;
    bool test_bool3 = test_int1 > test_int6 ;
    test_bool3 = test_vec2 == test_vec5;
    test_bool2 = test_bool3 && test_bool4;
    test_bool2 = test_bool3 || test_bool4;
    test_bool2 = test_bool3 ^^ test_bool4;
    test_bool2 = !test_bool3;
    test_bool3 = !(test_int1 > test_int6) ;
    test_float1 = test_int1 > test_int6 ? test_float2 : test_float3;
    test_vec2 = test_int1 > test_int6 ? test_vec2 : test_vec5;
    if(test_bool2)
        test_float1++;
    else
	test_float1--;
    if(test_float1 > test_float2)
        test_float1++;
    if( test_bool2 )
    {
        int if_int;
        test_float1++;
    }
    if(test_bool2)
       if(test_bool3)
           if(test_bool3)
	      test_float1++;
   for(int for_int=0; for_int < 5; for_int++)
   {
   }
   for(int x1=0; x1 < 10; x1++)
   {
     if (!test_bool2)
       break;
     int for_int;
   }
   for(int x2=-10; x2 < 100; x2++)
   {
     test_bool2 = (test_float1 > test_float2);
     if (!test_bool2)
       break;
   }
   for(int for_int1 = 0; for_int1 < 100; for_int1++)
   {
     if (!test_bool2)
       break;
     int for_int;
   }
   for(int for_int1 = 0; for_int1 < 100; for_int1++)
   {
     if (!test_bool2)
       continue;
     int for_int;
   }
   for(int i=0; i<100; i++)
   {
     if (!(test_float1 > test_float2))
     {
       break;
     }
     break;
     continue;
   }
   for(int i=0; i<100; i++)
   {
     if (!test_bool2)
       break;
     break;
   }
   for (int i=0; i<100; i++)
   {
     int dowhile_int;
     dowhile_int = 3;
     if (!test_bool2)
       break;
   }
    gl_Position = vec4(2.0, 3.0, 1.0, 1.1);
    gl_Position = gtf_Vertex;
    vec4 builtInV4 = gtf_Color + gtf_SecondaryColor + gtf_Vertex + gtf_MultiTexCoord0 + gtf_MultiTexCoord1 + gtf_MultiTexCoord2 +  gtf_MultiTexCoord3;
    int builtInI = gtf_MaxLights + gtf_MaxClipPlanes + gtf_MaxTextureUnits + gtf_MaxTextureCoords + gtf_MaxVertexAttribs + gtf_MaxVertexUniformComponents + gtf_MaxVaryingFloats + gtf_MaxVertexTextureImageUnits + gtf_MaxCombinedTextureImageUnits + gtf_MaxTextureImageUnits + gtf_MaxFragmentUniformComponents + gtf_MaxDrawBuffers ;
    mat4 builtInM4 = gtf_ModelViewMatrix + gtf_ModelViewProjectionMatrix + gtf_ProjectionMatrix;
    gtf_NormalMatrix;
    gtf_TextureMatrix[gtf_MaxTextureCoords-1];
    gtf_TextureMatrix;
    gtf_DepthRange.near ;
    test_float1 = gtf_DepthRange.near;
    test_float1 = gtf_DepthRange.far;
    test_float1 = gtf_DepthRange.diff;
    gtf_Point.size;
    gtf_Point.sizeMin;
    gtf_Point.sizeMax;
    gtf_Point.fadeThresholdSize ;
    gtf_Point.distanceConstantAttenuation;
    gtf_Point.distanceLinearAttenuation ;
    gtf_Point.distanceQuadraticAttenuation;
    gtf_MaterialParameters test;
    gtf_FrontMaterial.emission;
    color = gtf_FrontMaterial.emission;
    color = gtf_FrontMaterial.ambient;
    color = gtf_FrontMaterial.diffuse;
    color = gtf_FrontMaterial.specular;
    test_float1 = gtf_FrontMaterial.shininess;
    gtf_LightSourceParameters lightSource;
    float builtInFloat1 = gtf_LightSource[0].spotExponent;
    color = gtf_LightSource[0].ambient;
    color = lightSource.ambient;
    color = lightSource.diffuse;
    color = lightSource.specular;
    color = lightSource.position;
    color = lightSource.halfVector;
    color4 = lightSource.spotDirection;
    test_float1 = lightSource.spotExponent;
    test_float1 = lightSource.spotCutoff;
    test_float1 = lightSource.spotCosCutoff;
    test_float1 = lightSource.constantAttenuation;
    test_float1 = lightSource.linearAttenuation;
    test_float1 = lightSource.quadraticAttenuation;
    color = gtf_LightModel.ambient;
    gtf_LightModelParameters lightModel;
    color = gtf_LightModel.ambient;
    color = lightModel.ambient;
    color = gtf_FrontLightModelProduct.sceneColor ;
    gtf_LightModelProducts lightModelProd;
    color = lightModelProd.sceneColor;
    color = gtf_FrontLightModelProduct.sceneColor;
    color = gtf_FrontLightProduct[0].ambient;
    color = gtf_FrontLightProduct[0].ambient;
    gtf_LightProducts lightProd;
    color =  lightProd.ambient;
    color =  lightProd.diffuse;
    color =  lightProd.specular;
    test_float1 = gtf_Fog.density ;
    test_float1 = gtf_Fog.start ;
    test_float1 = gtf_Fog.end  ;
    test_float1 = gtf_Fog.scale ;
    color = gtf_Fog.color ;
    gtf_FrontColor =  vec4(1.0, 1.0, 1.0, 1.0);
    gtf_BackColor =  vec4(1.0, 1.0, 1.0, 1.0);
    gtf_FrontSecondaryColor =  vec4(1.0, 1.0, 1.0, 1.0);
    gtf_BackSecondaryColor =  vec4(1.0, 1.0, 1.0, 1.0);
    gtf_TexCoord[0] =  vec4(1.0, 1.0, 1.0, 1.0);
    gtf_FogFragCoord =  vec4(1.0, 1.0, 1.0, 1.0);
}
void test_function(const in int in_int, inout int out_int)
{
    out_int = 5;
    int i = 5;
    return ;
}
int test_function1(in int in_int1, inout int in_out_int)
{
   float ff;
   in_int1 = 5;
   return in_int1;
}
void test_function3(light3 ll)
{
    ll.i = 5.0;
    varying_flt = 1.2;
}
void test_function4(light5 ll20)
{
    ll20.i = 10.0;
}
void test_function5(light1 struct_light1)
{
    struct_light1.light2.a = 1;
    light5 ll5;
    struct_light1.light2.f = ll5.i;
    struct_light1.light2.f++;
    struct_light1.light2.a++;
}
light6 test_function6(int a)
{
    int x;
    light6 funcStruct;
    light7 funcStruct1;
    -x;
    x = x - x ;
    mat2 m;
    m++;
    -m;
    (m)++;
    return funcStruct;
}
float test_function7(light1 ll1, int light1 )
{
    float f;
    struct ss1 {
        int a;
    };
    return float(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nstruct gtf_MaterialParameters\n{\nvec4 emission;\nvec4 ambient;\nvec4 diffuse;\nvec4 specular;\nfloat shininess;\n};\nstruct gtf_LightSourceParameters\n{\nvec4 ambient;\nvec4 diffuse;\nvec4 specular;\nvec4 position;\nvec4 halfVector;\nvec3 spotDirection;\nfloat spotExponent;\nfloat spotCutoff;\nfloat spotCosCutoff;\nfloat constantAttenuation;\nfloat linearAttenuation;\nfloat quadraticAttenuation;\n};\nstruct gtf_PointParameters {\nfloat size;\nfloat sizeMin;\nfloat sizeMax;\nfloat fadeThresholdSize;\nfloat distanceConstantAttenuation;\nfloat distanceLinearAttenuation;\nfloat distanceQuadraticAttenuation;\n};\nstruct gtf_DepthRangeParameters {\nfloat near;\nfloat far;\nfloat diff;\n};\nstruct gtf_LightModelParameters {\nvec4 ambient;\n};\nstruct gtf_LightModelProducts {\nvec4 sceneColor;\n};\nstruct gtf_LightProducts {\nvec4 ambient;\nvec4 diffuse;\nvec4 specular;\n};\nstruct gtf_FogParameters {\nvec4 color;\nfloat density;\nfloat start;\nfloat end;\nfloat scale;\n};\nuniform int gtf_MaxFragmentUniformComponents;\nuniform int gtf_MaxVertexUniformComponents;\nuniform int gtf_MaxVertexTextureImageUnits;\nuniform int gtf_MaxLights;\nuniform int gtf_MaxClipPlanes;\nuniform int gtf_MaxCombinedTextureImageUnits;\nuniform int gtf_MaxTextureCoords;\nuniform int gtf_MaxVertexAttribs;\nuniform int gtf_MaxVaryingFloats;\nuniform int gtf_MaxTextureUnits;\nuniform int gtf_MaxDrawBuffers;\nuniform int gtf_MaxTextureImageUnits;\nuniform gtf_LightProducts gtf_FrontLightProduct[8];\nuniform gtf_LightModelProducts gtf_FrontLightModelProduct;\nuniform gtf_DepthRangeParameters gtf_DepthRange;\nuniform gtf_FogParameters gtf_Fog;\nuniform gtf_PointParameters gtf_Point;\nuniform gtf_LightModelParameters gtf_LightModel;\nvarying vec4 gtf_FogFragCoord;\nvarying vec4 gtf_BackColor;\nvarying vec4 gtf_BackSecondaryColor;\nvarying vec4 gtf_FrontSecondaryColor;\nvarying vec4 gtf_TexCoord[2];\nvarying vec4 gtf_FrontColor;\nuniform gtf_MaterialParameters gtf_FrontMaterial;\nuniform gtf_LightSourceParameters gtf_LightSource[8];\nattribute vec4 gtf_MultiTexCoord1;\nattribute vec4 gtf_MultiTexCoord2;\nattribute vec4 gtf_SecondaryColor;\nattribute vec4 gtf_Color;\nattribute vec4 gtf_MultiTexCoord3;\nattribute vec4 gtf_MultiTexCoord0;\nattribute vec4 gtf_Normal;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_NormalMatrix;\nuniform mat4 gtf_ProjectionMatrix;\nuniform mat4 gtf_TextureMatrix[8];\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid test_function(const in int in_int, inout int out_int);\nint test_function1(in int in_int1, inout int in_out_int);\nuniform float array_float[2];\nstruct nested\n{\n   int a;\n   float f;\n};\nstruct light1\n{\n   float intensity;\n   vec3 position;\n   int test_int[2];\n   nested light2;\n} lightVar;\nlight1 ll2;\nvoid Assign (out light1 out1, in light1 in1)\n{\n    out1.intensity = in1.intensity;\n     out1.position = in1.position;\n  out1.test_int[0] = in1.test_int[0];\n  out1.test_int[1] = in1.test_int[1];\n       out1.light2 = in1.light2;\n}\nstruct light3 {\n    float i;\n};\nstruct light4 {\n    float i;\n};\nstruct light5 {\n    float i ;\n    float a[2];\n} light5_inst;\nuniform light3 uniformLight3;\nstruct light6 {\n    float i;\n};\nuniform light6 uniformLight6;\nstruct slight10{\n     float f;\n     };\nstruct slight9{\n     slight10 light10;\n     };\nstruct slight8{\n     slight9 light9;\n     };\nstruct light7 {\n  slight8 light8;\n} ;\nlight3 struct_var = light3(5.0);\nattribute float flt_attrib;\nattribute vec2 vec2_attrib;\nattribute vec3 vec3_attrib;\nattribute vec4 vec4_attrib;\nattribute mat2 mat2_attrib;\nattribute mat3 mat3_attrib;\nattribute mat4 mat4_attrib;\nuniform float flt_uniform;\nuniform vec3 uniform_vec3;\nuniform mat3 uniform_mat3;\nuniform sampler2D samp[3];\nuniform sampler2D samp1;\nconst struct light12 {\n    int a;\n} uniform_struct = light12(2);\nvarying vec3 varying_vec3;\nvarying vec2 varying_vec2;\nvarying vec4 varying_vec4;\nvarying mat4 varying_mat4;\nvarying mat2 varying_mat2;\nvarying mat3 varying_mat3;\nvarying float varying_flt;\nfloat frequencies[2];\nvoid test_function2(int func_int)\n{\n}\nvoid test_function3(light3);\nvoid test_function4(light5 ll20);\nvoid test_function5(light1);\nlight6 test_function6(int a);\nconst float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;\nconst bool BoolConst1 = true && true || false;\nconst bool BoolConst2 = false || !false && false;\nvoid main()\n{\n    int test_int1 = 2;\n    const int const_test_int1 = 2;\n    struct structMain {\n        float i;\n    } testStruct;\n    struct {\n        structMain a;\n    } aStruct;\n    testStruct.i = 5.0 ;\n    struct_var.i = 5.0;\n    structMain newStruct, newStruct1;\n    testStruct = newStruct;\n    newStruct = newStruct1;\n    lightVar.light2.f = 1.1;\n    light1 ll1;\n    ll1.light2.a = 1;\n     const struct const_struct {\n        float i;\n    } const_struct_inst = const_struct(1.0);\n    Assign (ll1, ll2);\n    ll1.light2 = ll2.light2;\n    ll1.light2 = ll1.light2;\n    ll1.light2.f = ll2.light2.f;\n    ll1.light2.f = ll1.light2.f;\n    Assign (lightVar, ll2);\n    Assign (ll2, lightVar);\n    light5 ll10;\n    light7 ll7[4];\n    structMain newStruct2[2];\n    newStruct2[0].i = 1.1;\n    ll7[0].light8.light9.light10.f = 1.1;\n    bool test_bool4 = false ;\n    bool test_bool5 = 1.2 > 3.0 ;\n    int test_int2 =  047;\n    int test_int4 =  0xa8;\n    float test_float1 = 1.5;\n    float test_float2 = .01;\n    float test_float3 = 10.;\n    float test_float4 = 10.01;\n    float test_float5 = 23e+2;\n    float test_float6 = 23E-3;\n    float test_float8 = 23E2;\n    bool test_bool6 = BoolConst1 && ! (test_int1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (test_float1 != 0.0);\n    vec4 color = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 color2 = vec4(0.0);\n    vec3 color4 = vec3(test_float8);\n    ivec4 test_int_vect1 = ivec4(1.0,1.0,1.0,1.0);\n    ivec3 test_int_vec3 = ivec3(1, 1, 1) ;\n    bvec4 test_bool_vect1 = bvec4(1., 1., 1. , 1. );\n    vec2 test_vec2 = vec2(1., 1.);\n    vec2 test_vec3 = vec2(1., 1);\n    vec4 test_vec4 = vec4(test_int_vect1);\n    vec2 test_vec5 = vec2(color4);\n    vec3 test_vec7 = vec3(color);\n    vec3 test_vec8 = vec3(test_vec2, test_float4);\n    vec3 test_vec9 = vec3(test_float4, test_vec2);\n    vec4 test_vec10 = vec4(test_vec9, 0.01);\n    vec4 test_vec11 = vec4(0.01, test_vec9);\n    vec4 test_vec12 = vec4(test_vec2, test_vec2);\n    mat2 test_mat2 = mat2(test_float3);\n    mat3 test_mat3 = mat3(test_float3);\n    mat4 test_mat4 = mat4(test_float3);\n    mat2 test_mat7 = mat2(test_vec2, test_vec2);\n    mat2 test_mat8 = mat2(01.01, 2.01, 3.01, 4.01);\n    mat3 test_mat9 = mat3(test_vec7, test_vec7, test_vec7);\n    mat4 test_mat10 = mat4(test_vec10, test_vec10, test_vec10, test_vec10);\n    test_mat10[1] = test_vec10;\n    mat2 test_mat12 = mat2(test_vec2, 0.01, 0.01);\n    mat2 test_mat13 = mat2(0.01, 5., test_vec2);\n    mat2 test_mat15 = mat2(0.1, 5., test_vec2 );\n    float freq1[2];\n    float freq2[25];\n    for (int i=0; i<100; i++)\n    {\n      if (test_float1 < 1.0)\n      {\n      }\n      else\n      {\n        break;\n      }\n    }\n    freq2[1] = 1.9 ;\n    const int array_index = 2;\n    freq2[const_test_int1] = 1.9 ;\n    freq2[array_index] = 1.8;\n    const int const_int = 5;\n    test_float1 = varying_flt;\n    int out_int;\n    int intArray[6];\n    test_function(test_int1, test_int1);\n    test_function(test_int1, intArray[2]);\n    vec3 vv = vec3(test_function1(test_int1, out_int));\n    bool bool_var = true;\n    int test_int6 = int(bool_var);\n    test_float1 = float(bool_var);\n    test_float1 = float(test_int6);\n    test_int6 = int(test_float1);\n    bool_var = bool(test_int6);\n    bool_var = bool(test_float1);\n    test_float1 = float(test_vec9);\n    test_vec2.x = 1.2;\n    test_vec2.y = 1.4;\n    test_vec2.xy;\n    color.zy = test_vec2;\n   test_vec2[1] = 1.1;\n     test_mat2[0][0] = 1.1;\n    test_float1 += 1.0;\n    test_float1 -= 1.0;\n    test_float1 *= 1.0;\n    test_float1 /= 1.0;\n    test_mat12 *= test_mat13 ;\n    test_mat12  *= test_float1;\n    test_vec2 *= test_float1;\n    test_vec2 *= test_mat12;\n    test_float1++;\n    test_float1--;\n    --test_float1;\n    ++test_float1;\n    test_float1;\n    test_int1++;\n    test_int1--;\n    test_vec2 = test_vec2 + test_float1;\n    test_vec2 = test_float1 + test_vec2;\n    test_mat12 = test_mat12 * test_mat13;\n    test_vec2 = test_vec2 * test_vec5;\n    test_vec2++;\n    test_mat2++;\n    bool test_bool2 = test_float2 > test_float3;\n    bool test_bool3 = test_int1 > test_int6 ;\n    test_bool3 = test_vec2 == test_vec5;\n    test_bool2 = test_bool3 && test_bool4;\n    test_bool2 = test_bool3 || test_bool4;\n    test_bool2 = test_bool3 ^^ test_bool4;\n    test_bool2 = !test_bool3;\n    test_bool3 = !(test_int1 > test_int6) ;\n    test_float1 = test_int1 > test_int6 ? test_float2 : test_float3;\n    test_vec2 = test_int1 > test_int6 ? test_vec2 : test_vec5;\n    if(test_bool2)\n        test_float1++;\n    else\n\ttest_float1--;\n    if(test_float1 > test_float2)\n        test_float1++;\n    if( test_bool2 )\n    {\n        int if_int;\n        test_float1++;\n    }\n    if(test_bool2)\n       if(test_bool3)\n           if(test_bool3)\n\t      test_float1++;\n   for(int for_int=0; for_int < 5; for_int++)\n   {\n   }\n   for(int x1=0; x1 < 10; x1++)\n   {\n     if (!test_bool2)\n       break;\n     int for_int;\n   }\n   for(int x2=-10; x2 < 100; x2++)\n   {\n     test_bool2 = (test_float1 > test_float2);\n     if (!test_bool2)\n       break;\n   }\n   for(int for_int1 = 0; for_int1 < 100; for_int1++)\n   {\n     if (!test_bool2)\n       break;\n     int for_int;\n   }\n   for(int for_int1 = 0; for_int1 < 100; for_int1++)\n   {\n     if (!test_bool2)\n       continue;\n     int for_int;\n   }\n   for(int i=0; i<100; i++)\n   {\n     if (!(test_float1 > test_float2))\n     {\n       break;\n     }\n     break;\n     continue;\n   }\n   for(int i=0; i<100; i++)\n   {\n     if (!test_bool2)\n       break;\n     break;\n   }\n   for (int i=0; i<100; i++)\n   {\n     int dowhile_int;\n     dowhile_int = 3;\n     if (!test_bool2)\n       break;\n   }\n    gl_Position = vec4(2.0, 3.0, 1.0, 1.1);\n    gl_Position = gtf_Vertex;\n    vec4 builtInV4 = gtf_Color + gtf_SecondaryColor + gtf_Vertex + gtf_MultiTexCoord0 + gtf_MultiTexCoord1 + gtf_MultiTexCoord2 +  gtf_MultiTexCoord3;\n    int builtInI = gtf_MaxLights + gtf_MaxClipPlanes + gtf_MaxTextureUnits + gtf_MaxTextureCoords + gtf_MaxVertexAttribs + gtf_MaxVertexUniformComponents + gtf_MaxVaryingFloats + gtf_MaxVertexTextureImageUnits + gtf_MaxCombinedTextureImageUnits + gtf_MaxTextureImageUnits + gtf_MaxFragmentUniformComponents + gtf_MaxDrawBuffers ;\n    mat4 builtInM4 = gtf_ModelViewMatrix + gtf_ModelViewProjectionMatrix + gtf_ProjectionMatrix;\n    gtf_NormalMatrix;\n    gtf_TextureMatrix[gtf_MaxTextureCoords-1];\n    gtf_TextureMatrix;\n    gtf_DepthRange.near ;\n    test_float1 = gtf_DepthRange.near;\n    test_float1 = gtf_DepthRange.far;\n    test_float1 = gtf_DepthRange.diff;\n    gtf_Point.size;\n    gtf_Point.sizeMin;\n    gtf_Point.sizeMax;\n    gtf_Point.fadeThresholdSize ;\n    gtf_Point.distanceConstantAttenuation;\n    gtf_Point.distanceLinearAttenuation ;\n    gtf_Point.distanceQuadraticAttenuation;\n    gtf_MaterialParameters test;\n    gtf_FrontMaterial.emission;\n    color = gtf_FrontMaterial.emission;\n    color = gtf_FrontMaterial.ambient;\n    color = gtf_FrontMaterial.diffuse;\n    color = gtf_FrontMaterial.specular;\n    test_float1 = gtf_FrontMaterial.shininess;\n    gtf_LightSourceParameters lightSource;\n    float builtInFloat1 = gtf_LightSource[0].spotExponent;\n    color = gtf_LightSource[0].ambient;\n    color = lightSource.ambient;\n    color = lightSource.diffuse;\n    color = lightSource.specular;\n    color = lightSource.position;\n    color = lightSource.halfVector;\n    color4 = lightSource.spotDirection;\n    test_float1 = lightSource.spotExponent;\n    test_float1 = lightSource.spotCutoff;\n    test_float1 = lightSource.spotCosCutoff;\n    test_float1 = lightSource.constantAttenuation;\n    test_float1 = lightSource.linearAttenuation;\n    test_float1 = lightSource.quadraticAttenuation;\n    color = gtf_LightModel.ambient;\n    gtf_LightModelParameters lightModel;\n    color = gtf_LightModel.ambient;\n    color = lightModel.ambient;\n    color = gtf_FrontLightModelProduct.sceneColor ;\n    gtf_LightModelProducts lightModelProd;\n    color = lightModelProd.sceneColor;\n    color = gtf_FrontLightModelProduct.sceneColor;\n    color = gtf_FrontLightProduct[0].ambient;\n    color = gtf_FrontLightProduct[0].ambient;\n    gtf_LightProducts lightProd;\n    color =  lightProd.ambient;\n    color =  lightProd.diffuse;\n    color =  lightProd.specular;\n    test_float1 = gtf_Fog.density ;\n    test_float1 = gtf_Fog.start ;\n    test_float1 = gtf_Fog.end  ;\n    test_float1 = gtf_Fog.scale ;\n    color = gtf_Fog.color ;\n    gtf_FrontColor =  vec4(1.0, 1.0, 1.0, 1.0);\n    gtf_BackColor =  vec4(1.0, 1.0, 1.0, 1.0);\n    gtf_FrontSecondaryColor =  vec4(1.0, 1.0, 1.0, 1.0);\n    gtf_BackSecondaryColor =  vec4(1.0, 1.0, 1.0, 1.0);\n    gtf_TexCoord[0] =  vec4(1.0, 1.0, 1.0, 1.0);\n    gtf_FogFragCoord =  vec4(1.0, 1.0, 1.0, 1.0);\n}\nvoid test_function(const in int in_int, inout int out_int)\n{\n    out_int = 5;\n    int i = 5;\n    return ;\n}\nint test_function1(in int in_int1, inout int in_out_int)\n{\n   float ff;\n   in_int1 = 5;\n   return in_int1;\n}\nvoid test_function3(light3 ll)\n{\n    ll.i = 5.0;\n    varying_flt = 1.2;\n}\nvoid test_function4(light5 ll20)\n{\n    ll20.i = 10.0;\n}\nvoid test_function5(light1 struct_light1)\n{\n    struct_light1.light2.a = 1;\n    light5 ll5;\n    struct_light1.light2.f = ll5.i;\n    struct_light1.light2.f++;\n    struct_light1.light2.a++;\n}\nlight6 test_function6(int a)\n{\n    int x;\n    light6 funcStruct;\n    light7 funcStruct1;\n    -x;\n    x = x - x ;\n    mat2 m;\n    m++;\n    -m;\n    (m)++;\n    return funcStruct;\n}\nfloat test_function7(light1 ll1, int light1 )\n{\n    float f;\n    struct ss1 {\n        int a;\n    };\n    return float(1);\n}\n\x00')
59.876543209876544
Processing this: /home/oof/webgl_cleaned/structcopy_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
void main ()
{
	sabcd s = sabcd(1.0, 2.0, 4.0, 8.0);
	sabcd s2 = sabcd(0.0, 0.0, 0.0, 0.0);
	s2 = s;
	color = vec4((s.a + s.b + s.c + s.d) / 15.0, (s2.a + s2.b + s2.c + s2.d) / 15.0, 1.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(1.0, 2.0, 4.0, 8.0);\n\tsabcd s2 = sabcd(0.0, 0.0, 0.0, 0.0);\n\ts2 = s;\n\tcolor = vec4((s.a + s.b + s.c + s.d) / 15.0, (s2.a + s2.b + s2.c + s2.d) / 15.0, 1.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

void main()
{
  sabcd s = sabcd(1.0 , 2.0 , 4.0 , 8.0);
  sabcd s2 = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  s2 = s;
  color = vec4(((((s.a + s.b) + s.c) + s.d) / 15.0) , ((((s2.a + s2.b) + s2.c) + s2.d) / 15.0) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.92601726263872
Processing this: /home/oof/webgl_cleaned/sign_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 2.0 * (gtf_Color.r - 0.5);
	color = vec4(c * sign(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(c * sign(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  color = vec4((c * sign(c)) , 0.0 , 0.0 , 1.0);
  gtf_ModelViewProjectionMatrix = (gtf_ModelViewProjectionMatrix * gtf_Color);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'assign' : l-value required (can't modify a uniform "gtf_ModelViewProjectionMatrix")
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'uniform mediump 4X4 matrix of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (2.0 * (gtf_Color.r - 0.5));
  color = vec4((c * sign(c)) , 0.0 , 0.0 , 1.0);
  gtf_ModelViewProjectionMatrix = (gtf_ModelViewProjectionMatrix * gtf_Color);
}


==============================
59.85221674876847
Mutations attempted: 812
Valid mutations:     486
Success rate:        59.85%
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.85221674876847
Processing this: /home/oof/webgl_cleaned/prefixdecrement_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m=23;
	int k = --m;
	float gray;
	if( (k==22) && (m==22) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m=23;\n\tint k = --m;\n\tfloat gray;\n\tif( (k==22) && (m==22) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex[2] = vec4(-0.5, 0.5, -0.5, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 23;
  int k = --m;
  float gray;
  if (((k == 22) && (m == 22)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: '=' : array / non-array mismatch
ERROR: 0:4: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[2] of 4-component vector of float'
ERROR: 0:20: '*' : array / non-array mismatch
ERROR: 0:20: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[2] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:20: '=' : dimension mismatch
ERROR: 0:20: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex[2] = vec4(-0.5, 0.5, -0.5, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 23;
  int k = --m;
  float gray;
  if (((k == 22) && (m == 22)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.77859778597786
Processing this: /home/oof/webgl_cleaned/23i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec3 color[2];
void main ()
{
	float r = float(color[0][0] + color[0][1] + color[0][2]);
	float g = float(color[1][0] + color[1][1] + color[1][2]);
	gl_FragColor = vec4(r/256.0, g/256.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform ivec3 color[2];\nvoid main ()\n{\n\tfloat r = float(color[0][0] + color[0][1] + color[0][2]);\n\tfloat g = float(color[1][0] + color[1][1] + color[1][2]);\n\tgl_FragColor = vec4(r/256.0, g/256.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform ivec3 color[2] = ivec3[2](ivec3(2.0, 2.0, 2.0), ivec3(-1.0, 1.0, 1.0));

void main()
{
  float r = float(((color[0][0] + color[0][1]) + color[0][2]));
  float g = float(((color[1][0] + color[1][1]) + color[1][2]));
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform ivec3 color[2] = ivec3[2](ivec3(2.0, 2.0, 2.0), ivec3(-1.0, 1.0, 1.0));

void main()
{
  float r = float(((color[0][0] + color[0][1]) + color[0][2]));
  float g = float(((color[1][0] + color[1][1]) + color[1][2]));
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


==============================
59.7051597051597
Processing this: /home/oof/webgl_cleaned/float_empty_inout_float_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(inout float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(inout float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(inout float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(inout float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
59.7051597051597
Processing this: /home/oof/webgl_cleaned/mat2_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat2 a = mat2(1.0, 2.0,
	              4.0, 8.0);
	mat2 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 8.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = b[0][1] + b[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = b[1][0] + b[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat2 a = mat2(1.0, 2.0,\n\t              4.0, 8.0);\n\tmat2 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.75460122699386
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(in mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_ones) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(in mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(in mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_ones) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(in mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
59.75460122699386
Processing this: /home/oof/webgl_cleaned/intUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform int ival;
uniform ivec2 ival2;
uniform ivec3 ival3;
uniform ivec4 ival4;
void main()
{
    int sum = ival
            + ival2[0] + ival2[1]
            + ival3[0] + ival3[1] + ival3[2]
            + ival4[0] + ival4[1] + ival4[2] + ival4[3];
    gl_Position = vec4(sum, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform int ival;\nuniform ivec2 ival2;\nuniform ivec3 ival3;\nuniform ivec4 ival4;\nvoid main()\n{\n    int sum = ival\n            + ival2[0] + ival2[1]\n            + ival3[0] + ival3[1] + ival3[2]\n            + ival4[0] + ival4[1] + ival4[2] + ival4[3];\n    gl_Position = vec4(sum, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2 = ivec2(3, ((true || !true) ? 4 : ((true ? false : true) ? +ival : 2)));

uniform ivec3 ival3;

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2 = ivec2(3, ((true || !true) ? 4 : ((true ? false : true) ? +ival : 2)));

uniform ivec3 ival3;

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


==============================
59.681372549019606
Processing this: /home/oof/webgl_cleaned/structcopy_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec3 a;
	vec3 b;
};
void main ()
{
	sabcd s1 = sabcd(vec3(12.0, 29.0, 32.0), vec3(13.0, 26.0, 38.0 ) );
	sabcd s2 = sabcd(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0 ) );
	s2 = s1;
	color = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.b[0] + s2.b[1] + s2.b[2]) / 150.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec3 a;\n\tvec3 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec3(12.0, 29.0, 32.0), vec3(13.0, 26.0, 38.0 ) );\n\tsabcd s2 = sabcd(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0 ) );\n\ts2 = s1;\n\tcolor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.b[0] + s2.b[1] + s2.b[2]) / 150.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 2.0, 2.0, 2.0, (true ? 2.0 : 2.0), (true ? ((true && false) ? (2.0 - -1.0) : -1.0) : ((true ? 1.0 : 2.0) * --1.0)), 1.0, 0.0, ((true && (false ? true : true)) ? +0.0 : (true ? (2.0 / 2.0) : (false ? 0.5 : 0.0))), -1.0, 2.0, -1.0, 1.0, (1.0 * 0.5), 0.0, (!(true || false) ? -1.0 : (1.0 / 2.0)));

vec4 color;

struct sabcd {
  vec3 a;
  vec3 b;
};

void main()
{
  sabcd s1 = sabcd(vec3(12.0 , 29.0 , 32.0) , vec3(13.0 , 26.0 , 38.0));
  sabcd s2 = sabcd(vec3(0.0 , 0.0 , 0.0) , vec3(0.0 , 0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((((s2.a[0] + s2.a[1]) + s2.a[2]) + s2.b[0]) + s2.b[1]) + s2.b[2]) / 150.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 2.0, 2.0, 2.0, (true ? 2.0 : 2.0), (true ? ((true && false) ? (2.0 - -1.0) : -1.0) : ((true ? 1.0 : 2.0) * --1.0)), 1.0, 0.0, ((true && (false ? true : true)) ? +0.0 : (true ? (2.0 / 2.0) : (false ? 0.5 : 0.0))), -1.0, 2.0, -1.0, 1.0, (1.0 * 0.5), 0.0, (!(true || false) ? -1.0 : (1.0 / 2.0)));

vec4 color;

struct sabcd {
  vec3 a;
  vec3 b;
};

void main()
{
  sabcd s1 = sabcd(vec3(12.0 , 29.0 , 32.0) , vec3(13.0 , 26.0 , 38.0));
  sabcd s2 = sabcd(vec3(0.0 , 0.0 , 0.0) , vec3(0.0 , 0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((((s2.a[0] + s2.a[1]) + s2.a[2]) + s2.b[0]) + s2.b[1]) + s2.b[2]) / 150.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.60832313341493
Processing this: /home/oof/webgl_cleaned/structnest_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	float b;
};
struct nesta
{
	float a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(1.0, nestb(2.0)));
	color = vec4(vec3((s.nest_a.a + s.nest_a.nest_b.b) / 3.0), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tfloat b;\n};\nstruct nesta\n{\n\tfloat a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(1.0, nestb(2.0)));\n\tcolor = vec4(vec3((s.nest_a.a + s.nest_a.nest_b.b) / 3.0), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  float bx;
};

struct nesta {
  float a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(1.0 , nestb(2.0)));
  color = vec4(vec3(((s.nest_a.a + s.nest_a.nest_b.b) / 3.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:26: 'b' :  no such field in structure
ERROR: 0:26: '+' : Invalid operation for structs
ERROR: 0:26: '+' : wrong operand types - no operation '+' exists that takes a left-hand operand of type 'mediump float' and a right operand of type 'structure 'nestb' (symbol id 3004)' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  float bx;
};

struct nesta {
  float a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(1.0 , nestb(2.0)));
  color = vec4(vec3(((s.nest_a.a + s.nest_a.nest_b.b) / 3.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.535452322738394
Processing this: /home/oof/webgl_cleaned/CorrectParse2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;
const bool BoolConst1 = true && true || false;
const bool BoolConst2 = false || !false && false;
void main ()
{
    float float1 = 4.0, float2 = floatConst2;
    int int_1 = int(FloatConst1);
    vec4 vec4_1;
    vec3 vec3_1 = vec3(1, 1, 1);
	vec3 vec3_2 = vec3(0, 0, 0);
    bool bool4, bool5;
    bool4 = bool5;
    bool4 = 4 > 5;
    bool4 = !(3.2 != 0.0);
    bool4 = bool(float1);
    bool4 = bool(int_1);
    float1 = float(bool4);
    float1 = float(int_1);
    int_1 = int(float1);
    int_1 = int(bool4);
    {
        int a, b, c;
        a = b;
        b = c;
        {
            int b, c, d;
            b = c;
            c = d;
            {
                int a, d, e;
                a = d;
                d = e;
            }
            {
                int a, b, c;
                a = b;
                b = c;
            }
        }
        a = b;
        b = c;
    }
    {
        float f1, f2;
        vec3 v31, v32;
        max(f1, f2);
        max(v31, v32);
        vec4 v4 = vec4(3.0);
        vec3 v3 = -vec3(2.0, 1.0, 3.0);
        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);
    }
    if (BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst1 || BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2 && BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (FloatConst1 != 0.0)
        --int_1;
    else
        ++int_1;
    if (0 != 0)
        ++int_1;
    else
        --int_1;
    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);
    float1 = 5 != 0 ? float1 : float(int_1);
    float1 = BoolConst1 ? float1 : float(int_1);
    if (float1 != float1)
        ++int_1;
    else
        --int_1;
    float1 = float1 != float1 ? float1 : float(int_1);
    --int_1;
    ++float1;
    (vec4_1.x)--;
    vec3_1++;
    if (vec3_1.x > vec3_2.x)
        float1 = 4.0 + 6.0;
    if (bool4 ^^ bool5)
        float1 *= 2.4;
    if (false ^^ false)
        float1 *= 2.5;
    if (true ^^ false)
        float1 *= 2.6;
    {
        int i;
    }
    if (bool4) {
        int i;
    } else {
        int i;
        i = 5;
    }
    mat4 m1;
    m1[2][1] = 4.0;
    gl_Position = vec4(float1+float1, float1, float1, float(int_1));
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nconst float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;\nconst bool BoolConst1 = true && true || false;\nconst bool BoolConst2 = false || !false && false;\nvoid main ()\n{\n    float float1 = 4.0, float2 = floatConst2;\n    int int_1 = int(FloatConst1);\n    vec4 vec4_1;\n    vec3 vec3_1 = vec3(1, 1, 1);\n\tvec3 vec3_2 = vec3(0, 0, 0);\n    bool bool4, bool5;\n    bool4 = bool5;\n    bool4 = 4 > 5;\n    bool4 = !(3.2 != 0.0);\n    bool4 = bool(float1);\n    bool4 = bool(int_1);\n    float1 = float(bool4);\n    float1 = float(int_1);\n    int_1 = int(float1);\n    int_1 = int(bool4);\n    {\n        int a, b, c;\n        a = b;\n        b = c;\n        {\n            int b, c, d;\n            b = c;\n            c = d;\n            {\n                int a, d, e;\n                a = d;\n                d = e;\n            }\n            {\n                int a, b, c;\n                a = b;\n                b = c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n    {\n        float f1, f2;\n        vec3 v31, v32;\n        max(f1, f2);\n        max(v31, v32);\n        vec4 v4 = vec4(3.0);\n        vec3 v3 = -vec3(2.0, 1.0, 3.0);\n        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);\n    }\n    if (BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst1 || BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2 && BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (FloatConst1 != 0.0)\n        --int_1;\n    else\n        ++int_1;\n    if (0 != 0)\n        ++int_1;\n    else\n        --int_1;\n    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);\n    float1 = 5 != 0 ? float1 : float(int_1);\n    float1 = BoolConst1 ? float1 : float(int_1);\n    if (float1 != float1)\n        ++int_1;\n    else\n        --int_1;\n    float1 = float1 != float1 ? float1 : float(int_1);\n    --int_1;\n    ++float1;\n    (vec4_1.x)--;\n    vec3_1++;\n    if (vec3_1.x > vec3_2.x)\n        float1 = 4.0 + 6.0;\n    if (bool4 ^^ bool5)\n        float1 *= 2.4;\n    if (false ^^ false)\n        float1 *= 2.5;\n    if (true ^^ false)\n        float1 *= 2.6;\n    {\n        int i;\n    }\n    if (bool4) {\n        int i;\n    } else {\n        int i;\n        i = 5;\n    }\n    mat4 m1;\n    m1[2][1] = 4.0;\n    gl_Position = vec4(float1+float1, float1, float1, float(int_1));\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = (3.0 * 8.0) , floatConst2 = 4.0;

const bool BoolConst1 = ((true && true) || false);

const bool BoolConst2 = (false || (!false && false));

void main()
{
  float float1 = 4.0 , float2 = floatConst2;
  int int_1 = int(FloatConst1);
  vec4 vec4_1;
  vec3 vec3_1 = vec3(1 , 1 , 1);
  vec3 vec3_2 = vec3(0 , 0 , 0);
  bool bool4, bool5;
  bool4 = bool5;
  bool4 = (4 > 5);
  bool4 = !(3.2 != 0.0);
  bool4 = bool(float1);
  bool4 = bool(int_1);
  float1 = float(bool4);
  float1 = float(int_1);
  int_1 = int(float1);
  int_1 = int(bool4);
  {
    int a, b, c;
    a = b;
    b = c;
    {
      int b, c, d;
      b = c;
      c = d;
      {
        int a, d, e;
        a = d;
        d = e;
      }
      {
        int a, b, c;
        a = b;
        b = c;
      }
    }
    a = b;
    b = c;
  }
  {
    float f1, f2;
    vec3 v31, v32;
    max(f1 , f2);
    max(v31 , v32);
    vec4 v4 = vec4(3.0);
    vec3 v3 = -vec3(2.0 , 1.0 , 3.0);
    mat2 m2 = mat2(3.0 , 4.0 , 6.0 , 3.0);
  }
  if (BoolConst1)
    ++vec3_1;
  else
    --vec3_1;
  if (BoolConst2)
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst1 || BoolConst2))
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst2 && BoolConst1))
    ++vec3_1;
  else
    --vec3_1;
  if ((FloatConst1 != 0.0))
    --int_1;
  else
    ++int_1;
  if ((0 != 0))
    ++int_1;
  else
    --int_1;
  bool4 = (((((BoolConst1 && !(int_1 != 0)) && !BoolConst1) && !(FloatConst1 != 0.0)) && (FloatConst1 != 0.0)) && (float1 != 0.0));
  (float1 = (5 != 0) ? float1 : float(int_1));
  (float1 = BoolConst1 ? float1 : float(int_1));
  if ((float1 != float1))
    ++int_1;
  else
    --int_1;
  (float1 = (float1 != float1) ? float1 : float(int_1));
  --int_1;
  ++float1;
  vec4_1.x--;
  vec3_1++;
  if ((vec3_1.x > vec3_2.x))
    float1 = (4.0 + 6.0);
  if ((bool4 ^^ bool5))
    (float1 *= 2.4);
  if ((false ^^ false))
    (float1 *= 2.5);
  if ((true ^^ false))
    (float1 *= 2.6);
  {
    int i;
  }
  if (bool4)
  {
    int i;
  }
  else
  {
    int i;
    i = 5;
  }
  mat4 m1;
  m1[2][1] = 4.0;
  gl_Position = vec4((float1 + float1) , float1 , float1 , float(int_1));
}


As vertex? : True
SUCCESS!
59.584859584859586
Mutations attempted: 819
Valid mutations:     488
Success rate:        59.58%
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = -color.rg;
	gl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? (1.0 * -1.0) : 0.0), 2.0, ((0.0 - (-1.0 + -1.0)) + (true ? (-1.0 - 1.0) : 1.0)), 0.0);

void main()
{
  vec2 c = -color.rg;
  gl_FragColor = vec4(exp2((5.0 * c)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.63414634146341
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
59.63414634146341
Processing this: /home/oof/webgl_cleaned/float_empty_empty_float_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(float par[3])
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return 1.0;
	}
	else
		return 0.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(float par[3])\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.63414634146341
Processing this: /home/oof/webgl_cleaned/mix_float_vert_xvary_yconsthalf_aconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float y = 0.5;
	const float a = 0.5;
	float c = gtf_Color.r;
	color = vec4(mix(c, y, a), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float y = 0.5;\n\tconst float a = 0.5;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(mix(c, y, a), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, (false ? 0.5 : 2.0), +((false ? 0.5 : 0.5) - 0.0), 0.0, (((false || false) ? !true : !true) ? ((false || false) ? -1.0 : -1.0) : 0.0), -0.0, (0.5 / 1.0), 0.0, ++0.0, 0.5, -1.0, -1.0, 1.0, +2.0, (1.0 + -1.0), 0.0);

vec4 color;

void main()
{
  const float y = 0.5;
  const float a = 0.5;
  float c = gtf_Color.r;
  color = vec4(mix(c , y , a) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, (false ? 0.5 : 2.0), +((false ? 0.5 : 0.5) - 0.0), 0.0, (((false || false) ? !true : !true) ? ((false || false) ? -1.0 : -1.0) : 0.0), -0.0, (0.5 / 1.0), 0.0, ++0.0, 0.5, -1.0, -1.0, 1.0, +2.0, (1.0 + -1.0), 0.0);

vec4 color;

void main()
{
  const float y = 0.5;
  const float a = 0.5;
  float c = gtf_Color.r;
  color = vec4(mix(c , y , a) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.561510353227774
Processing this: /home/oof/webgl_cleaned/vec4_yx_wz_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.yx;
	vec2 n = lightloc.wz;
	vec4 a = vec4(m.y, m.x, n.y, n.x);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.yx;\n\tvec2 n = lightloc.wz;\n\tvec4 a = vec4(m.y, m.x, n.y, n.x);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.0, (true ? (false ? (false ? 1.0 : 0.0) : -0.5) : ((2.0 + 0.0) - 0.5)), +(1.0 - -1.0), (true ? 1.0 : (-1.0 / +0.0)), ((true || true) ? 1.0 : 0.5), ((true ? 0.0 : (1.0 - 0.5)) * 0.0), (false ? 1.0 : -0.5), 2.0, 0.0, (1.0 / 0.5), ((false ? true : (true ? false : false)) ? +--1.0 : 0.0), 0.0, +0.5, 1.0, 2.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.yx;
  vec2 n = lightloc.wz;
  vec4 a = vec4(m.y , m.x , n.y , n.x);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.0, (true ? (false ? (false ? 1.0 : 0.0) : -0.5) : ((2.0 + 0.0) - 0.5)), +(1.0 - -1.0), (true ? 1.0 : (-1.0 / +0.0)), ((true || true) ? 1.0 : 0.5), ((true ? 0.0 : (1.0 - 0.5)) * 0.0), (false ? 1.0 : -0.5), 2.0, 0.0, (1.0 / 0.5), ((false ? true : (true ? false : false)) ? +--1.0 : 0.0), 0.0, +0.5, 1.0, 2.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.yx;
  vec2 n = lightloc.wz;
  vec4 a = vec4(m.y , m.x , n.y , n.x);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
59.48905109489051
Processing this: /home/oof/webgl_cleaned/smoothstep_float_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float edge0 = 0.25;
	const float edge1 = 0.75;
	color = vec4(smoothstep(edge0, edge1, gtf_Color.r), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge0 = 0.25;\n\tconst float edge1 = 0.75;\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.r), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((-2.0 / 0.0), ((false ? true : (false ? false : false)) ? -1.0 : (true ? 2.0 : (2.0 * 0.0))), 0.0, (+1.0 * 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float edge0 = 0.25;
  const float edge1 = 0.75;
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.r) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.53827460510328
Processing this: /home/oof/webgl_cleaned/unary_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = +23;
	int k = -m;
	bool a = false;
	bool b = !a;
	float gray;
	if( (m==23) && (k==-23) && (b) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = +23;\n\tint k = -m;\n\tbool a = false;\n\tbool b = !a;\n\tfloat gray;\n\tif( (m==23) && (k==-23) && (b) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int m = +23;
  int k = -m;
  bool a = false;
  bool b = !a;
  float gray;
  if ((((m == 23) && (k == -23)) && b))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.5873786407767
Processing this: /home/oof/webgl_cleaned/mat2_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat2 a = mat2(1.0, 2.0,
	              4.0, 8.0);
	mat2 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 8.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = b[0][1] + b[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = b[1][0] + b[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat2 a = mat2(1.0, 2.0,\n\t              4.0, 8.0);\n\tmat2 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-+(false ? 0.5 : 0.0), +0.5, (true ? 0.5 : (-0.5 * +0.0)), (!(true || true) ? 2.0 : -1.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.63636363636363
Processing this: /home/oof/webgl_cleaned/sin_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.rg))) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.68523002421308
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = (color.rgb * 99.0) + 1.0;
	gl_FragColor = vec4(1.0 / sqrt(c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (color.rgb * 99.0) + 1.0;\n\tgl_FragColor = vec4(1.0 / sqrt(c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((color.rgb * 99.0) + 1.0);
  gl_FragColor = vec4((1.0 / sqrt(c)));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((color.rgb * 99.0) + 1.0);
  gl_FragColor = vec4((1.0 / sqrt(c)));
}


==============================
59.6130592503023
Mutations attempted: 827
Valid mutations:     493
Success rate:        59.61%
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (((true && true) ? -1.0 : 2.0) / +(false ? 0.0 : 0.5)), (-1.0 - (true ? (false ? -1.0 : 0.5) : 0.5)), (false ? (-1.0 + +2.0) : ((false ? true : true) ? -2.0 : 0.5)));

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.66183574879227
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
59.66183574879227
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.71049457177322
Processing this: /home/oof/webgl_cleaned/log2_vec3_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const float ln2 = 0.69314718055994530941723212145818;
void main ()
{
	vec3 x = (gtf_Color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0 / ln2;
	color = vec4(y / -8.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst float ln2 = 0.69314718055994530941723212145818;\nvoid main ()\n{\n\tvec3 x = (gtf_Color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0 / ln2;\n\tcolor = vec4(y / -8.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

const float ln2 = 0.6931471805599453;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (-2.0 / ln2));
  color = vec4((y / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.75903614457832
Processing this: /home/oof/webgl_cleaned/pow_vec3_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 16.0 * gtf_Color.rgb;
	color = vec4(sqrt(c) / 4.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 16.0 * gtf_Color.rgb;\n\tcolor = vec4(sqrt(c) / 4.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((0.5 / -1.0), (true ? (1.0 - (0.5 - 1.0)) : 2.0), 1.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (16.0 * gtf_Color.rgb);
  color = vec4((sqrt(c) / 4.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.80746089049338
Processing this: /home/oof/webgl_cleaned/bvec4_empty_inout_bvec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec4 function(inout bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bvec4 function(inout bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec4 function(inout bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbvec4 function(inout bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
59.80746089049338
Processing this: /home/oof/webgl_cleaned/not_bvec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	gl_FragColor = vec4(vec3(not(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tgl_FragColor = vec4(vec3(not(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  gl_FragColor = vec4(vec3(not(bvec3(c))) , 1.0);
}


As vertex? : False
SUCCESS!
59.855769230769226
Processing this: /home/oof/webgl_cleaned/distance_vec3_frag_xvaryyhalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(distance(color.rgb, vec3(0.5))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(distance(color.rgb, vec3(0.5))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.5, 2.0, -((false ? 1.0 : 1.0) / (0.0 - -1.0)));

void main()
{
  gl_FragColor = vec4(vec3(distance(color.rgb , vec3(0.5))) , 1.0);
}


As vertex? : False
SUCCESS!
59.903961584633855
Processing this: /home/oof/webgl_cleaned/fboShader0.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
varying vec4 texCoord[1];
uniform sampler2D gtf_Texture0;
uniform int gtf_UseTexture;
void main ()
{
    if ( gtf_UseTexture == 1 )
    {
        gl_FragColor = texture2D(gtf_Texture0, texCoord[0].xy);
    }
    else
    {
        gl_FragColor = color;
    }
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvarying vec4 texCoord[1];\nuniform sampler2D gtf_Texture0;\nuniform int gtf_UseTexture;\nvoid main ()\n{\n    if ( gtf_UseTexture == 1 )\n    {\n        gl_FragColor = texture2D(gtf_Texture0, texCoord[0].xy);\n    }\n    else\n    {\n        gl_FragColor = color;\n    }\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

vec4 texCoord[1] = vec4[1](vec4(0.0, 0.0, -1.0, 0.0));

uniform sampler2D gtf_Texture0;

uniform int gtf_UseTexture;

void main()
{
  if ((gtf_UseTexture == 1))
  {
    gl_FragColor = texture2D(gtf_Texture0 , texCoord[0].xy);
  }
  else
  {
    gl_FragColor = color;
  }
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : Invalid operation for arrays
ERROR: 0:6: '=' : cannot convert from 'const array[1] of 4-component vector of float' to 'mediump array[1] of 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

vec4 texCoord[1] = vec4[1](vec4(0.0, 0.0, -1.0, 0.0));

uniform sampler2D gtf_Texture0;

uniform int gtf_UseTexture;

void main()
{
  if ((gtf_UseTexture == 1))
  {
    gl_FragColor = texture2D(gtf_Texture0 , texCoord[0].xy);
  }
  else
  {
    gl_FragColor = color;
  }
}


==============================
59.832134292565954
Processing this: /home/oof/webgl_cleaned/faceforward_vec3_frag_nvaryiconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	if(dot(v1, v2) >= 0.0) v1 *= -1.0;
	gl_FragColor = vec4((v1 + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tif(dot(v1, v2) >= 0.0) v1 *= -1.0;\n\tgl_FragColor = vec4((v1 + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((+-0.0 - (!false ? 0.0 : 1.0)), (((false ? 0.5 : 2.0) / (0.5 + 1.0)) * (false ? -1.0 : (true ? 2.0 : 1.0))), 0.5, 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  gl_FragColor = vec4(((v1 + 1.0) / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
59.88023952095808
Mutations attempted: 835
Valid mutations:     500
Success rate:        59.88%
Processing this: /home/oof/webgl_cleaned/qualifiers_struct_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,
sabcd e)
{
        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
        b = a;
        c.a += d.a;
        c.b += d.b;
        c.c += d.c;
        c.d += d.d;
        a.a += one.a;
        a.b += one.b;
        a.c += one.c;
        a.d += one.d;
        return e;
}
void main ()
{
	sabcd a = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd b = sabcd(2.0, 2.0, 2.0, 2.0);
	sabcd c = sabcd(3.0, 3.0, 3.0, 3.0);
	sabcd d = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd e = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd f = sabcd(0.0, 0.0, 0.0, 0.0);
	sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd four = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == one) q += 1.0;
	if(b == one) q += 2.0;
	if(c == seven) q += 4.0;
	if(d == four) q2 += 1.0;
	if(e == one) q2 += 2.0;
	if(f == one) q2 += 4.0;
	gl_FragColor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nsabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,\nsabcd e)\n{\n        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n        b = a;\n        c.a += d.a;\n        c.b += d.b;\n        c.c += d.c;\n        c.d += d.d;\n        a.a += one.a;\n        a.b += one.b;\n        a.c += one.c;\n        a.d += one.d;\n        return e;\n}\nvoid main ()\n{\n\tsabcd a = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd b = sabcd(2.0, 2.0, 2.0, 2.0);\n\tsabcd c = sabcd(3.0, 3.0, 3.0, 3.0);\n\tsabcd d = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd e = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd f = sabcd(0.0, 0.0, 0.0, 0.0);\n\tsabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd four = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == one) q += 1.0;\n\tif(b == one) q += 2.0;\n\tif(c == seven) q += 4.0;\n\tif(d == four) q2 += 1.0;\n\tif(e == one) q2 += 2.0;\n\tif(f == one) q2 += 4.0;\n\tgl_FragColor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d, sabcd e)
{
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  b = a;
  (c.a += d.a);
  (c.b += d.b);
  (c.c += d.c);
  (c.d += d.d);
  (a.a += one.a);
  (a.b += one.b);
  (a.c += one.c);
  (a.d += one.d);
  return e;
}

void main()
{
  sabcd a = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd b = sabcd(2.0 , 2.0 , 2.0 , 2.0);
  sabcd c = sabcd(3.0 , 3.0 , 3.0 , 3.0);
  sabcd d = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd e = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd f = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd four = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd seven = sabcd(7.0 , 7.0 , 7.0 , 7.0);
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == one))
    (q += 1.0);
  if ((b == one))
    (q += 2.0);
  if ((c == seven))
    (q += 4.0);
  if ((d == four))
    (q2 += 1.0);
  if ((e == one))
    (q2 += 2.0);
  if ((f == one))
    (q2 += 4.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
}


As vertex? : False
SUCCESS!
59.928229665071775
Processing this: /home/oof/webgl_cleaned/gl_MaxTextureImageUnits_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(float(gl_MaxTextureImageUnits) / 8.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(gl_MaxTextureImageUnits) / 8.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-1.0 - 1.0), 0.0, 1.0, 1.0, 1.0, +(true ? (0.5 * 2.0) : (2.0 - -1.0)), (0.0 * 0.5), 0.5, ((0.0 * (true ? 0.5 : 1.0)) + 0.0), (0.0 + -1.0), (2.0 - 0.5), 0.5, ((1.0 / 0.5) - 2.0), 0.0, 0.5, (!(true ? false : true) ? (-1.0 + 2.0) : -2.0));

vec4 color;

void main()
{
  color = vec4((float(gl_MaxTextureImageUnits) / 8.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-1.0 - 1.0), 0.0, 1.0, 1.0, 1.0, +(true ? (0.5 * 2.0) : (2.0 - -1.0)), (0.0 * 0.5), 0.5, ((0.0 * (true ? 0.5 : 1.0)) + 0.0), (0.0 + -1.0), (2.0 - 0.5), 0.5, ((1.0 / 0.5) - 2.0), 0.0, 0.5, (!(true ? false : true) ? (-1.0 + 2.0) : -2.0));

vec4 color;

void main()
{
  color = vec4((float(gl_MaxTextureImageUnits) / 8.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.85663082437276
Processing this: /home/oof/webgl_cleaned/acos_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (gtf_Color.r - 0.5);
	color = vec4(acos(c) / M_PI, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(acos(c) / M_PI, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4(2.0, 0.5, 0.5, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  color = vec4((acos(c) / M_PI) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.90453460620525
Processing this: /home/oof/webgl_cleaned/for_nested_break_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count1 = 0, count2 = 0;
        for(int i=0;i<4;i++)
	{
	  count1++;
	  count2 = 0;
	  for(int j=0;j<4;j++)
	  {
	     count2++;
	     if(count2 == 3)
		break;
	  }
	  if(count1 == 2)
            break;
	}
	float gray;
	if( (count1 == 2) && (count2 == 3))
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint count1 = 0, count2 = 0;\n        for(int i=0;i<4;i++)\n\t{\n\t  count1++;\n\t  count2 = 0;\n\t  for(int j=0;j<4;j++)\n\t  {\n\t     count2++;\n\t     if(count2 == 3)\n\t\tbreak;\n\t  }\n\t  if(count1 == 2)\n            break;\n\t}\n\tfloat gray;\n\tif( (count1 == 2) && (count2 == 3))\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int count1 = 0 , count2 = 0;
  for (int i = 0; (i < 4); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 4); j++)
    {
      count2++;
      if ((count2 == 3))
        break;
    }
    if ((count1 == 2))
      break;
  }
  float gray = 0.0;
  if (((count1 == 2) && (count2 == 3)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
59.952324195470794
Processing this: /home/oof/webgl_cleaned/fract_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 1.0, -1.0, -0.5);

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/greaterThan_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(greaterThan(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(greaterThan(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, -2.0, (1.0 + -2.0), -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.04756242568371
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 ne(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(ne(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 ne(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(ne(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-0.0, +((true ? true : true) ? (-1.0 - 1.0) : (-1.0 / 2.0)), -1.0, ((!true && !false) ? -1.0 : 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 ne(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(ne(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.09501187648456
Processing this: /home/oof/webgl_cleaned/4b_lastthree_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform bvec4 color;
void main ()
{
	gl_FragColor = vec4 (float(color[1]), float(color[2]), float(color[3]), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform bvec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (float(color[1]), float(color[2]), float(color[3]), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct57556 {
  bvec4 f_2343;
};

uniform bvec4 color;

void main()
{
  vec4(2.0, 2.0, 0.0, ((0.0 + 2.0) + +(-1.0 + 1.0)));
}


As vertex? : False
SUCCESS!
60.14234875444839
Processing this: /home/oof/webgl_cleaned/log_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float x = 31.0 * color.r + 1.0;
	float y = 0.0;
	float z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	gl_FragColor = vec4(y / 3.466, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = 31.0 * color.r + 1.0;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tgl_FragColor = vec4(y / 3.466, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = (!(false ? false : false) ? vec4((+1.0 - (2.0 - 2.0)), (0.5 * 2.0), (1.0 + 2.0), ((false ? -1.0 : 1.0) / -+1.0)) : vec4(1.0, 0.0, 0.0, -0.5));

void main()
{
  float x = ((31.0 * color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  gl_FragColor = vec4((y / 3.466) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.18957345971564
Processing this: /home/oof/webgl_cleaned/abs_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	if((c[0] < 0.0)) c[0] *= -1.0;
	if((c[1] < 0.0)) c[1] *= -1.0;
	if((c[2] < 0.0)) c[2] *= -1.0;
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tif((c[0] < 0.0)) c[0] *= -1.0;\n\tif((c[1] < 0.0)) c[1] *= -1.0;\n\tif((c[2] < 0.0)) c[2] *= -1.0;\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.0, 2.0, -+(true ? 2.0 : -1.0), -++2.0);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  if ((c[2] < 0.0))
    (c[2] *= -1.0);
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '++' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.0, 2.0, -+(true ? 2.0 : -1.0), -++2.0);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  if ((c[2] < 0.0))
    (c[2] *= -1.0);
  gl_FragColor = vec4(c , 1.0);
}


==============================
60.11834319526628
Mutations attempted: 845
Valid mutations:     508
Success rate:        60.12%
Processing this: /home/oof/webgl_cleaned/notEqual_bvec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	vec3 result = vec3(notEqual(bvec3(c), bvec3(true)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tvec3 result = vec3(notEqual(bvec3(c), bvec3(true)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = color(color(bvec3(c)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: '=' : cannot convert from 'const mediump float' to 'mediump 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = color(color(bvec3(c)));
  gl_FragColor = vec4(result , 1.0);
}


==============================
60.047281323877066
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 ne(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(ne(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 ne(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(ne(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 ne(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(ne(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
  vec4(+-1.0, ((true || true) ? 0.0 : -1.0), 0.5, (+0.5 * (+0.0 / +1.0)));
}


As vertex? : False
SUCCESS!
60.09445100354191
Processing this: /home/oof/webgl_cleaned/distance_vec3_vert_xvaryyhalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(distance(gtf_Color.rgb, vec3(0.5))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(distance(gtf_Color.rgb, vec3(0.5))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4(vec3(distance(gtf_Color.rgb , vec3(0.5))));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(3, (true ? 5 : (9 - 5)));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4(vec3(distance(gtf_Color.rgb , vec3(0.5))));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(3, (true ? 5 : (9 - 5)));
}


==============================
60.02358490566038
Processing this: /home/oof/webgl_cleaned/refract_vec2_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, ((!true ? 2.0 : -1.0) + (0.0 + -0.0)), -((true ? 0.5 : 2.0) - +-1.0), 2.0, 2.0, +0.5, --1.0, ((true || (true ? false : true)) ? ((true && true) ? 0.5 : (false ? 0.5 : 0.0)) : (true ? 0.0 : -2.0)), 1.0, -0.5, (1.0 * ((false ? -1.0 : 2.0) * (0.0 / 0.0))), (true ? -1.0 : 2.0), 0.0, 1.0, -1.0, (false ? 2.0 : 0.0));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
WARNING: 0:8: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, ((!true ? 2.0 : -1.0) + (0.0 + -0.0)), -((true ? 0.5 : 2.0) - +-1.0), 2.0, 2.0, +0.5, --1.0, ((true || (true ? false : true)) ? ((true && true) ? 0.5 : (false ? 0.5 : 0.0)) : (true ? 0.0 : -2.0)), 1.0, -0.5, (1.0 * ((false ? -1.0 : 2.0) * (0.0 / 0.0))), (true ? -1.0 : 2.0), 0.0, 1.0, -1.0, (false ? 2.0 : 0.0));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.95288574793876
Processing this: /home/oof/webgl_cleaned/mat3_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat3 a = mat3( 1.0,   2.0,   4.0,
	               8.0,  16.0,  32.0,
	              64.0, 128.0, 256.0);
	mat3 b = a;
	bool elms = true;
	if(b[0][0] !=   1.0) elms = false;
	if(b[0][1] !=   2.0) elms = false;
	if(b[0][2] !=   4.0) elms = false;
	if(b[1][0] !=   8.0) elms = false;
	if(b[1][1] !=  16.0) elms = false;
	if(b[1][2] !=  32.0) elms = false;
	if(b[2][0] !=  64.0) elms = false;
	if(b[2][1] != 128.0) elms = false;
	if(b[2][2] != 256.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0];
	if( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;
	x = b[0][1] + b[1][1] + b[2][1];
	if(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;
	x = b[0][2] + b[1][2] + b[2][2];
	if(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2];
	if( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;
	x = b[1][0] + b[1][1] + b[1][2];
	if(x < 56.0-0.1 || x > 56.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2];
	if(x < 448.0-0.1 || x > 448.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat3 a = mat3( 1.0,   2.0,   4.0,\n\t               8.0,  16.0,  32.0,\n\t              64.0, 128.0, 256.0);\n\tmat3 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=   1.0) elms = false;\n\tif(b[0][1] !=   2.0) elms = false;\n\tif(b[0][2] !=   4.0) elms = false;\n\tif(b[1][0] !=   8.0) elms = false;\n\tif(b[1][1] !=  16.0) elms = false;\n\tif(b[1][2] !=  32.0) elms = false;\n\tif(b[2][0] !=  64.0) elms = false;\n\tif(b[2][1] != 128.0) elms = false;\n\tif(b[2][2] != 256.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tif( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1];\n\tif(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2];\n\tif(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2];\n\tif( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2];\n\tif(x < 56.0-0.1 || x > 56.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2];\n\tif(x < 448.0-0.1 || x > 448.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 0.0, 0.5, +(true ? 0.0 : +0.0));

void main()
{
  float x;
  mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  mat3 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[1][0] != 8.0))
    elms = false;
  if ((b[1][1] != 16.0))
    elms = false;
  if ((b[1][2] != 32.0))
    elms = false;
  if ((b[2][0] != 64.0))
    elms = false;
  if ((b[2][1] != 128.0))
    elms = false;
  if ((b[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((b[0][1] + b[1][1]) + b[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((b[0][2] + b[1][2]) + b[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((b[0][0] + b[0][1]) + b[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((b[1][0] + b[1][1]) + b[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((b[2][0] + b[2][1]) + b[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/step_float_vert_xvary_edgeconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float edge = 0.5;
	float c = gtf_Color.r;
	if(c >= edge) c = 1.0;
	else c = 0.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge = 0.5;\n\tfloat c = gtf_Color.r;\n\tif(c >= edge) c = 1.0;\n\telse c = 0.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 1.0, +0.5, 1.0, 1.0, 1.0, 0.5, 1.0, ((0.0 + --1.0) * ((1.0 + 1.0) + 0.0)), --1.0, (false ? 0.5 : (0.0 + 0.5)), ((false ? false : (true && true)) ? (!false ? 0.0 : 2.0) : (true ? (false ? 0.0 : 0.5) : (false ? 0.5 : 2.0))), 2.0, --1.0, +(1.0 + +0.0), 2.0);

vec4 color;

void main()
{
  const float edge = 0.5;
  float c = gtf_Color.r;
  if ((c >= edge))
    c = 1.0;
  else
    c = 0.0;
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 1.0, +0.5, 1.0, 1.0, 1.0, 0.5, 1.0, ((0.0 + --1.0) * ((1.0 + 1.0) + 0.0)), --1.0, (false ? 0.5 : (0.0 + 0.5)), ((false ? false : (true && true)) ? (!false ? 0.0 : 2.0) : (true ? (false ? 0.0 : 0.5) : (false ? 0.5 : 2.0))), 2.0, --1.0, +(1.0 + +0.0), 2.0);

vec4 color;

void main()
{
  const float edge = 0.5;
  float c = gtf_Color.r;
  if ((c >= edge))
    c = 1.0;
  else
    c = 0.0;
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.929494712103406
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xconst2_yvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(pow(vec2(2.0), 2.0 * c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, (!false ? 2.0 : 1.0), 2.0, (-1.0 * +(false ? 2.0 : 0.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((pow(vec2(2.0) , (2.0 * c)) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.97652582159625
Processing this: /home/oof/webgl_cleaned/vec4_wxz_y_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.wxz;
	float y = al.y;
	vec4 a = vec4(m.y, y, m.z, m.x);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.wxz;\n\tfloat y = al.y;\n\tvec4 a = vec4(m.y, y, m.z, m.x);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.wxz;
  float y = al.y;
  vec4 a = vec4(m.y , y , m.z , m.x);
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
60.02344665885111
Processing this: /home/oof/webgl_cleaned/qualifiers_struct_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,
sabcd e)
{
        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
        b = a;
        c.a += d.a;
        c.b += d.b;
        c.c += d.c;
        c.d += d.d;
        a.a += one.a;
        a.b += one.b;
        a.c += one.c;
        a.d += one.d;
        return e;
}
void main ()
{
	sabcd a = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd b = sabcd(2.0, 2.0, 2.0, 2.0);
	sabcd c = sabcd(3.0, 3.0, 3.0, 3.0);
	sabcd d = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd e = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd f = sabcd(0.0, 0.0, 0.0, 0.0);
	sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd four = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == one) q += 1.0;
	if(b == one) q += 2.0;
	if(c == seven) q += 4.0;
	if(d == four) q2 += 1.0;
	if(e == one) q2 += 2.0;
	if(f == one) q2 += 4.0;
	color = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nsabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,\nsabcd e)\n{\n        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n        b = a;\n        c.a += d.a;\n        c.b += d.b;\n        c.c += d.c;\n        c.d += d.d;\n        a.a += one.a;\n        a.b += one.b;\n        a.c += one.c;\n        a.d += one.d;\n        return e;\n}\nvoid main ()\n{\n\tsabcd a = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd b = sabcd(2.0, 2.0, 2.0, 2.0);\n\tsabcd c = sabcd(3.0, 3.0, 3.0, 3.0);\n\tsabcd d = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd e = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd f = sabcd(0.0, 0.0, 0.0, 0.0);\n\tsabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd four = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == one) q += 1.0;\n\tif(b == one) q += 2.0;\n\tif(c == seven) q += 4.0;\n\tif(d == four) q2 += 1.0;\n\tif(e == one) q2 += 2.0;\n\tif(f == one) q2 += 4.0;\n\tcolor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  float c;
  float b;
  float a;
  float d;
};

sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d, sabcd e)
{
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  b = a;
  (c.a += d.a);
  (c.b += d.b);
  (c.c += d.c);
  (c.d += d.d);
  (a.a += one.a);
  (a.b += one.b);
  (a.c += one.c);
  (a.d += one.d);
  return e;
}

void main()
{
  sabcd a = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd b = sabcd(2.0 , 2.0 , 2.0 , 2.0);
  sabcd c = sabcd(3.0 , 3.0 , 3.0 , 3.0);
  sabcd d = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd e = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd f = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd four = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd seven = sabcd(7.0 , 7.0 , 7.0 , 7.0);
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == one))
    (q += 1.0);
  if ((b == one))
    (q += 2.0);
  if ((c == seven))
    (q += 4.0);
  if ((d == four))
    (q2 += 1.0);
  if ((e == one))
    (q2 += 2.0);
  if ((f == one))
    (q2 += 4.0);
  color = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.07025761124122
Processing this: /home/oof/webgl_cleaned/vec4_pqs_t_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.pqs;
	float t = al.t;
	vec4 a = vec4(m.p, t, m.s, m.t);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.pqs;\n\tfloat t = al.t;\n\tvec4 a = vec4(m.p, t, m.s, m.t);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (false ? 2.0 : 0.5), 1.0, (-0.0 - (+0.5 / 0.0)));

void main()
{
  vec4 al = color;
  vec3 m = al.pqs;
  float t = al.t;
  vec4 a = vec4(m.p , t , m.s , m.t);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
60.11695906432749
Mutations attempted: 855
Valid mutations:     514
Success rate:        60.12%
Processing this: /home/oof/webgl_cleaned/any_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool _any(in bvec3 a)
{
	bool temp = false;
	if(a[0]) temp = true;
	if(a[1]) temp = true;
	if(a[2]) temp = true;
	return temp;
}
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	gl_FragColor = vec4(vec3(_any(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool _any(in bvec3 a)\n{\n\tbool temp = false;\n\tif(a[0]) temp = true;\n\tif(a[1]) temp = true;\n\tif(a[2]) temp = true;\n\treturn temp;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tgl_FragColor = vec4(vec3(_any(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bool _any(in bvec3 a)
{
  bool temp = false;
  if (a[0])
    temp = true;
  if (a[1])
    temp = true;
  if (a[2])
    temp = true;
  return temp;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  gl_FragColor = vec4(vec3(_any(bvec3(c))) , 1.0);
}


As vertex? : False
SUCCESS!
60.163551401869164
Processing this: /home/oof/webgl_cleaned/ceil_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(+0.0, 1.0, -1.0, ((-1.0 * (true ? 2.0 : 0.5)) * (false ? (false ? -1.0 : 0.5) : 1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.21003500583431
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[16] = vec4(-1.0, -(-0.5 + 2.0), ((true ? 0.0 : (true ? 0.5 : 2.0)) + -1.0), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[16] of 4-component vector of float'
ERROR: 0:17: '*' : array / non-array mismatch
ERROR: 0:17: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[16] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:17: '=' : dimension mismatch
ERROR: 0:17: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[16] = vec4(-1.0, -(-0.5 + 2.0), ((true ? 0.0 : (true ? 0.5 : 2.0)) + -1.0), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.13986013986013
Processing this: /home/oof/webgl_cleaned/cos_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * ( fract(abs(color.rgb)) - 0.5 );
	float sign =  1.0;
	vec3 cos_c = vec3(-1.0, -1.0, -1.0);
	float fact_even = 1.0;
	float fact_odd  = 1.0;
	vec3 sum;
	vec3 exp;
	for(int i = 2; i <= 10; i += 2)
	{
		fact_even *= float(i);
		fact_odd  *= float(i-1);
		exp = vec3(float(i/2), float(i/2), float(i/2));
		sum = sign * pow(abs(c), exp)/fact_even;
		cos_c += pow(abs(c), exp)*(sum/fact_odd);
		sign = -sign;
	}
	gl_FragColor = vec4(0.5 * cos_c + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * ( fract(abs(color.rgb)) - 0.5 );\n\tfloat sign =  1.0;\n\tvec3 cos_c = vec3(-1.0, -1.0, -1.0);\n\tfloat fact_even = 1.0;\n\tfloat fact_odd  = 1.0;\n\tvec3 sum;\n\tvec3 exp;\n\tfor(int i = 2; i <= 10; i += 2)\n\t{\n\t\tfact_even *= float(i);\n\t\tfact_odd  *= float(i-1);\n\t\texp = vec3(float(i/2), float(i/2), float(i/2));\n\t\tsum = sign * pow(abs(c), exp)/fact_even;\n\t\tcos_c += pow(abs(c), exp)*(sum/fact_odd);\n\t\tsign = -sign;\n\t}\n\tgl_FragColor = vec4(0.5 * cos_c + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * (fract(abs(color.rgb)) - 0.5));
  float sign = 1.0;
  vec3 cos_c = vec3(-1.0 , -1.0 , -1.0);
  float fact_even = 1.0;
  float fact_odd = 1.0;
  vec3 sum = vec3(+-1.0, 0.0, 1.0);
  vec3 exp;
  for (int i = 2; (i <= 10); (i += 2))
  {
    (fact_even *= float(i));
    (fact_odd *= float((i - 1)));
    exp = vec3(float((i / 2)) , float((i / 2)) , float((i / 2)));
    sum = ((sign * pow(abs(c) , exp)) / fact_even);
    (cos_c += (pow(abs(c) , exp) * (sum / fact_odd)));
    sign = -sign;
  }
  gl_FragColor = vec4(((0.5 * cos_c) + 0.5) , 1.0);
}


As vertex? : False
SUCCESS!
60.18626309662398
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	float c = color.r;
	gl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(exp(3.0 * c) / exp3, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 1.0, 2.0, -0.5);

void main()
{
  const float exp3 = 20.0855;
  float c = color.r;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.23255813953489
Processing this: /home/oof/webgl_cleaned/21i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform int color[2];
void main ()
{
	float r = float(color[0]);
	float g = float(color[1]);
	gl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform int color[2];\nvoid main ()\n{\n\tfloat r = float(color[0]);\n\tfloat g = float(color[1]);\n\tgl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform int color[2] = int[2](4, 4);

void main()
{
  float r = float(color[0]);
  float g = float(color[1]);
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform int color[2] = int[2](4, 4);

void main()
{
  float r = float(color[0]);
  float g = float(color[1]);
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


==============================
60.16260162601627
Processing this: /home/oof/webgl_cleaned/mat4_empty_out_mat4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
mat4 function(out mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(out mat4 par)
{
	set_all(par, 0.0);
	return mat4(1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nmat4 function(out mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(out mat4 par)\n{\n\tset_all(par, 0.0);\n\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.16260162601627
Processing this: /home/oof/webgl_cleaned/fract_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	c = abs((c - floor(c)) - 0.5) * 2.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tc = abs((c - floor(c)) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-0.5, 2.0, 0.0, 2.0);

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (abs(((c - floor(c)) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.20881670533643
Processing this: /home/oof/webgl_cleaned/acos_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (gtf_Color.r - 0.5);
	color = vec4(acos(c) / M_PI, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(acos(c) / M_PI, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  color = vec4((acos(c) / M_PI) , 0.0 , 0.0 , 1.0);
  (0.5 * -0.5) = mat4(2.0, 1.0, (1.0 / 0.5), 0.0, ((false ? true : false) ? ((true && true) ? (false ? 1.0 : -1.0) : 1.0) : 1.0), 2.0, ((true || (true ? true : false)) ? ((false && false) ? (true ? -1.0 : 0.5) : (1.0 * 0.5)) : 0.0), ((true && false) ? 1.0 : +0.0), 0.0, -1.0, +(false ? (false ? -1.0 : -1.0) : -0.0), (false ? ((true ? true : true) ? 0.5 : (false ? 1.0 : 2.0)) : 2.0), 0.0, 1.0, (true ? 0.5 : 0.5), 2.0);
  ivec2(8, (4 + (false ? 3 : (9 + 9))));
}

vec4 color;

vec4 gtf_Vertex;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'color' : undeclared identifier
ERROR: 0:12: 'assign' : l-value required (can't modify a const)
ERROR: 0:12: '=' : dimension mismatch
ERROR: 0:12: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const highp float'
ERROR: 0:13: 'assign' : l-value required (can't modify a const)
ERROR: 0:13: '=' : dimension mismatch
ERROR: 0:13: 'assign' : cannot convert from 'const 4X4 matrix of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (gtf_Color.r - 0.5));
  color = vec4((acos(c) / M_PI) , 0.0 , 0.0 , 1.0);
  (0.5 * -0.5) = mat4(2.0, 1.0, (1.0 / 0.5), 0.0, ((false ? true : false) ? ((true && true) ? (false ? 1.0 : -1.0) : 1.0) : 1.0), 2.0, ((true || (true ? true : false)) ? ((false && false) ? (true ? -1.0 : 0.5) : (1.0 * 0.5)) : 0.0), ((true && false) ? 1.0 : +0.0), 0.0, -1.0, +(false ? (false ? -1.0 : -1.0) : -0.0), (false ? ((true ? true : true) ? 0.5 : (false ? 1.0 : 2.0)) : 2.0), 0.0, 1.0, (true ? 0.5 : 0.5), 2.0);
  ivec2(8, (4 + (false ? 3 : (9 + 9))));
}

vec4 color;

vec4 gtf_Vertex;


==============================
60.139049826187716
Processing this: /home/oof/webgl_cleaned/copy_texture.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform sampler2D gtf_Texture0;
varying vec4 color;
varying vec4 gtf_TexCoord[1];
void main ()
{
	if (gtf_TexCoord[0].s == 1.0)
		gl_FragColor = color;
	else
		gl_FragColor = texture2D(gtf_Texture0, gtf_TexCoord[0].st, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform sampler2D gtf_Texture0;\nvarying vec4 color;\nvarying vec4 gtf_TexCoord[1];\nvoid main ()\n{\n\tif (gtf_TexCoord[0].s == 1.0)\n\t\tgl_FragColor = color;\n\telse\n\t\tgl_FragColor = texture2D(gtf_Texture0, gtf_TexCoord[0].st, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform sampler2D gtf_Texture0;

vec4 color;

vec4 gtf_TexCoord[1] = vec4[1](vec4(-0.5, 2.0, 0.5, 1.0));

void main()
{
  if ((gtf_TexCoord[0].s == 1.0))
    gl_FragColor = color;
  else
    gl_FragColor = texture2D(gtf_Texture0 , gtf_TexCoord[0].st , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:8: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:8: '=' : Invalid operation for arrays
ERROR: 0:8: '=' : cannot convert from 'const array[1] of 4-component vector of float' to 'mediump array[1] of 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform sampler2D gtf_Texture0;

vec4 color;

vec4 gtf_TexCoord[1] = vec4[1](vec4(-0.5, 2.0, 0.5, 1.0));

void main()
{
  if ((gtf_TexCoord[0].s == 1.0))
    gl_FragColor = color;
  else
    gl_FragColor = texture2D(gtf_Texture0 , gtf_TexCoord[0].st , 1.0);
}


==============================
60.06944444444444
Mutations attempted: 864
Valid mutations:     519
Success rate:        60.07%
Processing this: /home/oof/webgl_cleaned/greaterThan_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gt(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gt(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 gt(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(gt(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 gt(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(gt(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.115606936416185
Processing this: /home/oof/webgl_cleaned/empty_empty_array_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	new_mad[0]=float(1);
	new_mad[1]=float(2);
	if( (new_mad[0] == 1.0) && (new_mad[1] == 2.0) )
	  gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray,gray , gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tnew_mad[0]=float(1);\n\tnew_mad[1]=float(2);\n\tif( (new_mad[0] == 1.0) && (new_mad[1] == 2.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray,gray , gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int i = 0;
  float new_mad[2] = float[2](0.0, 1.0);
  float gray = 0.0;
  new_mad[0] = float(1);
  new_mad[1] = float(2);
  if (((new_mad[0] == 1.0) && (new_mad[1] == 2.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:9: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:9: '=' : Invalid operation for arrays
ERROR: 0:9: '=' : cannot convert from 'const array[2] of float' to 'mediump array[2] of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  int i = 0;
  float new_mad[2] = float[2](0.0, 1.0);
  float gray = 0.0;
  new_mad[0] = float(1);
  new_mad[1] = float(2);
  if (((new_mad[0] == 1.0) && (new_mad[1] == 2.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
60.046189376443415
Processing this: /home/oof/webgl_cleaned/structnest_mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	mat2 b;
};
struct nesta
{
	mat2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tmat2 b;\n};\nstruct nesta\n{\n\tmat2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  mat2 b;
};

struct nesta {
  mat2 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat2(11 , 13 , 29 , 33) , nestb(mat2(12 , 19 , 79 , 81))));
  color = vec4(vec3(((((((((s.nest_a.a[0][0] + s.nest_a.a[0][1]) + s.nest_a.a[1][0]) + s.nest_a.a[1][1]) + s.nest_a.nest_b.b[0][0]) + s.nest_a.nest_b.b[0][1]) + s.nest_a.nest_b.b[1][0]) + s.nest_a.nest_b.b[1][1]) / 277.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.09227220299884
Processing this: /home/oof/webgl_cleaned/atan_vec3_vert_xvaryyvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (gtf_Color.ggg - 0.5);
	vec3 y = 2.0 * (gtf_Color.bbb - 0.5);
	const float epsilon = 1.0e-4;
	color = vec4(0.0, 0.0, 0.0, 1.0);
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		color[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		color[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		color[2] = atan(y[2], x[2]) / (2.0 * M_PI) + 0.5;
	}
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 x = 2.0 * (gtf_Color.ggg - 0.5);\n\tvec3 y = 2.0 * (gtf_Color.bbb - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tcolor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tcolor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[2] > epsilon || abs(y[2]) > epsilon)\n\t{\n\t\tcolor[2] = atan(y[2], x[2]) / (2.0 * M_PI) + 0.5;\n\t}\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4(0.0, -(false ? (true ? 0.0 : 1.0) : -1.0), 1.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (gtf_Color.ggg - 0.5));
  vec3 y = (2.0 * (gtf_Color.bbb - 0.5));
  const float epsilon = 0.0001;
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    color[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    color[1] = ((atan(y[1] , x[1]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[2] > epsilon) || (abs(y[2]) > epsilon)))
  {
    color[2] = ((atan(y[2] , x[2]) / (2.0 * M_PI)) + 0.5);
  }
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.13824884792627
Processing this: /home/oof/webgl_cleaned/min_vec3_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 min_c = vec3(0.5, 0.5, 0.5);
	vec3 c = color.rgb;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	if(c[2] > min_c[2]) c[2] = min_c[2];
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 min_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = color.rgb;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tif(c[2] > min_c[2]) c[2] = min_c[2];\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? 0.0 : (1.0 - 1.0)), +(true ? (false ? 0.0 : 1.0) : (true ? 2.0 : -1.0)), (0.0 / ((false ? false : false) ? (true ? 2.0 : 0.0) : (-1.0 * 2.0))), 0.0);

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = color.rgb;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  if ((c[2] > min_c[2]))
    c[2] = min_c[2];
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
SUCCESS!
60.18411967779056
Processing this: /home/oof/webgl_cleaned/preprocess10_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(-15);
}


As vertex? : False
SUCCESS!
60.229885057471265
Processing this: /home/oof/webgl_cleaned/brick.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec3 gtf_Normal;
attribute vec4 gtf_Vertex;
uniform mat3 gtf_NormalMatrix;
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying float lightIntensity;
varying vec3  Position;
uniform vec3  LightPosition;
uniform vec3  NotActiveOne;
attribute float myAttribute1;
attribute vec3 myAttribute2;
const float specularContribution = 0.7;
const float diffuseContribution  = (1.0 - specularContribution);
void main() {
    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;
    Position        = vec3(gtf_Vertex);
    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);
    vec3 lightVec   = normalize(LightPosition - vec3(pos));
    vec3 reflectVec = reflect(lightVec, tnorm);
    vec3 viewVec    = normalize(vec3(pos));
	float spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +
                     specularContribution * spec;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec3 gtf_Normal;\nattribute vec4 gtf_Vertex;\nuniform mat3 gtf_NormalMatrix;\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying float lightIntensity;\nvarying vec3  Position;\nuniform vec3  LightPosition;\nuniform vec3  NotActiveOne;\nattribute float myAttribute1;\nattribute vec3 myAttribute2;\nconst float specularContribution = 0.7;\nconst float diffuseContribution  = (1.0 - specularContribution);\nvoid main() {\n    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;\n    Position        = vec3(gtf_Vertex);\n    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);\n    vec3 lightVec   = normalize(LightPosition - vec3(pos));\n    vec3 reflectVec = reflect(lightVec, tnorm);\n    vec3 viewVec    = normalize(vec3(pos));\n\tfloat spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +\n                     specularContribution * spec;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity = diffuseContribution;

vec3 Position;

uniform vec3 LightPosition;

uniform vec3 NotActiveOne;

float myAttribute1;

vec3 myAttribute2;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float spec = clamp(dot(reflectVec , viewVec) , myAttribute1 , myAttribute2[1]);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'diffuseContribution' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity = diffuseContribution;

vec3 Position;

uniform vec3 LightPosition;

uniform vec3 NotActiveOne;

float myAttribute1;

vec3 myAttribute2;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float spec = clamp(dot(reflectVec , viewVec) , myAttribute1 , myAttribute2[1]);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.160734787600454
Processing this: /home/oof/webgl_cleaned/mix_vec3_vert_xvary_yconsthalf_aconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 y = vec3(0.5, 0.5, 0.5);
	const vec3 a = vec3(0.5, 0.5, 0.5);
	color = vec4(mix(gtf_Color.rgb, y, a), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 y = vec3(0.5, 0.5, 0.5);\n\tconst vec3 a = vec3(0.5, 0.5, 0.5);\n\tcolor = vec4(mix(gtf_Color.rgb, y, a), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 y = vec3(0.5 , 0.5 , 0.5);
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  color = vec4(mix(gtf_Color.rgb , y , a) , 1.0);
  gl_Position = (mat4(+(false ? +0.0 : +0.0), (0.0 / ((1.0 - 2.0) + -1.0)), (false ? --0.0 : (!false ? (1.0 - 0.5) : 0.5)), 2.0, 2.0, -1.0, +-1.0, 0.5, ((!false ? (true ? false : false) : true) ? (true ? +-1.0 : (-1.0 * 0.5)) : 0.5), 0.0, ((true ? 2.0 : 0.0) - 1.0), (true ? 1.0 : -1.0), (+(-1.0 / 0.5) + (false ? 2.0 : 0.0)), 0.5, 2.0, ((0.0 - 0.0) * (1.0 * 0.0))) * gtf_Vertex);
  ivec2(+8, (((false ? false : true) ? !true : true) ? 2 : +4));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:17: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 y = vec3(0.5 , 0.5 , 0.5);
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  color = vec4(mix(gtf_Color.rgb , y , a) , 1.0);
  gl_Position = (mat4(+(false ? +0.0 : +0.0), (0.0 / ((1.0 - 2.0) + -1.0)), (false ? --0.0 : (!false ? (1.0 - 0.5) : 0.5)), 2.0, 2.0, -1.0, +-1.0, 0.5, ((!false ? (true ? false : false) : true) ? (true ? +-1.0 : (-1.0 * 0.5)) : 0.5), 0.0, ((true ? 2.0 : 0.0) - 1.0), (true ? 1.0 : -1.0), (+(-1.0 / 0.5) + (false ? 2.0 : 0.0)), 0.5, 2.0, ((0.0 - 0.0) * (1.0 * 0.0))) * gtf_Vertex);
  ivec2(+8, (((false ? false : true) ? !true : true) ? 2 : +4));
}


==============================
60.09174311926605
Processing this: /home/oof/webgl_cleaned/refract_vec3_frag_ivarynconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	vec3 result;
	float eta = 0.5;
	float k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));
	if(k < 0.0)
		result = vec3(0.0);
	else
		result = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;
	gl_FragColor = vec4((result + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tvec3 result;\n\tfloat eta = 0.5;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));\n\tif(k < 0.0)\n\t\tresult = vec3(0.0);\n\telse\n\t\tresult = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;\n\tgl_FragColor = vec4((result + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (true ? (false ? +1.0 : (true ? 1.0 : -1.0)) : -1.0), 0.5, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  vec3 result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = vec3(0.0);
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  gl_FragColor = vec4(((result + 1.0) / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
60.13745704467354
Processing this: /home/oof/webgl_cleaned/mat4_4vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 L1 = vec4(1.0, 2.0, 3.0, 4.0);
	vec4 L2 = vec4(5.0, 6.0, 7.0, 8.0);
	vec4 L3 = vec4(9.0, 10.0, 11.0, 12.0);
	vec4 L4 = vec4(13.0, 14.0, 15.0, 16.0);
	mat4 a = mat4(L1,L2,L3,L4);
	float gray,sum1=0.0,sum2=0.0,sum3=0.0,sum4=0.0;
	int i;
	sum1 = sum1 + a[0][0];
	sum2 = sum2 + a[1][0];
	sum3 = sum3 + a[2][0];
	sum4 = sum4 + a[3][0];
	sum1 = sum1 + a[0][1];
	sum2 = sum2 + a[1][1];
	sum3 = sum3 + a[2][1];
	sum4 = sum4 + a[3][1];
	sum1 = sum1 + a[0][2];
	sum2 = sum2 + a[1][2];
	sum3 = sum3 + a[2][2];
	sum4 = sum4 + a[3][2];
	sum1 = sum1 + a[0][3];
	sum2 = sum2 + a[1][3];
	sum3 = sum3 + a[2][3];
	sum4 = sum4 + a[3][3];
	if( ( sum1 > 10.0-0.1 && sum1 < 10.0+0.1  ) &&
		( sum2 > 26.0-0.1 && sum2 < 26.0+0.1) &&
		( sum3 > 42.0-0.1 && sum3 < 42.0+0.1) &&
		( sum4 > 58.0-0.1 && sum4 < 58.0+0.1) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 L1 = vec4(1.0, 2.0, 3.0, 4.0);\n\tvec4 L2 = vec4(5.0, 6.0, 7.0, 8.0);\n\tvec4 L3 = vec4(9.0, 10.0, 11.0, 12.0);\n\tvec4 L4 = vec4(13.0, 14.0, 15.0, 16.0);\n\tmat4 a = mat4(L1,L2,L3,L4);\n\tfloat gray,sum1=0.0,sum2=0.0,sum3=0.0,sum4=0.0;\n\tint i;\n\tsum1 = sum1 + a[0][0];\n\tsum2 = sum2 + a[1][0];\n\tsum3 = sum3 + a[2][0];\n\tsum4 = sum4 + a[3][0];\n\tsum1 = sum1 + a[0][1];\n\tsum2 = sum2 + a[1][1];\n\tsum3 = sum3 + a[2][1];\n\tsum4 = sum4 + a[3][1];\n\tsum1 = sum1 + a[0][2];\n\tsum2 = sum2 + a[1][2];\n\tsum3 = sum3 + a[2][2];\n\tsum4 = sum4 + a[3][2];\n\tsum1 = sum1 + a[0][3];\n\tsum2 = sum2 + a[1][3];\n\tsum3 = sum3 + a[2][3];\n\tsum4 = sum4 + a[3][3];\n\tif( ( sum1 > 10.0-0.1 && sum1 < 10.0+0.1  ) &&\n\t\t( sum2 > 26.0-0.1 && sum2 < 26.0+0.1) &&\n\t\t( sum3 > 42.0-0.1 && sum3 < 42.0+0.1) &&\n\t\t( sum4 > 58.0-0.1 && sum4 < 58.0+0.1) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, -1.0, --1.0, +1.0);

void main()
{
  vec4 L1 = vec4(1.0 , 2.0 , 3.0 , 4.0);
  vec4 L2 = vec4(5.0 , 6.0 , 7.0 , 8.0);
  vec4 L3 = vec4(9.0 , 10.0 , 11.0 , 12.0);
  vec4 L4 = vec4(13.0 , 14.0 , 15.0 , 16.0);
  mat4 a = mat4(L1 , L2 , L3 , L4);
  float gray, sum1 = 0.0 , sum2 = 0.0 , sum3 = 0.0 , sum4 = 0.0;
  int i;
  sum1 = (sum1 + a[0][0]);
  sum2 = (sum2 + a[1][0]);
  sum3 = (sum3 + a[2][0]);
  sum4 = (sum4 + a[3][0]);
  sum1 = (sum1 + a[0][1]);
  sum2 = (sum2 + a[1][1]);
  sum3 = (sum3 + a[2][1]);
  sum4 = (sum4 + a[3][1]);
  sum1 = (sum1 + a[0][2]);
  sum2 = (sum2 + a[1][2]);
  sum3 = (sum3 + a[2][2]);
  sum4 = (sum4 + a[3][2]);
  sum1 = (sum1 + a[0][3]);
  sum2 = (sum2 + a[1][3]);
  sum3 = (sum3 + a[2][3]);
  sum4 = (sum4 + a[3][3]);
  if ((((((sum1 > (10.0 - 0.1)) && (sum1 < (10.0 + 0.1))) && ((sum2 > (26.0 - 0.1)) && (sum2 < (26.0 + 0.1)))) && ((sum3 > (42.0 - 0.1)) && (sum3 < (42.0 + 0.1)))) && ((sum4 > (58.0 - 0.1)) && (sum4 < (58.0 + 0.1)))))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, -1.0, --1.0, +1.0);

void main()
{
  vec4 L1 = vec4(1.0 , 2.0 , 3.0 , 4.0);
  vec4 L2 = vec4(5.0 , 6.0 , 7.0 , 8.0);
  vec4 L3 = vec4(9.0 , 10.0 , 11.0 , 12.0);
  vec4 L4 = vec4(13.0 , 14.0 , 15.0 , 16.0);
  mat4 a = mat4(L1 , L2 , L3 , L4);
  float gray, sum1 = 0.0 , sum2 = 0.0 , sum3 = 0.0 , sum4 = 0.0;
  int i;
  sum1 = (sum1 + a[0][0]);
  sum2 = (sum2 + a[1][0]);
  sum3 = (sum3 + a[2][0]);
  sum4 = (sum4 + a[3][0]);
  sum1 = (sum1 + a[0][1]);
  sum2 = (sum2 + a[1][1]);
  sum3 = (sum3 + a[2][1]);
  sum4 = (sum4 + a[3][1]);
  sum1 = (sum1 + a[0][2]);
  sum2 = (sum2 + a[1][2]);
  sum3 = (sum3 + a[2][2]);
  sum4 = (sum4 + a[3][2]);
  sum1 = (sum1 + a[0][3]);
  sum2 = (sum2 + a[1][3]);
  sum3 = (sum3 + a[2][3]);
  sum4 = (sum4 + a[3][3]);
  if ((((((sum1 > (10.0 - 0.1)) && (sum1 < (10.0 + 0.1))) && ((sum2 > (26.0 - 0.1)) && (sum2 < (26.0 + 0.1)))) && ((sum3 > (42.0 - 0.1)) && (sum3 < (42.0 + 0.1)))) && ((sum4 > (58.0 - 0.1)) && (sum4 < (58.0 + 0.1)))))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
60.068649885583525
Mutations attempted: 874
Valid mutations:     525
Success rate:        60.07%
Processing this: /home/oof/webgl_cleaned/lessThan_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lessThan(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lessThan(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lessThan(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
  vec4(0.5, -((0.0 / 2.0) * 1.0), (0.5 * (+0.5 / (true ? 0.5 : 0.0))), +1.0);
}


As vertex? : False
SUCCESS!
60.11428571428571
Processing this: /home/oof/webgl_cleaned/sin_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * gtf_Color.rg;
	float sign = 1.0;
	vec2 sin_c = vec2(0.0);
	float fact;
	float fact_of;
	for(int i = 0; i < 12; i++)
	{
		fact = 1.0;
		for(int j = 2; j <= 23; j++)
			if (j <= 2 * i + 1)
				fact *= float(j);
		sin_c += sign * pow(c, vec2(2.0 * float(i) + 1.0)) / fact;
		sign *= -1.0;
	}
	color = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * gtf_Color.rg;\n\tfloat sign = 1.0;\n\tvec2 sin_c = vec2(0.0);\n\tfloat fact;\n\tfloat fact_of;\n\tfor(int i = 0; i < 12; i++)\n\t{\n\t\tfact = 1.0;\n\t\tfor(int j = 2; j <= 23; j++)\n\t\t\tif (j <= 2 * i + 1)\n\t\t\t\tfact *= float(j);\n\t\tsin_c += sign * pow(c, vec2(2.0 * float(i) + 1.0)) / fact;\n\t\tsign *= -1.0;\n\t}\n\tcolor = vec4(0.5 * sin_c + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(1.0, (0.5 * (+0.5 + (false ? 0.0 : 0.0))), (false ? 0.5 : (false ? (-1.0 * -1.0) : lerp(2.0, 2.0, -1.0))), (!(true || false) ? lerp(+2.0, lerp(0.0, -1.0, 1.0), (2.0 * 2.0)) : 1.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  vec2 c = ((2.0 * M_PI) * gtf_Color.rg);
  float sign = 1.0;
  vec2 sin_c = vec2(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec2(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'lerp' : no matching overloaded function found
ERROR: 0:4: 'lerp' : no matching overloaded function found
ERROR: 0:4: 'lerp' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(1.0, (0.5 * (+0.5 + (false ? 0.0 : 0.0))), (false ? 0.5 : (false ? (-1.0 * -1.0) : lerp(2.0, 2.0, -1.0))), (!(true || false) ? lerp(+2.0, lerp(0.0, -1.0, 1.0), (2.0 * 2.0)) : 1.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  sinValues[16] = 0.0;
  const float M_PI = 3.141592653589793;
  vec2 c = ((2.0 * M_PI) * gtf_Color.rg);
  float sign = 1.0;
  vec2 sin_c = vec2(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec2(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.04566210045662
Processing this: /home/oof/webgl_cleaned/acos_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(acos(c) / M_PI, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(acos(c) / M_PI, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = vec4((acos(c) / M_PI) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.091220068415055
Processing this: /home/oof/webgl_cleaned/clamp_vec2_vert_xvary_yconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec2 c = gtf_Color.rg;
	if(c[0] > max_c) c[0] = max_c;
	if(c[0] < min_c) c[0] = min_c;
	if(c[1] > max_c) c[1] = max_c;
	if(c[1] < min_c) c[1] = min_c;
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tvec2 c = gtf_Color.rg;\n\tif(c[0] > max_c) c[0] = max_c;\n\tif(c[0] < min_c) c[0] = min_c;\n\tif(c[1] > max_c) c[1] = max_c;\n\tif(c[1] < min_c) c[1] = min_c;\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, -1.0, -1.0, (true ? 2.0 : (1.0 + 0.5)));

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  if ((c[0] > max_c))
    c[0] = max_c;
  if ((c[0] < min_c))
    c[0] = min_c;
  if ((c[1] > max_c))
    c[1] = max_c;
  if ((c[1] < min_c))
    c[1] = min_c;
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.13667425968109
Processing this: /home/oof/webgl_cleaned/vec3_bgr_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec3 t = m.bgr;
	vec4 a = vec4(t.b, t.g, t.r, lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec3 t = m.bgr;\n\tvec4 a = vec4(t.b, t.g, t.r, lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, +2.0, 0.5, 0.5, (-(false ? 0.5 : 2.0) + ((false ? false : false) ? (false ? -1.0 : 0.5) : (true ? 0.5 : 0.0))), (!true ? ((1.0 - 2.0) / 0.5) : 2.0), 2.0, (!true ? ((false || true) ? 0.5 : 0.5) : (2.0 * -1.0)), (true ? (0.5 / (0.5 + 1.0)) : -1.0), -1.0, (false ? (true ? 2.0 : 2.0) : 1.0), 0.0, (0.5 + 2.0), +0.0, -+0.0, (-1.0 / 0.5));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec3 t = m.bgr;
  vec4 a = vec4(t.b , t.g , t.r , lightloc.a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, +2.0, 0.5, 0.5, (-(false ? 0.5 : 2.0) + ((false ? false : false) ? (false ? -1.0 : 0.5) : (true ? 0.5 : 0.0))), (!true ? ((1.0 - 2.0) / 0.5) : 2.0), 2.0, (!true ? ((false || true) ? 0.5 : 0.5) : (2.0 * -1.0)), (true ? (0.5 / (0.5 + 1.0)) : -1.0), -1.0, (false ? (true ? 2.0 : 2.0) : 1.0), 0.0, (0.5 + 2.0), +0.0, -+0.0, (-1.0 / 0.5));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec3 t = m.bgr;
  vec4 a = vec4(t.b , t.g , t.r , lightloc.a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
60.068259385665534
Processing this: /home/oof/webgl_cleaned/vec3_yxz_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	vec3 t = m.yxz;
	vec4 a = vec4(t.y, t.x, t.z ,al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tvec3 t = m.yxz;\n\tvec4 a = vec4(t.y, t.x, t.z ,al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  vec3 t = m.yxz;
  vec4 a = vec4(t.y , t.x , t.z , al.w);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
60.11363636363637
Processing this: /home/oof/webgl_cleaned/initfunc_empty_array_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void initialise_array(out float array[2], float init_val);
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	initialise_array(new_mad,25.0);
	if( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )
	  gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
void initialise_array(out float array[2], float init_val)
{
	int i=0;
	array[0] = init_val;
	array[1] = init_val;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid initialise_array(out float array[2], float init_val);\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tinitialise_array(new_mad,25.0);\n\tif( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvoid initialise_array(out float array[2], float init_val)\n{\n\tint i=0;\n\tarray[0] = init_val;\n\tarray[1] = init_val;\n}\n\x00')
60.11363636363637
Processing this: /home/oof/webgl_cleaned/mat_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat2 vuni2;
uniform mat3 vuni3;
uniform mat4 vuni4;
varying vec4 color;
void main ()
{
	color = vec4( vuni2[0][0] + vuni2[0][1] + vuni2[1][0] + vuni2[1][1],
		      vuni3[0][0] + vuni3[0][1] + vuni3[0][2] + vuni3[1][0] + vuni3[1][1] + vuni3[1][2] + vuni3[2][0] + vuni3[2][1] + vuni3[2][2],
                     vuni4[0][0] + vuni4[0][1] + vuni4[0][2] + vuni4[0][3] + vuni4[1][0] + vuni4[1][1] + vuni4[1][2] + vuni4[1][3] + vuni4[2][0] + vuni4[2][1] + vuni4[2][2] + vuni4[2][3] + vuni4[3][0] + vuni4[3][1] + vuni4[3][2] + vuni4[3][3], 1.0 );
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat2 vuni2;\nuniform mat3 vuni3;\nuniform mat4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4( vuni2[0][0] + vuni2[0][1] + vuni2[1][0] + vuni2[1][1],\n\t\t      vuni3[0][0] + vuni3[0][1] + vuni3[0][2] + vuni3[1][0] + vuni3[1][1] + vuni3[1][2] + vuni3[2][0] + vuni3[2][1] + vuni3[2][2],\n                     vuni4[0][0] + vuni4[0][1] + vuni4[0][2] + vuni4[0][3] + vuni4[1][0] + vuni4[1][1] + vuni4[1][2] + vuni4[1][3] + vuni4[2][0] + vuni4[2][1] + vuni4[2][2] + vuni4[2][3] + vuni4[3][0] + vuni4[3][1] + vuni4[3][2] + vuni4[3][3], 1.0 );\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform mat2 vuni2;

uniform mat3 vuni3;

uniform mat4 vuni4;

vec4 color;

void main()
{
  color = vec4((((vuni2[0][0] + vuni2[0][1]) + vuni2[1][0]) + vuni2[1][1]) , ((((((((vuni3[0][0] + vuni3[0][1]) + vuni3[0][2]) + vuni3[1][0]) + vuni3[1][1]) + vuni3[1][2]) + vuni3[2][0]) + vuni3[2][1]) + vuni3[2][2]) , (((((((((((((((vuni4[0][0] + vuni4[0][1]) + vuni4[0][2]) + vuni4[0][3]) + vuni4[1][0]) + vuni4[1][1]) + vuni4[1][2]) + vuni4[1][3]) + vuni4[2][0]) + vuni4[2][1]) + vuni4[2][2]) + vuni4[2][3]) + vuni4[3][0]) + vuni4[3][1]) + vuni4[3][2]) + vuni4[3][3]) , 1.0);
  gtf_Vertex = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.1589103291714
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
60.1589103291714
Processing this: /home/oof/webgl_cleaned/abs_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (color.rg - 0.5);
	if((c[0] < 0.0)) c[0] *= -1.0;
	if((c[1] < 0.0)) c[1] *= -1.0;
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tif((c[0] < 0.0)) c[0] *= -1.0;\n\tif((c[1] < 0.0)) c[1] *= -1.0;\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (1.0 - 2.0), (2.0 * (false ? 1.0 : (1.0 - -1.0))), (false ? 1.0 : +(2.0 + 2.0)));

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.204081632653065
Mutations attempted: 882
Valid mutations:     531
Success rate:        60.20%
Processing this: /home/oof/webgl_cleaned/21i_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform int color[2];
void main ()
{
	float r = float(color[0]);
	float g = float(color[1]);
	gl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform int color[2];\nvoid main ()\n{\n\tfloat r = float(color[0]);\n\tfloat g = float(color[1]);\n\tgl_FragColor = vec4 (r/256.0, g/256.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform int color[2] = int[2](7, 6);

void main()
{
  float r = float(color[0]);
  float g = float(color[1]);
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform int color[2] = int[2](7, 6);

void main()
{
  float r = float(color[0]);
  float g = float(color[1]);
  gl_FragColor = vec4((r / 256.0) , (g / 256.0) , 0.0 , 1.0);
}


==============================
60.13590033975085
Processing this: /home/oof/webgl_cleaned/vec3_zyx_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec3 t = m.zyx;
	vec4 a = vec4(t.z, t.y, t.x, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec3 t = m.zyx;\n\tvec4 a = vec4(t.z, t.y, t.x, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, -1.0, (-(2.0 + 0.5) / -0.5), -1.0, ((-1.0 - -1.0) * (true ? -1.0 : +0.5)), (1.0 / 2.0), 2.0, (((false ? false : true) || (false && false)) ? (!true ? 1.0 : +2.0) : 0.5), 2.0, ((true ? true : false) ? (true ? +0.5 : 2.0) : 0.0), +(0.5 * 0.0), +-2.0, 0.0, (false ? -1.0 : 0.5), 1.0, 1.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec3 t = m.zyx;
  vec4 a = vec4(t.z , t.y , t.x , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, -1.0, (-(2.0 + 0.5) / -0.5), -1.0, ((-1.0 - -1.0) * (true ? -1.0 : +0.5)), (1.0 / 2.0), 2.0, (((false ? false : true) || (false && false)) ? (!true ? 1.0 : +2.0) : 0.5), 2.0, ((true ? true : false) ? (true ? +0.5 : 2.0) : 0.0), +(0.5 * 0.0), +-2.0, 0.0, (false ? -1.0 : 0.5), 1.0, 1.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec3 t = m.zyx;
  vec4 a = vec4(t.z , t.y , t.x , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
60.06787330316742
Processing this: /home/oof/webgl_cleaned/fract_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.5, 2.0, -1.0);

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.11299435028249
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat3 m1 = mat3(gtf_Color.rgb, gtf_Color.rgb, gtf_Color.rgb);
	mat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);
	mat3 m3 = mat3(0.0);
	vec3 result = vec3(0.0, 0.0, 0.0);
	m3 = matrixCompMult(m1, m2);
	result[0] += m3[0][0];
	result[0] += m3[0][1];
	result[0] += m3[0][2];
	result[1] += m3[1][0];
	result[1] += m3[1][1];
	result[1] += m3[1][2];
	result[2] += m3[2][0];
	result[2] += m3[2][1];
	result[2] += m3[2][2];
	color = vec4(result / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m1 = mat3(gtf_Color.rgb, gtf_Color.rgb, gtf_Color.rgb);\n\tmat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);\n\tmat3 m3 = mat3(0.0);\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tm3 = matrixCompMult(m1, m2);\n\tresult[0] += m3[0][0];\n\tresult[0] += m3[0][1];\n\tresult[0] += m3[0][2];\n\tresult[1] += m3[1][0];\n\tresult[1] += m3[1][1];\n\tresult[1] += m3[1][2];\n\tresult[2] += m3[2][0];\n\tresult[2] += m3[2][1];\n\tresult[2] += m3[2][2];\n\tcolor = vec4(result / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  mat3 m1 = mat3(gtf_Color.rgb , gtf_Color.rgb , gtf_Color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3 = matrixCompMult(m1 , m2);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  color = vec4((result / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex = vec4(-0.5, 0.0, 0.5, 2.0);

vec4 gtf_Color;

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_Color' : undeclared identifier
ERROR: 0:6: 'rgb' :  field selection requires structure or vector on left hand side
ERROR: 0:6: 'gtf_Color' : undeclared identifier
ERROR: 0:6: 'rgb' :  field selection requires structure or vector on left hand side
ERROR: 0:6: 'gtf_Color' : undeclared identifier
ERROR: 0:6: 'rgb' :  field selection requires structure or vector on left hand side
ERROR: 0:6: 'constructor' : not enough data provided for construction
ERROR: 0:20: 'color' : undeclared identifier
ERROR: 0:20: 'assign' : l-value required (can't modify a const)
ERROR: 0:20: '=' : dimension mismatch
ERROR: 0:20: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const highp float'
ERROR: 0:21: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:21: 'gtf_Vertex' : undeclared identifier
ERROR: 0:21: '=' : dimension mismatch
ERROR: 0:21: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  mat3 m1 = mat3(gtf_Color.rgb , gtf_Color.rgb , gtf_Color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3 = matrixCompMult(m1 , m2);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  color = vec4((result / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex = vec4(-0.5, 0.0, 0.5, 2.0);

vec4 gtf_Color;

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;


==============================
60.0451467268623
Processing this: /home/oof/webgl_cleaned/all_bvec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(4.0 * gtf_Color.rg);
	color = vec4(vec3(all(bvec2(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(4.0 * gtf_Color.rg);\n\tcolor = vec4(vec3(all(bvec2(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((false ? -(-1.0 + 0.5) : ((false ? 2.0 : 2.0) / -2.0)), (--1.0 + +1.0), (-(0.5 + 0.5) + -1.0), (!false ? ((false ? 2.0 : 1.0) * (1.0 * 0.5)) : 0.0));

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor((4.0 * gtf_Color.rg));
  color = vec4(vec3(all(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((false ? -(-1.0 + 0.5) : ((false ? 2.0 : 2.0) / -2.0)), (--1.0 + +1.0), (-(0.5 + 0.5) + -1.0), (!false ? ((false ? 2.0 : 1.0) * (1.0 * 0.5)) : 0.0));

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor((4.0 * gtf_Color.rg));
  color = vec4(vec3(all(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.97745208568207
Processing this: /home/oof/webgl_cleaned/floor_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4((floor(c) + 10.0) / 20.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4((floor(c) + 10.0) / 20.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = color(((floor(c) + 10.0) / 20.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'gl_FragColor' : undeclared identifier
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = color(((floor(c) + 10.0) / 20.0));
}


==============================
59.909909909909906
Processing this: /home/oof/webgl_cleaned/abs_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(abs(c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(abs(c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-((false && true) ? (true ? 1.0 : 0.5) : 0.0), -1.0, -0.5, 0.5);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  color = vec4(abs(c) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
59.955005624296966
Processing this: /home/oof/webgl_cleaned/acos_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(acos(c) / M_PI, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(acos(c) / M_PI, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (gtf_Color.rg - 0.5));
  color = vec4((acos(c) / M_PI) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.0
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = -gtf_Color.rg;
	color = vec4(exp(3.0 * c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -gtf_Color.rg;\n\tcolor = vec4(exp(3.0 * c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(+-1.0, -1.0, +0.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = -gtf_Color.rg;
  color = vec4(exp((3.0 * c)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.04489337822672
Processing this: /home/oof/webgl_cleaned/inversesqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r * 99.0) + 1.0;
	color = vec4(inversesqrt(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r * 99.0) + 1.0;\n\tcolor = vec4(inversesqrt(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-+2.0, (((false ? true : true) && false) ? -(2.0 * 2.0) : -0.0), (-1.0 - -1.0), -1.0, +0.5, -1.0, (false ? (!false ? (0.5 + 0.5) : 0.0) : -(0.5 + 2.0)), -1.0, 2.0, (0.0 + (0.0 + 1.0)), +-1.0, (0.0 + -(1.0 - -1.0)), --+1.0, +(false ? 2.0 : -1.0), +0.0, 0.0);

vec4 color;

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4(inversesqrt(c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-+2.0, (((false ? true : true) && false) ? -(2.0 * 2.0) : -0.0), (-1.0 - -1.0), -1.0, +0.5, -1.0, (false ? (!false ? (0.5 + 0.5) : 0.0) : -(0.5 + 2.0)), -1.0, 2.0, (0.0 + (0.0 + 1.0)), +-1.0, (0.0 + -(1.0 - -1.0)), --+1.0, +(false ? 2.0 : -1.0), +0.0, 0.0);

vec4 color;

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4(inversesqrt(c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
Mutations attempted: 892
Valid mutations:     535
Success rate:        59.98%
