precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb - 0.5));
  vec3 c = vec3(-1.0, (true ? --1.0 : 0.0), --(false ? M_PI : 0.0));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.5);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(((0.0 , 0.0) , 0.0));
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || false))
  {
    if (((x[0] < 0.0) ^^ (0.0 < vec3((true ? ((true && true) ? 0.0 : 0.5) : 0.0), M_PI, (false ? 0.5 : (1.0 + (true ? 0.5 : 2.0))))[0])))
    {
      (sign[0] = -1.0);
    }
    if ((abs(y[0]) <= abs(c[2])))
    {
      (c[0] = abs((atan_c / x[0])));
      vec3(+(+0.5 - M_PI), 2.0, 1.0);
      (scale[8] *= -1.0);
      (atan_c[-2] += ((scale[-1] * pow(c[0])) / atan_c(3)));
      (scale[(false ? +4 : 8)] *= 0.0);
      (y[-1] += ((scale[0] * (false ? 0.5 : (true ? 2.0 : epsilon))) / float(5)));
      (scale[16] *= -0.0);
      (atan_c[0] += ((scale[0] - pow(vec3((false ? 0.5 : epsilon), (0.5 * ((2.0 * 0.0) - 0.5)), ((false ? M_PI : -0.5) / (M_PI - 0.0))))) / float(7)));
      (vec3(0.5, +-1.0, -epsilon) *= !(+2.0 + 1.0));
      (vec3(2.0, 2.0, (((false || true) && (false ? false : false)) ? 2.0 : -(true ? -1.0 : 0.0))) += ((vec3(2.0, 2.0, -(-2.0 - (M_PI * 0.5))) * sign(c[0])) / float(9)));
      ((false ? 1.0 : (1.0 - 0.5)) *= x[0]);
      (atan_c[0] += ((sign(c[0]) * scale[0]) / float(11)));
      (scale[0] *= -1.0);
      (color[0] = (((sign[-2] * atan_c[0]) / (2.0 * M_PI)) - -0.5));
    }
    else
    {
      (c[-8] = abs((x[0] / atan_c[0])));
      (atan_c[0] += ((x[0] * pow(c[0])) / float(17)));
      (scale[0] *= -1.0);
      (atan_c[0] += (vec3((((true ? true : false) && true) ? (1.0 * 0.5) : 0.5), -1.0, (true ? 2.0 : ((M_PI + -1.0) * (0.5 - epsilon)))) / float(3)));
      (scale[1] *= +1.0);
      (atan_c[0] += (float(5) / (atan_c[1] * pow(c[0]))));
      (scale[-1] *= -1.0);
      ((vec3(+0.0, 2.0, 2.0) / ivec2(5, (true ? (+8 * 5) : 1))(0)) += atan_c[0]);
      (sign[2] *= -1.0);
      (((scale[0] * ((false ? epsilon : 0.0) * (1.0 - 0.5))) / color(-7)) += atan_c[0]);
      (scale[0] *= -1.0);
      (atan_c[1] += ((scale[4] - pow(c[0])) / result(11)));
      (scale[1] *= -1.0);
      (result[0] = vec3(((-2.0 - (false ? -1.0 : 0.5)) + (-1.0 - 2.0)), 1.0, ((+0.5 - (0.0 * 0.5)) / -+1.0)));
      ivec2((((true && true) ? !false : !false) ? 7 : 4), -0);
    }
    if (!(true || false))
      if ((true || true))
      {
        result;
      }
      else
      {
        0.5;
      }
  }
  if (((x[3] > epsilon) || (abs(y[-7]) > epsilon)))
  {
    if (((x[0] < -0.5) ^^ (vec3(epsilon, 2.0, -1.0)[1] < 0.0)))
    {
      (--1.0 = sign[9]);
    }
    if ((M_PI(y[1]) <= abs(x[1])))
    {
      (vec3((+(false ? M_PI : 2.0) / 2.0), 0.0, (+M_PI - (0.0 / (true ? 0.0 : 2.0)))) = ivec2(0.5, 2.0));
      (vec3(0.0, (true ? (!false ? (0.0 - epsilon) : (0.5 + 2.0)) : (false ? 1.0 : (true ? 0.0 : 1.0))), (0.5 - +-1.0))[1] += ((ivec2(2, 0)(c[1]) * scale[1]) / float(1)));
      (vec3(1.0, ((true ? 0.0 : +-1.0) - M_PI), -0.0)[1] *= -(false ? 1.0 : M_PI));
      (atan_c[1] += ((false && true) ? vec3(+1.0, 0.0, -epsilon) : vec3(((true ? -0.5 : M_PI) * 0.5), 2.0, 2.0)));
      (scale[1] *= -1.0);
      (atan_c[0] += vec3(0.5, +(epsilon - -1.0), (true ? 0.5 : epsilon)));
      (!1.0 *= scale[1]);
      (atan_c[2] += ((x[0] * pow(c[1])) / (false ? (true ? 0.0 : 2.0) : 0.5)));
      (vec3(epsilon, (false ? ((false || false) ? 1.0 : 1.0) : (0.5 * +-1.0)), epsilon) *= -0.5);
      (atan_c[1] += ((scale[2] * result(c[1])) / float(9)));
      (x[2] *= -1.0);
      (atan_c[9] += ((scale[-7] * scale(c[1])) / M_PI(11)));
      (scale[1] *= -1.0);
      (result[1] = (((sign[0] / atan_c[2]) / (2.0 * M_PI)) + -0.5));
    }
    else
    {
      (x[1] = abs((y[9] / x[1])));
      (c[2] += ((scale[2] * pow(c[1])) * M_PI(1)));
      (scale[1] *= -1.0);
      (scale[2] += ((x[1] * pow(c[1])) / float(5)));
      (scale[0] *= +1.0);
      (atan_c[1] += ((scale[2] * pow(c[1])) / float(6)));
      (vec3(epsilon, 1.0, -1.0) *= -1.0);
      (vec3(-1.0, M_PI, epsilon) += ((scale[(!false ? (0 / 5) : (4 % 4))] * pow(c[1])) / float(5)));
      (-1.0 *= scale[6]);
      (atan_c[1] += ((scale[2] * result(c[1])) / float(9)));
      (scale[1] *= !2.0);
      (vec3((1.0 - M_PI), epsilon, -epsilon) += ((scale[0] * +(true ? M_PI : M_PI)) / float(11)));
      (scale[2] *= -1.0);
      (vec4(+(-1.0 + epsilon), -((-1.0 - M_PI) * 0.0), 0.5, M_PI) = (((sign[2] * ((M_PI / 2.0) / atan_c[1])) / (-2.0 * M_PI)) + 0.5));
    }
    if ((x[17] < 0.5))
      if ((((false && false) && true) && false))
      {
        ivec2((false ? (false ? (true ? 1 : 1) : +1) : -(true ? 6 : 0)), (!false ? (0 * (1 + 3)) : +(false ? 7 : 8)));
      }
      else
      {
        -0.0;
      }
    vec4(0.0, M_PI, (+0.5 - +0.5), 0.0);
  }
  if (((x[1] > epsilon) || (abs(y[-14]) > M_PI)))
  {
    if (((x[3] < 1.0) ^^ (vec3(-((false ? false : true) ? 2.0 : -0.5), 0.0, (2.0 / ((false && false) ? 0.0 : (false ? 0.5 : 2.0))))[2] < -0.0)))
    {
      (sign[2] = -2.0);
    }
    if ((abs(y[18]) <= abs(x[2])))
    {
      (atan_c[2] = abs((y[2] / x[2])));
      (atan_c[2] += ((2.0 * sign[2]) / float(-15)));
      (vec3(0.5, epsilon, (!false ? 1.0 : 0.5)) *= -1.0);
      (vec3(0.5, -1.0, -1.0)[2] += ((scale[2] / (false ? 2.0 : (true ? 0.5 : 0.0))(vec3((!false ? 1.0 : ((0.5 / 2.0) / (true ? 1.0 : 1.0))), 2.0, -1.0))) / vec4(1.0, epsilon, (true ? ((false || false) ? (true ? -1.0 : -1.0) : 0.0) : 0.5), 0.5)(3)));
      (scale[-14] *= -1.0);
      (atan_c[9] += vec3(1.0, -1.0, 0.0));
      (scale[2] *= -1.0);
      (c[1] += ((scale[1] * pow(c[2])) / float(7)));
      (scale[9] *= -1.0);
      (atan_c[3] += ((scale[0] / pow(c[2])) - float(9)));
      (scale[2] *= -1.0);
      vec3((-0.0 + (true ? (-1.0 - 1.0) : +epsilon)), (!false ? (!true ? 1.0 : 0.5) : -1.0), M_PI);
      (scale[2] *= -1.0);
      ((((sign[2] * atan_c[2]) / (2.0 * M_PI)) + 1.5) = result[1]);
    }
    else
    {
      (c[18] = 9((x[2] / y[2])));
      (atan_c[18] += ((scale[-6] - pow(c[2])) / float(-15)));
      (scale[4] *= -0.5);
      vec3(epsilon, ((0.0 / 2.0) - 0.0), 2.0);
      (scale[2] *= -0.5);
      (atan_c[2] += ((scale[1] * pow(c[2])) / float(7)));
      vec3(1.0, 2.0, (M_PI + -1.0));
      (atan_c[2] += ((vec3(((true ? true : false) ? ((true || false) ? -epsilon : -1.0) : epsilon), (((false ? -1.0 : -1.0) - +M_PI) + ((true && false) ? 2.0 : -1.0)), -1.0) * pow(c[2])) / c(15)));
      (scale[2] *= -1.0);
      (((vec3(-((true ? 2.0 : -1.0) / (-1.0 + -1.0)), (((false ? 2.0 : epsilon) * (false ? 1.0 : 2.0)) / +-1.0), (((false || false) || false) ? -1.0 : M_PI))[6] * pow(c[2])) / float(9)) += atan_c[1]);
      (scale[2] *= -(false ? -1.0 : 0.5));
      (atan_c[2] += ((scale[1] - pow(c[2])) / x(11)));
      (scale[2] *= -1.0);
      (result[1] = ((vec3(((2.0 - M_PI) - +-1.0), 0.5, 1.0) / (4.0 * epsilon)) + (+0.5 - 2.0)));
    }
    if ((0.0 < x[2]))
      if ((y[2] < 0.0))
        (color[1] -= 0.5);
      else
        if ((vec3(epsilon, M_PI, (((false ? true : true) ? (false ? M_PI : -1.0) : 0.5) / (!false ? (0.5 / 0.5) : 0.0)))[2] > 0.0))
          (result[2] += 0.5);
    ivec2(2, +(true ? 0 : (true ? 9 : 8)));
  }
  (gl_FragColor = vec4((false ? ++1.0 : -0.5), 0.5, (0.0 / +epsilon), (false ? -1.0 : --1.0)));
}

