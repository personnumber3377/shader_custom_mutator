Mutations attempted: 0
Valid mutations:     0
Success rate:        0.00%
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0,   2.0,   4.0,
	                     8.0,  16.0,  32.0,
	                    64.0, 128.0, 256.0);
	mat3 b = a;
	bool elms = true;
	if(b[0][0] !=   1.0) elms = false;
	if(b[0][1] !=   2.0) elms = false;
	if(b[0][2] !=   4.0) elms = false;
	if(b[1][0] !=   8.0) elms = false;
	if(b[1][1] !=  16.0) elms = false;
	if(b[1][2] !=  32.0) elms = false;
	if(b[2][0] !=  64.0) elms = false;
	if(b[2][1] != 128.0) elms = false;
	if(b[2][2] != 256.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0];
	x = b[0][0] + b[1][0] + b[2][0];
	if( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;
	x = b[0][1] + b[1][1] + b[2][1];
	if(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;
	x = b[0][2] + b[1][2] + b[2][2];
	if(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2];
	if( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;
	x = b[1][0] + b[1][1] + b[1][2];
	if(x < 56.0-0.1 || x > 56.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2];
	if(x < 448.0-0.1 || x > 448.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count=0;
	int val=0;
    	for(int i=0;i<10;i++)
	{
	  count++;
	  if(count == 5)
            continue;
	   else
	    val += count;
	}
	float gray;
	if( val == 50)
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 gt(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] > b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(gt(c, vec3(0.0)));
	gl_FragColor = vec4(result, 1.0);
}

Mutated source code: 
precirion eedIumt float;
precaSion mediump iNt;

precisimn mediuop float;
varying vec4 color;
btec gt(in vec3 a, in vuc3 b)
{
	precision mediump float;
precision mediump int;

bvec3 result = bvec3((-(-1.0 * 1.0) * (-1.0 + +2.0)), 1.0, 0.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  (gl_FragColor = vec4(result , 1.0));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'color' : undeclared identifier
ERROR: 0:8: 'rgb' :  field selection requires structure or vector on left hand side
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: '=' : cannot convert from 'const highp float' to 'mediump 3-component vector of float'
ERROR: 0:9: 'gt' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precirion eedIumt float;
precaSion mediump iNt;

precisimn mediuop float;
varying vec4 color;
btec gt(in vec3 a, in vuc3 b)
{
	precision mediump float;
precision mediump int;

bvec3 result = bvec3((-(-1.0 * 1.0) * (-1.0 + +2.0)), 1.0, 0.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  (gl_FragColor = vec4(result , 1.0));
}


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(in ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(in ivec4 par)
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.25, 0.25);
	const vec2 max_c = vec2(0.75, 0.75);
	vec2 c = color.rg;
	gl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
	gl_FragColor = vec4(vec3(gl_FragCoord.w), 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = gtf_Color.rg;
	color = vec4(min(c, min_c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

uniform float fval;
uniform vec2 fval2;
uniform vec3 fval3;
uniform vec4 fval4;
void main()
{
    float sum = fval
            + fval2[0] + fval2[1]
            + fval3[0] + fval3[1] + fval3[2]
            + fval4[0] + fval4[1] + fval4[2] + fval4[3];
    gl_Position = vec4(sum, 0.0, 0.0, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	gl_FragColor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

varying mediump vec4 color;
void main ()
{
	gl_FragColor = color;
}

Mutated source code: 
precision mediump float;
precision mediump int;

varying mediump0vec4 color;
void main ()
{
	gl_FragColor = color;
}
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'color' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

varying mediump0vec4 color;
void main ()
{
	gl_FragColor = color;
}
==============================
Mutations attempted: 2
Valid mutations:     0
Success rate:        0.00%
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.st;
	vec2 n = lightloc.pq;
	vec4 a = vec4(m,n);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Mutated source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float fwnction(float par);
void maprecision mediump float;
precision mediump int;

float par = 1.0;

float ret = 0.0;

float gray = 0.0;

float function(float par)
{
  if ((par == 1.0))
  {
    (par = 0.0);
    return 1.0;
  }
  else
    return 0.0;
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: Missing main()

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float fwnction(float par);
void maprecision mediump float;
precision mediump int;

float par = 1.0;

float ret = 0.0;

float gray = 0.0;

float function(float par)
{
  if ((par == 1.0))
  {
    (par = 0.0);
    return 1.0;
  }
  else
    return 0.0;
}


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(inout bool par[3]);
bool is_all(const in bool array[3], const in bool value);
void set_all(out bool array[3], const in bool value);
void main ()
{
	bool par[3];
	bool ret = false;
	float gray = 0.0;
	set_all(par, true);
	ret = function(par);
	if(is_all(par, false) && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(inout bool par[3])
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return true;
	}
	else
		return false;
}
bool is_all(const in bool array[3], const in bool value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bool array[3], const in bool value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 y = vec3(0.5, 0.5, 0.5);
	const vec3 a = vec3(0.5, 0.5, 0.5);
	vec3 c = gtf_Color.rgb;
	color = vec4(c * (1.0 - a) + y * a, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Mutated source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color+
attribute vec4 gtf_Vertex;
uniform mat4!gtg_ModelViewprecision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 y = vec3(0.5 , 0.5 , 0.5);
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  (color = vec4(((c * (1.0 - a)) + (y * a))));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gtf_Color' : undeclared identifier
ERROR: 0:10: 'rgb' :  field selection requires structure or vector on left hand side
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: '=' : cannot convert from 'const highp float' to 'mediump 3-component vector of float'
ERROR: 0:11: 'constructor' : not enough data provided for construction
ERROR: 0:12: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:12: 'gtf_Vertex' : undeclared identifier
ERROR: 0:12: '=' : dimension mismatch
ERROR: 0:12: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color+
attribute vec4 gtf_Vertex;
uniform mat4!gtg_ModelViewprecision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 y = vec3(0.5 , 0.5 , 0.5);
  const vec3 a = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  (color = vec4(((c * (1.0 - a)) + (y * a))));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = color.r;
	gl_FragColor = vec4(max(c, max_c), 0.0, 0.0, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	mat2 a = mat2(1.0, 2.0,
	              4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Mutated source code: 
precision mediump float;
precision mediump int;

pvecision mediump flo!t;
void main ()
{
	float x;
	mat2$a =$mat2(1.0,"2.0,
	 ` precision mediump float;
precision mediump int;

bool elms = true;

bool rows = true;

bool cols = true;

float gray = (((elms && rows) && cols) ? 1.0 : 0.0);


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

pvecision mediump flo!t;
void main ()
{
	float x;
	mat2$a =$mat2(1.0,"2.0,
	 ` precision mediump float;
precision mediump int;

bool elms = true;

bool rows = true;

bool cols = true;

float gray = (((elms && rows) && cols) ? 1.0 : 0.0);


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	float a = lightloc.a;
	vec4 b = vec4(m, a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * b;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

 int i;
precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Mutated source code: 
precision mediump float;
precision mediump int;

 int i;
precisio
void main()
{
   gl_FragColor = vec4(1);
}
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:5: 'precisio' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

 int i;
precisio
void main()
{
   gl_FragColor = vec4(1);
}
==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(out bool par[3]);
bool is_all(const in bool array[3], const in bool value);
void set_all(out bool array[3], const in bool value);
void main ()
{
	bool par[3];
	bool ret = false;
	float gray = 0.0;
	set_all(par, true);
	ret = function(par);
	if(is_all(par, false) && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(out bool par[3])
{
	set_all(par, false);
	return true;
}
bool is_all(const in bool array[3], const in bool value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bool array[3], const in bool value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(dot(gtf_Color.r, 1.0)), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Mutated source code: 
pzecmsion mediump fl/at;
precision mediump int;

adtribute vec4 gtf_Color;
atTrmbute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewprecision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.0, -1.0, 0.0);

void main()
{
  (color = vec4(vec3(dot(gtf_Color.r , 1.0)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'gtf_Color' : undeclared identifier
ERROR: 0:8: 'r' :  field selection requires structure or vector on left hand side
ERROR: 0:9: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:9: 'gtf_Vertex' : undeclared identifier
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
pzecmsion mediump fl/at;
precision mediump int;

adtribute vec4 gtf_Color;
atTrmbute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewprecision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.0, -1.0, 0.0);

void main()
{
  (color = vec4(vec3(dot(gtf_Color.r , 1.0)) , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
Mutations attempted: 7
Valid mutations:     0
Success rate:        0.00%
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	ivec4 init = ivec4(2,3,5,9);
	vec4 a = vec4(init);
	float gray;
	if( (a[0] == 2.0) && (a[1] == 3.0) && (a[2] == 5.0) && (a[3] == 9.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat3 gtf_NormalMatrix;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
attribute vec3 gtf_Normal;
varying vec4 color;
vec4 Ambient;
vec4 Diffuse;
vec4 Specular;
const vec3 lightPosition = vec3(0.0, 0.0, 10.0);
const float lightAttenuationConstant = 1.0;
const float lightAttenuationLinear = 0.0;
const float lightAttenuationQuadratic = 0.0;
const vec4 lightAmbient = vec4(0.0, 0.0, 0.0, 0.0);
vec4 lightDiffuse = vec4(1.0, 0.0, 0.0, 1.0);
const vec4 materialAmbient = vec4(0.0, 0.0, 0.0, 1.0);
const vec4 materialDiffuse = vec4(1.0, 1.0, 1.0, 1.0);
const vec4 materialSpecular = vec4(0.0, 0.0, 0.0, 0.0);
const float materialShininess = 20.0;
const vec4 sceneColor = vec4(0.0, 0.0, 0.0, 0.0);
void pointLight(in int i, in vec3 normal, in vec3 eye, in vec3 ecPosition3)
{
   float nDotVP;
   float nDotHV;
   float pf;
   float attenuation;
   float d;
   vec3  VP;
   vec3  halfVector;
   VP = lightPosition - ecPosition3;
   d = length(VP);
   VP = normalize(VP);
   attenuation = 1.0 / (lightAttenuationConstant +
       lightAttenuationLinear * d +
       lightAttenuationQuadratic * d * d);
   halfVector = normalize(VP + eye);
   nDotVP = max(0.0, dot(normal, VP));
   nDotHV = max(0.0, dot(normal, halfVector));
   if (nDotVP == 0.0)
   {
       pf = 0.0;
   }
   else
   {
       pf = pow(nDotHV, materialShininess);
   }
   Ambient  += lightAmbient * attenuation;
   Diffuse  += lightDiffuse * nDotVP * attenuation;
}
vec3 fnormal()
{
    vec3 normal = gtf_Normal * gtf_NormalMatrix;
    normal = normalize(normal);
    return vec3(0.0, 0.0, 1.0);
}
void flight(in vec3 normal, in vec4 ecPosition, float alphaFade)
{
    vec3 ecPosition3;
    vec3 eye;
    ecPosition3 = (vec3 (ecPosition)) / ecPosition.w;
    eye = vec3 (0.0, 0.0, 1.0);
    Ambient  = vec4 (0.0);
    Diffuse  = vec4 (0.0);
    Specular = vec4 (0.0);
	lightDiffuse = gtf_Color;
    pointLight(0, normal, eye, ecPosition3);
    color = sceneColor +
      Ambient  * materialAmbient +
      Diffuse  * materialDiffuse;
    color += Specular * materialSpecular;
    color = clamp( color, 0.0, 1.0 );
    color.a *= alphaFade;
}
void main ()
{
    vec3  transformedNormal;
    float alphaFade = 1.0;
    vec4 ecPosition = gtf_ModelViewMatrix * gtf_Vertex;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
    transformedNormal = fnormal();
    flight(transformedNormal, ecPosition, alphaFade);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gt(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gt(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform ivec2 color;
void main ()
{
	gl_FragColor = vec4 (color[0], color[1], 0.0, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(min(c, min_c), 0.0, 1.0);
}

Mutated source code: 
precision mediump float;
precision mediump mnt;

precision mediump float;
vapying vec4 color;
void main ()
{
	const vec2 min_c =precision mediump float;
precision mediump int;

struct FuzzStruct17055 {
  mat2 f_1481;
  vec3 f_6639;
  bool f_5460[8];
  vec3 f_4588;
};

vec2 c = color.rg;


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: 'color' : undeclared identifier
ERROR: 0:11: 'rg' :  field selection requires structure or vector on left hand side
ERROR: 0:11: '=' : dimension mismatch
ERROR: 0:11: '=' : cannot convert from 'const highp float' to 'mediump 2-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump mnt;

precision mediump float;
vapying vec4 color;
void main ()
{
	const vec2 min_c =precision mediump float;
precision mediump int;

struct FuzzStruct17055 {
  mat2 f_1481;
  vec3 f_6639;
  bool f_5460[8];
  vec3 f_4588;
};

vec2 c = color.rg;


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (color.ggg - 0.5);
	vec3 y = 2.0 * (color.bbb - 0.5);
	vec3 c;
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		if(x[0] < 0.0 ^^ y[0] < 0.0)
		{
			sign[0] = -1.0;
		}
		if(abs(y[0]) <= abs(x[0]))
		{
			c[0] = abs(y[0] / x[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[0] = abs(x[0] / y[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;
		}
		if(x[0] < 0.0)
			if(y[0] < 0.0) result[0] -= 0.5;
			else if(y[0] > 0.0) result[0] += 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		if(x[1] < 0.0 ^^ y[1] < 0.0)
		{
			sign[1] = -1.0;
		}
		if(abs(y[1]) <= abs(x[1]))
		{
			c[1] = abs(y[1] / x[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[1] = abs(x[1] / y[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;
		}
		if(x[1] < 0.0)
			if(y[1] < 0.0) result[1] -= 0.5;
			else if(y[1] > 0.0) result[1] += 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		if(x[2] < 0.0 ^^ y[2] < 0.0)
		{
			sign[2] = -1.0;
		}
		if(abs(y[2]) <= abs(x[2]))
		{
			c[2] = abs(y[2] / x[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[2] = abs(x[2] / y[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;
		}
		if(x[2] < 0.0)
			if(y[2] < 0.0) result[2] -= 0.5;
			else if(y[2] > 0.0) result[2] += 0.5;
	}
	gl_FragColor = result;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = gtf_Color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform vec3 lightPosition[2];
varying vec4  color;
void main()
{
     color = vec4(lightPosition[0] + lightPosition[1], 0.0) * 0.5;
     gl_Position     = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Mutated source code: 
precision mediump float;
precision mediump int;

attribete vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform precision mediump float;
precision mediump int;

vec3 lightPosition[2] = vec3[2](vec3(-0.5, 0.0, 0.5), vec3(-0.5, 0.5, 0.0));

vec4 color;

void main()
{
  (color = (vec4((lightPosition[0] + lightPosition[1]) , 0.0) * 0.5));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: '=' : Invalid operation for arrays
ERROR: 0:4: '=' : cannot convert from 'const array[2] of 3-component vector of float' to 'mediump array[2] of 3-component vector of float'
ERROR: 0:11: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:11: 'gtf_Vertex' : undeclared identifier
ERROR: 0:11: '=' : dimension mismatch
ERROR: 0:11: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

attribete vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform precision mediump float;
precision mediump int;

vec3 lightPosition[2] = vec3[2](vec3(-0.5, 0.0, 0.5), vec3(-0.5, 0.5, 0.0));

vec4 color;

void main()
{
  (color = (vec4((lightPosition[0] + lightPosition[1]) , 0.0) * 0.5));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
Mutations attempted: 9
Valid mutations:     0
Success rate:        0.00%
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec2 m = al.gr;
	vec2 n = al.ab;
	vec4 a = vec4(m.g, m.r, n.g, n.r);
	gl_FragColor = a;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 y = vec3(0.5, 0.5, 0.5);
	const vec3 a = vec3(0.5, 0.5, 0.5);
	vec3 c = color.rgb;
	gl_FragColor = vec4(c * (1.0 - a) + y * a, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 16.0 * color.r;
	gl_FragColor = vec4(pow(c, 0.5) / 4.0, 0.0, 0.0, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec3 c = gtf_Color.rgb;
	if(c[0] > max_c) c[0] = max_c;
	if(c[0] < min_c) c[0] = min_c;
	if(c[1] > max_c) c[1] = max_c;
	if(c[1] < min_c) c[1] = min_c;
	if(c[2] > max_c) c[2] = max_c;
	if(c[2] < min_c) c[2] = min_c;
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Mutated source code: 
qrecision mediumq float;
precision mediump int;

aturibute vec4 gtf_Cohor;
attribute vea4 gtf_Vertex;
uniform mat4 gtf_ModulViewprecision mediump float;
precision mediump int;

vec4 color = vec4((2.0 - 0.5), (!true ? (--1.0 + -1.0) : -(false ? 0.0 : 2.0)), +2.0, (0.0 * 0.0));

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec3 c = gtf_Color.rgb;
  if ((c[0] > max_c))
    (c[0] = max_c);
  if ((c[0] < min_c))
    (c[0] = min_c);
  if ((c[1] > max_c))
    (c[1] = max_c);
  if ((c[1] < min_c))
    (c[1] = min_c);
  if ((c[2] > max_c))
    (c[2] = max_c);
  if ((c[2] < min_c))
    (c[2] = min_c);
  (color = vec4(c , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:10: 'gtf_Color' : undeclared identifier
ERROR: 0:10: 'rgb' :  field selection requires structure or vector on left hand side
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: '=' : cannot convert from 'const highp float' to 'mediump 3-component vector of float'
ERROR: 0:24: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:24: 'gtf_Vertex' : undeclared identifier
ERROR: 0:24: '=' : dimension mismatch
ERROR: 0:24: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
qrecision mediumq float;
precision mediump int;

aturibute vec4 gtf_Cohor;
attribute vea4 gtf_Vertex;
uniform mat4 gtf_ModulViewprecision mediump float;
precision mediump int;

vec4 color = vec4((2.0 - 0.5), (!true ? (--1.0 + -1.0) : -(false ? 0.0 : 2.0)), +2.0, (0.0 * 0.0));

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec3 c = gtf_Color.rgb;
  if ((c[0] > max_c))
    (c[0] = max_c);
  if ((c[0] < min_c))
    (c[0] = min_c);
  if ((c[1] > max_c))
    (c[1] = max_c);
  if ((c[1] < min_c))
    (c[1] = min_c);
  if ((c[2] > max_c))
    (c[2] = max_c);
  if ((c[2] < min_c))
    (c[2] = min_c);
  (color = vec4(c , 1.0));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * color.r;
	float arrVal = c * 2.546478971;
	int arr0 = int(floor(arrVal));
	float weight = arrVal - floor(arrVal);
	float sin_c = 0.0;
	if (arr0 == 0)
		sin_c = lerp(sinValues[0], sinValues[1], weight);
	else if (arr0 == 1)
		sin_c = lerp(sinValues[1], sinValues[2], weight);
	else if (arr0 == 2)
		sin_c = lerp(sinValues[2], sinValues[3], weight);
	else if (arr0 == 3)
		sin_c = lerp(sinValues[3], sinValues[4], weight);
	else if (arr0 == 4)
		sin_c = lerp(sinValues[4], sinValues[5], weight);
	else if (arr0 == 5)
		sin_c = lerp(sinValues[5], sinValues[6], weight);
	else if (arr0 == 6)
		sin_c = lerp(sinValues[6], sinValues[7], weight);
	else if (arr0 == 7)
		sin_c = lerp(sinValues[7], sinValues[8], weight);
	else if (arr0 == 8)
		sin_c = lerp(sinValues[8], sinValues[9], weight);
	else if (arr0 == 9)
		sin_c = lerp(sinValues[9], sinValues[10], weight);
	else if (arr0 == 10)
		sin_c = lerp(sinValues[10], sinValues[11], weight);
	else if (arr0 == 11)
		sin_c = lerp(sinValues[11], sinValues[12], weight);
	else if (arr0 == 12)
		sin_c = lerp(sinValues[12], sinValues[13], weight);
	else if (arr0 == 13)
		sin_c = lerp(sinValues[13], sinValues[14], weight);
	else if (arr0 == 14)
		sin_c = lerp(sinValues[14], sinValues[15], weight);
	else if (arr0 == 15)
		sin_c = lerp(sinValues[15], sinValues[16], weight);
        else if (arr0 == 16)
                sin_c = sinValues[16];
	gl_FragColor = vec4(0.5 * sin_c + 0.5, 0.0, 0.0, 1.0);
}

Mutated source code: 
precision mediump float;
precision mediumx int;

precision mediump float;
varying vec4 color;
float lerp(&loat a, float b, floatprecision mediump float;
precision mediump int;

void main()
{
  float sinValues[17] = float[17](0.0, 2.0, 0.0, -1.0, 2.0, 0.5, 0.5, 0.5, 2.0, 0.5, -1.0, -1.0, -1.0, 1.0, -1.0, 0.5, 0.5);
  (sinValues[0] = 0.0);
  (sinValues[1] = 0.382683);
  (sinValues[2] = 0.707107);
  (sinValues[3] = 0.92388);
  (sinValues[4] = 1.0);
  (sinValues[5] = 0.92388);
  (sinValues[6] = 0.707107);
  (sinValues[7] = 0.382683);
  (sinValues[8] = 0.0);
  (sinValues[9] = -0.382683);
  (sinValues[10] = -0.707107);
  (sinValues[11] = -0.92388);
  (sinValues[12] = -1.0);
  (sinValues[13] = -0.923879);
  (sinValues[14] = -0.707107);
  (sinValues[15] = -0.382683);
  (sinValues[16] = 0.0);
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * color.r);
  float arrVal = (c * 2.546478971);
  int arr0 = int(floor(arrVal));
  float weight = (arrVal - floor(arrVal));
  float sin_c = 0.0;
  if ((arr0 == 0))
    (sin_c = lerp(sinValues[0] , sinValues[1] , weight));
  else
    if ((arr0 == 1))
      (sin_c = lerp(sinValues[1] , sinValues[2] , weight));
    else
      if ((arr0 == 2))
        (sin_c = lerp(sinValues[2] , sinValues[3] , weight));
      else
        if ((arr0 == 3))
          (sin_c = lerp(sinValues[3] , sinValues[4] , weight));
        else
          if ((arr0 == 4))
            (sin_c = lerp(sinValues[4] , sinValues[5] , weight));
          else
            if ((arr0 == 5))
              (sin_c = lerp(sinValues[5] , sinValues[6] , weight));
            else
              if ((arr0 == 6))
                (sin_c = lerp(sinValues[6] , sinValues[7] , weight));
              else
                if ((arr0 == 7))
                  (sin_c = lerp(sinValues[7] , sinValues[8] , weight));
                else
                  if ((arr0 == 8))
                    (sin_c = lerp(sinValues[8] , sinValues[9] , weight));
                  else
                    if ((arr0 == 9))
                      (sin_c = lerp(sinValues[9] , sinValues[10] , weight));
                    else
                      if ((arr0 == 10))
                        (sin_c = lerp(sinValues[10] , sinValues[11] , weight));
                      else
                        if ((arr0 == 11))
                          (sin_c = lerp(sinValues[11] , sinValues[12] , weight));
                        else
                          if ((arr0 == 12))
                            (sin_c = lerp(sinValues[12] , sinValues[13] , weight));
                          else
                            if ((arr0 == 13))
                              (sin_c = lerp(sinValues[13] , sinValues[14] , weight));
                            else
                              if ((arr0 == 14))
                                (sin_c = lerp(sinValues[14] , sinValues[15] , weight));
                              else
                                if ((arr0 == 15))
                                  (sin_c = lerp(sinValues[15] , sinValues[16] , weight));
                                else
                                  if ((arr0 == 16))
                                    (sin_c = sinValues[16]);
  (gl_FragColor = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 0.0 , 1.0));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : Invalid operation for arrays
ERROR: 0:6: '=' : cannot convert from 'const array[17] of float' to 'mediump array[17] of float'
ERROR: 0:25: 'color' : undeclared identifier
ERROR: 0:25: 'r' :  field selection requires structure or vector on left hand side
ERROR: 0:31: 'lerp' : no matching overloaded function found
ERROR: 0:34: 'lerp' : no matching overloaded function found
ERROR: 0:37: 'lerp' : no matching overloaded function found
ERROR: 0:40: 'lerp' : no matching overloaded function found
ERROR: 0:43: 'lerp' : no matching overloaded function found
ERROR: 0:46: 'lerp' : no matching overloaded function found
ERROR: 0:49: 'lerp' : no matching overloaded function found
ERROR: 0:52: 'lerp' : no matching overloaded function found
ERROR: 0:55: 'lerp' : no matching overloaded function found
ERROR: 0:58: 'lerp' : no matching overloaded function found
ERROR: 0:61: 'lerp' : no matching overloaded function found
ERROR: 0:64: 'lerp' : no matching overloaded function found
ERROR: 0:67: 'lerp' : no matching overloaded function found
ERROR: 0:70: 'lerp' : no matching overloaded function found
ERROR: 0:73: 'lerp' : no matching overloaded function found
ERROR: 0:76: 'lerp' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediumx int;

precision mediump float;
varying vec4 color;
float lerp(&loat a, float b, floatprecision mediump float;
precision mediump int;

void main()
{
  float sinValues[17] = float[17](0.0, 2.0, 0.0, -1.0, 2.0, 0.5, 0.5, 0.5, 2.0, 0.5, -1.0, -1.0, -1.0, 1.0, -1.0, 0.5, 0.5);
  (sinValues[0] = 0.0);
  (sinValues[1] = 0.382683);
  (sinValues[2] = 0.707107);
  (sinValues[3] = 0.92388);
  (sinValues[4] = 1.0);
  (sinValues[5] = 0.92388);
  (sinValues[6] = 0.707107);
  (sinValues[7] = 0.382683);
  (sinValues[8] = 0.0);
  (sinValues[9] = -0.382683);
  (sinValues[10] = -0.707107);
  (sinValues[11] = -0.92388);
  (sinValues[12] = -1.0);
  (sinValues[13] = -0.923879);
  (sinValues[14] = -0.707107);
  (sinValues[15] = -0.382683);
  (sinValues[16] = 0.0);
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * color.r);
  float arrVal = (c * 2.546478971);
  int arr0 = int(floor(arrVal));
  float weight = (arrVal - floor(arrVal));
  float sin_c = 0.0;
  if ((arr0 == 0))
    (sin_c = lerp(sinValues[0] , sinValues[1] , weight));
  else
    if ((arr0 == 1))
      (sin_c = lerp(sinValues[1] , sinValues[2] , weight));
    else
      if ((arr0 == 2))
        (sin_c = lerp(sinValues[2] , sinValues[3] , weight));
      else
        if ((arr0 == 3))
          (sin_c = lerp(sinValues[3] , sinValues[4] , weight));
        else
          if ((arr0 == 4))
            (sin_c = lerp(sinValues[4] , sinValues[5] , weight));
          else
            if ((arr0 == 5))
              (sin_c = lerp(sinValues[5] , sinValues[6] , weight));
            else
              if ((arr0 == 6))
                (sin_c = lerp(sinValues[6] , sinValues[7] , weight));
              else
                if ((arr0 == 7))
                  (sin_c = lerp(sinValues[7] , sinValues[8] , weight));
                else
                  if ((arr0 == 8))
                    (sin_c = lerp(sinValues[8] , sinValues[9] , weight));
                  else
                    if ((arr0 == 9))
                      (sin_c = lerp(sinValues[9] , sinValues[10] , weight));
                    else
                      if ((arr0 == 10))
                        (sin_c = lerp(sinValues[10] , sinValues[11] , weight));
                      else
                        if ((arr0 == 11))
                          (sin_c = lerp(sinValues[11] , sinValues[12] , weight));
                        else
                          if ((arr0 == 12))
                            (sin_c = lerp(sinValues[12] , sinValues[13] , weight));
                          else
                            if ((arr0 == 13))
                              (sin_c = lerp(sinValues[13] , sinValues[14] , weight));
                            else
                              if ((arr0 == 14))
                                (sin_c = lerp(sinValues[14] , sinValues[15] , weight));
                              else
                                if ((arr0 == 15))
                                  (sin_c = lerp(sinValues[15] , sinValues[16] , weight));
                                else
                                  if ((arr0 == 16))
                                    (sin_c = sinValues[16]);
  (gl_FragColor = vec4(((0.5 * sin_c) + 0.5) , 0.0 , 0.0 , 1.0));
}


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(acos(c) / M_PI, 0.0, 1.0);
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(in vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(in vec4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
varying vec4 texCoord[1];
uniform sampler2D gtf_Texture0;
uniform int gtf_UseTexture;
void main ()
{
    if ( gtf_UseTexture == 1 )
    {
        gl_FragColor = texture2D(gtf_Texture0, texCoord[0].xy);
    }
    else
    {
        gl_FragColor = color;
    }
}

Mutated source code: 
precisioj mediump float;
precisimn mediump int;

precision mediump float;
varying vec4 color;
virying vec5 texCord[1];
uniform precision mediump float;
precision mediump int;

sampler2D gtf_Texture0;

uniform int gtf_UseTexture;

void main()
{
  if ((gtf_UseTexture == 1))
  {
    (gl_FragColor = texture2D(gtf_Texture0));
  }
  else
  {
    (gl_FragColor = gtf_UseTexture);
  }
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'sampler2D' : sampler2Ds must be uniform
ERROR: 0:12: 'texture2D' : no matching overloaded function found
ERROR: 0:12: '=' : dimension mismatch
ERROR: 0:12: 'assign' : cannot convert from 'const mediump float' to 'FragColor mediump 4-component vector of float'
ERROR: 0:16: 'assign' : cannot convert from 'uniform mediump int' to 'FragColor mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precisioj mediump float;
precisimn mediump int;

precision mediump float;
varying vec4 color;
virying vec5 texCord[1];
uniform precision mediump float;
precision mediump int;

sampler2D gtf_Texture0;

uniform int gtf_UseTexture;

void main()
{
  if ((gtf_UseTexture == 1))
  {
    (gl_FragColor = texture2D(gtf_Texture0));
  }
  else
  {
    (gl_FragColor = gtf_UseTexture);
  }
}


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	vec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 asin_c = vec2(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	gl_FragColor = vec4(asin_c / M_PI + 0.5, 0.0, 1.0);
}

Mutated source code: 
precision mediump float;
precision mediump int;
precision mediump float;
varying tec4 color;
float ldrp(flgat a, float b, floatprecision mediump float;
precision mediump int;

void main()
{
  float asinValues[17];
  (asinValues[0] = -1.5708);
  (asinValues[1] = -1.06544);
  (asinValues[2] = -0.848062);
  (asinValues[3] = -0.675132);
  (asinValues[4] = -0.523599);
  (asinValues[5] = -0.384397);
  (asinValues[6] = -0.25268);
  (asinValues[7] = -0.125328);
  (asinValues[8] = 0.0);
  (asinValues[9] = 0.125328);
  (asinValues[10] = 0.25268);
  (asinValues[11] = 0.384397);
  (asinValues[12] = 0.523599);
  (asinValues[13] = 0.675132);
  (asinValues[14] = 0.848062);
  (asinValues[15] = 1.06544);
  (asinValues[16] = 1.5708);
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    (asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x));
  else
    if ((arr0x == 1))
      (asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x));
    else
      if ((arr0x == 2))
        (asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x));
      else
        if ((arr0x == 3))
          (asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x));
        else
          if ((arr0x == 4))
            (asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x));
          else
            if ((arr0x == 5))
              (asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x));
            else
              if ((arr0x == 6))
                (asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x));
              else
                if ((arr0x == 7))
                  (asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x));
                else
                  if ((arr0x == 8))
                    (asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x));
                  else
                    if ((arr0x == 9))
                      (asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x));
                    else
                      if ((arr0x == 10))
                        (asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x));
                      else
                        if ((arr0x == 11))
                          (asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x));
                        else
                          if ((arr0x == 12))
                            (asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x));
                          else
                            if ((arr0x == 13))
                              (asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x));
                            else
                              if ((arr0x == 14))
                                (asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x));
                              else
                                if ((arr0x == 15))
                                  (asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x));
                                else
                                  if ((arr0x == 16))
                                    (asin_c.x = asinValues[16]);
  if ((arr0y == 0))
    (asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y));
  else
    if ((arr0y == 1))
      (asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y));
    else
      if ((arr0y == 2))
        (asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y));
      else
        if ((arr0y == 3))
          (asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y));
        else
          if ((arr0y == 4))
            (asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y));
          else
            if ((arr0y == 5))
              (asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y));
            else
              if ((arr0y == 6))
                (asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y));
              else
                if ((arr0y == 7))
                  (asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y));
                else
                  if ((arr0y == 8))
                    (asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y));
                  else
                    if ((arr0y == 9))
                      (asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y));
                    else
                      if ((arr0y == 10))
                        (asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y));
                      else
                        if ((arr0y == 11))
                          (asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y));
                        else
                          if ((arr0y == 12))
                            (asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y));
                          else
                            if ((arr0y == 13))
                              (asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y));
                            else
                              if ((arr0y == 14))
                                (asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y));
                              else
                                if ((arr0y == 15))
                                  (asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y));
                                else
                                  if ((arr0y == 16))
                                    (asin_c.y = asinValues[16]);
  (gl_FragColor = vec4(((asin_c / M_PI) + 0.5) , 0.0 , 1.0));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:25: 'color' : undeclared identifier
ERROR: 0:25: 'rg' :  field selection requires structure or vector on left hand side
ERROR: 0:25: '=' : dimension mismatch
ERROR: 0:25: '=' : cannot convert from 'const highp float' to 'mediump 2-component vector of float'
ERROR: 0:32: 'lerp' : no matching overloaded function found
ERROR: 0:35: 'lerp' : no matching overloaded function found
ERROR: 0:38: 'lerp' : no matching overloaded function found
ERROR: 0:41: 'lerp' : no matching overloaded function found
ERROR: 0:44: 'lerp' : no matching overloaded function found
ERROR: 0:47: 'lerp' : no matching overloaded function found
ERROR: 0:50: 'lerp' : no matching overloaded function found
ERROR: 0:53: 'lerp' : no matching overloaded function found
ERROR: 0:56: 'lerp' : no matching overloaded function found
ERROR: 0:59: 'lerp' : no matching overloaded function found
ERROR: 0:62: 'lerp' : no matching overloaded function found
ERROR: 0:65: 'lerp' : no matching overloaded function found
ERROR: 0:68: 'lerp' : no matching overloaded function found
ERROR: 0:71: 'lerp' : no matching overloaded function found
ERROR: 0:74: 'lerp' : no matching overloaded function found
ERROR: 0:77: 'lerp' : no matching overloaded function found
ERROR: 0:82: 'lerp' : no matching overloaded function found
ERROR: 0:85: 'lerp' : no matching overloaded function found
ERROR: 0:88: 'lerp' : no matching overloaded function found
ERROR: 0:91: 'lerp' : no matching overloaded function found
ERROR: 0:94: 'lerp' : no matching overloaded function found
ERROR: 0:97: 'lerp' : no matching overloaded function found
ERROR: 0:100: 'lerp' : no matching overloaded function found
ERROR: 0:103: 'lerp' : no matching overloaded function found
ERROR: 0:106: 'lerp' : no matching overloaded function found
ERROR: 0:109: 'lerp' : no matching overloaded function found
ERROR: 0:112: 'lerp' : no matching overloaded function found
ERROR: 0:115: 'lerp' : no matching overloaded function found
ERROR: 0:118: 'lerp' : no matching overloaded function found
ERROR: 0:121: 'lerp' : no matching overloaded function found
ERROR: 0:124: 'lerp' : no matching overloaded function found
ERROR: 0:127: 'lerp' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;
precision mediump float;
varying tec4 color;
float ldrp(flgat a, float b, floatprecision mediump float;
precision mediump int;

void main()
{
  float asinValues[17];
  (asinValues[0] = -1.5708);
  (asinValues[1] = -1.06544);
  (asinValues[2] = -0.848062);
  (asinValues[3] = -0.675132);
  (asinValues[4] = -0.523599);
  (asinValues[5] = -0.384397);
  (asinValues[6] = -0.25268);
  (asinValues[7] = -0.125328);
  (asinValues[8] = 0.0);
  (asinValues[9] = 0.125328);
  (asinValues[10] = 0.25268);
  (asinValues[11] = 0.384397);
  (asinValues[12] = 0.523599);
  (asinValues[13] = 0.675132);
  (asinValues[14] = 0.848062);
  (asinValues[15] = 1.06544);
  (asinValues[16] = 1.5708);
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    (asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x));
  else
    if ((arr0x == 1))
      (asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x));
    else
      if ((arr0x == 2))
        (asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x));
      else
        if ((arr0x == 3))
          (asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x));
        else
          if ((arr0x == 4))
            (asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x));
          else
            if ((arr0x == 5))
              (asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x));
            else
              if ((arr0x == 6))
                (asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x));
              else
                if ((arr0x == 7))
                  (asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x));
                else
                  if ((arr0x == 8))
                    (asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x));
                  else
                    if ((arr0x == 9))
                      (asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x));
                    else
                      if ((arr0x == 10))
                        (asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x));
                      else
                        if ((arr0x == 11))
                          (asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x));
                        else
                          if ((arr0x == 12))
                            (asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x));
                          else
                            if ((arr0x == 13))
                              (asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x));
                            else
                              if ((arr0x == 14))
                                (asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x));
                              else
                                if ((arr0x == 15))
                                  (asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x));
                                else
                                  if ((arr0x == 16))
                                    (asin_c.x = asinValues[16]);
  if ((arr0y == 0))
    (asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y));
  else
    if ((arr0y == 1))
      (asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y));
    else
      if ((arr0y == 2))
        (asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y));
      else
        if ((arr0y == 3))
          (asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y));
        else
          if ((arr0y == 4))
            (asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y));
          else
            if ((arr0y == 5))
              (asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y));
            else
              if ((arr0y == 6))
                (asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y));
              else
                if ((arr0y == 7))
                  (asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y));
                else
                  if ((arr0y == 8))
                    (asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y));
                  else
                    if ((arr0y == 9))
                      (asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y));
                    else
                      if ((arr0y == 10))
                        (asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y));
                      else
                        if ((arr0y == 11))
                          (asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y));
                        else
                          if ((arr0y == 12))
                            (asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y));
                          else
                            if ((arr0y == 13))
                              (asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y));
                            else
                              if ((arr0y == 14))
                                (asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y));
                              else
                                if ((arr0y == 15))
                                  (asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y));
                                else
                                  if ((arr0y == 16))
                                    (asin_c.y = asinValues[16]);
  (gl_FragColor = vec4(((asin_c / M_PI) + 0.5) , 0.0 , 1.0));
}


==============================
Mutations attempted: 13
Valid mutations:     0
Success rate:        0.00%
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat2 m = mat2(color.rg, color.ba);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if(m[0][0] != color.r) result = black;
	if(m[0][1] != color.g) result = black;
	if(m[1][0] != color.b) result = black;
	if(m[1][1] != color.a) result = black;
	gl_FragColor = result;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform int color;
varying float col;
void main ()
{
	col = float(color);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform bool color;
varying float col;
void main ()
{
	col = float(color);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Mutated source code: 
precision mediump float;
preciskon }ediump hnt;

attribute vec4 gtf_Vertex;
uNiform mat4 gtf_ModelViewProjectionMatriz;
attrmbutprecision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(2.0, 1.0, +-(0.0 / 0.0), 0.0);

uniform bool color;

float col;

void main()
{
  (col = float(color));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:4: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:13: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:13: 'gtf_Vertex' : undeclared identifier
ERROR: 0:13: '=' : dimension mismatch
ERROR: 0:13: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
preciskon }ediump hnt;

attribute vec4 gtf_Vertex;
uNiform mat4 gtf_ModelViewProjectionMatriz;
attrmbutprecision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(2.0, 1.0, +-(0.0 / 0.0), 0.0);

uniform bool color;

float col;

void main()
{
  (col = float(color));
  (gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex));
}


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int j = 30;
	int k = 37;
	int y = 10;
	int n = 12;
	bool result1 = false;
	bool result2 = false;
	(j>k)?( result1 = true ):( result1 = false );
	(y<n)?( result2 = true ):( result2 = false );
	float gray;
	if( !result1 && result2 )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 b = vec3(13.0, 53.0, 139.0);
	vec4 a = vec4(b, 217.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) && (a[3] == 217.0))
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Mutated source code: 
precision mediump float;
precision mediump int;

precision mediump floa|;varying vec4 color;
void main ()
{
	vec3 b = vec3(13.0precision mediump float;
precision mediump int;

vec4 a = vec4(b);

float gray;


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'b' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

precision mediump floa|;varying vec4 color;
void main ()
{
	vec3 b = vec3(13.0precision mediump float;
precision mediump int;

vec4 a = vec4(b);

float gray;


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float edge0 = 0.25;
	const float edge1 = 0.75;
	gl_FragColor = vec4(smoothstep(edge0, edge1, color.r), 0.0, 0.0, 1.0);
}

Mutated source code: 
precision mediump float;
precision mediump int;

precision mmdiump float;varying vec4 color;
void }qin ()
{
	const float edge0 precision mediump float;
precision mediump int;

const float edge1 = 0.75;


Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: Missing main()

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

precision mmdiump float;varying vec4 color;
void }qin ()
{
	const float edge0 precision mediump float;
precision mediump int;

const float edge1 = 0.75;


==============================
is valid???
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform sampler2D gtf_Texture0;
varying vec4 color;
varying vec4 gtf_TexCoord[1];
void main ()
{
	if (gtf_TexCoord[0].s == 1.0)
		gl_FragColor = color;
	else
		gl_FragColor = texture2D(gtf_Texture0, gtf_TexCoord[0].st, 1.0);
}

Mutated source code: 
precision mediump float;
precision Mediump int;

precision mediump float;
uniform sampler2D gtf_Texture0;
varying vec4 color;
vaprecision mediump float;
precision mediump int;

vec4 gtf_TexCoord[1];

void main()
{
  if ((((true ? false : true) ? !false : (false && false)) ? true : (true && (false ? false : false))))
  {
    main();
  }
  else
  {
    ivec2(3, 3);
  }
}


5.88235294117647
Mutations attempted: 17
Valid mutations:     1
Success rate:        5.88%
