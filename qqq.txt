Using this seed: 10137
Mutations attempted: 0
Valid mutations:     0
Success rate:        0.00%
Processing this: /home/oof/webgl_cleaned/bvec4_empty_inout_bvec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec4 function(inout bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, false) && is_all(ret, true))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bvec4 function(inout bvec4 par)
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec4 function(inout bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, false) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbvec4 function(inout bvec4 par)\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
Processing this: /home/oof/webgl_cleaned/inversesqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r * 99.0) + 1.0;
	color = vec4(inversesqrt(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r * 99.0) + 1.0;\n\tcolor = vec4(inversesqrt(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((false ? +2.0 : -1.0), 2.0, 0.5, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4(inversesqrt(c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
100.0
Processing this: /home/oof/webgl_cleaned/bvec4_empty_in_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(in bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(in bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(in bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(in bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
100.0
Processing this: /home/oof/webgl_cleaned/dot_vec3_frag_xvaryythird.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(dot(color.rgb, vec3(0.3333))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(dot(color.rgb, vec3(0.3333))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(dot(color.rgb , vec3(0.3333))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(dot(color.rgb , vec3(0.3333))));
}


==============================
50.0
Processing this: /home/oof/webgl_cleaned/ivec4_empty_inout_ivec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(inout ivec4 par[3]);
bool is_all(const in ivec4 par, const in int value);
bool is_all(const in ivec4 array[3], const in ivec4 value);
void set_all(out ivec4 array[3], const in ivec4 value);
void main ()
{
	ivec4 par[3];
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	set_all(par, ivec4(1, 1, 1, 1));
	ret = function(par);
	if(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(inout ivec4 par[3])
{
	if(is_all(par, ivec4(1, 1, 1, 1)))
	{
		set_all(par, ivec4(0, 0, 0, 0));
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in ivec4 array[3], const in ivec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 array[3], const in ivec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(inout ivec4 par[3]);\nbool is_all(const in ivec4 par, const in int value);\nbool is_all(const in ivec4 array[3], const in ivec4 value);\nvoid set_all(out ivec4 array[3], const in ivec4 value);\nvoid main ()\n{\n\tivec4 par[3];\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tset_all(par, ivec4(1, 1, 1, 1));\n\tret = function(par);\n\tif(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(inout ivec4 par[3])\n{\n\tif(is_all(par, ivec4(1, 1, 1, 1)))\n\t{\n\t\tset_all(par, ivec4(0, 0, 0, 0));\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in ivec4 array[3], const in ivec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 array[3], const in ivec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
50.0
Processing this: /home/oof/webgl_cleaned/mat4_empty_out_mat4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
mat4 function(out mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(out mat4 par)
{
	set_all(par, 0.0);
	return mat4(1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0,
		    1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nmat4 function(out mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(out mat4 par)\n{\n\tset_all(par, 0.0);\n\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t    1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
50.0
Processing this: /home/oof/webgl_cleaned/acos_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (gtf_Color.rgb - 0.5);
	vec3 acos_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	if(c.r < 0.0)
	{
		sign.r = -1.0;
		c.r *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.r += scale.r * pow(c.r, float(i)) / float(i);
		scale.r *= float(i) / float(i + 1);
	}
	acos_c.r = M_PI / 2.0 - sign.r * acos_c.r;
	if(c.g < 0.0)
	{
		sign.g = -1.0;
		c.g *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.g += scale.g * pow(c.g, float(i)) / float(i);
		scale.g *= float(i) / float(i + 1);
	}
	acos_c.g = M_PI / 2.0 - sign.g * acos_c.g;
	if(c.b < 0.0)
	{
		sign.b = -1.0;
		c.b *= -1.0;
	}
	for(int i = 1; i < 1000; i += 2)
	{
		acos_c.b += scale.b * pow(c.b, float(i)) / float(i);
		scale.b *= float(i) / float(i + 1);
	}
	acos_c.b = M_PI / 2.0 - sign.b * acos_c.b;
	color = vec4(acos_c / M_PI, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 acos_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tif(c.r < 0.0)\n\t{\n\t\tsign.r = -1.0;\n\t\tc.r *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.r += scale.r * pow(c.r, float(i)) / float(i);\n\t\tscale.r *= float(i) / float(i + 1);\n\t}\n\tacos_c.r = M_PI / 2.0 - sign.r * acos_c.r;\n\tif(c.g < 0.0)\n\t{\n\t\tsign.g = -1.0;\n\t\tc.g *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.g += scale.g * pow(c.g, float(i)) / float(i);\n\t\tscale.g *= float(i) / float(i + 1);\n\t}\n\tacos_c.g = M_PI / 2.0 - sign.g * acos_c.g;\n\tif(c.b < 0.0)\n\t{\n\t\tsign.b = -1.0;\n\t\tc.b *= -1.0;\n\t}\n\tfor(int i = 1; i < 1000; i += 2)\n\t{\n\t\tacos_c.b += scale.b * pow(c.b, float(i)) / float(i);\n\t\tscale.b *= float(i) / float(i + 1);\n\t}\n\tacos_c.b = M_PI / 2.0 - sign.b * acos_c.b;\n\tcolor = vec4(acos_c / M_PI, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-+0.5, ((true ? false : (true ? false : false)) ? (0.5 / (-1.0 * 0.0)) : 0.0), -1.0, (-1.0 * (false ? (2.0 + 0.5) : -1.0)));

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (gtf_Color.rgb - 0.5));
  vec3 acos_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  if ((c.r < 0.0))
  {
    sign.r = -1.0;
    (c.r *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.r += ((scale.r * pow(c.r , float(i))) / float(i)));
    (scale.r *= (float(i) / float((i + 1))));
  }
  acos_c.r = ((M_PI / 2.0) - (sign.r * acos_c.r));
  if ((c.g < 0.0))
  {
    sign.g = -1.0;
    (c.g *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.g += ((scale.g * pow(c.g , float(i))) / float(i)));
    (scale.g *= (float(i) / float((i + 1))));
  }
  acos_c.g = ((M_PI / 2.0) - (sign.g * acos_c.g));
  if ((c.b < 0.0))
  {
    sign.b = -1.0;
    (c.b *= -1.0);
  }
  for (int i = 1; (i < 1000); (i += 2))
  {
    (acos_c.b += ((scale.b * pow(c.b , float(i))) / float(i)));
    (scale.b *= (float(i) / float((i + 1))));
  }
  acos_c.b = ((M_PI / 2.0) - (sign.b * acos_c.b));
  color = vec4((acos_c / M_PI) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/lessThanEqual_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((1.0 / 0.5), 2.0, 0.0, 0.0);

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
75.0
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	float c = color.r;
	gl_FragColor = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(pow(exp1, 3.0 * c) / exp3, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, 1.0, 0.5, -0.5);

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  float c = color.r;
  gl_FragColor = vec4((pow(exp1 , (3.0 * c)) / exp3) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
80.0
Processing this: /home/oof/webgl_cleaned/mix_float_vert_xvary_yconsthalf_aconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float y = 0.5;
	const float a = 0.5;
	float c = gtf_Color.r;
	color = vec4(mix(c, y, a), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float y = 0.5;\n\tconst float a = 0.5;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(mix(c, y, a), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = (!(false ? false : true) ? vec4(((2.0 + 1.0) - ((true && true) ? 0.0 : (1.0 - 1.0))), (-1.0 + 0.0), 0.0, (0.0 - ((true ? true : false) ? (true ? -1.0 : 0.0) : 2.0))) : vec4(-1.0, -1.0, (((true && true) ? (0.5 / 2.0) : (0.5 * -1.0)) + +-0.0), --1.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float y = 0.5;
  const float a = 0.5;
  float c = gtf_Color.r;
  color = vec4(mix(c , y , a) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = (!(false ? false : true) ? vec4(((2.0 + 1.0) - ((true && true) ? 0.0 : (1.0 - 1.0))), (-1.0 + 0.0), 0.0, (0.0 - ((true ? true : false) ? (true ? -1.0 : 0.0) : 2.0))) : vec4(-1.0, -1.0, (((true && true) ? (0.5 / 2.0) : (0.5 * -1.0)) + +-0.0), --1.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float y = 0.5;
  const float a = 0.5;
  float c = gtf_Color.r;
  color = vec4(mix(c , y , a) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
66.66666666666666
Mutations attempted: 6
Valid mutations:     4
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/atan_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 4.0 * 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(atan(c) / M_PI + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 4.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(atan(c) / M_PI + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(-1.0, ((0.5 + 1.0) / ((false || true) ? (0.0 + 1.0) : 0.5)), 0.0, 2.0);

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((atan(c) / M_PI) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
71.42857142857143
Processing this: /home/oof/webgl_cleaned/reflect_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (-1.0 / (0.5 / -1.0)), 0.0, +--1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (-1.0 / (0.5 / -1.0)), 0.0, +--1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Processing this: /home/oof/webgl_cleaned/vertexOnly2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    gl_Position = vec4(4.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    gl_Position = vec4(4.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(4.0);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/4i_vert.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 col;
void main ()
{
	gl_FragColor = vec4 (col[0], col[1], col[2], col[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 col;\nvoid main ()\n{\n\tgl_FragColor = vec4 (col[0], col[1], col[2], col[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 col = vec4(1.0, ((false ? (false ? 2.0 : -1.0) : 0.0) * 0.5), (+(1.0 * 0.5) + +0.0), 0.5);

void main()
{
  gl_FragColor = vec4(col[0] , col[1] , col[2] , col[3]);
}


As vertex? : False
SUCCESS!
70.0
Processing this: /home/oof/webgl_cleaned/vec3_vec2_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 b = vec2(13.0, 53.0);
	vec3 a = vec3(b, 139.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 b = vec2(13.0, 53.0);\n\tvec3 a = vec3(b, 139.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 b = vec2(13.0 , 53.0);
  vec3 a = vec3(b , 139.0);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 b = vec2(13.0 , 53.0);
  vec3 a = vec3(b , 139.0);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray);
}


==============================
63.63636363636363
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par[3])
{
	set_all(par, 0);
	return 1;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par[3])\n{\n\tset_all(par, 0);\n\treturn 1;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.63636363636363
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat2 m1 = mat2(color.rg, color.ba);
	mat2 m2 = mat2(1.0, 0.5, 0.5, 1.0);
	mat2 m3 = mat2(0.0);
	m3[0][0] = m1[0][0] * m2[0][0];
	m3[0][1] = m1[0][1] * m2[0][1];
	m3[1][0] = m1[1][0] * m2[1][0];
	m3[1][1] = m1[1][1] * m2[1][1];
	gl_FragColor = vec4(m3[0][0], m3[1][0], m3[0][1], m3[1][1]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m1 = mat2(color.rg, color.ba);\n\tmat2 m2 = mat2(1.0, 0.5, 0.5, 1.0);\n\tmat2 m3 = mat2(0.0);\n\tm3[0][0] = m1[0][0] * m2[0][0];\n\tm3[0][1] = m1[0][1] * m2[0][1];\n\tm3[1][0] = m1[1][0] * m2[1][0];\n\tm3[1][1] = m1[1][1] * m2[1][1];\n\tgl_FragColor = vec4(m3[0][0], m3[1][0], m3[0][1], m3[1][1]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 2.0, +(false ? (0.0 * 1.0) : (-1.0 / -1.0)), -1.0);

void main()
{
  mat2 m1 = mat2(color.rg , color.ba);
  mat2 m2 = mat2(1.0 , 0.5 , 0.5 , 1.0);
  mat2 m3 = mat2(0.0);
  m3[0][0] = (m1[0][0] * m2[0][0]);
  m3[0][1] = (m1[0][1] * m2[0][1]);
  m3[1][0] = (m1[1][0] * m2[1][0]);
  m3[1][1] = (m1[1][1] * m2[1][1]);
  gl_FragColor = vec4(m3[0][0] , m3[1][0] , m3[0][1] , m3[1][1]);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/cos_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * ( fract(abs(color.r)) - 0.5 );
	float sign =  1.0;
	float cos_c = -1.0;
	float fact_even = 1.0;
	float fact_odd  = 1.0;
	float sum;
	for(int i = 2; i <= 10; i += 2)
	{
		fact_even *= float(i);
		fact_odd  *= float(i-1);
		sum = sign * pow(abs(c), float(i/2))/fact_even;
		cos_c += pow(abs(c), float(i/2))*(sum/fact_odd);
		sign = -sign;
	}
	gl_FragColor = vec4(0.5 * cos_c + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * ( fract(abs(color.r)) - 0.5 );\n\tfloat sign =  1.0;\n\tfloat cos_c = -1.0;\n\tfloat fact_even = 1.0;\n\tfloat fact_odd  = 1.0;\n\tfloat sum;\n\tfor(int i = 2; i <= 10; i += 2)\n\t{\n\t\tfact_even *= float(i);\n\t\tfact_odd  *= float(i-1);\n\t\tsum = sign * pow(abs(c), float(i/2))/fact_even;\n\t\tcos_c += pow(abs(c), float(i/2))*(sum/fact_odd);\n\t\tsign = -sign;\n\t}\n\tgl_FragColor = vec4(0.5 * cos_c + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, (-1.0 + (2.0 * (0.5 - 0.5))), 0.0, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((2.0 * M_PI) * (fract(abs(color.r)) - 0.5));
  float sign = 1.0;
  float cos_c = -1.0;
  float fact_even = 1.0;
  float fact_odd = 1.0;
  float sum;
  for (int i = 2; (i <= 10); (i += 2))
  {
    (fact_even *= float(i));
    (fact_odd *= float((i - 1)));
    sum = ((sign * pow(abs(c) , float((i / 2)))) / fact_even);
    (cos_c += (pow(abs(c) , float((i / 2))) * (sum / fact_odd)));
    sign = -sign;
  }
  gl_FragColor = vec4(((0.5 * cos_c) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
69.23076923076923
Processing this: /home/oof/webgl_cleaned/emit1.glsl
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform sampler2D GLGE_EMIT;
varying vec2 texCoord;
float blurSize=0.007;
void main(){
	vec4 color=vec4(0.0,0.0,0.0,0.0);
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - 4.0*blurSize, texCoord.y)) * 0.05;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - 3.0*blurSize, texCoord.y)) * 0.09;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - 2.0*blurSize, texCoord.y)) * 0.12;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x - blurSize, texCoord.y)) * 0.15;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x, texCoord.y)) * 0.16;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + blurSize, texCoord.y)) * 0.15;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + 2.0*blurSize, texCoord.y)) * 0.12;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + 3.0*blurSize, texCoord.y)) * 0.09;
	color += texture2D(GLGE_EMIT, vec2(texCoord.x + 4.0*blurSize, texCoord.y)) * 0.05;
    gl_FragColor = vec4(color.rgb,1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform sampler2D GLGE_EMIT;\nvarying vec2 texCoord;\nfloat blurSize=0.007;\nvoid main(){\n\tvec4 color=vec4(0.0,0.0,0.0,0.0);\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - 4.0*blurSize, texCoord.y)) * 0.05;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - 3.0*blurSize, texCoord.y)) * 0.09;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - 2.0*blurSize, texCoord.y)) * 0.12;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x - blurSize, texCoord.y)) * 0.15;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x, texCoord.y)) * 0.16;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + blurSize, texCoord.y)) * 0.15;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + 2.0*blurSize, texCoord.y)) * 0.12;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + 3.0*blurSize, texCoord.y)) * 0.09;\n\tcolor += texture2D(GLGE_EMIT, vec2(texCoord.x + 4.0*blurSize, texCoord.y)) * 0.05;\n    gl_FragColor = vec4(color.rgb,1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform sampler2D GLGE_EMIT = GLGE_EMIT;

vec2 texCoord;

float blurSize = 0.007;

void main()
{
  vec4 color = vec4(0.0 , 0.0 , 0.0 , 0.0);
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (4.0 * blurSize)) , texCoord.y)) * 0.05));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2(texCoord.x , texCoord.y)) * 0.16));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (4.0 * blurSize)) , texCoord.y)) * 0.05));
  gl_FragColor = vec4(color.rgb , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'GLGE_EMIT' : undeclared identifier
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform sampler2D GLGE_EMIT = GLGE_EMIT;

vec2 texCoord;

float blurSize = 0.007;

void main()
{
  vec4 color = vec4(0.0 , 0.0 , 0.0 , 0.0);
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (4.0 * blurSize)) , texCoord.y)) * 0.05));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x - blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2(texCoord.x , texCoord.y)) * 0.16));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + blurSize) , texCoord.y)) * 0.15));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (2.0 * blurSize)) , texCoord.y)) * 0.12));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (3.0 * blurSize)) , texCoord.y)) * 0.09));
  (color += (texture2D(GLGE_EMIT , vec2((texCoord.x + (4.0 * blurSize)) , texCoord.y)) * 0.05));
  gl_FragColor = vec4(color.rgb , 1.0);
}


==============================
64.28571428571429
Processing this: /home/oof/webgl_cleaned/DuplicateVersion1_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1);
}


As vertex? : False
SUCCESS!
66.66666666666666
Mutations attempted: 15
Valid mutations:     10
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/vec4_r_g_b_a_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float r = al.r;
	float g = al.g;
	float b = al.b;
	float a = al.a;
	vec4 m = vec4(r,g,b,a);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat r = al.r;\n\tfloat g = al.g;\n\tfloat b = al.b;\n\tfloat a = al.a;\n\tvec4 m = vec4(r,g,b,a);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((1.0 / ((false || false) ? -2.0 : -2.0)), +(+-1.0 * -1.0), ((false ? (false ? false : false) : !false) ? 1.0 : +2.0), 0.0);

void main()
{
  vec4 al = color;
  float r = al.r;
  float g = al.g;
  float b = al.b;
  float a = al.a;
  vec4 m = vec4(r , g , b , a);
  gl_FragColor = m;
}


As vertex? : False
SUCCESS!
68.75
Processing this: /home/oof/webgl_cleaned/bvec4_2int_2float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	bvec4 a = bvec4(0, 23, 0.0, 23.0);
	float gray;
	if( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tbvec4 a = bvec4(0, 23, 0.0, 23.0);\n\tfloat gray;\n\tif( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+((2.0 + 0.5) + 2.0), -0.0, (true ? (false ? (false ? 0.0 : 0.0) : (2.0 + -1.0)) : ((false ? 2.0 : 2.0) - +-1.0)), +(-0.0 + -1.0));

void main()
{
  bvec4 a = bvec4(0 , 23 , 0.0 , 23.0);
  float gray;
  if (((((a[0] == false) && (a[1] == true)) && (a[2] == false)) && (a[3] == true)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
70.58823529411765
Processing this: /home/oof/webgl_cleaned/sin_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rg) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  ivec2(((true ? true : true) ? ((3 / 9) * 1) : 0), 3);
}


As vertex? : False
SUCCESS!
72.22222222222221
Processing this: /home/oof/webgl_cleaned/compressed_paletted_texture.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 gtf_TexCoord[1];
attribute vec4 gtf_MultiTexCoord0;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 gtf_TexCoord[1];\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(((!true || (true ? true : false)) ? +2.0 : ((2.0 * 2.0) + (true ? -1.0 : -1.0))), ++(false ? 2.0 : 2.0), 1.0, 1.0);

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: '++' : l-value required (can't modify a const)
ERROR: 0:12: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(((!true || (true ? true : false)) ? +2.0 : ((2.0 * 2.0) + (true ? -1.0 : -1.0))), ++(false ? 2.0 : 2.0), 1.0, 1.0);

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
68.42105263157895
Processing this: /home/oof/webgl_cleaned/CorrectSwizzle1_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Normal;
uniform mat4 gtf_NormalMatrix;
void main()
{
   vec4 v = vec4(1,2,3,4);
   vec3 v3 = vec3(5,6,7);
   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);
   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Normal;\nuniform mat4 gtf_NormalMatrix;\nvoid main()\n{\n   vec4 v = vec4(1,2,3,4);\n   vec3 v3 = vec3(5,6,7);\n   vec4 v4  = vec4(normalize(v3.yzy).xyz.zyx, 1.0);\n   gl_Position = v4 + vec4(normalize(gtf_NormalMatrix * gtf_Normal).xyz.zyx, v4.y);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Normal;

uniform mat4 gtf_NormalMatrix = mat4((!!false ? ((true || true) ? 0.0 : 2.0) : -1.0), 0.0, (0.5 + -2.0), 0.5, 0.0, 1.0, (true ? +2.0 : ((false ? true : false) ? (1.0 * 0.0) : (2.0 + 1.0))), (!!false ? --1.0 : 0.0), (((false ? -1.0 : 0.0) + (0.5 - -1.0)) * (+2.0 - -1.0)), -1.0, --1.0, 0.0, 2.0, 2.0, (false ? 1.0 : 0.5), (0.5 - +-2.0));

void main()
{
  vec4 v = vec4(1 , 2 , 3 , 4);
  vec3 v3 = vec3(5 , 6 , 7);
  vec4 v4 = vec4(normalize(v3.yzy).xyz.zyx , 1.0);
  gl_Position = (v4 + vec4(normalize((gtf_NormalMatrix * gtf_Normal)).xyz.zyx , v4.y));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Normal;

uniform mat4 gtf_NormalMatrix = mat4((!!false ? ((true || true) ? 0.0 : 2.0) : -1.0), 0.0, (0.5 + -2.0), 0.5, 0.0, 1.0, (true ? +2.0 : ((false ? true : false) ? (1.0 * 0.0) : (2.0 + 1.0))), (!!false ? --1.0 : 0.0), (((false ? -1.0 : 0.0) + (0.5 - -1.0)) * (+2.0 - -1.0)), -1.0, --1.0, 0.0, 2.0, 2.0, (false ? 1.0 : 0.5), (0.5 - +-2.0));

void main()
{
  vec4 v = vec4(1 , 2 , 3 , 4);
  vec3 v3 = vec3(5 , 6 , 7);
  vec4 v4 = vec4(normalize(v3.yzy).xyz.zyx , 1.0);
  gl_Position = (v4 + vec4(normalize((gtf_NormalMatrix * gtf_Normal)).xyz.zyx , v4.y));
}


==============================
65.0
Processing this: /home/oof/webgl_cleaned/acos_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	vec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 asin_c = vec2(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	gl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tvec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tvec2 weight = arrVal - floor(arrVal);\n\tvec2 asin_c = vec2(0.0);\n\tif (arr0x == 0)\n\t\tasin_c.x = lerp(asinValues[0], asinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tasin_c.x = lerp(asinValues[1], asinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tasin_c.x = lerp(asinValues[2], asinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tasin_c.x = lerp(asinValues[3], asinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tasin_c.x = lerp(asinValues[4], asinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tasin_c.x = lerp(asinValues[5], asinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tasin_c.x = lerp(asinValues[6], asinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tasin_c.x = lerp(asinValues[7], asinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tasin_c.x = lerp(asinValues[8], asinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tasin_c.x = lerp(asinValues[9], asinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tasin_c.x = lerp(asinValues[10], asinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tasin_c.x = lerp(asinValues[11], asinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tasin_c.x = lerp(asinValues[12], asinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tasin_c.x = lerp(asinValues[13], asinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tasin_c.x = lerp(asinValues[14], asinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tasin_c.x = lerp(asinValues[15], asinValues[16], weight.x);\n        else if (arr0x == 16)\n                asin_c.x = asinValues[16];\n\tif (arr0y == 0)\n\t\tasin_c.y = lerp(asinValues[0], asinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tasin_c.y = lerp(asinValues[1], asinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tasin_c.y = lerp(asinValues[2], asinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tasin_c.y = lerp(asinValues[3], asinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tasin_c.y = lerp(asinValues[4], asinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tasin_c.y = lerp(asinValues[5], asinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tasin_c.y = lerp(asinValues[6], asinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tasin_c.y = lerp(asinValues[7], asinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tasin_c.y = lerp(asinValues[8], asinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tasin_c.y = lerp(asinValues[9], asinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tasin_c.y = lerp(asinValues[10], asinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tasin_c.y = lerp(asinValues[11], asinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tasin_c.y = lerp(asinValues[12], asinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tasin_c.y = lerp(asinValues[13], asinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tasin_c.y = lerp(asinValues[14], asinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tasin_c.y = lerp(asinValues[15], asinValues[16], weight.y);\n        else if (arr0y == 16)\n                asin_c.y = asinValues[16];\n\tgl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 1.348062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/vec4_qspt_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.qspt;
	vec4 a = vec4(m.t, m.q, m.p, m.s);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.qspt;\n\tvec4 a = vec4(m.t, m.q, m.p, m.s);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.qspt;
  vec4 a = vec4(m.t , m.q , m.p , m.s);
  gl_FragColor = a;
  ivec2(((false || !true) ? (false ? 8 : +2) : 3), +((5 * 1) / (6 + 3)));
}


As vertex? : False
SUCCESS!
68.18181818181817
Processing this: /home/oof/webgl_cleaned/vec4_xyz_w_1vec3_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	float w = lightloc.w;
	vec4 a = vec4(m, w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tfloat w = lightloc.w;\n\tvec4 a = vec4(m, w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-2.0, (false ? (true ? 2.0 : (true ? 0.0 : 0.5)) : -1.0), 2.0, 1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  float w = lightloc.w;
  vec4 a = vec4(m , w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
69.56521739130434
Processing this: /home/oof/webgl_cleaned/ceil_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((ceil(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 0.0, 0.0, 2.0, 0.5, -1.0, -0.5, 0.0, 2.0, -0.5, 1.0, 2.0, 0.0, 0.0, -0.5);

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 0.0, 0.0, 2.0, 0.5, -1.0, -0.5, 0.0, 2.0, -0.5, 1.0, 2.0, 0.0, 0.0, -0.5);

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
66.66666666666666
Processing this: /home/oof/webgl_cleaned/length_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(length(color.r)), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(length(color.r)), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = ivec2(1.0, -0.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'assign' : cannot convert from 'const 2-component vector of int' to 'FragColor mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = ivec2(1.0, -0.5);
}


==============================
64.0
Mutations attempted: 25
Valid mutations:     16
Success rate:        64.00%
Processing this: /home/oof/webgl_cleaned/mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	               5.0,  6.0,  7.0,  8.0,
	               9.0, 10.0, 11.0, 12.0,
	              13.0, 14.0, 15.0, 16.0);
	bool elms = true;
	if(a[0][0] !=  1.0) elms = false;
	if(a[0][1] !=  2.0) elms = false;
	if(a[0][2] !=  3.0) elms = false;
	if(a[0][3] !=  4.0) elms = false;
	if(a[1][0] !=  5.0) elms = false;
	if(a[1][1] !=  6.0) elms = false;
	if(a[1][2] !=  7.0) elms = false;
	if(a[1][3] !=  8.0) elms = false;
	if(a[2][0] !=  9.0) elms = false;
	if(a[2][1] != 10.0) elms = false;
	if(a[2][2] != 11.0) elms = false;
	if(a[2][3] != 12.0) elms = false;
	if(a[3][0] != 13.0) elms = false;
	if(a[3][1] != 14.0) elms = false;
	if(a[3][2] != 15.0) elms = false;
	if(a[3][3] != 16.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tmat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t               5.0,  6.0,  7.0,  8.0,\n\t               9.0, 10.0, 11.0, 12.0,\n\t              13.0, 14.0, 15.0, 16.0);\n\tbool elms = true;\n\tif(a[0][0] !=  1.0) elms = false;\n\tif(a[0][1] !=  2.0) elms = false;\n\tif(a[0][2] !=  3.0) elms = false;\n\tif(a[0][3] !=  4.0) elms = false;\n\tif(a[1][0] !=  5.0) elms = false;\n\tif(a[1][1] !=  6.0) elms = false;\n\tif(a[1][2] !=  7.0) elms = false;\n\tif(a[1][3] !=  8.0) elms = false;\n\tif(a[2][0] !=  9.0) elms = false;\n\tif(a[2][1] != 10.0) elms = false;\n\tif(a[2][2] != 11.0) elms = false;\n\tif(a[2][3] != 12.0) elms = false;\n\tif(a[3][0] != 13.0) elms = false;\n\tif(a[3][1] != 14.0) elms = false;\n\tif(a[3][2] != 15.0) elms = false;\n\tif(a[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 * -0.9)) || (x > (!true ? -1.0 : (false ? 0.5 : -1.0)))))
    -(0.0 * 1.0);
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
65.38461538461539
Processing this: /home/oof/webgl_cleaned/exp_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec3 c = gtf_Color.rgb;
	color = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(pow(vec3(exp1), 3.0 * c) / exp3, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec3 c = gtf_Color.rgb;
  color = vec4((pow(vec3(exp1) , (3.0 * c)) / exp3) , 1.0);
  gtf_ModelViewProjectionMatrix = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  vec4(+0.0, 0.5, +1.0, (true ? 0.0 : (-1.0 + (1.0 - -1.0))));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'assign' : l-value required (can't modify a uniform "gtf_ModelViewProjectionMatrix")
ERROR: 0:18: '=' : dimension mismatch
ERROR: 0:18: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'uniform mediump 4X4 matrix of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec3 c = gtf_Color.rgb;
  color = vec4((pow(vec3(exp1) , (3.0 * c)) / exp3) , 1.0);
  gtf_ModelViewProjectionMatrix = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  vec4(+0.0, 0.5, +1.0, (true ? 0.0 : (-1.0 + (1.0 - -1.0))));
}


==============================
62.96296296296296
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 16.0 * gtf_Color.r;
	color = vec4(pow(c, 0.5) / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 16.0 * gtf_Color.r;\n\tcolor = vec4(pow(c, 0.5) / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex = vec4(-1.0, 0.5, 0.5, +(+0.5 / 1.0));

void main()
{
  float c = (16.0 * gtf_Color.r);
  color = vec4((pow(c , 0.5) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.28571428571429
Processing this: /home/oof/webgl_cleaned/mod_vec3_frag_xvary_yconst1.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(mod(c, 1.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(mod(c, 1.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -0.5, 0.5, 0.5);

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(mod(c , 1.0) , 1.0);
}


As vertex? : False
SUCCESS!
65.51724137931035
Processing this: /home/oof/webgl_cleaned/extension9_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
65.51724137931035
Processing this: /home/oof/webgl_cleaned/vec4_empty_empty_vec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
65.51724137931035
Processing this: /home/oof/webgl_cleaned/version2_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/clamp_vec2_vert_xvary_yconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec2 c = gtf_Color.rg;
	if(c[0] > max_c) c[0] = max_c;
	if(c[0] < min_c) c[0] = min_c;
	if(c[1] > max_c) c[1] = max_c;
	if(c[1] < min_c) c[1] = min_c;
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tvec2 c = gtf_Color.rg;\n\tif(c[0] > max_c) c[0] = max_c;\n\tif(c[0] < min_c) c[0] = min_c;\n\tif(c[1] > max_c) c[1] = max_c;\n\tif(c[1] < min_c) c[1] = min_c;\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  if ((c[0] > max_c))
    c[0] = max_c;
  if ((c[0] < min_c))
    c[0] = min_c;
  if ((c[1] > max_c))
    c[1] = max_c;
  if ((gtf_Color[0] < min_c))
    min_c = c[1];
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  if ((c[0] > max_c))
    c[0] = max_c;
  if ((c[0] < min_c))
    c[0] = min_c;
  if ((c[1] > max_c))
    c[1] = max_c;
  if ((gtf_Color[0] < min_c))
    min_c = c[1];
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
64.51612903225806
Processing this: /home/oof/webgl_cleaned/vec2_2float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 a = vec2(13.0,53.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 a = vec2(13.0,53.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-0.5, 1.0, -1.0, -0.5);

void main()
{
  vec2 a = vec2(13.0 , 53.0);
  float gray;
  if (((a[0] == 13.0) && (a[1] == 53.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
65.625
Processing this: /home/oof/webgl_cleaned/relational_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int m = 102;
	int k = 12;
	bool lessthan  = (m<k);
	bool greaterthan = (m>k);
	bool lessthanorequalto = (m <= 102);
	bool greaterthanorequalto = (k >=12);
	float gray;
	if( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 102;\n\tint k = 12;\n\tbool lessthan  = (m<k);\n\tbool greaterthan = (m>k);\n\tbool lessthanorequalto = (m <= 102);\n\tbool greaterthanorequalto = (k >=12);\n\tfloat gray;\n\tif( !lessthan && greaterthan && lessthanorequalto && greaterthanorequalto )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int m = 102;
  int k = 12;
  bool lessthan = (m < k);
  bool greaterthan = (m > k);
  bool lessthanorequalto = (m <= 102);
  bool greaterthanorequalto = (k >= 12);
  float gray;
  if ((((!lessthan && greaterthan) && lessthanorequalto) && greaterthanorequalto))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.66666666666666
Mutations attempted: 33
Valid mutations:     22
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * color.rg;
	gl_FragColor = vec4(c / 100.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * color.rg;\n\tgl_FragColor = vec4(c / 100.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = (100.0 * color.rg);
  gl_FragColor = color((c / 100.0) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'gl_FragColor' : undeclared identifier
ERROR: 0:9: 'color' : function name expected
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = (100.0 * color.rg);
  gl_FragColor = color((c / 100.0) , 0.0);
}


==============================
64.70588235294117
Processing this: /home/oof/webgl_cleaned/for_nested_continue_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int count1 = 0, count2 = 0;
	int val1 = 0, val2 = 0;
    	for(int i=0;i<10;i++)
	{
	  	count1++;
		count2 = 0;
		for(int j=0;j<10;j++)
		{
			count2++;
			if(count2 == 5)
				continue;
			else
				val2 += count2;
		}
	  	if(count1 == 5)
            		continue;
	  	else
	    		val1 += count1;
	}
	float gray;
	if( (val1 == 50) && (val2 == 500) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint count1 = 0, count2 = 0;\n\tint val1 = 0, val2 = 0;\n    \tfor(int i=0;i<10;i++)\n\t{\n\t  \tcount1++;\n\t\tcount2 = 0;\n\t\tfor(int j=0;j<10;j++)\n\t\t{\n\t\t\tcount2++;\n\t\t\tif(count2 == 5)\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tval2 += count2;\n\t\t}\n\t  \tif(count1 == 5)\n            \t\tcontinue;\n\t  \telse\n\t    \t\tval1 += count1;\n\t}\n\tfloat gray;\n\tif( (val1 == 50) && (val2 == 500) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int count1 = 0 , count2 = 0;
  int val1 = 0 , val2 = 0;
  for (int i = 0; (i < 10); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 10); j++)
    {
      count2++;
      if ((count2 == 5))
        continue;
      else
        (val2 += count2);
    }
    if ((count1 == 5))
      continue;
    else
      (val1 += count1);
  }
  float gray;
  if (((+0.5 == 50) && (main() == 500)))
    gtf_ModelViewProjectionMatrix = 1.0;
  else
    gray = ((true || true) ? (false ? 0.5 : 0.0) : (0.0 + 2.0));
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:32: '==' : wrong operand types - no operation '==' exists that takes a left-hand operand of type 'const float' and a right operand of type 'const int' (or there is no acceptable conversion)
ERROR: 0:32: '==' : operation with void operands
ERROR: 0:32: '==' : wrong operand types - no operation '==' exists that takes a left-hand operand of type 'void' and a right operand of type 'const int' (or there is no acceptable conversion)
ERROR: 0:33: 'assign' : l-value required (can't modify a uniform "gtf_ModelViewProjectionMatrix")
ERROR: 0:33: '=' : dimension mismatch
ERROR: 0:33: 'assign' : cannot convert from 'const float' to 'uniform mediump 4X4 matrix of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int count1 = 0 , count2 = 0;
  int val1 = 0 , val2 = 0;
  for (int i = 0; (i < 10); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 10); j++)
    {
      count2++;
      if ((count2 == 5))
        continue;
      else
        (val2 += count2);
    }
    if ((count1 == 5))
      continue;
    else
      (val1 += count1);
  }
  float gray;
  if (((+0.5 == 50) && (main() == 500)))
    gtf_ModelViewProjectionMatrix = 1.0;
  else
    gray = ((true || true) ? (false ? 0.5 : 0.0) : (0.0 + 2.0));
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.857142857142854
Processing this: /home/oof/webgl_cleaned/tan_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);
	vec2 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * tan(c.r) + 0.5;
	else
		o.r = 0.5 / tan(c.r) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * tan(c.g) + 0.5;
	else
		o.g = 0.5 / tan(c.g) + 0.5;
	gl_FragColor = vec4(o, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);\n\tvec2 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * tan(c.r) + 0.5;\n\telse\n\t\to.r = 0.5 / tan(c.r) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * tan(c.g) + 0.5;\n\telse\n\t\to.g = 0.5 / tan(c.g) + 0.5;\n\tgl_FragColor = vec4(o, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((0.5 * M_PI) * 2.0) * (color.rg - 0.5));
  vec2 o = vec2(++0.5, +2.0);
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '++' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((0.5 * M_PI) * 2.0) * (color.rg - 0.5));
  vec2 o = vec2(++0.5, +2.0);
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 1.0);
}


==============================
61.111111111111114
Processing this: /home/oof/webgl_cleaned/smoothstep_vec2_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 edge0 = vec2(0.25, 0.25);
	const vec2 edge1 = vec2(0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rg), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge0 = vec2(0.25, 0.25);\n\tconst vec2 edge1 = vec2(0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rg), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-1.0, 2.0, (((true || false) ? 0.0 : 0.5) - 1.0), 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge0 = vec2(0.25 , 0.25);
  const vec2 edge1 = vec2(0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rg) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.16216216216216
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 31.0 * gtf_Color.r + 1.0;
	color = vec4(log(c) / 3.466, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 31.0 * gtf_Color.r + 1.0;\n\tcolor = vec4(log(c) / 3.466, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-(false ? 1.0 : (true ? 1.0 : -1.0)), ((1.0 - (0.0 + 2.0)) * ((true ? 0.0 : -1.0) * 2.0)), -1.0, --(1.0 / 1.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((31.0 * gtf_Color.r) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-(false ? 1.0 : (true ? 1.0 : -1.0)), ((1.0 - (0.0 + 2.0)) * ((true ? 0.0 : -1.0) * 2.0)), -1.0, --(1.0 / 1.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((31.0 * gtf_Color.r) + 1.0);
  color = vec4((log(c) / 3.466) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.526315789473685
Processing this: /home/oof/webgl_cleaned/length_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && true) ? (!true ? 2.0 : 0.0) : (-1.0 / 0.0)), ((true || !true) ? 1.0 : -0.0), 0.0, 2.0);

void main()
{
  gl_FragColor = vec4(vec3((sqrt(((color.r * color.r) + (color.g * color.g))) / 2.0)) , 1.0);
}


As vertex? : False
SUCCESS!
61.53846153846154
Processing this: /home/oof/webgl_cleaned/vec4_ar_bg_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.ar;
	vec2 n = lightloc.bg;
	vec4 a = vec4(m.g, n.g, n.r, m.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.ar;\n\tvec2 n = lightloc.bg;\n\tvec4 a = vec4(m.g, n.g, n.r, m.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((((false && true) ? false : false) ? ((true && true) ? 0.0 : 2.0) : 1.0), 0.5, -1.0, 1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.ar;
  vec2 n = lightloc.bg;
  vec4 a = vec4(m.g , n.g , n.r , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
62.5
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconsthalf_yvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = -2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((!true ? !false : true) ? 0.0 : +(false ? 2.0 : 0.0)), -1.0, 1.0, 0.0);

void main()
{
  vec3 c = (-2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4((exp2((2.0 * c)) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
63.41463414634146
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(in mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_ones) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(in mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(in mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_ones) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(in mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
63.41463414634146
Processing this: /home/oof/webgl_cleaned/any_bvec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	gl_FragColor = vec4(vec3(any(bvec2(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tgl_FragColor = vec4(vec3(any(bvec2(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(+-(0.5 - 0.5), 0.0, 1.0, 0.5);

void main()
{
  vec2 c = floor((1.5 * color.rg));
  gl_FragColor = vec4(vec3(any(bvec2(c))) , 1.0);
}


As vertex? : False
SUCCESS!
64.28571428571429
Mutations attempted: 42
Valid mutations:     27
Success rate:        64.29%
Processing this: /home/oof/webgl_cleaned/struct_bool_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	bool a;
	bool b;
	bool c;
	bool d;
};
void main ()
{
	sabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));
	float gray = 0.0;
	if( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))
	  gray=1.0;
	else
          gray =0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tbool a;\n\tbool b;\n\tbool c;\n\tbool d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));\n\tfloat gray = 0.0;\n\tif( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix / gtf_Vertex);
  sabcd((false ? false : !(true ? true : false)), (!!true ? false : false), !true, true);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:26: '/' : wrong operand types - no operation '/' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:26: '=' : dimension mismatch
ERROR: 0:26: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix / gtf_Vertex);
  sabcd((false ? false : !(true ? true : false)), (!!true ? false : false), !true, true);
}


==============================
62.7906976744186
Processing this: /home/oof/webgl_cleaned/fract_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/matrix2VSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-1.0 - -(1.0 - 2.0)), ((false ? -2.0 : 0.5) / -1.0), 2.0, -+-1.0);

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
64.44444444444444
Processing this: /home/oof/webgl_cleaned/vec4_xyzw_1vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec4 m = lightloc.xyzw;
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec4 m = lightloc.xyzw;\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, -1.0, 0.0, 1.0, -1.0, 2.0, (+(2.0 / 0.5) + -1.0), -1.0, -2.0, ((false ? (true ? false : true) : (false && true)) ? 0.0 : (2.0 + +1.0)), ---1.0, 0.5, 2.0, 0.0, 1.0, (2.0 + 0.5));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.xyzw;
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, -1.0, 0.0, 1.0, -1.0, 2.0, (+(2.0 / 0.5) + -1.0), -1.0, -2.0, ((false ? (true ? false : true) : (false && true)) ? 0.0 : (2.0 + +1.0)), ---1.0, 0.5, 2.0, 0.0, 1.0, (2.0 + 0.5));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec4 m = lightloc.xyzw;
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


==============================
63.04347826086957
Processing this: /home/oof/webgl_cleaned/vec3_yxz_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec3 t = m.yxz;
	vec4 a = vec4(t.y, t.x, t.z, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec3 t = m.yxz;\n\tvec4 a = vec4(t.y, t.x, t.z, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, (true ? -(true ? 2.0 : -1.0) : (true ? -1.0 : (1.0 + -1.0))), -1.0, (+(-1.0 / 2.0) + +0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec3 t = m.yxz;
  vec4 a = vec4(t.y , t.x , t.z , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
63.829787234042556
Processing this: /home/oof/webgl_cleaned/bvec4_empty_in_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(in bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(in bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(in bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(in bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.829787234042556
Processing this: /home/oof/webgl_cleaned/mat3_9float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat3 m = mat3(gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if(m[0][0] != gtf_Color.r) result = black;
	if(m[0][1] != gtf_Color.g) result = black;
	if(m[0][2] != gtf_Color.b) result = black;
	if(m[1][0] != gtf_Color.r) result = black;
	if(m[1][1] != gtf_Color.g) result = black;
	if(m[1][2] != gtf_Color.b) result = black;
	if(m[2][0] != gtf_Color.r) result = black;
	if(m[2][1] != gtf_Color.g) result = black;
	if(m[2][2] != gtf_Color.b) result = black;
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m = mat3(gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b, gtf_Color.r, gtf_Color.g, gtf_Color.b);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif(m[0][0] != gtf_Color.r) result = black;\n\tif(m[0][1] != gtf_Color.g) result = black;\n\tif(m[0][2] != gtf_Color.b) result = black;\n\tif(m[1][0] != gtf_Color.r) result = black;\n\tif(m[1][1] != gtf_Color.g) result = black;\n\tif(m[1][2] != gtf_Color.b) result = black;\n\tif(m[2][0] != gtf_Color.r) result = black;\n\tif(m[2][1] != gtf_Color.g) result = black;\n\tif(m[2][2] != gtf_Color.b) result = black;\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 1.0, 1.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat3 m = mat3(gtf_Color.r , gtf_Color.g , gtf_Color.b , gtf_Color.r , gtf_Color.g , gtf_Color.b , gtf_Color.r , gtf_Color.g , gtf_Color.b);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != gtf_Color.r))
    result = black;
  if ((m[0][1] != gtf_Color.g))
    result = black;
  if ((m[0][2] != gtf_Color.b))
    result = black;
  if ((m[1][0] != gtf_Color.r))
    result = black;
  if ((m[1][1] != gtf_Color.g))
    result = black;
  if ((m[1][2] != gtf_Color.b))
    result = black;
  if ((m[2][0] != gtf_Color.r))
    result = black;
  if ((m[2][1] != gtf_Color.g))
    result = black;
  if ((m[2][2] != gtf_Color.b))
    result = black;
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.58333333333334
Processing this: /home/oof/webgl_cleaned/length_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(sqrt(color.r*color.r + color.g*color.g) / 2.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 1.0, 0.0, --1.0);

void main()
{
  gl_FragColor = vec4(vec3((sqrt(((color.r * color.r) + (color.g * color.g))) / 2.0)) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 1.0, 0.0, --1.0);

void main()
{
  gl_FragColor = vec4(vec3((sqrt(((color.r * color.r) + (color.g * color.g))) / 2.0)) , 1.0);
}


==============================
63.26530612244898
Processing this: /home/oof/webgl_cleaned/length_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(vec3(gtf_Color.r), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(vec3(gtf_Color.r), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = vec4(vec3(gtf_Color.r) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.0
Processing this: /home/oof/webgl_cleaned/mat2_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat2 m = mat2(0.5);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if((m[0][0] != 0.5))
		result = black;
	if((m[0][1] != 0.0))
		result = black;
	if((m[1][0] != 0.0))
		result = black;
	if((m[1][1] != 0.5))
		result = black;
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m = mat2(0.5);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif((m[0][0] != 0.5))\n\t\tresult = black;\n\tif((m[0][1] != 0.0))\n\t\tresult = black;\n\tif((m[1][0] != 0.0))\n\t\tresult = black;\n\tif((m[1][1] != 0.5))\n\t\tresult = black;\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  mat2 m = mat2(0.5);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != 0.5))
    result = black;
  if ((m[0][1] != 0.0))
    result = black;
  if ((m[1][0] != 0.0))
    result = black;
  if ((m[1][1] != 0.5))
    result = black;
  gl_FragColor = result;
}


As vertex? : False
SUCCESS!
64.70588235294117
Mutations attempted: 51
Valid mutations:     33
Success rate:        64.71%
Processing this: /home/oof/webgl_cleaned/clamp_float_vert_xvary_yconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = gtf_Color.r;
	if(c > max_c) c = max_c;
	if(c < min_c) c = min_c;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = gtf_Color.r;\n\tif(c > max_c) c = max_c;\n\tif(c < min_c) c = min_c;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(+((0.5 / 0.0) / (1.0 / 0.5)), (0.0 + 2.0), 0.0, 2.0);

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = gtf_Color.r;
  if ((c > max_c))
    c = max_c;
  if ((c < min_c))
    c = min_c;
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
65.38461538461539
Processing this: /home/oof/webgl_cleaned/matrix2VSU.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform mat4 transforms;
uniform mat4 anotherMatrix;
varying vec4 color;
void main()
{
  color = gtf_Color;
   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform mat4 transforms;\nuniform mat4 anotherMatrix;\nvarying vec4 color;\nvoid main()\n{\n  color = gtf_Color;\n   gl_Position = gtf_ModelViewProjectionMatrix* transforms * anotherMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, --1.0, (false ? 0.5 : 0.0), -1.0, -1.0, 2.0, 2.0, 2.0, 0.5, (false ? +2.0 : ((true || false) ? 2.0 : (true ? 0.0 : 2.0))), (0.5 * (-1.0 / 1.0)), 0.0, (!true ? 2.0 : (true ? 2.0 : 2.0)), +((true ? false : true) ? +1.0 : +2.0), (0.5 / (-0.0 * 1.0)), 0.0);

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms) * anotherMatrix) * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, --1.0, (false ? 0.5 : 0.0), -1.0, -1.0, 2.0, 2.0, 2.0, 0.5, (false ? +2.0 : ((true || false) ? 2.0 : (true ? 0.0 : 2.0))), (0.5 * (-1.0 / 1.0)), 0.0, (!true ? 2.0 : (true ? 2.0 : 2.0)), +((true ? false : true) ? +1.0 : +2.0), (0.5 / (-0.0 * 1.0)), 0.0);

uniform mat4 transforms;

uniform mat4 anotherMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  gl_Position = (((gtf_ModelViewProjectionMatrix * transforms) * anotherMatrix) * gtf_Vertex);
}


==============================
64.15094339622641
Processing this: /home/oof/webgl_cleaned/max_float_vert_xvary_yconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = gtf_Color.r;
	color = vec4(max(c, max_c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(max(c, max_c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((true ? 2.0 : 2.0) * 2.0) + -1.0), (1.0 / (false ? (true ? 0.5 : 0.0) : 2.0)), 2.0, -2.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = gtf_Color.r;
  color = vec4(max(c , max_c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.81481481481481
Processing this: /home/oof/webgl_cleaned/mix_vec2_vert_xvary_yconsthalf_aconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = gtf_Color.rg;
	color = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = gtf_Color.rg;
  color = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  vec4(0.5, 2.0, (2.0 * 2.0), (false ? ((false ? 2.0 : 2.0) + (true ? 0.5 : 0.0)) : ((true && false) ? 0.5 : -1.0)));
}


As vertex? : True
SUCCESS!
65.45454545454545
Processing this: /home/oof/webgl_cleaned/vec3_zx_y_1vec2_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	float k = m.y;
	vec2 n = m.zx;
	vec4 a = vec4(n.y, k, n.x, al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tfloat k = m.y;\n\tvec2 n = m.zx;\n\tvec4 a = vec4(n.y, k, n.x, al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 0.5, -0.5, 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  float k = m.y;
  vec2 n = m.zx;
  vec4 a = vec4(n.y , k , n.x , al.w);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
66.07142857142857
Processing this: /home/oof/webgl_cleaned/varying1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float foo;
void main()
{
    foo = 5.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float foo;\nvoid main()\n{\n    foo = 5.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

float foo;

void main()
{
  foo = 5.0;
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
66.66666666666666
Processing this: /home/oof/webgl_cleaned/vec3_yz_x_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec2 t = m.yz;
	float k = m.x;
	vec4 a = vec4(k, t.x, t.y,  lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec2 t = m.yz;\n\tfloat k = m.x;\n\tvec4 a = vec4(k, t.x, t.y,  lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((!false ? -1.0 : -1.0), +0.0, 1.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec2 t = m.yz;
  float k = m.x;
  vec4 a = vec4(k , t.x , t.y , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
67.24137931034483
Processing this: /home/oof/webgl_cleaned/normalize_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(normalize(tmp_Color.rg), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((+(2.0 * 0.5) * (-1.0 * (-1.0 / -1.0))), 1.0, (((-1.0 + 1.0) * (0.0 / 0.5)) * -1.0), 0.0);

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  gl_FragColor = vec4(normalize(tmp_Color.rg) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
67.79661016949152
Processing this: /home/oof/webgl_cleaned/mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	               5.0,  6.0,  7.0,  8.0,
	               9.0, 10.0, 11.0, 12.0,
	              13.0, 14.0, 15.0, 16.0);
	bool elms = true;
	if(a[0][0] !=  1.0) elms = false;
	if(a[0][1] !=  2.0) elms = false;
	if(a[0][2] !=  3.0) elms = false;
	if(a[0][3] !=  4.0) elms = false;
	if(a[1][0] !=  5.0) elms = false;
	if(a[1][1] !=  6.0) elms = false;
	if(a[1][2] !=  7.0) elms = false;
	if(a[1][3] !=  8.0) elms = false;
	if(a[2][0] !=  9.0) elms = false;
	if(a[2][1] != 10.0) elms = false;
	if(a[2][2] != 11.0) elms = false;
	if(a[2][3] != 12.0) elms = false;
	if(a[3][0] != 13.0) elms = false;
	if(a[3][1] != 14.0) elms = false;
	if(a[3][2] != 15.0) elms = false;
	if(a[3][3] != 16.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tmat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t               5.0,  6.0,  7.0,  8.0,\n\t               9.0, 10.0, 11.0, 12.0,\n\t              13.0, 14.0, 15.0, 16.0);\n\tbool elms = true;\n\tif(a[0][0] !=  1.0) elms = false;\n\tif(a[0][1] !=  2.0) elms = false;\n\tif(a[0][2] !=  3.0) elms = false;\n\tif(a[0][3] !=  4.0) elms = false;\n\tif(a[1][0] !=  5.0) elms = false;\n\tif(a[1][1] !=  6.0) elms = false;\n\tif(a[1][2] !=  7.0) elms = false;\n\tif(a[1][3] !=  8.0) elms = false;\n\tif(a[2][0] !=  9.0) elms = false;\n\tif(a[2][1] != 10.0) elms = false;\n\tif(a[2][2] != 11.0) elms = false;\n\tif(a[2][3] != 12.0) elms = false;\n\tif(a[3][0] != 13.0) elms = false;\n\tif(a[3][1] != 14.0) elms = false;\n\tif(a[3][2] != 15.0) elms = false;\n\tif(a[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  (((a[0][(false ? (true ? 2 : 3) : 2)] + a[1][1]) + a[4][1]) + vec4(1.0, (((false || true) || false) ? -1.0 : 2.0), 2.0, 1.0)) = +--1.0;
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:45: '[]' : matrix field selection out of range
ERROR: 0:45: '--' : l-value required (can't modify a const)
ERROR: 0:45: 'assign' :  l-value required
ERROR: 0:45: '=' : dimension mismatch
ERROR: 0:45: 'assign' : cannot convert from 'const float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  (((a[0][(false ? (true ? 2 : 3) : 2)] + a[1][1]) + a[4][1]) + vec4(1.0, (((false || true) || false) ? -1.0 : 2.0), 2.0, 1.0)) = +--1.0;
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
66.66666666666666
Mutations attempted: 60
Valid mutations:     40
Success rate:        66.67%
Processing this: /home/oof/webgl_cleaned/vertexOnly2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
    gl_Position = vec4(4.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n    gl_Position = vec4(4.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(((true ? 2.0 : 0.5) + (0.0 + 0.5)), (((false || true) ? (true && true) : !true) ? (false ? 1.0 : 1.0) : (-1.0 * 0.5)), (0.0 / -(0.5 + 2.0)), (true ? (--1.0 * (1.0 + 0.0)) : (true ? 0.0 : +1.0)))(3.5);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  gl_Position = vec4(((true ? 2.0 : 0.5) + (0.0 + 0.5)), (((false || true) ? (true && true) : !true) ? (false ? 1.0 : 1.0) : (-1.0 * 0.5)), (0.0 / -(0.5 + 2.0)), (true ? (--1.0 * (1.0 + 0.0)) : (true ? 0.0 : +1.0)))(3.5);
}


==============================
65.57377049180327
Processing this: /home/oof/webgl_cleaned/atan_vec2_frag_xvaryyvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 x = 2.0 * (color.gg - 0.5);
	vec2 y = 2.0 * (color.bb - 0.5);
	const float epsilon = 1.0e-4;
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		gl_FragColor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		gl_FragColor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;
	}
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 x = 2.0 * (color.gg - 0.5);\n\tvec2 y = 2.0 * (color.bb - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tgl_FragColor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tgl_FragColor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;\n\t}\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 x = (2.0 * (color.gg - 0.5));
  vec2 y = (2.0 * (color.bb - 0.5));
  const float epsilon = 0.0001;
  gl_FragColor = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    gl_FragColor[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    gl_FragColor[1] = ((atan(y[1] , x[1]) / (2.0 * M_PI)) + 0.5);
  }
}


As vertex? : False
SUCCESS!
66.12903225806451
Processing this: /home/oof/webgl_cleaned/inversesqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = (gtf_Color.r * 99.0) + 1.0;
	color = vec4(inversesqrt(c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = (gtf_Color.r * 99.0) + 1.0;\n\tcolor = vec4(inversesqrt(c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, -0.5, 0.5, -1.0);

void main()
{
  float c = ((gtf_Color.r * 99.0) + 1.0);
  color = vec4(inversesqrt(c) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/step_float_frag_xvary_edgeconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float edge = 0.5;
	gl_FragColor = vec4(step(edge, color.r), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge = 0.5;\n\tgl_FragColor = vec4(step(edge, color.r), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.0, (((false ? true : false) ? !false : false) ? 0.5 : 2.0), 0.0);

void main()
{
  const float edge = 0.5;
  gl_FragColor = vec4(step(edge , color.r) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
67.1875
Processing this: /home/oof/webgl_cleaned/postfixdecrement_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int m = 23;
	int k = m--;
	float gray;
	if( ( k == 23 ) && ( m == 22 ) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint m = 23;\n\tint k = m--;\n\tfloat gray;\n\tif( ( k == 23 ) && ( m == 22 ) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((-1.0 - 0.0) / -0.0), 2.0, 1.0, 0.0);

void main()
{
  int m = 23;
  int k = m--;
  float gray;
  if (((k == 23) && (m == 22)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
67.6923076923077
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 lte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lte(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 lte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lte(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
68.18181818181817
Processing this: /home/oof/webgl_cleaned/radians_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 360.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 360.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, -0.5, 0.0, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((360.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((radians(c) / (4.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
68.65671641791045
Processing this: /home/oof/webgl_cleaned/floor_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, 2.0, 0.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
69.11764705882352
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xconst2_yvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(pow(vec3(2.0), 2.0 * c) / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((0.5 - color.rgb) * -2.0);
  gl_FragColor = vec4((pow(vec3(2.0) , (2.0 * c)) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
69.56521739130434
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
69.56521739130434
Mutations attempted: 69
Valid mutations:     48
Success rate:        69.57%
Processing this: /home/oof/webgl_cleaned/exp2_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 0.5, 0.0, +-1.0, 2.0, --0.5, -1.0, 0.5, 2.0, (1.0 * 0.5), +--1.0, -1.0, (true ? (0.5 + 0.5) : ((true && true) ? 2.0 : 0.0)), 0.0, 0.5, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 0.5, 0.0, +-1.0, 2.0, --0.5, -1.0, 0.5, 2.0, (1.0 * 0.5), +--1.0, -1.0, (true ? (0.5 + 0.5) : ((true && true) ? 2.0 : 0.0)), 0.0, 0.5, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
68.57142857142857
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!false ? +0.0 : 1.0), 1.0, 0.0, 1.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(greaterThanEqual(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
69.01408450704226
Processing this: /home/oof/webgl_cleaned/tan_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 0.5 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);
	vec3 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * tan(c.r) + 0.5;
	else
		o.r = 0.5 / tan(c.r) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * tan(c.g) + 0.5;
	else
		o.g = 0.5 / tan(c.g) + 0.5;
	if(abs(c.b) < 0.5)
		o.b = 0.5 * tan(c.b) + 0.5;
	else
		o.b = 0.5 / tan(c.b) + 0.5;
	color = vec4(o, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 0.5 * M_PI * 2.0 * (gtf_Color.rgb - 0.5);\n\tvec3 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * tan(c.r) + 0.5;\n\telse\n\t\to.r = 0.5 / tan(c.r) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * tan(c.g) + 0.5;\n\telse\n\t\to.g = 0.5 / tan(c.g) + 0.5;\n\tif(abs(c.b) < 0.5)\n\t\to.b = 0.5 * tan(c.b) + 0.5;\n\telse\n\t\to.b = 0.5 / tan(c.b) + 0.5;\n\tcolor = vec4(o, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 1.0, 1.0, -0.5, 1.0, 1.0, 0.0, 0.0, -0.5, -1.0, 1.0, 1.0, 0.0, -0.5, -0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (gtf_Color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * tan(c.b)) + 0.5);
  else
    o.b = ((0.5 / tan(c.b)) + 0.5);
  color = vec4(o , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(2.0, 1.0, 1.0, 1.0, -0.5, 1.0, 1.0, 0.0, 0.0, -0.5, -1.0, 1.0, 1.0, 0.0, -0.5, -0.5);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (gtf_Color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * tan(c.b)) + 0.5);
  else
    o.b = ((0.5 / tan(c.b)) + 0.5);
  color = vec4(o , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
68.05555555555556
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
68.05555555555556
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	gl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tgl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  gl_FragColor = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
}


As vertex? : False
SUCCESS!
68.4931506849315
Processing this: /home/oof/webgl_cleaned/Low_Level_Assembly_Reserved_Words_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform float MIN;
uniform float R0;
uniform float FOGC;
uniform float CUBE;
uniform float f;
uniform float o;
uniform float p;
uniform float w;
uniform float x;
uniform float y;
uniform float z;
void main()
{
	gl_FragColor = vec4(f, o, p, w);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform float MIN;\nuniform float R0;\nuniform float FOGC;\nuniform float CUBE;\nuniform float f;\nuniform float o;\nuniform float p;\nuniform float w;\nuniform float x;\nuniform float y;\nuniform float z;\nvoid main()\n{\n\tgl_FragColor = vec4(f, o, p, w);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w;

uniform float x;

uniform float y = ((false ? (2.0 * 0.0) : (0.0 + 1.0)) / -1.0);

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w;

uniform float x;

uniform float y = ((false ? (2.0 * 0.0) : (0.0 + 1.0)) / -1.0);

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


==============================
67.56756756756756
Processing this: /home/oof/webgl_cleaned/int_empty_inout_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(inout int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(inout int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(inout int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(inout int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
67.56756756756756
Processing this: /home/oof/webgl_cleaned/2b_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform bvec2 color;
varying vec2 col;
void main ()
{
	col = vec2(color);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform bvec2 color;\nvarying vec2 col;\nvoid main ()\n{\n\tcol = vec2(color);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.5, 0.0, 2.0, -1.0, 0.5, 2.0, 0.5, 0.5, 0.0, 0.0, 0.0, -0.5, -0.5, 0.5, 0.0);

vec4 gtf_Color;

uniform bvec2 color;

vec2 col;

void main()
{
  col = vec2(color);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 0.5, 0.0, 2.0, -1.0, 0.5, 2.0, 0.5, 0.5, 0.0, 0.0, 0.0, -0.5, -0.5, 0.5, 0.0);

vec4 gtf_Color;

uniform bvec2 color;

vec2 col;

void main()
{
  col = vec2(color);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
66.66666666666666
Processing this: /home/oof/webgl_cleaned/acos_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float asinValues[17];
	asinValues[0] = -1.5708;
	asinValues[1] = -1.06544;
	asinValues[2] = -0.848062;
	asinValues[3] = -0.675132;
	asinValues[4] = -0.523599;
	asinValues[5] = -0.384397;
	asinValues[6] = -0.25268;
	asinValues[7] = -0.125328;
	asinValues[8] = 0.0;
	asinValues[9] = 0.125328;
	asinValues[10] = 0.25268;
	asinValues[11] = 0.384397;
	asinValues[12] = 0.523599;
	asinValues[13] = 0.675132;
	asinValues[14] = 0.848062;
	asinValues[15] = 1.06544;
	asinValues[16] = 1.5708;
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * (color.rg - 0.5);
	vec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;
	int arr0x = int(floor(arrVal.x));
	int arr0y = int(floor(arrVal.y));
	vec2 weight = arrVal - floor(arrVal);
	vec2 asin_c = vec2(0.0);
	if (arr0x == 0)
		asin_c.x = lerp(asinValues[0], asinValues[1], weight.x);
	else if (arr0x == 1)
		asin_c.x = lerp(asinValues[1], asinValues[2], weight.x);
	else if (arr0x == 2)
		asin_c.x = lerp(asinValues[2], asinValues[3], weight.x);
	else if (arr0x == 3)
		asin_c.x = lerp(asinValues[3], asinValues[4], weight.x);
	else if (arr0x == 4)
		asin_c.x = lerp(asinValues[4], asinValues[5], weight.x);
	else if (arr0x == 5)
		asin_c.x = lerp(asinValues[5], asinValues[6], weight.x);
	else if (arr0x == 6)
		asin_c.x = lerp(asinValues[6], asinValues[7], weight.x);
	else if (arr0x == 7)
		asin_c.x = lerp(asinValues[7], asinValues[8], weight.x);
	else if (arr0x == 8)
		asin_c.x = lerp(asinValues[8], asinValues[9], weight.x);
	else if (arr0x == 9)
		asin_c.x = lerp(asinValues[9], asinValues[10], weight.x);
	else if (arr0x == 10)
		asin_c.x = lerp(asinValues[10], asinValues[11], weight.x);
	else if (arr0x == 11)
		asin_c.x = lerp(asinValues[11], asinValues[12], weight.x);
	else if (arr0x == 12)
		asin_c.x = lerp(asinValues[12], asinValues[13], weight.x);
	else if (arr0x == 13)
		asin_c.x = lerp(asinValues[13], asinValues[14], weight.x);
	else if (arr0x == 14)
		asin_c.x = lerp(asinValues[14], asinValues[15], weight.x);
	else if (arr0x == 15)
		asin_c.x = lerp(asinValues[15], asinValues[16], weight.x);
        else if (arr0x == 16)
                asin_c.x = asinValues[16];
	if (arr0y == 0)
		asin_c.y = lerp(asinValues[0], asinValues[1], weight.y);
	else if (arr0y == 1)
		asin_c.y = lerp(asinValues[1], asinValues[2], weight.y);
	else if (arr0y == 2)
		asin_c.y = lerp(asinValues[2], asinValues[3], weight.y);
	else if (arr0y == 3)
		asin_c.y = lerp(asinValues[3], asinValues[4], weight.y);
	else if (arr0y == 4)
		asin_c.y = lerp(asinValues[4], asinValues[5], weight.y);
	else if (arr0y == 5)
		asin_c.y = lerp(asinValues[5], asinValues[6], weight.y);
	else if (arr0y == 6)
		asin_c.y = lerp(asinValues[6], asinValues[7], weight.y);
	else if (arr0y == 7)
		asin_c.y = lerp(asinValues[7], asinValues[8], weight.y);
	else if (arr0y == 8)
		asin_c.y = lerp(asinValues[8], asinValues[9], weight.y);
	else if (arr0y == 9)
		asin_c.y = lerp(asinValues[9], asinValues[10], weight.y);
	else if (arr0y == 10)
		asin_c.y = lerp(asinValues[10], asinValues[11], weight.y);
	else if (arr0y == 11)
		asin_c.y = lerp(asinValues[11], asinValues[12], weight.y);
	else if (arr0y == 12)
		asin_c.y = lerp(asinValues[12], asinValues[13], weight.y);
	else if (arr0y == 13)
		asin_c.y = lerp(asinValues[13], asinValues[14], weight.y);
	else if (arr0y == 14)
		asin_c.y = lerp(asinValues[14], asinValues[15], weight.y);
	else if (arr0y == 15)
		asin_c.y = lerp(asinValues[15], asinValues[16], weight.y);
        else if (arr0y == 16)
                asin_c.y = asinValues[16];
	gl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat asinValues[17];\n\tasinValues[0] = -1.5708;\n\tasinValues[1] = -1.06544;\n\tasinValues[2] = -0.848062;\n\tasinValues[3] = -0.675132;\n\tasinValues[4] = -0.523599;\n\tasinValues[5] = -0.384397;\n\tasinValues[6] = -0.25268;\n\tasinValues[7] = -0.125328;\n\tasinValues[8] = 0.0;\n\tasinValues[9] = 0.125328;\n\tasinValues[10] = 0.25268;\n\tasinValues[11] = 0.384397;\n\tasinValues[12] = 0.523599;\n\tasinValues[13] = 0.675132;\n\tasinValues[14] = 0.848062;\n\tasinValues[15] = 1.06544;\n\tasinValues[16] = 1.5708;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tvec2 arrVal = (c + vec2(1.0, 1.0)) * 8.0;\n\tint arr0x = int(floor(arrVal.x));\n\tint arr0y = int(floor(arrVal.y));\n\tvec2 weight = arrVal - floor(arrVal);\n\tvec2 asin_c = vec2(0.0);\n\tif (arr0x == 0)\n\t\tasin_c.x = lerp(asinValues[0], asinValues[1], weight.x);\n\telse if (arr0x == 1)\n\t\tasin_c.x = lerp(asinValues[1], asinValues[2], weight.x);\n\telse if (arr0x == 2)\n\t\tasin_c.x = lerp(asinValues[2], asinValues[3], weight.x);\n\telse if (arr0x == 3)\n\t\tasin_c.x = lerp(asinValues[3], asinValues[4], weight.x);\n\telse if (arr0x == 4)\n\t\tasin_c.x = lerp(asinValues[4], asinValues[5], weight.x);\n\telse if (arr0x == 5)\n\t\tasin_c.x = lerp(asinValues[5], asinValues[6], weight.x);\n\telse if (arr0x == 6)\n\t\tasin_c.x = lerp(asinValues[6], asinValues[7], weight.x);\n\telse if (arr0x == 7)\n\t\tasin_c.x = lerp(asinValues[7], asinValues[8], weight.x);\n\telse if (arr0x == 8)\n\t\tasin_c.x = lerp(asinValues[8], asinValues[9], weight.x);\n\telse if (arr0x == 9)\n\t\tasin_c.x = lerp(asinValues[9], asinValues[10], weight.x);\n\telse if (arr0x == 10)\n\t\tasin_c.x = lerp(asinValues[10], asinValues[11], weight.x);\n\telse if (arr0x == 11)\n\t\tasin_c.x = lerp(asinValues[11], asinValues[12], weight.x);\n\telse if (arr0x == 12)\n\t\tasin_c.x = lerp(asinValues[12], asinValues[13], weight.x);\n\telse if (arr0x == 13)\n\t\tasin_c.x = lerp(asinValues[13], asinValues[14], weight.x);\n\telse if (arr0x == 14)\n\t\tasin_c.x = lerp(asinValues[14], asinValues[15], weight.x);\n\telse if (arr0x == 15)\n\t\tasin_c.x = lerp(asinValues[15], asinValues[16], weight.x);\n        else if (arr0x == 16)\n                asin_c.x = asinValues[16];\n\tif (arr0y == 0)\n\t\tasin_c.y = lerp(asinValues[0], asinValues[1], weight.y);\n\telse if (arr0y == 1)\n\t\tasin_c.y = lerp(asinValues[1], asinValues[2], weight.y);\n\telse if (arr0y == 2)\n\t\tasin_c.y = lerp(asinValues[2], asinValues[3], weight.y);\n\telse if (arr0y == 3)\n\t\tasin_c.y = lerp(asinValues[3], asinValues[4], weight.y);\n\telse if (arr0y == 4)\n\t\tasin_c.y = lerp(asinValues[4], asinValues[5], weight.y);\n\telse if (arr0y == 5)\n\t\tasin_c.y = lerp(asinValues[5], asinValues[6], weight.y);\n\telse if (arr0y == 6)\n\t\tasin_c.y = lerp(asinValues[6], asinValues[7], weight.y);\n\telse if (arr0y == 7)\n\t\tasin_c.y = lerp(asinValues[7], asinValues[8], weight.y);\n\telse if (arr0y == 8)\n\t\tasin_c.y = lerp(asinValues[8], asinValues[9], weight.y);\n\telse if (arr0y == 9)\n\t\tasin_c.y = lerp(asinValues[9], asinValues[10], weight.y);\n\telse if (arr0y == 10)\n\t\tasin_c.y = lerp(asinValues[10], asinValues[11], weight.y);\n\telse if (arr0y == 11)\n\t\tasin_c.y = lerp(asinValues[11], asinValues[12], weight.y);\n\telse if (arr0y == 12)\n\t\tasin_c.y = lerp(asinValues[12], asinValues[13], weight.y);\n\telse if (arr0y == 13)\n\t\tasin_c.y = lerp(asinValues[13], asinValues[14], weight.y);\n\telse if (arr0y == 14)\n\t\tasin_c.y = lerp(asinValues[14], asinValues[15], weight.y);\n\telse if (arr0y == 15)\n\t\tasin_c.y = lerp(asinValues[15], asinValues[16], weight.y);\n        else if (arr0y == 16)\n                asin_c.y = asinValues[16];\n\tgl_FragColor = vec4(0.5 - asin_c / M_PI, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? (true ? 0.0 : (false ? 0.0 : 1.0)) : ((1.0 * -1.0) - (0.5 * 2.0))), 0.5, lerp(((false ? -1.0 : -1.0) + (2.0 + 0.5)), +(false ? -1.0 : 1.0), (false ? 1.0 : lerp(0.0, 0.0, 0.0))), (true ? 0.0 : lerp((1.0 / -1.0), (-1.0 + 2.0), 0.0)));

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'lerp' : no matching overloaded function found
ERROR: 0:4: 'lerp' : no matching overloaded function found
ERROR: 0:4: 'lerp' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? (true ? 0.0 : (false ? 0.0 : 1.0)) : ((1.0 * -1.0) - (0.5 * 2.0))), 0.5, lerp(((false ? -1.0 : -1.0) + (2.0 + 0.5)), +(false ? -1.0 : 1.0), (false ? 1.0 : lerp(0.0, 0.0, 0.0))), (true ? 0.0 : lerp((1.0 / -1.0), (-1.0 + 2.0), 0.0)));

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float asinValues[17];
  asinValues[0] = -1.5708;
  asinValues[1] = -1.06544;
  asinValues[2] = -0.848062;
  asinValues[3] = -0.675132;
  asinValues[4] = -0.523599;
  asinValues[5] = -0.384397;
  asinValues[6] = -0.25268;
  asinValues[7] = -0.125328;
  asinValues[8] = 0.0;
  asinValues[9] = 0.125328;
  asinValues[10] = 0.25268;
  asinValues[11] = 0.384397;
  asinValues[12] = 0.523599;
  asinValues[13] = 0.675132;
  asinValues[14] = 0.848062;
  asinValues[15] = 1.06544;
  asinValues[16] = 1.5708;
  const float M_PI = 3.141592653589793;
  vec2 c = (2.0 * (color.rg - 0.5));
  vec2 arrVal = ((c + vec2(1.0 , 1.0)) * 8.0);
  int arr0x = int(floor(arrVal.x));
  int arr0y = int(floor(arrVal.y));
  vec2 weight = (arrVal - floor(arrVal));
  vec2 asin_c = vec2(0.0);
  if ((arr0x == 0))
    asin_c.x = lerp(asinValues[0] , asinValues[1] , weight.x);
  else
    if ((arr0x == 1))
      asin_c.x = lerp(asinValues[1] , asinValues[2] , weight.x);
    else
      if ((arr0x == 2))
        asin_c.x = lerp(asinValues[2] , asinValues[3] , weight.x);
      else
        if ((arr0x == 3))
          asin_c.x = lerp(asinValues[3] , asinValues[4] , weight.x);
        else
          if ((arr0x == 4))
            asin_c.x = lerp(asinValues[4] , asinValues[5] , weight.x);
          else
            if ((arr0x == 5))
              asin_c.x = lerp(asinValues[5] , asinValues[6] , weight.x);
            else
              if ((arr0x == 6))
                asin_c.x = lerp(asinValues[6] , asinValues[7] , weight.x);
              else
                if ((arr0x == 7))
                  asin_c.x = lerp(asinValues[7] , asinValues[8] , weight.x);
                else
                  if ((arr0x == 8))
                    asin_c.x = lerp(asinValues[8] , asinValues[9] , weight.x);
                  else
                    if ((arr0x == 9))
                      asin_c.x = lerp(asinValues[9] , asinValues[10] , weight.x);
                    else
                      if ((arr0x == 10))
                        asin_c.x = lerp(asinValues[10] , asinValues[11] , weight.x);
                      else
                        if ((arr0x == 11))
                          asin_c.x = lerp(asinValues[11] , asinValues[12] , weight.x);
                        else
                          if ((arr0x == 12))
                            asin_c.x = lerp(asinValues[12] , asinValues[13] , weight.x);
                          else
                            if ((arr0x == 13))
                              asin_c.x = lerp(asinValues[13] , asinValues[14] , weight.x);
                            else
                              if ((arr0x == 14))
                                asin_c.x = lerp(asinValues[14] , asinValues[15] , weight.x);
                              else
                                if ((arr0x == 15))
                                  asin_c.x = lerp(asinValues[15] , asinValues[16] , weight.x);
                                else
                                  if ((arr0x == 16))
                                    asin_c.x = asinValues[16];
  if ((arr0y == 0))
    asin_c.y = lerp(asinValues[0] , asinValues[1] , weight.y);
  else
    if ((arr0y == 1))
      asin_c.y = lerp(asinValues[1] , asinValues[2] , weight.y);
    else
      if ((arr0y == 2))
        asin_c.y = lerp(asinValues[2] , asinValues[3] , weight.y);
      else
        if ((arr0y == 3))
          asin_c.y = lerp(asinValues[3] , asinValues[4] , weight.y);
        else
          if ((arr0y == 4))
            asin_c.y = lerp(asinValues[4] , asinValues[5] , weight.y);
          else
            if ((arr0y == 5))
              asin_c.y = lerp(asinValues[5] , asinValues[6] , weight.y);
            else
              if ((arr0y == 6))
                asin_c.y = lerp(asinValues[6] , asinValues[7] , weight.y);
              else
                if ((arr0y == 7))
                  asin_c.y = lerp(asinValues[7] , asinValues[8] , weight.y);
                else
                  if ((arr0y == 8))
                    asin_c.y = lerp(asinValues[8] , asinValues[9] , weight.y);
                  else
                    if ((arr0y == 9))
                      asin_c.y = lerp(asinValues[9] , asinValues[10] , weight.y);
                    else
                      if ((arr0y == 10))
                        asin_c.y = lerp(asinValues[10] , asinValues[11] , weight.y);
                      else
                        if ((arr0y == 11))
                          asin_c.y = lerp(asinValues[11] , asinValues[12] , weight.y);
                        else
                          if ((arr0y == 12))
                            asin_c.y = lerp(asinValues[12] , asinValues[13] , weight.y);
                          else
                            if ((arr0y == 13))
                              asin_c.y = lerp(asinValues[13] , asinValues[14] , weight.y);
                            else
                              if ((arr0y == 14))
                                asin_c.y = lerp(asinValues[14] , asinValues[15] , weight.y);
                              else
                                if ((arr0y == 15))
                                  asin_c.y = lerp(asinValues[15] , asinValues[16] , weight.y);
                                else
                                  if ((arr0y == 16))
                                    asin_c.y = asinValues[16];
  gl_FragColor = vec4((0.5 - (asin_c / M_PI)) , 0.0 , 1.0);
}


==============================
65.78947368421053
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 1.0, 1.0, 1.0);

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.23376623376623
Mutations attempted: 77
Valid mutations:     51
Success rate:        66.23%
Processing this: /home/oof/webgl_cleaned/reflect_float_frag_ivarynconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (color.g + 1.0) / 2.0;
	float v2 = (color.b + 1.0) / 2.0;
	gl_FragColor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (color.g + 1.0) / 2.0;\n\tfloat v2 = (color.b + 1.0) / 2.0;\n\tgl_FragColor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((color.g + 1.0) / 2.0);
  float v2 = ((color.b + 1.0) / 2.0);
  gl_FragColor = vec4((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
66.66666666666666
Processing this: /home/oof/webgl_cleaned/const_mat2_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	mat2 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 8.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = b[0][1] + b[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = b[1][0] + b[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tmat2 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((main() < (10.0 - 0.1)) || (x > (10.0 + -0.1))))
    gtf_Vertex = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:29: '<' : operation with void operands
ERROR: 0:29: '<' : wrong operand types - no operation '<' exists that takes a left-hand operand of type 'void' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:30: 'assign' : cannot convert from 'const bool' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((main() < (10.0 - 0.1)) || (x > (10.0 + -0.1))))
    gtf_Vertex = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
65.82278481012658
Processing this: /home/oof/webgl_cleaned/max_float_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = gtf_Color.r;
	if(c < max_c) c = max_c;
	color = vec4(c, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = gtf_Color.r;\n\tif(c < max_c) c = max_c;\n\tcolor = vec4(c, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-1.0, 1.0, 2.0, (2.0 / (-1.0 - -1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = gtf_Color.r;
  if ((c < max_c))
    c = max_c;
  color = vec4(c , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.25
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
66.25
Processing this: /home/oof/webgl_cleaned/exp2_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((!true ? -1.0 : 0.0), 2.0, ((0.5 / 1.0) * 0.0), (((false ? true : false) && true) ? 2.0 : 0.0), (0.0 * 0.5), (false ? 0.5 : ((false ? 0.5 : 2.0) - 1.0)), -(0.0 + (2.0 + 1.0)), ((false ? 0.5 : +2.0) + 0.5), -1.0, 2.0, ++(0.0 / -1.0), 0.0, (1.0 + 0.0), +((true ? -1.0 : 2.0) + -1.0), 2.0, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((!true ? -1.0 : 0.0), 2.0, ((0.5 / 1.0) * 0.0), (((false ? true : false) && true) ? 2.0 : 0.0), (0.0 * 0.5), (false ? 0.5 : ((false ? 0.5 : 2.0) - 1.0)), -(0.0 + (2.0 + 1.0)), ((false ? 0.5 : +2.0) + 0.5), -1.0, 2.0, ++(0.0 / -1.0), 0.0, (1.0 + 0.0), +((true ? -1.0 : 2.0) + -1.0), 2.0, -1.0);

vec4 color;

void main()
{
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
65.4320987654321
Processing this: /home/oof/webgl_cleaned/length_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(length(color.rgb) / 3.0), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(length(color.rgb) / 3.0), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, -1.0, -0.5, 0.0);

void main()
{
  gl_FragColor = vec4(vec3((length(color.rgb) / 3.0)) , 1.0);
}


As vertex? : False
SUCCESS!
65.85365853658537
Processing this: /home/oof/webgl_cleaned/ivec4_empty_empty_ivec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
ivec4 function(ivec4 par);
bool is_all(const in ivec4 par, const in int value);
void set_all(out ivec4 par, const in int value);
void main ()
{
	ivec4 par = ivec4(1, 1, 1, 1);
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
ivec4 function(ivec4 par)
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return ivec4(1, 1, 1, 1);
	}
	else
		return ivec4(0, 0, 0, 0);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 par, const in int value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nivec4 function(ivec4 par);\nbool is_all(const in ivec4 par, const in int value);\nvoid set_all(out ivec4 par, const in int value);\nvoid main ()\n{\n\tivec4 par = ivec4(1, 1, 1, 1);\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nivec4 function(ivec4 par)\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn ivec4(1, 1, 1, 1);\n\t}\n\telse\n\t\treturn ivec4(0, 0, 0, 0);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 par, const in int value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
65.85365853658537
Processing this: /home/oof/webgl_cleaned/sqrt_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = sqrt(100.0 * gtf_Color.r);
	color = vec4(c * c / 100.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = sqrt(100.0 * gtf_Color.r);\n\tcolor = vec4(c * c / 100.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 1.0, (((false || false) || true) ? 2.0 : 2.0), (true ? 0.0 : (true ? (2.0 + -1.0) : -0.5)));

void main()
{
  float c = sqrt((100.0 * gtf_Color.r));
  color = vec4(((c * c) / 100.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
66.26506024096386
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	vec2 c = gtf_Color.rg;
	color = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(exp(3.0 * c) / exp3, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, (0.5 * 0.0), 2.0, (true ? 0.5 : (-1.0 + (1.0 / 1.0))), -2.0, -1.0, 0.0, -0.5, (+0.5 * 0.0), (1.0 - -1.0), -2.0, 2.0, ((false || false) ? -1.0 : -1.0), +1.0, +-1.0, (1.0 - 0.0));

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, (0.5 * 0.0), 2.0, (true ? 0.5 : (-1.0 + (1.0 / 1.0))), -2.0, -1.0, 0.0, -0.5, (+0.5 * 0.0), (1.0 - -1.0), -2.0, 2.0, ((false || false) ? -1.0 : -1.0), +1.0, +-1.0, (1.0 - 0.0));

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((exp((3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
65.47619047619048
Processing this: /home/oof/webgl_cleaned/structnest_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct nestb
{
	mat2 b;
};
struct nesta
{
	mat2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );
	gl_FragColor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct nestb\n{\n\tmat2 b;\n};\nstruct nesta\n{\n\tmat2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );\n\tgl_FragColor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nestb {
  mat2 b;
};

struct nesta {
  mat2 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat2(11 , 13 , 29 , 33) , nestb(mat2(12 , 19 , 79 , 81))));
  gl_FragColor = vec4(vec3(((((((((s.nest_a.a[0][0] + s.nest_a.a[0][1]) + s.nest_a.a[1][0]) + s.nest_a.a[1][1]) + s.nest_a.nest_b.b[0][0]) + s.nest_a.nest_b.b[0][1]) + s.nest_a.nest_b.b[1][0]) + s.nest_a.nest_b.b[1][1]) / 277.0)) , 1.0);
}


As vertex? : False
SUCCESS!
65.88235294117646
Mutations attempted: 85
Valid mutations:     56
Success rate:        65.88%
Processing this: /home/oof/webgl_cleaned/Low_Level_Assembly_Reserved_Words_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform float MIN;
uniform float R0;
uniform float FOGC;
uniform float CUBE;
uniform float f;
uniform float o;
uniform float p;
uniform float w;
uniform float x;
uniform float y;
uniform float z;
void main()
{
	gl_FragColor = vec4(f, o, p, w);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform float MIN;\nuniform float R0;\nuniform float FOGC;\nuniform float CUBE;\nuniform float f;\nuniform float o;\nuniform float p;\nuniform float w;\nuniform float x;\nuniform float y;\nuniform float z;\nvoid main()\n{\n\tgl_FragColor = vec4(f, o, p, w);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w = 2.0;

uniform float x;

uniform float y;

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:18: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float MIN;

uniform float R0;

uniform float FOGC;

uniform float CUBE;

uniform float f;

uniform float o;

uniform float p;

uniform float w = 2.0;

uniform float x;

uniform float y;

uniform float z;

void main()
{
  gl_FragColor = vec4(f , o , p , w);
}


==============================
65.11627906976744
Processing this: /home/oof/webgl_cleaned/clamp_float_frag_xvary_yconstquarter_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = color.r;
	if(c > max_c) c = max_c;
	if(c < min_c) c = min_c;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = color.r;\n\tif(c > max_c) c = max_c;\n\tif(c < min_c) c = min_c;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = color.r;
  if ((c > max_c))
    c = max_c;
  if ((c < min_c))
    c = min_c;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
65.51724137931035
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x = (gtf_Color.r + 0.01) / 1.01;
	float y = 0.0;
	float z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	color = vec4(y / -4.61, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = (gtf_Color.r + 0.01) / 1.01;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tcolor = vec4(y / -4.61, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, 0.0, ((+1.0 + 1.0) * (2.0 / (false ? 0.5 : 0.5))), (2.0 + 0.5));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x = ((gtf_Color.r + 0.01) / 1.01);
  float y = 0.0;
  float z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  color = vec4((y / -4.61) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
65.9090909090909
Processing this: /home/oof/webgl_cleaned/lessThanEqual_ivec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec2 lte(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lte(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec2 lte(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lte(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec2 lte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


==============================
65.1685393258427
Processing this: /home/oof/webgl_cleaned/pow_float_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 16.0 * color.r;
	gl_FragColor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 16.0 * color.r;\n\tgl_FragColor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((-1.0 - 0.5) - 1.0), 1.0, --(true ? 1.0 : 2.0), 0.5);

void main()
{
  float c = (16.0 * color.r);
  gl_FragColor = vec4((sqrt(c) / 4.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((-1.0 - 0.5) - 1.0), 1.0, --(true ? 1.0 : 2.0), 0.5);

void main()
{
  float c = (16.0 * color.r);
  gl_FragColor = vec4((sqrt(c) / 4.0) , 0.0 , 0.0 , 1.0);
}


==============================
64.44444444444444
Processing this: /home/oof/webgl_cleaned/exp2_float_vert_xvaryneg_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = gtf_Color.r;
	color = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((true ? false : false) ? !true : false) ? 0.5 : 0.5), +0.0, (((false ? true : false) ? (true ? 0.5 : 2.0) : -1.0) + 2.0), -1.0, (0.0 - (-1.0 + 0.5)), 1.0, 1.0, (+0.0 - -0.0), 0.0, ((true ? 0.0 : 1.0) + 2.0), (1.0 - 1.0), 1.0, 1.0, (0.5 / -1.0), (false ? +0.5 : 0.0), (true ? ((true ? false : true) ? (1.0 + -1.0) : 0.5) : ((true ? true : false) ? -0.0 : (true ? 0.5 : -1.0))));

vec4 color;

void main()
{
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(2.0 , (5.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((true ? false : false) ? !true : false) ? 0.5 : 0.5), +0.0, (((false ? true : false) ? (true ? 0.5 : 2.0) : -1.0) + 2.0), -1.0, (0.0 - (-1.0 + 0.5)), 1.0, 1.0, (+0.0 - -0.0), 0.0, ((true ? 0.0 : 1.0) + 2.0), (1.0 - 1.0), 1.0, 1.0, (0.5 / -1.0), (false ? +0.5 : 0.0), (true ? ((true ? false : true) ? (1.0 + -1.0) : 0.5) : ((true ? true : false) ? -0.0 : (true ? 0.5 : -1.0))));

vec4 color;

void main()
{
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(2.0 , (5.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.73626373626373
Processing this: /home/oof/webgl_cleaned/sign_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 2.0 * (color.rgb - 0.5);
	if(c[0] > 0.0) c[0] = 1.0 * c[0];
	if(c[0] < 0.0) c[0] = -1.0 * c[0];
	if(c[1] > 0.0) c[1] = 1.0 * c[1];
	if(c[1] < 0.0) c[1] = -1.0 * c[1];
	if(c[2] > 0.0) c[2] = 1.0 * c[2];
	if(c[2] < 0.0) c[2] = -1.0 * c[2];
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tif(c[0] > 0.0) c[0] = 1.0 * c[0];\n\tif(c[0] < 0.0) c[0] = -1.0 * c[0];\n\tif(c[1] > 0.0) c[1] = 1.0 * c[1];\n\tif(c[1] < 0.0) c[1] = -1.0 * c[1];\n\tif(c[2] > 0.0) c[2] = 1.0 * c[2];\n\tif(c[2] < 0.0) c[2] = -1.0 * c[2];\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.5, 0.5, 0.5);

void main()
{
  vec3 c = (2.0 * (color.rgb - 0.5));
  if ((c[0] > 0.0))
    c[0] = (1.0 * c[0]);
  if ((c[0] < 0.0))
    c[0] = (-1.0 * c[0]);
  if ((c[1] > 0.0))
    c[1] = (1.0 * c[1]);
  if ((c[1] < 0.0))
    c[1] = (-1.0 * c[1]);
  if ((c[2] > 0.0))
    c[2] = (1.0 * c[2]);
  if ((c[2] < 0.0))
    c[2] = (-1.0 * c[2]);
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
SUCCESS!
64.13043478260869
Processing this: /home/oof/webgl_cleaned/structUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 a_vertex;
attribute vec3 a_normal;
uniform mat4 u_modelViewProjMatrix;
struct MyStruct
{
  int x;
  int y;
};
uniform MyStruct u_struct;
uniform float u_array[4];
varying vec3 v_normal;
void main()
{
    v_normal = a_normal;
    gl_Position = u_modelViewProjMatrix * a_vertex +
        vec4(u_struct.x, u_struct.y, 0, 1) +
        vec4(u_array[0], u_array[1], u_array[2], u_array[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 a_vertex;\nattribute vec3 a_normal;\nuniform mat4 u_modelViewProjMatrix;\nstruct MyStruct\n{\n  int x;\n  int y;\n};\nuniform MyStruct u_struct;\nuniform float u_array[4];\nvarying vec3 v_normal;\nvoid main()\n{\n    v_normal = a_normal;\n    gl_Position = u_modelViewProjMatrix * a_vertex +\n        vec4(u_struct.x, u_struct.y, 0, 1) +\n        vec4(u_array[0], u_array[1], u_array[2], u_array[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 a_vertex;

vec3 a_normal;

uniform mat4 u_modelViewProjMatrix;

struct MyStruct {
  int x;
  int y;
};

uniform MyStruct u_struct;

uniform float u_array[4];

vec3 v_normal;

void main()
{
  v_normal = a_normal;
  gl_Position = (((u_modelViewProjMatrix * a_vertex) + vec4(u_struct.x , u_struct.y , 0 , 1)) + vec4(u_array[0] , u_array[1] , u_array[2] , u_array[3]));
}


As vertex? : True
SUCCESS!
64.51612903225806
Processing this: /home/oof/webgl_cleaned/abs_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (color.rg - 0.5);
	if((c[0] < 0.0)) c[0] *= -1.0;
	if((c[1] < 0.0)) c[1] *= -1.0;
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (color.rg - 0.5);\n\tif((c[0] < 0.0)) c[0] *= -1.0;\n\tif((c[1] < 0.0)) c[1] *= -1.0;\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(--(-1.0 - -1.0), 0.5, 0.0, 0.0);

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(--(-1.0 - -1.0), 0.5, 0.0, 0.0);

void main()
{
  vec2 c = (2.0 * (color.rg - 0.5));
  if ((c[0] < 0.0))
    (c[0] *= -1.0);
  if ((c[1] < 0.0))
    (c[1] *= -1.0);
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


==============================
63.829787234042556
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.829787234042556
Mutations attempted: 94
Valid mutations:     60
Success rate:        63.83%
Processing this: /home/oof/webgl_cleaned/cos_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * gtf_Color.rgb;
	float sign = -1.0;
	vec3 cos_c = vec3(1.0,1.0,1.0);
	float fact = 1.0;
	for(int i = 2; i <= 20; i += 2)
	{
		fact *= float(i)*float(i-1);
		cos_c += sign*pow(c, vec3(float(i),float(i),float(i)))/fact;
		sign = -sign;
	}
	color = vec4(0.5 * cos_c + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * gtf_Color.rgb;\n\tfloat sign = -1.0;\n\tvec3 cos_c = vec3(1.0,1.0,1.0);\n\tfloat fact = 1.0;\n\tfor(int i = 2; i <= 20; i += 2)\n\t{\n\t\tfact *= float(i)*float(i-1);\n\t\tcos_c += sign*pow(c, vec3(float(i),float(i),float(i)))/fact;\n\t\tsign = -sign;\n\t}\n\tcolor = vec4(0.5 * cos_c + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * gtf_Color.rgb);
  float sign = -1.0;
  vec3 cos_c = vec3(1.0 , 1.0 , 1.0);
  float fact = 1.0;
  for (int i = 2; (i <= 20); (i += 2))
  {
    (fact *= (float(i) * float((i - 1))));
    (cos_c += ((sign * pow(c , vec3(float(i) , float(i) , float(i)))) / fact));
    sign = -sign;
  }
  color = vec4(((0.5 * cos_c) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.21052631578948
Processing this: /home/oof/webgl_cleaned/fboShader0.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
varying vec4 texCoord[1];
varying vec4 color;
uniform mat4 gtf_ModelViewProjectionMatrix;
void main ()
{
    color = gtf_Color;
    texCoord[0] = gtf_MultiTexCoord0;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 texCoord[1];\nvarying vec4 color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid main ()\n{\n    color = gtf_Color;\n    texCoord[0] = gtf_MultiTexCoord0;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1] = vec4[1](vec4(2.0, 1.0, -0.5, -0.5));

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '[]' : array constructor supported in GLSL ES 3.00 and above only
ERROR: 0:10: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:10: '=' : Invalid operation for arrays
ERROR: 0:10: '=' : cannot convert from 'const array[1] of 4-component vector of float' to 'mediump array[1] of 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1] = vec4[1](vec4(2.0, 1.0, -0.5, -0.5));

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.541666666666664
Processing this: /home/oof/webgl_cleaned/vec4_tsqp_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.tsqp;
	vec4 a = vec4(m.t, m.s, m.q, m.p);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.tsqp;\n\tvec4 a = vec4(m.t, m.s, m.q, m.p);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!false ? 0.5 : --1.0), 0.0, -1.0, 0.5);

void main()
{
  vec4 al = color;
  vec4 m = al.tsqp;
  vec4 a = vec4(m.t , m.s , m.q , m.p);
  gl_FragColor = a;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4((!false ? 0.5 : --1.0), 0.0, -1.0, 0.5);

void main()
{
  vec4 al = color;
  vec4 m = al.tsqp;
  vec4 a = vec4(m.t , m.s , m.q , m.p);
  gl_FragColor = a;
}


==============================
62.88659793814433
Processing this: /home/oof/webgl_cleaned/sin_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((true ? -1.0 : 0.0) + (0.0 + 0.0)) / (1.0 * (1.0 / 0.0))), 0.5, 0.5, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.26530612244898
Processing this: /home/oof/webgl_cleaned/step_float_frag_xvary_edgeconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float edge = 0.5;
	float c = color.r;
	if(c >= edge) c = 1.0;
	else c = 0.0;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float edge = 0.5;\n\tfloat c = color.r;\n\tif(c >= edge) c = 1.0;\n\telse c = 0.0;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((!(true && true) ? 1.0 : (!false ? (true ? 2.0 : 0.5) : 0.5)), (((false && true) ? false : (false && false)) ? ((false ? false : true) ? 0.0 : 0.5) : (true ? 2.0 : 0.0)), -((false && true) ? (0.5 * 1.0) : 0.5), -1.0);

void main()
{
  const float edge = 0.5;
  float c = color.r;
  if ((c >= edge))
    c = 1.0;
  else
    c = 0.0;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(greaterThanEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(greaterThanEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(greaterThanEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0);
}


==============================
63.0
Processing this: /home/oof/webgl_cleaned/bool_empty_inout_bool_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(inout bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(!par && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(inout bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(inout bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(!par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(inout bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
63.0
Processing this: /home/oof/webgl_cleaned/degrees_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +-1.0, (0.5 / -(0.0 * 1.0)), 1.0, -0.5, (false ? -1.0 : 1.0), 2.0, +0.0, 0.5, 0.5, 0.5, 0.5, 2.0, 1.0, 0.5, 2.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, +-1.0, (0.5 / -(0.0 * 1.0)), 1.0, -0.5, (false ? -1.0 : 1.0), 2.0, +0.0, 0.5, 0.5, 0.5, 0.5, 2.0, 1.0, 0.5, 2.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.37623762376238
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg * 99.0) + 1.0;
	gl_FragColor = vec4(inversesqrt(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg * 99.0) + 1.0;\n\tgl_FragColor = vec4(inversesqrt(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = ((color.rg * 99.0) + 2.0);
  gl_FragColor = vec4(inversesqrt(c) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.745098039215684
Processing this: /home/oof/webgl_cleaned/gl_FrontFacing_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
	if(gl_FrontFacing)
		gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);
	else
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n\tif(gl_FrontFacing)\n\t\tgl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n\telse\n\t\tgl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  if (gl_FrontFacing)
    gl_FragColor = vec4(0.0 , 1.0 , 0.0);
  else
    (-(false ? -1.0 : 2.0) / +0.5) = vec4(1.0 , 0.0 , 0.0);
  vec4(((false && (false ? true : false)) ? (0.5 + (0.0 + -1.0)) : 1.0), -1.0, 0.0, -1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:7: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'assign' : l-value required (can't modify a const)
ERROR: 0:9: '=' : dimension mismatch
ERROR: 0:9: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  if (gl_FrontFacing)
    gl_FragColor = vec4(0.0 , 1.0 , 0.0);
  else
    (-(false ? -1.0 : 2.0) / +0.5) = vec4(1.0 , 0.0 , 0.0);
  vec4(((false && (false ? true : false)) ? (0.5 + (0.0 + -1.0)) : 1.0), -1.0, 0.0, -1.0);
}


==============================
62.13592233009708
Mutations attempted: 103
Valid mutations:     64
Success rate:        62.14%
Processing this: /home/oof/webgl_cleaned/exp_vec3_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	vec3 c = color.rgb;
	gl_FragColor = vec4(1.0 / pow(vec3(exp1), 3.0 * c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(1.0 / pow(vec3(exp1), 3.0 * c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  vec3 c = color.rgb;
  ((false ? 0.0 : 2.0) * +1.0) = vec4((1.0 / pow(vec3(exp1) , (3.0 * c))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction
ERROR: 0:10: 'assign' : l-value required (can't modify a const)
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: 'assign' : cannot convert from 'const 4-component vector of float' to 'const float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  vec3 c = color.rgb;
  ((false ? 0.0 : 2.0) * +1.0) = vec4((1.0 / pow(vec3(exp1) , (3.0 * c))));
}


==============================
61.53846153846154
Processing this: /home/oof/webgl_cleaned/fragmentOnly3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    gl_FragColor = vec4(1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    gl_FragColor = vec4(1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1.0);
}


As vertex? : True
SUCCESS!
61.904761904761905
Processing this: /home/oof/webgl_cleaned/tan_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	float o;
	if(abs(c) < 0.5)
		o = 0.5 * tan(c) + 0.5;
	else
		o = 0.5 / tan(c) + 0.5;
	color = vec4(o, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 0.5 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tfloat o;\n\tif(abs(c) < 0.5)\n\t\to = 0.5 * tan(c) + 0.5;\n\telse\n\t\to = 0.5 / tan(c) + 0.5;\n\tcolor = vec4(o, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(2.0, ((true ? (true && false) : (false ? true : true)) ? ((false && true) ? (false ? -1.0 : 2.0) : -0.0) : 2.0), 0.0, 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((0.5 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  float o;
  if ((abs(c) < 0.5))
    o = ((0.5 * tan(c)) + 0.5);
  else
    o = ((0.5 / tan(c)) + 0.5);
  color = vec4(o , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.264150943396224
Processing this: /home/oof/webgl_cleaned/array_const_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
		             5.0,  6.0,  7.0,  8.0,
			     9.0, 10.0, 11.0, 12.0,
			    13.0, 14.0, 15.0, 16.0);
	const mat4 b = mat4(17.0, 18.0, 19.0, 20.0,
		            21.0, 22.0, 23.0, 24.0,
			    25.0, 26.0, 27.0, 28.0,
			    29.0, 30.0, 31.0, 32.0);
	mat4 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t\t             5.0,  6.0,  7.0,  8.0,\n\t\t\t     9.0, 10.0, 11.0, 12.0,\n\t\t\t    13.0, 14.0, 15.0, 16.0);\n\tconst mat4 b = mat4(17.0, 18.0, 19.0, 20.0,\n\t\t            21.0, 22.0, 23.0, 24.0,\n\t\t\t    25.0, 26.0, 27.0, 28.0,\n\t\t\t    29.0, 30.0, 31.0, 32.0);\n\tmat4 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.616822429906534
Processing this: /home/oof/webgl_cleaned/4b_firstthree_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform bvec4 color;
void main ()
{
	gl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform bvec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (float(color[0]), float(color[1]), float(color[2]), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bvec4 color = bvec4((0.5 - (false ? (false ? -1.0 : 2.0) : -1.0)), (!true ? 1.0 : -1.0), (false ? -1.0 : 0.5), 2.0);

void main()
{
  gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bvec4 color = bvec4((0.5 - (false ? (false ? -1.0 : 2.0) : -1.0)), (!true ? 1.0 : -1.0), (false ? -1.0 : 0.5), 2.0);

void main()
{
  gl_FragColor = vec4(float(color[0]) , float(color[1]) , float(color[2]) , 1.0);
}


==============================
62.03703703703704
Processing this: /home/oof/webgl_cleaned/vec4_empty_empty_vec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(vec4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(vec4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
62.03703703703704
Processing this: /home/oof/webgl_cleaned/mat2_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	mat2 m = mat2(0.5);
	vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
	vec4 result = vec4(1.0, 1.0, 1.0, 1.0);
	if((m[0][0] != 0.5))
		result = black;
	if((m[0][1] != 0.0))
		result = black;
	if((m[1][0] != 0.0))
		result = black;
	if((m[1][1] != 0.5))
		result = black;
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tmat2 m = mat2(0.5);\n\tvec4 black = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec4 result = vec4(1.0, 1.0, 1.0, 1.0);\n\tif((m[0][0] != 0.5))\n\t\tresult = black;\n\tif((m[0][1] != 0.0))\n\t\tresult = black;\n\tif((m[1][0] != 0.0))\n\t\tresult = black;\n\tif((m[1][1] != 0.5))\n\t\tresult = black;\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.0, 0.0, -1.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  mat2 m = mat2(0.5);
  vec4 black = vec4(0.0 , 0.0 , 0.0 , 1.0);
  vec4 result = vec4(1.0 , 1.0 , 1.0 , 1.0);
  if ((m[0][0] != 0.5))
    result = black;
  if ((m[0][1] != 0.0))
    result = black;
  if ((m[1][0] != 0.0))
    result = black;
  if ((m[1][1] != 0.5))
    result = black;
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.38532110091744
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par)
{
	par = 0;
	return 1;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par)\n{\n\tpar = 0;\n\treturn 1;\n}\n\x00')
62.38532110091744
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.81818181818181
Processing this: /home/oof/webgl_cleaned/faceforward_float_vert_nvaryiconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g * 2.0) - 1.0;
	float v2 = (gtf_Color.b * 2.0) - 1.0;
	if(dot(v1, v2) >= 0.0) v1 *= -1.0;
	color = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g * 2.0) - 1.0;\n\tfloat v2 = (gtf_Color.b * 2.0) - 1.0;\n\tif(dot(v1, v2) >= 0.0) v1 *= -1.0;\n\tcolor = vec4((v1 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g * 2.0) - 1.0);
  float v2 = ((gtf_Color.b * 2.0) - 1.0);
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  color = vec4(((v1 + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'color' : undeclared identifier
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g * 2.0) - 1.0);
  float v2 = ((gtf_Color.b * 2.0) - 1.0);
  if ((dot(v1 , v2) >= 0.0))
    (v1 *= -1.0);
  color = vec4(((v1 + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.261261261261254
Mutations attempted: 111
Valid mutations:     68
Success rate:        61.26%
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	vec3 c = clamp((gtf_Color.rgb - edge0) / (edge1 - edge0), 0.0, 1.0);
	color = vec4(c * c * (3.0 - 2.0 * c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tvec3 c = clamp((gtf_Color.rgb - edge0) / (edge1 - edge0), 0.0, 1.0);\n\tcolor = vec4(c * c * (3.0 - 2.0 * c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, 0.5, -0.5, 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  vec3 c = clamp(((gtf_Color.rgb - edge0) / (edge1 - edge0)) , 0.0 , 1.0);
  color = vec4(((c * c) * (3.0 - (2.0 * c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.60714285714286
Processing this: /home/oof/webgl_cleaned/vec4_gr_ab_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.gr;
	vec2 n = lightloc.ab;
	vec4 a = vec4(m.g, m.r, n.g, n.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.gr;\n\tvec2 n = lightloc.ab;\n\tvec4 a = vec4(m.g, m.r, n.g, n.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, --1.0, +(false ? (true ? 2.0 : 0.5) : 0.5), 2.0, 1.0, 0.0, +((0.0 / 1.0) / (-1.0 / 1.0)), 0.0, 1.0, 2.0, 1.0, 0.5, 2.0, 0.5, (2.0 + 1.0), 0.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.gr;
  vec2 n = lightloc.ab;
  vec4 a = vec4(m.g , m.r , n.g , n.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, --1.0, +(false ? (true ? 2.0 : 0.5) : 0.5), 2.0, 1.0, 0.0, +((0.0 / 1.0) / (-1.0 / 1.0)), 0.0, 1.0, 2.0, 1.0, 0.5, 2.0, 0.5, (2.0 + 1.0), 0.0);

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.gr;
  vec2 n = lightloc.ab;
  vec4 a = vec4(m.g , m.r , n.g , n.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
61.06194690265486
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
61.06194690265486
Processing this: /home/oof/webgl_cleaned/max_float_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float max_c = 0.5;
	float c = color.r;
	if(c < max_c) c = max_c;
	gl_FragColor = vec4(c, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float max_c = 0.5;\n\tfloat c = color.r;\n\tif(c < max_c) c = max_c;\n\tgl_FragColor = vec4(c, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float max_c = 0.5;
  float c = color.r;
  if ((c < max_c))
    c = max_c;
  gl_FragColor = vec4(c , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.40350877192983
Processing this: /home/oof/webgl_cleaned/matrix2arrayVSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --1.0, (true ? +1.0 : ((2.0 / 0.5) * (2.0 + 1.0))), (2.0 * 0.0));

void main()
{
  gl_FragColor = color;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --1.0, (true ? +1.0 : ((2.0 / 0.5) * (2.0 + 1.0))), (2.0 * 0.0));

void main()
{
  gl_FragColor = color;
}


==============================
60.86956521739131
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-(true ? 1.0 : (1.0 * -1.0)), (-1.0 / +(-1.0 + 2.0)), -1.0, +1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.206896551724135
Processing this: /home/oof/webgl_cleaned/const_mat4_copy_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	mat4 b = a;
	bool elms = true;
	if(b[0][0] !=  1.0) elms = false;
	if(b[0][1] !=  2.0) elms = false;
	if(b[0][2] !=  3.0) elms = false;
	if(b[0][3] !=  4.0) elms = false;
	if(b[1][0] !=  5.0) elms = false;
	if(b[1][1] !=  6.0) elms = false;
	if(b[1][2] !=  7.0) elms = false;
	if(b[1][3] !=  8.0) elms = false;
	if(b[2][0] !=  9.0) elms = false;
	if(b[2][1] != 10.0) elms = false;
	if(b[2][2] != 11.0) elms = false;
	if(b[2][3] != 12.0) elms = false;
	if(b[3][0] != 13.0) elms = false;
	if(b[3][1] != 14.0) elms = false;
	if(b[3][2] != 15.0) elms = false;
	if(b[3][3] != 16.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0] + b[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = b[0][1] + b[1][1] + b[2][1] + b[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = b[0][2] + b[1][2] + b[2][2] + b[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = b[0][3] + b[1][3] + b[2][3] + b[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2] + b[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = b[1][0] + b[1][1] + b[1][2] + b[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2] + b[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = b[3][0] + b[3][1] + b[3][2] + b[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tmat4 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=  1.0) elms = false;\n\tif(b[0][1] !=  2.0) elms = false;\n\tif(b[0][2] !=  3.0) elms = false;\n\tif(b[0][3] !=  4.0) elms = false;\n\tif(b[1][0] !=  5.0) elms = false;\n\tif(b[1][1] !=  6.0) elms = false;\n\tif(b[1][2] !=  7.0) elms = false;\n\tif(b[1][3] !=  8.0) elms = false;\n\tif(b[2][0] !=  9.0) elms = false;\n\tif(b[2][1] != 10.0) elms = false;\n\tif(b[2][2] != 11.0) elms = false;\n\tif(b[2][3] != 12.0) elms = false;\n\tif(b[3][0] != 13.0) elms = false;\n\tif(b[3][1] != 14.0) elms = false;\n\tif(b[3][2] != 15.0) elms = false;\n\tif(b[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0] + b[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1] + b[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2] + b[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = b[0][3] + b[1][3] + b[2][3] + b[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2] + b[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2] + b[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2] + b[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = b[3][0] + b[3][1] + b[3][2] + b[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 3.0))
    elms = false;
  if ((b[0][3] != 4.0))
    elms = false;
  if ((b[1][0] != 5.0))
    elms = false;
  if ((b[1][1] != 6.0))
    elms = false;
  if ((b[1][2] != 7.0))
    elms = false;
  if ((b[1][3] != 8.0))
    elms = false;
  if ((b[2][0] != 9.0))
    elms = false;
  if ((b[2][1] != 10.0))
    elms = false;
  if ((b[2][2] != 11.0))
    elms = false;
  if ((b[2][3] != 12.0))
    elms = false;
  if ((b[3][0] != 13.0))
    elms = false;
  if ((b[3][1] != 14.0))
    elms = false;
  if ((b[3][2] != 15.0))
    elms = false;
  if ((b[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((b[0][0] + b[0][1]) + b[0][2]) + b[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
61.53846153846154
Processing this: /home/oof/webgl_cleaned/log_vec3_frag_xvary01_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 x = (color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	gl_FragColor = vec4(y / -4.61, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 x = (color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tgl_FragColor = vec4(y / -4.61, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 x = ((color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  gl_FragColor = vec4((y / -4.61) , 1.0);
}


As vertex? : False
SUCCESS!
61.86440677966102
Processing this: /home/oof/webgl_cleaned/degrees_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.18487394957983
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 x = 31.0 * gtf_Color.rg + 1.0;
	vec2 y = vec2(0.0);
	vec2 z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	vec2 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	color = vec4(y / 3.466, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 x = 31.0 * gtf_Color.rg + 1.0;\n\tvec2 y = vec2(0.0);\n\tvec2 z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tvec2 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tcolor = vec4(y / 3.466, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.5, 2.0, 2.0, ((true ? !true : (false ? false : true)) ? -2.0 : +(0.0 / 0.0)));

void main()
{
  vec2 x = ((31.0 * gtf_Color.rg) + 1.0);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.5
Mutations attempted: 120
Valid mutations:     75
Success rate:        62.50%
Processing this: /home/oof/webgl_cleaned/sqrt_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 100.0 * color.rgb;
	gl_FragColor = vec4(c / 100.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 100.0 * color.rgb;\n\tgl_FragColor = vec4(c / 100.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, -1.0, 0.0, 2.0);

void main()
{
  vec3 c = (100.0 * color.rgb);
  gl_FragColor = vec4((c / 100.0) , 1.0);
}


As vertex? : False
SUCCESS!
62.8099173553719
Processing this: /home/oof/webgl_cleaned/normalize_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = color + vec4(0.25);
	gl_FragColor = vec4(tmp_Color.rg / length(tmp_Color.rg), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = color + vec4(0.25);\n\tgl_FragColor = vec4(tmp_Color.rg / length(tmp_Color.rg), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? 2.0 : (-1.0 * (false ? -1.0 : 2.0))), 0.5, 1.0, 1.0);

void main()
{
  vec4 tmp_Color = (color + vec4(0.25));
  gl_FragColor = vec4((tmp_Color.rg / length(tmp_Color.rg)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.114754098360656
Processing this: /home/oof/webgl_cleaned/greaterThan_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 gt(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] > b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(gt(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 gt(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] > b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(gt(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((0.0 * -1.0), 1.0, (0.5 * ((true || false) ? (1.0 / 0.0) : 0.0)), (1.0 * 1.0));

bvec3 gt(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] > b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] > b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(gt(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.41463414634146
Processing this: /home/oof/webgl_cleaned/gl_MaxVertexUniformVectors_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(float(gl_MaxVertexUniformVectors) / 128.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(gl_MaxVertexUniformVectors) / 128.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((+0.5 * 0.5), (2.0 * (+0.0 - (false ? 0.5 : 0.5))), (true ? -1.0 : +(false ? 2.0 : 0.5)), 2.0);

void main()
{
  color = vec4((float(gl_MaxVertexUniformVectors) / 128.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.70967741935484
Processing this: /home/oof/webgl_cleaned/tan_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);
	vec2 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * tan(c.r) + 0.5;
	else
		o.r = 0.5 / tan(c.r) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * tan(c.g) + 0.5;
	else
		o.g = 0.5 / tan(c.g) + 0.5;
	gl_FragColor = vec4(o, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 0.5 * M_PI * 2.0 * (color.rg - 0.5);\n\tvec2 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * tan(c.r) + 0.5;\n\telse\n\t\to.r = 0.5 / tan(c.r) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * tan(c.g) + 0.5;\n\telse\n\t\to.g = 0.5 / tan(c.g) + 0.5;\n\tgl_FragColor = vec4(o, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((0.5 * M_PI) * 2.0) * (color.rg - 0.5));
  vec2 o = vec2(2.0, 2.0);
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * tan(c.r)) + 0.5);
  else
    o.r = ((0.5 / tan(c.r)) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * tan(c.g)) + 0.5);
  else
    o.g = ((0.5 / tan(c.g)) + 0.5);
  gl_FragColor = vec4(o , 0.0 , 1.0);
  ivec2((-3 - ((false || true) ? 6 : (3 / 6))), (true ? (false ? 3 : 7) : +6));
}


As vertex? : False
SUCCESS!
64.0
Processing this: /home/oof/webgl_cleaned/exp_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp3 = 20.0855;
	vec3 c = color.rgb;
	gl_FragColor = vec4(exp(3.0 * c) / exp3, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp3 = 20.0855;\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(exp(3.0 * c) / exp3, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp3 = 20.0855;
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp((3.0 * c)) / exp3));
}


==============================
63.49206349206349
Processing this: /home/oof/webgl_cleaned/cross_vec3_frag_xvaryyconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = vec3(1.0, 0.0, 0.0);
	vec3 v3;
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	v3.x = v1.y * v2.z - v2.y * v1.z;
	v3.y = v2.x * v1.z - v1.x * v2.z;
	v3.z = v1.x * v2.y - v2.x * v1.y;
	gl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = vec3(1.0, 0.0, 0.0);\n\tvec3 v3;\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tv3.x = v1.y * v2.z - v2.y * v1.z;\n\tv3.y = v2.x * v1.z - v1.x * v2.z;\n\tv3.z = v1.x * v2.y - v2.x * v1.y;\n\tgl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, ((1.0 - -1.0) + 1.0), 0.5, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = vec3(1.0 , 0.0 , 0.0);
  vec3 v3;
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  v3.x = ((v1.y * v2.z) - (v2.y * v1.z));
  v3.y = ((v2.x * v1.z) - (v1.x * v2.z));
  v3.z = ((v1.x * v2.y) - (v2.x * v1.y));
  gl_FragColor = vec4(((v3 + 1.0) / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
63.77952755905512
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 lte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] <= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] <= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lte(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 lte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] <= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] <= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lte(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = mat4((-2.0 - -2.0), --1.0, 2.0, 2.0, 0.0, ((true ? (false ? 0.5 : 2.0) : 2.0) + 0.0), 0.0, +(true ? -0.5 : (-1.0 / -1.0)), --1.0, ((0.5 - -2.0) / (2.0 - 0.5)), 1.0, 2.0, 0.0, 0.0, 0.5, 2.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:31: '--' : l-value required (can't modify a const)
ERROR: 0:31: '--' : l-value required (can't modify a const)
ERROR: 0:31: '=' : dimension mismatch
ERROR: 0:31: 'assign' : cannot convert from 'const 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 lte(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] <= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] <= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = mat4((-2.0 - -2.0), --1.0, 2.0, 2.0, 0.0, ((true ? (false ? 0.5 : 2.0) : 2.0) + 0.0), 0.0, +(true ? -0.5 : (-1.0 / -1.0)), --1.0, ((0.5 - -2.0) / (2.0 - 0.5)), 1.0, 2.0, 0.0, 0.0, 0.5, 2.0);
}


==============================
63.28125
Processing this: /home/oof/webgl_cleaned/vec3_zyx_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	vec3 t = m.zyx;
	vec4 a = vec4(t.z, t.y, t.x ,al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tvec3 t = m.zyx;\n\tvec4 a = vec4(t.z, t.y, t.x ,al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  vec3 t = m.zyx;
  vec4 a = vec4(t.z , t.y , t.x , al.w);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
63.565891472868216
Processing this: /home/oof/webgl_cleaned/fboShader0.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
varying vec4 texCoord[1];
varying vec4 color;
uniform mat4 gtf_ModelViewProjectionMatrix;
void main ()
{
    color = gtf_Color;
    texCoord[0] = gtf_MultiTexCoord0;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 texCoord[1];\nvarying vec4 color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid main ()\n{\n    color = gtf_Color;\n    texCoord[0] = gtf_MultiTexCoord0;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0 = vec4(-(-1.0 * 0.5), (!(true ? false : true) ? 2.0 : (true ? (false ? 0.0 : 2.0) : -1.0)), (+--1.0 * -+-1.0), -(1.0 + 0.5));

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0 = vec4(-(-1.0 * 0.5), (!(true ? false : true) ? 2.0 : (true ? (false ? 0.0 : 2.0) : -1.0)), (+--1.0 * -+-1.0), -(1.0 + 0.5));

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix;

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.07692307692307
Mutations attempted: 130
Valid mutations:     82
Success rate:        63.08%
Processing this: /home/oof/webgl_cleaned/log2_vec3_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = (gtf_Color.rgb + 0.01) / 1.01;
	color = vec4(log2(c) / -8.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (gtf_Color.rgb + 0.01) / 1.01;\n\tcolor = vec4(log2(c) / -8.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, -1.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.5, -0.5, 1.0, 1.0, -1.0, 2.0, -1.0, 2.0, 1.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log2(c) / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-0.5, -1.0, 0.0, 0.5, 0.0, -1.0, 0.0, 0.5, -0.5, 1.0, 1.0, -1.0, 2.0, -1.0, 2.0, 1.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log2(c) / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.59541984732825
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = ((!true ? (true ? true : false) : (false ? false : false)) ? vec4((-1.0 + (0.5 + (1.0 * 0.0))), 1.0, 1.0, +2.0) : gtf_Vertex);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_Vertex' : undeclared identifier
ERROR: 0:6: '?:' : mismatching ternary operator operand types 'const 4-component vector of float and 'const highp float'
ERROR: 0:6: '=' : dimension mismatch
ERROR: 0:6: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = ((!true ? (true ? true : false) : (false ? false : false)) ? vec4((-1.0 + (0.5 + (1.0 * 0.0))), 1.0, 1.0, +2.0) : gtf_Vertex);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.121212121212125
Processing this: /home/oof/webgl_cleaned/degrees_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 / 0.0), (!true ? -(false ? -1.0 : 2.0) : -1.0), +1.0, 0.0, --1.0, (((true && true) ? (0.5 / 0.5) : 1.0) / ((-1.0 * 2.0) - (false ? -1.0 : 1.0))), -2.0, 0.0, 0.5, 1.0, +0.5, (-(false ? 0.5 : -1.0) + (false ? -2.0 : (true ? 1.0 : 2.0))), (-1.0 / -1.0), 1.0, -1.0, (!(true || false) ? ((-1.0 + 1.0) * (false ? -1.0 : 0.5)) : -0.5));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 / 0.0), (!true ? -(false ? -1.0 : 2.0) : -1.0), +1.0, 0.0, --1.0, (((true && true) ? (0.5 / 0.5) : 1.0) / ((-1.0 * 2.0) - (false ? -1.0 : 1.0))), -2.0, 0.0, 0.5, 1.0, +0.5, (-(false ? 0.5 : -1.0) + (false ? -2.0 : (true ? 1.0 : 2.0))), (-1.0 / -1.0), 1.0, -1.0, (!(true || false) ? ((-1.0 + 1.0) * (false ? -1.0 : 0.5)) : -0.5));

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.65413533834586
Processing this: /home/oof/webgl_cleaned/bvec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform bool vuni1;
uniform bvec2 vuni2;
uniform bvec3 vuni3;
uniform bvec4 vuni4;
varying vec4 color;
void main ()
{
	if(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])
	color = vec4(1.0, 0.0, 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform bool vuni1;\nuniform bvec2 vuni2;\nuniform bvec3 vuni3;\nuniform bvec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tif(vuni1 || vuni2[0] && vuni2[1] && vuni3[0] && vuni3[1] && vuni3[2] || vuni4[0] && vuni4[1] && vuni4[2] && vuni4[3])\n\tcolor = vec4(1.0, 0.0, 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((true ? (0.0 - -1.0) : 1.0), (false ? -1.0 : -1.0), 2.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform bool vuni1;

uniform bvec2 vuni2;

uniform bvec3 vuni3;

uniform bvec4 vuni4;

vec4 color;

void main()
{
  if (((vuni1 || ((((vuni2[0] && vuni2[1]) && vuni3[0]) && vuni3[1]) && vuni3[2])) || (((vuni4[0] && vuni4[1]) && vuni4[2]) && vuni4[3])))
    color = vec4(1.0 , 0.0 , 0.5 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.940298507462686
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 ne(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(ne(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 ne(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(ne(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(0.5 / 0.5), (1.0 - ((0.0 / -1.0) / --1.0)), -(1.0 - 0.5), +(0.5 + 0.0));

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(0.5 / 0.5), (1.0 - ((0.0 / -1.0) / --1.0)), -(1.0 - 0.5), +(0.5 + 0.0));

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.48148148148148
Processing this: /home/oof/webgl_cleaned/extension8_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
61.48148148148148
Processing this: /home/oof/webgl_cleaned/exp2_float_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = -gtf_Color.r;
	color = vec4(exp2(5.0 * c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = -gtf_Color.r;\n\tcolor = vec4(exp2(5.0 * c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (-0.5 + 2.0), -1.0, (0.0 - (false ? (true ? 2.0 : -1.0) : 1.0)));

void main()
{
  float c = -gtf_Color.r;
  color = vec4(exp2((5.0 * c)) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.76470588235294
Processing this: /home/oof/webgl_cleaned/pow_vec3_frag_xvary_yconst2_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = color.rgb;
	gl_FragColor = vec4(c * c / 4.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(c * c / 4.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, -1.0, (((false ? 0.5 : 1.0) / 0.0) / (1.0 + (false ? 0.0 : 1.0))), ((false ? false : !true) ? 0.5 : (true ? (true ? 1.0 : 0.0) : (0.0 + 0.0))));

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4(((c * c) / 4.0) , 1.0);
}


As vertex? : False
SUCCESS!
62.04379562043796
Processing this: /home/oof/webgl_cleaned/preprocess10_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  -2.0;
  vec4(+-1.0, 0.5, 1.0, 1.0);
}


As vertex? : False
SUCCESS!
62.31884057971014
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	float s = lightloc.s;
	float t = lightloc.t;
	float p = lightloc.p;
	float q = lightloc.q;
	vec4 m = vec4(s, t, p, q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tfloat s = lightloc.s;\n\tfloat t = lightloc.t;\n\tfloat p = lightloc.p;\n\tfloat q = lightloc.q;\n\tvec4 m = vec4(s, t, p, q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  float s = lightloc.s;
  float t = lightloc.t;
  float p = lightloc.p;
  float q = lightloc.q;
  vec4 m = vec4(s , t , p , q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * m);
}


As vertex? : True
SUCCESS!
62.589928057553955
Mutations attempted: 139
Valid mutations:     87
Success rate:        62.59%
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gte(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 gte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(gte(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 gte(in vec2 a, in vec2 b)
{
  bvec2 result = bvec2(-1.0, 1.0);
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
  vec4(2.0, (((true ? -1.0 : 0.5) * 0.5) / (false ? 0.5 : 0.0)), 2.0, -1.0);
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(gte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.857142857142854
Processing this: /home/oof/webgl_cleaned/notEqual_bvec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 ne(in bvec2 a, in bvec2 b)
{
	bvec2 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(ne(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 ne(in bvec2 a, in bvec2 b)\n{\n\tbvec2 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(ne(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 ne(in bvec2 a, in bvec2 b)
{
  bvec2 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(ne(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.12056737588653
Processing this: /home/oof/webgl_cleaned/ceil_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0));
}


==============================
62.676056338028175
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float s = al.s;
	float t = al.t;
	float p = al.p;
	float q = al.q;
	vec4 m = vec4(s,t,p,q);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat s = al.s;\n\tfloat t = al.t;\n\tfloat p = al.p;\n\tfloat q = al.q;\n\tvec4 m = vec4(s,t,p,q);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-0.5, 0.0, (false ? (!true ? 1.0 : (-1.0 * 1.0)) : -1.0), 2.0);

void main()
{
  vec4 al = color;
  float s = al.s;
  float t = al.t;
  float p = al.p;
  float q = al.q;
  vec4 m = vec4(s , t , p , q);
  gl_FragColor = m;
}


As vertex? : False
SUCCESS!
62.93706293706294
Processing this: /home/oof/webgl_cleaned/dFdx_frag_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.19444444444444
Processing this: /home/oof/webgl_cleaned/const_mat3_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat3 a = mat3( 1.0,   2.0,   4.0,
	                     8.0,  16.0,  32.0,
	                    64.0, 128.0, 256.0);
	mat3 b = a;
	bool elms = true;
	if(b[0][0] !=   1.0) elms = false;
	if(b[0][1] !=   2.0) elms = false;
	if(b[0][2] !=   4.0) elms = false;
	if(b[1][0] !=   8.0) elms = false;
	if(b[1][1] !=  16.0) elms = false;
	if(b[1][2] !=  32.0) elms = false;
	if(b[2][0] !=  64.0) elms = false;
	if(b[2][1] != 128.0) elms = false;
	if(b[2][2] != 256.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0];
	x = b[0][0] + b[1][0] + b[2][0];
	if( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;
	x = b[0][1] + b[1][1] + b[2][1];
	if(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;
	x = b[0][2] + b[1][2] + b[2][2];
	if(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2];
	if( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;
	x = b[1][0] + b[1][1] + b[1][2];
	if(x < 56.0-0.1 || x > 56.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2];
	if(x < 448.0-0.1 || x > 448.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat3 a = mat3( 1.0,   2.0,   4.0,\n\t                     8.0,  16.0,  32.0,\n\t                    64.0, 128.0, 256.0);\n\tmat3 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=   1.0) elms = false;\n\tif(b[0][1] !=   2.0) elms = false;\n\tif(b[0][2] !=   4.0) elms = false;\n\tif(b[1][0] !=   8.0) elms = false;\n\tif(b[1][1] !=  16.0) elms = false;\n\tif(b[1][2] !=  32.0) elms = false;\n\tif(b[2][0] !=  64.0) elms = false;\n\tif(b[2][1] != 128.0) elms = false;\n\tif(b[2][2] != 256.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tx = b[0][0] + b[1][0] + b[2][0];\n\tif( x < 73.0-0.1 || x > 73.0+0.1 ) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1];\n\tif(x < 146.0-0.1 || x > 146.0+0.1 ) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2];\n\tif(x < 292.0-0.1 || x > 292.0+0.1 ) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2];\n\tif( x < 7.0-0.1 || x > 7.0+0.1 ) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2];\n\tif(x < 56.0-0.1 || x > 56.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2];\n\tif(x < 448.0-0.1 || x > 448.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 * (1.0 + 0.5)), -1.0, (true ? (!false ? +-1.0 : 2.0) : 2.0), (((false ? false : true) ? true : !true) ? (2.0 / -1.0) : 0.0), +2.0, +0.0, ((+1.0 - (true ? 2.0 : 0.5)) / 1.0), -0.0, ((false ? -2.0 : 0.5) * +(-1.0 - 1.0)), -(!false ? (true ? -1.0 : 0.5) : (false ? 0.0 : 2.0)), 0.5, 0.5, (1.0 + 0.5), (!false ? (true ? 0.5 : 1.0) : 0.5), -1.0, 0.5);

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  mat3 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[1][0] != 8.0))
    elms = false;
  if ((b[1][1] != 16.0))
    elms = false;
  if ((b[1][2] != 32.0))
    elms = false;
  if ((b[2][0] != 64.0))
    elms = false;
  if ((b[2][1] != 128.0))
    elms = false;
  if ((b[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((b[0][1] + b[1][1]) + b[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((b[0][2] + b[1][2]) + b[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((b[0][0] + b[0][1]) + b[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((b[1][0] + b[1][1]) + b[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((b[2][0] + b[2][1]) + b[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 * (1.0 + 0.5)), -1.0, (true ? (!false ? +-1.0 : 2.0) : 2.0), (((false ? false : true) ? true : !true) ? (2.0 / -1.0) : 0.0), +2.0, +0.0, ((+1.0 - (true ? 2.0 : 0.5)) / 1.0), -0.0, ((false ? -2.0 : 0.5) * +(-1.0 - 1.0)), -(!false ? (true ? -1.0 : 0.5) : (false ? 0.0 : 2.0)), 0.5, 0.5, (1.0 + 0.5), (!false ? (true ? 0.5 : 1.0) : 0.5), -1.0, 0.5);

vec4 color;

void main()
{
  float x;
  const mat3 a = mat3(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0);
  mat3 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 4.0))
    elms = false;
  if ((b[1][0] != 8.0))
    elms = false;
  if ((b[1][1] != 16.0))
    elms = false;
  if ((b[1][2] != 32.0))
    elms = false;
  if ((b[2][0] != 64.0))
    elms = false;
  if ((b[2][1] != 128.0))
    elms = false;
  if ((b[2][2] != 256.0))
    elms = false;
  bool rows = true;
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  x = ((b[0][0] + b[1][0]) + b[2][0]);
  if (((x < (73.0 - 0.1)) || (x > (73.0 + 0.1))))
    rows = false;
  x = ((b[0][1] + b[1][1]) + b[2][1]);
  if (((x < (146.0 - 0.1)) || (x > (146.0 + 0.1))))
    rows = false;
  x = ((b[0][2] + b[1][2]) + b[2][2]);
  if (((x < (292.0 - 0.1)) || (x > (292.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = ((b[0][0] + b[0][1]) + b[0][2]);
  if (((x < (7.0 - 0.1)) || (x > (7.0 + 0.1))))
    cols = false;
  x = ((b[1][0] + b[1][1]) + b[1][2]);
  if (((x < (56.0 - 0.1)) || (x > (56.0 + 0.1))))
    cols = false;
  x = ((b[2][0] + b[2][1]) + b[2][2]);
  if (((x < (448.0 - 0.1)) || (x > (448.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.758620689655174
Processing this: /home/oof/webgl_cleaned/floor_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, (0.0 + -1.0), 2.0, 0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((10.0 * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.013698630136986
Processing this: /home/oof/webgl_cleaned/refract_float_vert_ivarynconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	float result;
	float eta = 0.5;
	float k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));
	if(k < 0.0)
		result = 0.0;
	else
		result = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;
	color = vec4((result + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tfloat result;\n\tfloat eta = 0.5;\n\tfloat k = 1.0 - eta * eta * (1.0 - dot(v1, v2) * dot(v1, v2));\n\tif(k < 0.0)\n\t\tresult = 0.0;\n\telse\n\t\tresult = eta * v1 - (eta * dot(v1, v2) + sqrt(k)) * v2;\n\tcolor = vec4((result + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((-(true ? -1.0 : 1.0) + 0.0), --2.0, +(2.0 / 0.0), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  float result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = 0.0;
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  color = vec4(((result + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((-(true ? -1.0 : 1.0) + 0.0), --2.0, +(2.0 / 0.0), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  float result;
  float eta = 0.5;
  float k = (1.0 - ((eta * eta) * (1.0 - (dot(v1 , v2) * dot(v1 , v2)))));
  if ((k < 0.0))
    result = 0.0;
  else
    result = ((eta * v1) - (((eta * dot(v1 , v2)) + sqrt(k)) * v2));
  color = vec4(((result + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.585034013605444
Processing this: /home/oof/webgl_cleaned/vec3_xy_z_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec2 t = m.xy;
	float k = m.z;
	vec4 a = vec4(t, k, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec2 t = m.xy;\n\tfloat k = m.z;\n\tvec4 a = vec4(t, k, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(0.5, 2.0, -1.0, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec2 t = m.xy;
  float k = m.z;
  vec4 a = vec4(t , k , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
62.83783783783784
Processing this: /home/oof/webgl_cleaned/floor_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 2.0, -0.5, -1.0, -1.0, 1.0, 2.0, -1.0, 2.0, -1.0, 0.0, -1.0, 2.0, 2.0, 2.0, 0.0);

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.5, 2.0, -0.5, -1.0, -1.0, 1.0, 2.0, -1.0, 2.0, -1.0, 0.0, -1.0, 2.0, 2.0, 2.0, 0.0);

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.41610738255034
Mutations attempted: 149
Valid mutations:     93
Success rate:        62.42%
Processing this: /home/oof/webgl_cleaned/asin_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * (color.r - 0.5);
	gl_FragColor = vec4(asin(c) / M_PI + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4(asin(c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = color(((asin(c) / M_PI) + 0.5) , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gl_FragColor' : undeclared identifier
ERROR: 0:10: 'color' : function name expected
ERROR: 0:10: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (2.0 * (color.r - 0.5));
  gl_FragColor = color(((asin(c) / M_PI) + 0.5) , 0.0 , 0.0);
}


==============================
62.0
Processing this: /home/oof/webgl_cleaned/degrees_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.5, 1.0, 0.5);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.251655629139066
Processing this: /home/oof/webgl_cleaned/dataType8_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float f;
void main()
{
    f = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float f;\nvoid main()\n{\n    f = 1.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

float f = (((-1.0 - f) / 0.5) * ++0.0);

void main()
{
  f = 1.0;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'f' : undeclared identifier
ERROR: 0:4: '++' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

float f = (((-1.0 - f) / 0.5) * ++0.0);

void main()
{
  f = 1.0;
}


==============================
61.8421052631579
Processing this: /home/oof/webgl_cleaned/bvec4_empty_out_bvec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec4 function(out bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bvec4 function(out bvec4 par[3])
{
	set_all(par, bvec4(false, false, false, false));
	return bvec4(true, true, true, true);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec4 function(out bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(false, false, false, false)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbvec4 function(out bvec4 par[3])\n{\n\tset_all(par, bvec4(false, false, false, false));\n\treturn bvec4(true, true, true, true);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
61.8421052631579
Processing this: /home/oof/webgl_cleaned/CorrectParse2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;
const bool BoolConst1 = true && true || false;
const bool BoolConst2 = false || !false && false;
void main ()
{
    float float1 = 4.0, float2 = floatConst2;
    int int_1 = int(FloatConst1);
    vec4 vec4_1;
    vec3 vec3_1 = vec3(1, 1, 1);
	vec3 vec3_2 = vec3(0, 0, 0);
    bool bool4, bool5;
    bool4 = bool5;
    bool4 = 4 > 5;
    bool4 = !(3.2 != 0.0);
    bool4 = bool(float1);
    bool4 = bool(int_1);
    float1 = float(bool4);
    float1 = float(int_1);
    int_1 = int(float1);
    int_1 = int(bool4);
    {
        int a, b, c;
        a = b;
        b = c;
        {
            int b, c, d;
            b = c;
            c = d;
            {
                int a, d, e;
                a = d;
                d = e;
            }
            {
                int a, b, c;
                a = b;
                b = c;
            }
        }
        a = b;
        b = c;
    }
    {
        float f1, f2;
        vec3 v31, v32;
        max(f1, f2);
        max(v31, v32);
        vec4 v4 = vec4(3.0);
        vec3 v3 = -vec3(2.0, 1.0, 3.0);
        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);
    }
    if (BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst1 || BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2 && BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (FloatConst1 != 0.0)
        --int_1;
    else
        ++int_1;
    if (0 != 0)
        ++int_1;
    else
        --int_1;
    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);
    float1 = 5 != 0 ? float1 : float(int_1);
    float1 = BoolConst1 ? float1 : float(int_1);
    if (float1 != float1)
        ++int_1;
    else
        --int_1;
    float1 = float1 != float1 ? float1 : float(int_1);
    --int_1;
    ++float1;
    (vec4_1.x)--;
    vec3_1++;
    if (vec3_1.x > vec3_2.x)
        float1 = 4.0 + 6.0;
    if (bool4 ^^ bool5)
        float1 *= 2.4;
    if (false ^^ false)
        float1 *= 2.5;
    if (true ^^ false)
        float1 *= 2.6;
    {
        int i;
    }
    if (bool4) {
        int i;
    } else {
        int i;
        i = 5;
    }
    mat4 m1;
    m1[2][1] = 4.0;
    gl_Position = vec4(float1+float1, float1, float1, float(int_1));
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nconst float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;\nconst bool BoolConst1 = true && true || false;\nconst bool BoolConst2 = false || !false && false;\nvoid main ()\n{\n    float float1 = 4.0, float2 = floatConst2;\n    int int_1 = int(FloatConst1);\n    vec4 vec4_1;\n    vec3 vec3_1 = vec3(1, 1, 1);\n\tvec3 vec3_2 = vec3(0, 0, 0);\n    bool bool4, bool5;\n    bool4 = bool5;\n    bool4 = 4 > 5;\n    bool4 = !(3.2 != 0.0);\n    bool4 = bool(float1);\n    bool4 = bool(int_1);\n    float1 = float(bool4);\n    float1 = float(int_1);\n    int_1 = int(float1);\n    int_1 = int(bool4);\n    {\n        int a, b, c;\n        a = b;\n        b = c;\n        {\n            int b, c, d;\n            b = c;\n            c = d;\n            {\n                int a, d, e;\n                a = d;\n                d = e;\n            }\n            {\n                int a, b, c;\n                a = b;\n                b = c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n    {\n        float f1, f2;\n        vec3 v31, v32;\n        max(f1, f2);\n        max(v31, v32);\n        vec4 v4 = vec4(3.0);\n        vec3 v3 = -vec3(2.0, 1.0, 3.0);\n        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);\n    }\n    if (BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst1 || BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2 && BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (FloatConst1 != 0.0)\n        --int_1;\n    else\n        ++int_1;\n    if (0 != 0)\n        ++int_1;\n    else\n        --int_1;\n    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);\n    float1 = 5 != 0 ? float1 : float(int_1);\n    float1 = BoolConst1 ? float1 : float(int_1);\n    if (float1 != float1)\n        ++int_1;\n    else\n        --int_1;\n    float1 = float1 != float1 ? float1 : float(int_1);\n    --int_1;\n    ++float1;\n    (vec4_1.x)--;\n    vec3_1++;\n    if (vec3_1.x > vec3_2.x)\n        float1 = 4.0 + 6.0;\n    if (bool4 ^^ bool5)\n        float1 *= 2.4;\n    if (false ^^ false)\n        float1 *= 2.5;\n    if (true ^^ false)\n        float1 *= 2.6;\n    {\n        int i;\n    }\n    if (bool4) {\n        int i;\n    } else {\n        int i;\n        i = 5;\n    }\n    mat4 m1;\n    m1[2][1] = 4.0;\n    gl_Position = vec4(float1+float1, float1, float1, float(int_1));\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = (3.0 * 8.0) , floatConst2 = 4.0;

const bool BoolConst1 = ((true && true) || false);

const bool BoolConst2 = (false || (!true && false));

void main()
{
  float float1 = 4.0 , float2 = floatConst2;
  int int_1 = int(FloatConst1);
  vec4 vec4_1;
  vec3 vec3_1 = vec3(1 , 1 , 1);
  vec3 vec3_2 = vec3(0 , 0 , 0);
  bool bool4, bool5;
  bool4 = bool5;
  bool4 = (4 > 5);
  bool4 = !(3.2 != 0.0);
  bool4 = bool(float1);
  bool4 = bool(int_1);
  float1 = float(bool4);
  float1 = float(int_1);
  int_1 = int(float1);
  int_1 = int(bool4);
  {
    int a, b, c;
    a = b;
    b = c;
    {
      int b, c, d;
      b = c;
      c = d;
      {
        int a, d, e;
        a = d;
        d = e;
      }
      {
        int a, b, c;
        a = b;
        b = c;
      }
    }
    a = b;
    b = c;
  }
  {
    float f1, f2;
    vec3 v31, v32;
    max(f1 , f2);
    max(v31 , v32);
    vec4 v4 = vec4(3.0);
    vec3 v3 = -vec3(2.0 , 1.0 , 3.0);
    mat2 m2 = mat2(3.0 , 4.0 , 6.0 , 3.0);
  }
  if (BoolConst1)
    ++vec3_1;
  else
    --vec3_1;
  if (BoolConst2)
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst1 || BoolConst2))
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst2 && BoolConst1))
    ++vec3_1;
  else
    --vec3_1;
  if ((FloatConst1 != 0.0))
    --int_1;
  else
    ++int_1;
  if ((0 != 0))
    ++int_1;
  else
    --int_1;
  bool4 = (((((BoolConst1 && !(int_1 != 0)) && !BoolConst1) && !(FloatConst1 != 0.0)) && (FloatConst1 != 0.0)) && (float1 != 0.0));
  (float1 = (5 != 0) ? float1 : float(int_1));
  (float1 = BoolConst1 ? float1 : float(int_1));
  if ((float1 != float1))
    ++int_1;
  else
    --int_1;
  (float1 = (float1 != float1) ? float1 : float(int_1));
  --int_1;
  ++float1;
  vec4_1.x--;
  vec3_1++;
  if ((vec3_1.x > vec3_2.x))
    float1 = (4.0 + 6.0);
  if ((bool4 ^^ bool5))
    (float1 *= 2.4);
  if ((false ^^ false))
    (float1 *= 2.5);
  if ((true ^^ false))
    (float1 *= 2.6);
  {
    int i;
  }
  if (bool4)
  {
    int i;
  }
  else
  {
    int i;
    i = 5;
  }
  mat4 m1;
  m1[2][1] = 4.0;
  gl_Position = vec4((float1 + float1) , float1 , float1 , float(int_1));
}


As vertex? : True
SUCCESS!
62.091503267973856
Processing this: /home/oof/webgl_cleaned/all_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool _all(in bvec3 a)
{
	bool temp = true;
	if(!a[0]) temp = false;
	if(!a[1]) temp = false;
	if(!a[2]) temp = false;
	return temp;
}
void main ()
{
	vec3 c = floor(4.0 * color.rgb);
	gl_FragColor = vec4(vec3(_all(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool _all(in bvec3 a)\n{\n\tbool temp = true;\n\tif(!a[0]) temp = false;\n\tif(!a[1]) temp = false;\n\tif(!a[2]) temp = false;\n\treturn temp;\n}\nvoid main ()\n{\n\tvec3 c = floor(4.0 * color.rgb);\n\tgl_FragColor = vec4(vec3(_all(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bool _all(in bvec3 a)
{
  bool temp = true;
  if (!a[0])
    temp = false;
  if (!a[1])
    temp = false;
  if (!a[2])
    temp = false;
  return temp;
}

void main()
{
  vec3 c = floor((4.0 * color.rgb));
  gl_FragColor = vec4(vec3(_all(bvec3(c))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:21: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bool _all(in bvec3 a)
{
  bool temp = true;
  if (!a[0])
    temp = false;
  if (!a[1])
    temp = false;
  if (!a[2])
    temp = false;
  return temp;
}

void main()
{
  vec3 c = floor((4.0 * color.rgb));
  gl_FragColor = vec4(vec3(_all(bvec3(c))));
}


==============================
61.68831168831169
Processing this: /home/oof/webgl_cleaned/vec3_zyx_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.xyz;
	vec3 t = m.zyx;
	vec4 a = vec4(t.z, t.y, t.x ,al.w);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.xyz;\n\tvec3 t = m.zyx;\n\tvec4 a = vec4(t.z, t.y, t.x ,al.w);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec3 m = al.xyz;
  vec3 t = m.zyx;
  vec4 a = vec4(t.z , t.y , t.x , al.w);
  gl_FragColor = a;
  vec4(-1.0, 2.0, +0.5, 2.0);
}


As vertex? : False
SUCCESS!
61.935483870967744
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 4.0 * (gtf_Color.rg);
	color = vec4(c * c / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 4.0 * (gtf_Color.rg);\n\tcolor = vec4(c * c / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, 2.0, 1.0, 1.0);

void main()
{
  vec2 c = (4.0 * gtf_Color.rg);
  color = vec4(((c * c) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.17948717948718
Processing this: /home/oof/webgl_cleaned/bool_empty_empty_bool_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool function(bool par);
void main ()
{
	bool par = true;
	bool ret = false;
	float gray = 0.0;
	ret = function(par);
	if(par && ret)
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bool function(bool par)
{
	if(par)
	{
		par = false;
		return true;
	}
	else
		return false;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool function(bool par);\nvoid main ()\n{\n\tbool par = true;\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(par && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbool function(bool par)\n{\n\tif(par)\n\t{\n\t\tpar = false;\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\x00')
62.17948717948718
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = color[17];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:13: '[]' : vector field selection out of range

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = color[17];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


==============================
61.78343949044586
Mutations attempted: 157
Valid mutations:     97
Success rate:        61.78%
Processing this: /home/oof/webgl_cleaned/equal_bvec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
bvec2 eq(in bvec2 a, in bvec2 b)
{
	bvec2 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(eq(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nbvec2 eq(in bvec2 a, in bvec2 b)\n{\n\tbvec2 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(eq(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? 2.0 : 2.0), +-0.0, ((-1.0 - 0.5) + +(false ? 1.0 : 0.0)), 0.5);

bvec2 eq(in bvec2 a, in bvec2 b)
{
  bvec2 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(eq(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.0253164556962
Processing this: /home/oof/webgl_cleaned/vec3_ps_t_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.stp;
	vec2 t = m.ps;
	float k = m.t;
	vec4 a = vec4(t.t, k, t.s, lightloc.q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.stp;\n\tvec2 t = m.ps;\n\tfloat k = m.t;\n\tvec4 a = vec4(t.t, k, t.s, lightloc.q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((false && false) ? false : true) ? 0.5 : -(false ? 1.0 : -1.0)), -1.0, 0.0, 1.0, 0.5, (((true && false) ? 0.5 : 2.0) * (true ? (false ? -1.0 : 0.0) : 0.0)), +(0.5 + -2.0), 1.0, (true ? -1.0 : 1.0), 2.0, -1.0, -1.0, ((!false ? false : true) ? 1.0 : -1.0), (!true ? 2.0 : --1.0), ((+0.5 / (2.0 + 2.0)) * ((true ? false : true) ? 1.0 : (0.5 / -1.0))), (-1.0 * ((true ? false : true) ? 0.0 : 0.5)));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.stp;
  vec2 t = m.ps;
  float k = m.t;
  vec4 a = vec4(t.t , k , t.s , lightloc.q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((((false && false) ? false : true) ? 0.5 : -(false ? 1.0 : -1.0)), -1.0, 0.0, 1.0, 0.5, (((true && false) ? 0.5 : 2.0) * (true ? (false ? -1.0 : 0.0) : 0.0)), +(0.5 + -2.0), 1.0, (true ? -1.0 : 1.0), 2.0, -1.0, -1.0, ((!false ? false : true) ? 1.0 : -1.0), (!true ? 2.0 : --1.0), ((+0.5 / (2.0 + 2.0)) * ((true ? false : true) ? 1.0 : (0.5 / -1.0))), (-1.0 * ((true ? false : true) ? 0.0 : 0.5)));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.stp;
  vec2 t = m.ps;
  float k = m.t;
  vec4 a = vec4(t.t , k , t.s , lightloc.q);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
61.63522012578616
Processing this: /home/oof/webgl_cleaned/vec4_bar_g_1vec3_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.bar;
	float g = lightloc.g;
	vec4 a = vec4(m.b, g, m.r, m.g);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.bar;\n\tfloat g = lightloc.g;\n\tvec4 a = vec4(m.b, g, m.r, m.g);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 0.5, -1.0, 2.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.bar;
  float g = lightloc.g;
  vec4 a = vec4(m.b , g , m.r , m.g);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
61.875
Processing this: /home/oof/webgl_cleaned/for_continue_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count=0;
	int val=0;
    	for(int i=0;i<10;i++)
	{
	  count++;
	  if(count == 5)
            continue;
	   else
	    val += count;
	}
	float gray;
	if( val == 50)
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint count=0;\n\tint val=0;\n    \tfor(int i=0;i<10;i++)\n\t{\n\t  count++;\n\t  if(count == 5)\n            continue;\n\t   else\n\t    val += count;\n\t}\n\tfloat gray;\n\tif( val == 50)\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, (true ? -0.5 : (2.0 + 1.0)), (0.0 * 0.5), -0.5);

void main()
{
  int count = 0;
  int val = 0;
  for (int i = 0; (i < 10); i++)
  {
    count++;
    if ((count == 5))
      continue;
    else
      (val += count);
  }
  float gray;
  if ((val == 50))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.11180124223602
Processing this: /home/oof/webgl_cleaned/struct_bool_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	bool a;
	bool b;
	bool c;
	bool d;
};
void main ()
{
	sabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));
	float gray = 0.0;
	if( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))
	  gray=1.0;
	else
          gray =0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tbool a;\n\tbool b;\n\tbool c;\n\tbool d;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(bool(12), bool(0), bool(25.5), bool(0.0));\n\tfloat gray = 0.0;\n\tif( (s.a==true) && (s.b==false) && (s.c == true) && (s.d==false))\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  bool a;
  bool b;
  bool c;
  bool d;
};

void main()
{
  sabcd s = sabcd(bool(12) , bool(0) , bool(25.5) , bool(0.0));
  float gray = 0.0;
  if (((((s.a == true) && (s.b == false)) && (s.c == true)) && (s.d == false)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.34567901234568
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.57668711656442
Processing this: /home/oof/webgl_cleaned/bvec4_empty_empty_bvec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, true) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(bvec4 par)
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, true) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(bvec4 par)\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
62.57668711656442
Processing this: /home/oof/webgl_cleaned/vec3_grb_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.rgb;
	vec3 t = m.grb;
	vec4 a = vec4(t.g, t.r, t.b ,al.a);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.rgb;\n\tvec3 t = m.grb;\n\tvec4 a = vec4(t.g, t.r, t.b ,al.a);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, +1.0, -1.0, 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.rgb;
  vec3 t = m.grb;
  vec4 a = vec4(t.g , t.r , t.b , al.a);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
62.80487804878049
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	float c = color.r;
	gl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, 0.5, 0.5, 0.5);

void main()
{
  const float exp1 = 2.7183;
  float c = color.r;
  gl_FragColor = vec4((1.0 / pow(exp1 , (3.0 * c))) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.030303030303024
Processing this: /home/oof/webgl_cleaned/fragmentOnly4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

void main()
{
    discard;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nvoid main()\n{\n    discard;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  discard;
}


As vertex? : True
SUCCESS!
63.25301204819277
Mutations attempted: 166
Valid mutations:     105
Success rate:        63.25%
Processing this: /home/oof/webgl_cleaned/vec3_vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 b = vec4(13.0, 53.0, 139.0, 217.0);
	vec3 a = vec3(b);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 b = vec4(13.0, 53.0, 139.0, 217.0);\n\tvec3 a = vec3(b);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) && (a[2] == 139.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --(0.0 - 2.0), 0.5, (false ? 2.0 : (true ? 0.0 : 0.5)));

void main()
{
  vec4 b = vec4(13.0 , 53.0 , 139.0 , 217.0);
  vec3 a = vec3(b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions
ERROR: 0:16: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:16: 'gtf_Vertex' : undeclared identifier
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, --(0.0 - 2.0), 0.5, (false ? 2.0 : (true ? 0.0 : 0.5)));

void main()
{
  vec4 b = vec4(13.0 , 53.0 , 139.0 , 217.0);
  vec3 a = vec3(b);
  float gray;
  if ((((a[0] == 13.0) && (a[1] == 53.0)) && (a[2] == 139.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


==============================
62.874251497005986
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 ne(in vec3 a, in vec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(ne(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 ne(in vec3 a, in vec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(ne(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((true ? false : true) && false) ? -1.0 : ((false ? -1.0 : 2.0) / (false ? -1.0 : 2.0))), (-1.0 * ((-1.0 - 0.5) * -0.5)), (0.5 + --1.0), -0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((true ? false : true) && false) ? -1.0 : ((false ? -1.0 : 2.0) / (false ? -1.0 : 2.0))), (-1.0 * ((-1.0 - 0.5) * -0.5)), (0.5 + --1.0), -0.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 ne(in vec3 a, in vec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(ne(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Processing this: /home/oof/webgl_cleaned/not_bvec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 _not(in bvec2 a)
{
	bvec2 result;
	if(a[0]) result[0] = false;
	else result[0] = true;
	if(a[1]) result[1] = false;
	else result[1] = true;
	return result;
}
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	color = vec4(vec2(_not(bvec2(c))), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 _not(in bvec2 a)\n{\n\tbvec2 result;\n\tif(a[0]) result[0] = false;\n\telse result[0] = true;\n\tif(a[1]) result[1] = false;\n\telse result[1] = true;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tcolor = vec4(vec2(_not(bvec2(c))), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((true ? (-1.0 - -2.0) : ((true ? false : false) ? -1.0 : (1.0 * -1.0))), 0.0, 0.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 _not(in bvec2 a)
{
  bvec2 result;
  if (a[0])
    result[0] = false;
  else
    result[0] = true;
  if (a[1])
    result[1] = false;
  else
    result[1] = true;
  return result;
}

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  color = vec4(vec2(_not(bvec2(c))) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.721893491124256
Processing this: /home/oof/webgl_cleaned/reflect_float_vert_ivarynconst_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	color = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tcolor = vec4((v1 - 2.0 * dot(v2, v1) * v2 + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.5, (+0.0 / (1.0 - 1.0)), (true ? ++2.0 : -1.0), 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:6: '++' : l-value required (can't modify a const)
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : global variable initializers must be constant expressions
ERROR: 0:18: '*' : array / non-array mismatch
ERROR: 0:18: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[2] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:18: '=' : dimension mismatch
ERROR: 0:18: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.5, (+0.0 / (1.0 - 1.0)), (true ? ++2.0 : -1.0), 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4((((v1 - ((2.0 * dot(v2 , v1)) * v2)) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.35294117647059
Processing this: /home/oof/webgl_cleaned/float_empty_empty_float_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(float par[3])
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return 1.0;
	}
	else
		return 0.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(float par[3])\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
62.35294117647059
Processing this: /home/oof/webgl_cleaned/degrees_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((((false && true) ? 0.0 : (2.0 * -1.0)) * (0.0 + 0.5)), 1.0, ((0.5 + 1.0) / (-1.0 - 0.5)), 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((2.0 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.57309941520468
Processing this: /home/oof/webgl_cleaned/vec4_ar_bg_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.ar;
	vec2 n = lightloc.bg;
	vec4 a = vec4(m.g, n.g, n.r, m.r);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.ar;\n\tvec2 n = lightloc.bg;\n\tvec4 a = vec4(m.g, n.g, n.r, m.r);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-(2.0 + 1.0) * (0.5 - -1.0)), (false ? -1.0 : 0.0), 0.5, -0.0, 1.0, 2.0, -1.0, 1.0, 0.5, +(-1.0 / 0.5), 1.0, -1.0, +0.0, -1.0, 0.5, (-1.0 / 1.0));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.ar;
  vec2 n = lightloc.bg;
  vec4 a = vec4(m.g , n.g , n.r , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((-(2.0 + 1.0) * (0.5 - -1.0)), (false ? -1.0 : 0.0), 0.5, -0.0, 1.0, 2.0, -1.0, 1.0, 0.5, +(-1.0 / 0.5), 1.0, -1.0, +0.0, -1.0, 0.5, (-1.0 / 1.0));

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.ar;
  vec2 n = lightloc.bg;
  vec4 a = vec4(m.g , n.g , n.r , m.r);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
62.2093023255814
Processing this: /home/oof/webgl_cleaned/max_vec3_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 max_c = vec3(0.5, 0.5, 0.5);
	vec3 c = gtf_Color.rgb;
	if(c[0] < max_c[0]) c[0] = max_c[0];
	if(c[1] < max_c[1]) c[1] = max_c[1];
	if(c[2] < max_c[2]) c[2] = max_c[2];
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 max_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = gtf_Color.rgb;\n\tif(c[0] < max_c[0]) c[0] = max_c[0];\n\tif(c[1] < max_c[1]) c[1] = max_c[1];\n\tif(c[2] < max_c[2]) c[2] = max_c[2];\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 2.0, (((true ? false : true) || (false && false)) ? (+2.0 / (false ? 2.0 : 1.0)) : 0.0), (true ? 1.0 : -1.0));

void main()
{
  const vec3 max_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] < max_c[0]))
    c[0] = max_c[0];
  if ((c[1] < max_c[1]))
    c[1] = max_c[1];
  if ((c[2] < max_c[2]))
    c[2] = max_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.42774566473989
Processing this: /home/oof/webgl_cleaned/floor_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = 10.0 * 2.0 * (color.r - 0.5);
	gl_FragColor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 10.0 * 2.0 * (color.r - 0.5);\n\tgl_FragColor = vec4((floor(c) + 10.0) / 20.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 0.0, 0.0, (true ? -1.0 : -1.0));

void main()
{
  float c = ((10.0 * 2.0) * (color.r - 0.5));
  gl_FragColor = vec4(((floor(c) + 10.0) / 20.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.643678160919535
Processing this: /home/oof/webgl_cleaned/lessThanEqual_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, -0.5, 0.5, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.857142857142854
Mutations attempted: 175
Valid mutations:     110
Success rate:        62.86%
Processing this: /home/oof/webgl_cleaned/gl_MaxVertexUniformVectors_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = vec4(float(gl_MaxVertexUniformVectors) / 128.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(gl_MaxVertexUniformVectors) / 128.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (!false ? 2.0 : (-1.0 / 2.0)) : (false ? (true ? -1.0 : -1.0) : 2.0)), (!!true ? 2.0 : (false ? 2.0 : -1.0)), (1.0 * 1.0), 2.0, -1.0, 0.0, (0.5 / (0.5 / -0.0)), (((false ? true : true) ? 1.0 : (-1.0 - 2.0)) + 0.0), 0.5, +0.0, 1.0, (!true ? 2.0 : ((true ? false : false) ? (-1.0 * 2.0) : -1.0)), 0.5, +2.0, 2.0, 0.5);

vec4 color;

void main()
{
  color = vec4((float(gl_MaxVertexUniformVectors) / 128.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (!false ? 2.0 : (-1.0 / 2.0)) : (false ? (true ? -1.0 : -1.0) : 2.0)), (!!true ? 2.0 : (false ? 2.0 : -1.0)), (1.0 * 1.0), 2.0, -1.0, 0.0, (0.5 / (0.5 / -0.0)), (((false ? true : true) ? 1.0 : (-1.0 - 2.0)) + 0.0), 0.5, +0.0, 1.0, (!true ? 2.0 : ((true ? false : false) ? (-1.0 * 2.0) : -1.0)), 0.5, +2.0, 2.0, 0.5);

vec4 color;

void main()
{
  color = vec4((float(gl_MaxVertexUniformVectors) / 128.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Processing this: /home/oof/webgl_cleaned/cos_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.r) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((false ? (-1.0 / 0.0) : ((true ? 0.0 : 1.0) - 1.0)), +0.5, (+-1.0 / ++1.0), 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:10: '/' : Divide by zero during constant folding
ERROR: 0:10: '++' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((false ? (-1.0 / 0.0) : ((true ? 0.0 : 1.0) - 1.0)), +0.5, (+-1.0 / ++1.0), 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.14689265536724
Processing this: /home/oof/webgl_cleaned/vec4_wx_zy_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.wx;
	vec2 n = lightloc.zy;
	vec4 a = vec4(m.y, n.y, n.x, m.x);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.wx;\n\tvec2 n = lightloc.zy;\n\tvec4 a = vec4(m.y, n.y, n.x, m.x);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.wx;
  vec2 n = lightloc.zy;
  vec4 a = vec4(m.y , n.y , n.x , m.x);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
62.35955056179775
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	color = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tcolor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 1.0, (0.5 - ((-1.0 - 0.5) / (2.0 * 2.0))), -+(0.0 + -1.0));

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.56983240223464
Processing this: /home/oof/webgl_cleaned/exp_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	const float exp3 = 20.0855;
	vec2 c = gtf_Color.rg;
	color = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tconst float exp3 = 20.0855;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(pow(vec2(exp1), 3.0 * c) / exp3, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((((false ? true : true) && (true ? true : true)) ? 0.0 : ((true ? true : true) ? -0.5 : 0.5)), 1.0, 0.5, -1.0);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  const float exp3 = 20.0855;
  vec2 c = gtf_Color.rg;
  color = vec4((pow(vec2(exp1) , (3.0 * c)) / exp3) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.77777777777778
Processing this: /home/oof/webgl_cleaned/const_mat2_copy_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	mat2 b = a;
	bool elms = true;
	if(b[0][0] != 1.0) elms = false;
	if(b[0][1] != 2.0) elms = false;
	if(b[1][0] != 4.0) elms = false;
	if(b[1][1] != 8.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = b[0][1] + b[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = b[1][0] + b[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tmat2 b = a;\n\tbool elms = true;\n\tif(b[0][0] != 1.0) elms = false;\n\tif(b[0][1] != 2.0) elms = false;\n\tif(b[1][0] != 4.0) elms = false;\n\tif(b[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(0.0, -0.0, -1.0, 2.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  mat2 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[1][0] != 4.0))
    elms = false;
  if ((b[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (b[0][0] + b[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (b[0][1] + b[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (b[0][0] + b[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (b[1][0] + b[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.98342541436463
Processing this: /home/oof/webgl_cleaned/vec3_rgb_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.rgb;
	vec4 a = vec4(m.rgb,lightloc.a);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.rgb;\n\tvec4 a = vec4(m.rgb,lightloc.a);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.0, 0.0, ((false ? false : (false || false)) ? +(2.0 * 1.0) : (2.0 / 0.5)), ((-1.0 * 2.0) * (true ? 0.5 : 1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.rgb;
  vec4 a = vec4(m.rgb , lightloc.a);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
63.18681318681318
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0,
			   1.0, 1.0, 1.0, 1.0);
const mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
mat4 function(inout mat4 par[2]);
bool is_all(const in mat4 par, const in float value);
bool is_all(const in mat4 array[2], const in mat4 value);
void set_all(out mat4 array[2], const in mat4 value);
void main ()
{
	mat4 par[2];
	mat4 ret = mat_zeros;
	float gray = 0.0;
	set_all(par, mat_ones);
	ret = function(par);
	if(is_all(par, mat_zeros) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(inout mat4 par[2])
{
	if(is_all(par, mat_ones))
	{
		set_all(par, mat_zeros);
		return mat_ones;
	}
	else
		return mat_zeros;
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
bool is_all(const in mat4 array[2], const in mat4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 array[2], const in mat4 value)
{
	array[0] = value;
	array[1] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst mat4 mat_ones = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0,\n\t\t\t   1.0, 1.0, 1.0, 1.0);\nconst mat4 mat_zeros = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\nmat4 function(inout mat4 par[2]);\nbool is_all(const in mat4 par, const in float value);\nbool is_all(const in mat4 array[2], const in mat4 value);\nvoid set_all(out mat4 array[2], const in mat4 value);\nvoid main ()\n{\n\tmat4 par[2];\n\tmat4 ret = mat_zeros;\n\tfloat gray = 0.0;\n\tset_all(par, mat_ones);\n\tret = function(par);\n\tif(is_all(par, mat_zeros) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(inout mat4 par[2])\n{\n\tif(is_all(par, mat_ones))\n\t{\n\t\tset_all(par, mat_zeros);\n\t\treturn mat_ones;\n\t}\n\telse\n\t\treturn mat_zeros;\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in mat4 array[2], const in mat4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 array[2], const in mat4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n}\n\x00')
63.18681318681318
Processing this: /home/oof/webgl_cleaned/bool_empty_inout_bool_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bool function(inout bool par[3]);
bool is_all(const in bool array[3], const in bool value);
void set_all(out bool array[3], const in bool value);
void main ()
{
	bool par[3];
	bool ret = false;
	float gray = 0.0;
	set_all(par, true);
	ret = function(par);
	if(is_all(par, false) && ret)
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
bool function(inout bool par[3])
{
	if(is_all(par, true))
	{
		set_all(par, false);
		return true;
	}
	else
		return false;
}
bool is_all(const in bool array[3], const in bool value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bool array[3], const in bool value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbool function(inout bool par[3]);\nbool is_all(const in bool array[3], const in bool value);\nvoid set_all(out bool array[3], const in bool value);\nvoid main ()\n{\n\tbool par[3];\n\tbool ret = false;\n\tfloat gray = 0.0;\n\tset_all(par, true);\n\tret = function(par);\n\tif(is_all(par, false) && ret)\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nbool function(inout bool par[3])\n{\n\tif(is_all(par, true))\n\t{\n\t\tset_all(par, false);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\nbool is_all(const in bool array[3], const in bool value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bool array[3], const in bool value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.18681318681318
Processing this: /home/oof/webgl_cleaned/ceil_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((ceil(c) + 10.0) / 20.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, (true ? -1.0 : -1.0), 0.5, -1.0);

void main()
{
  vec2 c = ((10.0 * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((ceil(c) + 10.0) / 20.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.387978142076506
Mutations attempted: 183
Valid mutations:     116
Success rate:        63.39%
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x = (gtf_Color.r + 0.01) / 1.01;
	float y = 0.0;
	float z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	color = vec4(y / -4.61, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = (gtf_Color.r + 0.01) / 1.01;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tcolor = vec4(y / -4.61, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((1.0 / (!false ? (0.5 * 2.0) : -1.0)), -1.0, (true ? +(true ? -1.0 : -1.0) : (2.0 * 1.0)), 0.0);

void main()
{
  float x = ((gtf_Color.r + 0.01) / 1.01);
  float y = 0.0;
  float z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  color = vec4((y / -4.61) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.58695652173913
Processing this: /home/oof/webgl_cleaned/lessThanEqual_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThanEqual(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThanEqual(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, -1.0, -0.5, 0.0);

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThanEqual(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.78378378378379
Processing this: /home/oof/webgl_cleaned/vec3_stp_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	vec4 a = vec4(m.stp,al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tvec4 a = vec4(m.stp,al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 m = al.stp;
  vec4 a = vec4(m.stp , al.q);
  vec4 al = color;
  vec4(2.0, 0.5, 0.5, (0.5 - 1.0));
  gl_FragColor = a;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'al' : undeclared identifier
ERROR: 0:8: 'stp' :  field selection requires structure or vector on left hand side
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: '=' : cannot convert from 'const highp float' to 'mediump 3-component vector of float'
ERROR: 0:9: 'al' : undeclared identifier
ERROR: 0:9: 'q' :  field selection requires structure or vector on left hand side

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 m = al.stp;
  vec4 a = vec4(m.stp , al.q);
  vec4 al = color;
  vec4(2.0, 0.5, 0.5, (0.5 - 1.0));
  gl_FragColor = a;
}


==============================
63.44086021505376
Processing this: /home/oof/webgl_cleaned/vec4_empty_inout_vec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(inout vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(inout vec4 par[3])
{
	if(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))
	{
		set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
		return vec4(1.0, 1.0, 1.0, 1.0);
	}
	else
		return vec4(0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(inout vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(inout vec4 par[3])\n{\n\tif(is_all(par, vec4(1.0, 1.0, 1.0, 1.0)))\n\t{\n\t\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\t\treturn vec4(1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
63.44086021505376
Processing this: /home/oof/webgl_cleaned/greaterThan_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gt(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] > b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] > b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gt(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 gt(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] > b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] > b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(gt(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 gt(in vec2 a, in vec2 b)
{
  bvec2 result;
  if ((a[0] > b[1]))
    result[0] = false;
  else
    result[0] = true;
  if ((a[1] > b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(gt(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/structnest_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	vec3 b;
};
struct nesta
{
	vec3 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec3(11, 13, 17), nestb(vec3(12, 19, 29) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2]) / 101.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tvec3 b;\n};\nstruct nesta\n{\n\tvec3 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec3(11, 13, 17), nestb(vec3(12, 19, 29) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2]) / 101.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = (((true ? false : false) || false) ? mat4(-0.5, 0.0, +0.5, ((true ? 1.0 : 0.5) / (+0.5 * 0.0)), ((!false ? true : (true || true)) ? ((1.0 * 1.0) - +1.0) : 2.0), 1.0, +2.0, (true ? 0.0 : ((true ? 0.0 : 0.0) * (1.0 * 0.0))), +-(2.0 / 2.0), 0.5, (2.0 / (0.5 * 0.0)), (-1.0 - 2.0), (2.0 + (-2.0 + 0.5)), -((2.0 - 0.5) + 0.5), (false ? (!true ? 0.5 : +0.5) : 1.0), 2.0) : mat4(((!true || !true) ? (0.5 / -2.0) : (0.5 - 2.0)), (false ? (2.0 + 0.0) : ((false ? false : false) ? (-1.0 / 0.0) : -1.0)), (((1.0 * 0.0) + 0.0) - -(false ? 0.5 : 0.0)), +(+0.5 + (2.0 / -1.0)), 0.5, ((false ? !true : (false ? false : true)) ? 2.0 : -2.0), 0.0, --(0.5 * -1.0), +0.5, +-0.0, ((true ? 0.5 : -1.0) + 0.0), +(0.0 / (0.5 - 0.0)), 0.0, -1.0, 2.0, 2.0));

vec4 color;

struct nestb {
  vec3 b;
};

struct nesta {
  vec3 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec3(11 , 13 , 17) , nestb(vec3(12 , 19 , 29))));
  color = vec4(vec3(((((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.a[2]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) + s.nest_a.nest_b.b[2]) / 101.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:6: '/' : Divide by zero during constant folding
WARNING: 0:6: '/' : Divide by zero during constant folding
WARNING: 0:6: '/' : Divide by zero during constant folding
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = (((true ? false : false) || false) ? mat4(-0.5, 0.0, +0.5, ((true ? 1.0 : 0.5) / (+0.5 * 0.0)), ((!false ? true : (true || true)) ? ((1.0 * 1.0) - +1.0) : 2.0), 1.0, +2.0, (true ? 0.0 : ((true ? 0.0 : 0.0) * (1.0 * 0.0))), +-(2.0 / 2.0), 0.5, (2.0 / (0.5 * 0.0)), (-1.0 - 2.0), (2.0 + (-2.0 + 0.5)), -((2.0 - 0.5) + 0.5), (false ? (!true ? 0.5 : +0.5) : 1.0), 2.0) : mat4(((!true || !true) ? (0.5 / -2.0) : (0.5 - 2.0)), (false ? (2.0 + 0.0) : ((false ? false : false) ? (-1.0 / 0.0) : -1.0)), (((1.0 * 0.0) + 0.0) - -(false ? 0.5 : 0.0)), +(+0.5 + (2.0 / -1.0)), 0.5, ((false ? !true : (false ? false : true)) ? 2.0 : -2.0), 0.0, --(0.5 * -1.0), +0.5, +-0.0, ((true ? 0.5 : -1.0) + 0.0), +(0.0 / (0.5 - 0.0)), 0.0, -1.0, 2.0, 2.0));

vec4 color;

struct nestb {
  vec3 b;
};

struct nesta {
  vec3 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec3(11 , 13 , 17) , nestb(vec3(12 , 19 , 29))));
  color = vec4(vec3(((((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.a[2]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) + s.nest_a.nest_b.b[2]) / 101.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.297872340425535
Processing this: /home/oof/webgl_cleaned/log2_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 31.0 * gtf_Color.r + 1.0;
	color = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 31.0 * gtf_Color.r + 1.0;\n\tcolor = vec4(log2(c) / 5.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(+(0.5 - 2.0), -1.0, -0.5, (!true ? (false ? (false ? 2.0 : 0.0) : -2.0) : 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = ((31.0 * gtf_Color.r) + 1.0);
  color = vec4((log2(c) / 5.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.49206349206349
Processing this: /home/oof/webgl_cleaned/CorrectBuiltInOveride_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump int;
int radians(int f)
{
    return f;
}
void main()
{
    int f = 45;
    f = radians(f);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump int;\nint radians(int f)\n{\n    return f;\n}\nvoid main()\n{\n    int f = 45;\n    f = radians(f);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

int radians(int f)
{
  return f;
}

void main()
{
  int f = 45;
  f = radians(f);
}


As vertex? : False
SUCCESS!
63.68421052631579
Processing this: /home/oof/webgl_cleaned/matrix2VSU.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = color;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = color;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
63.87434554973822
Processing this: /home/oof/webgl_cleaned/log2_vec3_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
const float ln2 = 0.69314718055994530941723212145818;
void main ()
{
	vec3 x = (gtf_Color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0 / ln2;
	color = vec4(y / -8.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nconst float ln2 = 0.69314718055994530941723212145818;\nvoid main ()\n{\n\tvec3 x = (gtf_Color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0 / ln2;\n\tcolor = vec4(y / -8.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(ln2 - -1.0), ln2, 0.5, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (-2.0 / ln2));
  color = vec4((y / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'ln2' : undeclared identifier
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: 'ln2' : undeclared identifier
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(--(ln2 - -1.0), ln2, 0.5, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 1.01);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (-2.0 / ln2));
  color = vec4((y / -8.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.541666666666664
Mutations attempted: 192
Valid mutations:     122
Success rate:        63.54%
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, +0.5, --1.0, 1.0);

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(2.0, +0.5, --1.0, 1.0);

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


==============================
63.212435233160626
Processing this: /home/oof/webgl_cleaned/for_break_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int count = 0;
        for(int i=0;i<45;i++)
	{
	  count++;
	  if(count == 29)
            break;
	}
	float gray;
	if( count == 29)
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint count = 0;\n        for(int i=0;i<45;i++)\n\t{\n\t  count++;\n\t  if(count == 29)\n            break;\n\t}\n\tfloat gray;\n\tif( count == 29)\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4(2.0, 0.0, -1.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  int count = 0;
  for (int i = 0; (i < 45); i++)
  {
    count++;
    if ((count == 29))
      break;
  }
  float gray;
  if ((count == 29))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.4020618556701
Processing this: /home/oof/webgl_cleaned/any_bvec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	color = vec4(vec3(any(bvec2(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tcolor = vec4(vec3(any(bvec2(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct66964 {
  mat3 f_3967[8];
  ivec3 f_4289[3];
  int f_5192[8];
};

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+((true || true) ? -1.0 : 2.0), +(true ? (0.0 - 1.0) : 0.0), (true ? (-2.0 - 2.0) : (+1.0 + (0.0 / -1.0))), (0.0 * (0.5 / 0.0)), ((1.0 - (false ? 2.0 : 1.0)) + ((true || false) ? (false ? 1.0 : 0.5) : (false ? 2.0 : 2.0))), ((-1.0 - (2.0 + 1.0)) / -1.0), (true ? +0.5 : 0.0), -+-1.0, 1.0, (!(false && false) ? ((-1.0 / 0.0) / 0.5) : (true ? -0.0 : +2.0)), 0.5, ((true ? 0.0 : (true ? 2.0 : 2.0)) - (true ? (true ? 2.0 : 1.0) : 1.0)), (false ? 1.0 : (false ? 0.0 : 2.0)), +((false ? true : false) ? 1.0 : (1.0 / 2.0)), ((0.5 + 0.0) / (0.5 * 1.0)), 0.0);

vec4 color;

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  color = vec4(vec3(any(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:14: '/' : Divide by zero during constant folding
WARNING: 0:14: '*' : Constant folded undefined multiplication generated NaN
WARNING: 0:14: '/' : Divide by zero during constant folding
ERROR: 0:14: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct66964 {
  mat3 f_3967[8];
  ivec3 f_4289[3];
  int f_5192[8];
};

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+((true || true) ? -1.0 : 2.0), +(true ? (0.0 - 1.0) : 0.0), (true ? (-2.0 - 2.0) : (+1.0 + (0.0 / -1.0))), (0.0 * (0.5 / 0.0)), ((1.0 - (false ? 2.0 : 1.0)) + ((true || false) ? (false ? 1.0 : 0.5) : (false ? 2.0 : 2.0))), ((-1.0 - (2.0 + 1.0)) / -1.0), (true ? +0.5 : 0.0), -+-1.0, 1.0, (!(false && false) ? ((-1.0 / 0.0) / 0.5) : (true ? -0.0 : +2.0)), 0.5, ((true ? 0.0 : (true ? 2.0 : 2.0)) - (true ? (true ? 2.0 : 1.0) : 1.0)), (false ? 1.0 : (false ? 0.0 : 2.0)), +((false ? true : false) ? 1.0 : (1.0 / 2.0)), ((0.5 + 0.0) / (0.5 * 1.0)), 0.0);

vec4 color;

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  color = vec4(vec3(any(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.07692307692307
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? +(false ? 2.0 : 0.5) : 0.0), 0.0, -1.0, 1.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
63.26530612244898
Processing this: /home/oof/webgl_cleaned/preprocess10_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
   gl_FragColor = vec4(1);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n   gl_FragColor = vec4(1);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  gl_FragColor = vec4(1);
}


As vertex? : False
SUCCESS!
63.45177664974619
Processing this: /home/oof/webgl_cleaned/struct_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	gl_FragColor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tgl_FragColor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -0.5, -0.5, 2.0);

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  gl_FragColor = vec4(vec3(((((((((s.a[0] + s.a[1]) + s.a[2]) + s.a[3]) + s.b[0]) + s.b[1]) + s.b[2]) + s.b[3]) / 250.0)) , 1.0);
}


As vertex? : False
SUCCESS!
63.63636363636363
Processing this: /home/oof/webgl_cleaned/22f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec2 color[2];
void main ()
{
	gl_FragColor = vec4 (color[0][0], color[0][1], color[1][0], color[1][1]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec2 color[2];\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0], color[0][1], color[1][0], color[1][1]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec2 color[2];

void main()
{
  color = vec4(color[0][0] , color[0][1] , color[1][0]);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a uniform "color")
ERROR: 0:8: '=' : array / non-array mismatch
ERROR: 0:8: 'assign' : cannot convert from 'const 4-component vector of float' to 'uniform mediump array[2] of 2-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec2 color[2];

void main()
{
  color = vec4(color[0][0] , color[0][1] , color[1][0]);
}


==============================
63.31658291457286
Processing this: /home/oof/webgl_cleaned/clamp_float_frag_xvary_yconstquarter.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	float c = color.r;
	gl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(clamp(c, min_c, max_c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  float c = color.r;
  gl_FragColor = vec4(clamp(c , min_c , max_c) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.5
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(notEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(notEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct50000 {
  bool f_8550;
  bool f_5715;
  vec4 f_285;
  bool f_166[1];
  float f_5613;
  uint f_6037;
};

vec4 color = vec4(+-1.0, ((+0.5 - +0.0) / (true ? 0.5 : 0.0)), 1.0, 1.0);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct50000 {
  bool f_8550;
  bool f_5715;
  vec4 f_285;
  bool f_166[1];
  float f_5613;
  uint f_6037;
};

vec4 color = vec4(+-1.0, ((+0.5 - +0.0) / (true ? 0.5 : 0.0)), 1.0, 1.0);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


==============================
63.18407960199005
Processing this: /home/oof/webgl_cleaned/reflect_vec3_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	gl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tgl_FragColor = vec4((reflect(v1, v2) + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = ivec2(0.0, -0.5)(color);
  gl_FragColor = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'assign' : cannot convert from 'const 2-component vector of int' to 'mediump float'
ERROR: 0:15: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = ivec2(0.0, -0.5)(color);
  gl_FragColor = vec4(((reflect(v1 , v2) + 1.0) / 2.0) , 1.0);
}


==============================
62.87128712871287
Mutations attempted: 202
Valid mutations:     127
Success rate:        62.87%
Processing this: /home/oof/webgl_cleaned/gl_MaxCombinedTextureImageUnits_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(float(gl_MaxCombinedTextureImageUnits) / 8.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(float(gl_MaxCombinedTextureImageUnits) / 8.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, (2.0 + (!true ? (true ? 2.0 : 0.0) : 1.0)), 1.0, ((0.5 * (true ? 0.0 : 1.0)) - 0.5))((float(gl_MaxCombinedTextureImageUnits) / 8.5));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, (2.0 + (!true ? (true ? 2.0 : 0.0) : 1.0)), 1.0, ((0.5 * (true ? 0.0 : 1.0)) - 0.5))((float(gl_MaxCombinedTextureImageUnits) / 8.5));
}


==============================
62.5615763546798
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par[3])
{
	set_all(par, 0);
	return 1;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par[3])\n{\n\tset_all(par, 0);\n\treturn 1;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
62.5615763546798
Processing this: /home/oof/webgl_cleaned/refract_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.745098039215684
Processing this: /home/oof/webgl_cleaned/int_empty_in_int_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(in int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(in int par[3])
{
	if(is_all(par, 1))
	{
		set_all(par, 0);
		return 1;
	}
	else
		return 0;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(in int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(in int par[3])\n{\n\tif(is_all(par, 1))\n\t{\n\t\tset_all(par, 0);\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
62.745098039215684
Processing this: /home/oof/webgl_cleaned/refract_vec2_frag_ivarynconst.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	gl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tgl_FragColor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.0, 0.5, 1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  gl_FragColor = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.926829268292686
Processing this: /home/oof/webgl_cleaned/refract_vec2_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 v1;
	vec2 v2 = normalize(vec2(1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 v1;\n\tvec2 v2 = normalize(vec2(1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(-1.0, 0.5, (true ? -(2.0 / 0.5) : 0.0), 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 v1;
  vec2 v2 = normalize(vec2(1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.10679611650486
Processing this: /home/oof/webgl_cleaned/mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x;
	mat4 a = mat4(   1.0,    2.0,     4.0,     8.0,
	                16.0,   32.0,    64.0,   128.0,
	               256.0,  512.0,  1024.0,  2048.0,
	              4096.0, 8192.0, 16384.0, 32768.0);
	bool elms = true;
	if(a[0][0] !=     1.0) elms = false;
	if(a[0][1] !=     2.0) elms = false;
	if(a[0][2] !=     4.0) elms = false;
	if(a[0][3] !=     8.0) elms = false;
	if(a[1][0] !=    16.0) elms = false;
	if(a[1][1] !=    32.0) elms = false;
	if(a[1][2] !=    64.0) elms = false;
	if(a[1][3] !=   128.0) elms = false;
	if(a[2][0] !=   256.0) elms = false;
	if(a[2][1] !=   512.0) elms = false;
	if(a[2][2] !=  1024.0) elms = false;
	if(a[2][3] !=  2048.0) elms = false;
	if(a[3][0] !=  4096.0) elms = false;
	if(a[3][1] !=  8192.0) elms = false;
	if(a[3][2] != 16384.0) elms = false;
	if(a[3][3] != 32768.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 4369.0-0.1 || x > 4369.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 8738.0-0.1 || x > 8738.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 17476.0-0.1 || x > 17476.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 34952.0-0.1 || x > 34952.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 15.0-0.1 || x > 15.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 240.0-0.1 || x > 240.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 3840.0-0.1 || x > 3840.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 61440.0-0.1 || x > 61440.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x;\n\tmat4 a = mat4(   1.0,    2.0,     4.0,     8.0,\n\t                16.0,   32.0,    64.0,   128.0,\n\t               256.0,  512.0,  1024.0,  2048.0,\n\t              4096.0, 8192.0, 16384.0, 32768.0);\n\tbool elms = true;\n\tif(a[0][0] !=     1.0) elms = false;\n\tif(a[0][1] !=     2.0) elms = false;\n\tif(a[0][2] !=     4.0) elms = false;\n\tif(a[0][3] !=     8.0) elms = false;\n\tif(a[1][0] !=    16.0) elms = false;\n\tif(a[1][1] !=    32.0) elms = false;\n\tif(a[1][2] !=    64.0) elms = false;\n\tif(a[1][3] !=   128.0) elms = false;\n\tif(a[2][0] !=   256.0) elms = false;\n\tif(a[2][1] !=   512.0) elms = false;\n\tif(a[2][2] !=  1024.0) elms = false;\n\tif(a[2][3] !=  2048.0) elms = false;\n\tif(a[3][0] !=  4096.0) elms = false;\n\tif(a[3][1] !=  8192.0) elms = false;\n\tif(a[3][2] != 16384.0) elms = false;\n\tif(a[3][3] != 32768.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 4369.0-0.1 || x > 4369.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 8738.0-0.1 || x > 8738.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 17476.0-0.1 || x > 17476.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 34952.0-0.1 || x > 34952.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 15.0-0.1 || x > 15.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 240.0-0.1 || x > 240.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 3840.0-0.1 || x > 3840.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 61440.0-0.1 || x > 61440.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0 , 512.0 , 1024.0 , 2048.0 , 4096.0 , 8192.0 , 16384.0 , 32768.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 4.0))
    elms = false;
  if ((a[0][3] != 8.0))
    elms = false;
  if ((a[1][0] != 16.0))
    elms = false;
  if ((a[-15][1] != 32.0))
    elms = false;
  if ((a[1][2] != 64.0))
    elms = false;
  if ((a[1][3] != 128.0))
    elms = false;
  if ((a[2][0] != 256.0))
    elms = false;
  if ((a[2][1] != 512.0))
    elms = false;
  if ((a[2][2] != 1024.0))
    elms = false;
  if ((a[2][3] != 2048.0))
    elms = false;
  if ((a[3][0] != 4096.0))
    elms = false;
  if ((a[3][1] != 8192.0))
    elms = false;
  if ((a[3][2] != 16384.0))
    elms = false;
  if ((a[3][3] != 32768.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (4369.0 - 0.1)) || (x > (4369.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (8738.0 - 0.1)) || (x > (8738.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (17476.0 - 0.1)) || (x > (17476.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (34952.0 - 0.1)) || (x > (34952.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (240.0 - 0.1)) || (x > (240.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (3840.0 - 0.1)) || (x > (3840.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (61440.0 - 0.1)) || (x > (61440.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:25: '[]' : index expression is negative

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float x;
  mat4 a = mat4(1.0 , 2.0 , 4.0 , 8.0 , 16.0 , 32.0 , 64.0 , 128.0 , 256.0 , 512.0 , 1024.0 , 2048.0 , 4096.0 , 8192.0 , 16384.0 , 32768.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 4.0))
    elms = false;
  if ((a[0][3] != 8.0))
    elms = false;
  if ((a[1][0] != 16.0))
    elms = false;
  if ((a[-15][1] != 32.0))
    elms = false;
  if ((a[1][2] != 64.0))
    elms = false;
  if ((a[1][3] != 128.0))
    elms = false;
  if ((a[2][0] != 256.0))
    elms = false;
  if ((a[2][1] != 512.0))
    elms = false;
  if ((a[2][2] != 1024.0))
    elms = false;
  if ((a[2][3] != 2048.0))
    elms = false;
  if ((a[3][0] != 4096.0))
    elms = false;
  if ((a[3][1] != 8192.0))
    elms = false;
  if ((a[3][2] != 16384.0))
    elms = false;
  if ((a[3][3] != 32768.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (4369.0 - 0.1)) || (x > (4369.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (8738.0 - 0.1)) || (x > (8738.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (17476.0 - 0.1)) || (x > (17476.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (34952.0 - 0.1)) || (x > (34952.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (15.0 - 0.1)) || (x > (15.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (240.0 - 0.1)) || (x > (240.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (3840.0 - 0.1)) || (x > (3840.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (61440.0 - 0.1)) || (x > (61440.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.80193236714976
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c) / 32.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = color.rg;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.980769230769226
Processing this: /home/oof/webgl_cleaned/exp2_vec3_vert_xvaryneg.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = -gtf_Color.rgb;
	color = vec4(exp2(5.0 * c), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -gtf_Color.rgb;\n\tcolor = vec4(exp2(5.0 * c), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, 0.0, +-1.0, (((true && true) ? 1.0 : 1.0) + (false ? (0.0 - 1.0) : -1.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = -gtf_Color.rgb;
  color = vec4(exp2((5.0 * c)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.1578947368421
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = (gtf_Color.rgb + 0.01) / 1.01;
	color = vec4(log(c) / -4.61, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (gtf_Color.rgb + 0.01) / 1.01;\n\tcolor = vec4(log(c) / -4.61, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (-1.0 + -0.5) : (0.0 / (0.0 + 0.5))), ((true ? (false ? 1.0 : 0.5) : (true ? 1.0 : 0.0)) + -1.0), 0.5, +0.5, (((false ? true : false) && (true ? false : true)) ? +0.0 : -1.0), (-1.0 - ((2.0 - 0.5) + 2.0)), -2.0, 2.0, -1.0, 1.0, (((1.0 * 2.0) + -2.0) / 0.5), 1.0, +((true ? 2.0 : 1.0) + 0.0), -(!true ? (true ? 1.0 : 1.0) : 2.0), -+2.0, 2.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((true ? (-1.0 + -0.5) : (0.0 / (0.0 + 0.5))), ((true ? (false ? 1.0 : 0.5) : (true ? 1.0 : 0.0)) + -1.0), 0.5, +0.5, (((false ? true : false) && (true ? false : true)) ? +0.0 : -1.0), (-1.0 - ((2.0 - 0.5) + 2.0)), -2.0, 2.0, -1.0, 1.0, (((1.0 * 2.0) + -2.0) / 0.5), 1.0, +((true ? 2.0 : 1.0) + 0.0), -(!true ? (true ? 1.0 : 1.0) : 2.0), -+2.0, 2.0);

vec4 color;

void main()
{
  vec3 c = ((gtf_Color.rgb + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.857142857142854
Mutations attempted: 210
Valid mutations:     132
Success rate:        62.86%
Processing this: /home/oof/webgl_cleaned/equal_ivec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(equal(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(equal(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(equal(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.03317535545023
Processing this: /home/oof/webgl_cleaned/vec4_zwxy_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.zwxy;
	vec4 a = vec4(m.z, m.w, m.x, m.y);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.zwxy;\n\tvec4 a = vec4(m.z, m.w, m.x, m.y);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.zwxy;
  vec4 a = vec4(m.z , m.w , m.x , m.y);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
63.20754716981132
Processing this: /home/oof/webgl_cleaned/cross_vec3_frag_xvaryyconst_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = vec3(1.0, 0.0, 0.0);
	vec3 v3;
	float theta = color.g * 2.0 * M_PI;
	float phi = color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	v3.x = v1.y * v2.z - v2.y * v1.z;
	v3.y = v2.x * v1.z - v1.x * v2.z;
	v3.z = v1.x * v2.y - v2.x * v1.y;
	gl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = vec3(1.0, 0.0, 0.0);\n\tvec3 v3;\n\tfloat theta = color.g * 2.0 * M_PI;\n\tfloat phi = color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tv3.x = v1.y * v2.z - v2.y * v1.z;\n\tv3.y = v2.x * v1.z - v1.x * v2.z;\n\tv3.z = v1.x * v2.y - v2.x * v1.y;\n\tgl_FragColor = vec4((v3 + 1.0) / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1 = (!(true ? true : true) ? vec3(+2.0, -((true ? 0.5 : -1.0) / (true ? 0.5 : -1.0)), 2.0) : vec3((true ? (-1.0 + 0.5) : -(0.5 * 1.0)), ((true ? true : false) ? ((false || false) ? (false ? 0.5 : 0.5) : -1.0) : +(true ? -1.0 : 0.5)), 0.5));
  vec3 v2 = vec3(1.0 , 0.0 , 0.0);
  vec3 v3;
  float theta = ((color.g * 2.0) * M_PI);
  float phi = ((color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  v3.x = ((v1.y * v2.z) - (v2.y * v1.z));
  v3.y = ((v2.x * v1.z) - (v1.x * v2.z));
  v3.z = ((v1.x * v2.y) - (v2.x * v1.y));
  gl_FragColor = vec4(((v3 + 1.0) / 2.0) , 1.0);
  ivec2(-6, 3);
}


As vertex? : False
SUCCESS!
63.38028169014085
Processing this: /home/oof/webgl_cleaned/log_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float x = 31.0 * gtf_Color.r + 1.0;
	float y = 0.0;
	float z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	color = vec4(y / 3.466, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat x = 31.0 * gtf_Color.r + 1.0;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tcolor = vec4(y / 3.466, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 2.0, 0.0, 2.0);

void main()
{
  float x = ((31.0 * gtf_Color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.55140186915887
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary01_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 x = (gtf_Color.rgb + 0.01) / 1.01;
	vec3 y = vec3(0.0);
	vec3 z;
	int n = 50;
	z = abs((x - 1.0) / (x + 1.0));
	vec3 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= -2.0;
	color = vec4(y / -4.61, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 x = (gtf_Color.rgb + 0.01) / 1.01;\n\tvec3 y = vec3(0.0);\n\tvec3 z;\n\tint n = 50;\n\tz = abs((x - 1.0) / (x + 1.0));\n\tvec3 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= -2.0;\n\tcolor = vec4(y / -4.61, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 x = ((gtf_Color.rgb + 0.01) / 0.505);
  vec3 y = vec3(0.0);
  vec3 z;
  int n = 50;
  z = abs(((x - 1.0) / (x + 1.0)));
  vec3 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= -2.0);
  color = vec4((y / -4.61) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
63.72093023255814
Processing this: /home/oof/webgl_cleaned/length_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(color.r), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(color.r), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(color.r));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(vec3(color.r));
}


==============================
63.42592592592593
Processing this: /home/oof/webgl_cleaned/const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.05)) || (vec4(((false ? 1.0 : 0.5) * 1.0), (0.5 - 0.0), (((true ? true : false) ? !true : (true && false)) ? 0.0 : 2.0), 1.0) > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: '>' : comparison operator only defined for scalars
ERROR: 0:22: '>' : wrong operand types - no operation '>' exists that takes a left-hand operand of type 'const 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.05)) || (vec4(((false ? 1.0 : 0.5) * 1.0), (0.5 - 0.0), (((true ? true : false) ? !true : (true && false)) ? 0.0 : 2.0), 1.0) > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
63.133640552995395
Processing this: /home/oof/webgl_cleaned/vec3_tsp_1vec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.stp;
	vec3 t = m.tsp;
	vec4 a = vec4(t.t, t.s, t.p ,al.q);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.stp;\n\tvec3 t = m.tsp;\n\tvec4 a = vec4(t.t, t.s, t.p ,al.q);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, -0.5, 1.0, 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.stp;
  vec3 t = m.tsp;
  vec4 a = vec4(t.t , t.s , t.p , al.q);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
63.30275229357798
Processing this: /home/oof/webgl_cleaned/inversesqrt_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg * 99.0) + 1.0;
	gl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg * 99.0) + 1.0;\n\tgl_FragColor = vec4(1.0 / sqrt(c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((0.5 - 0.5) / -1.0), (true ? (1.0 - 2.0) : 2.0), -(false ? +1.0 : (2.0 / 0.0)), 1.0);

void main()
{
  vec2 c = ((color.rg * 99.0) + 1.0);
  gl_FragColor = vec4((1.0 / sqrt(c)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.4703196347032
Processing this: /home/oof/webgl_cleaned/vec3_xy_z_1vec2_1float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec2 t = m.xy;
	float k = m.z;
	vec4 a = vec4(t, k, lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec2 t = m.xy;\n\tfloat k = m.z;\n\tvec4 a = vec4(t, k, lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, 2.0, (+0.0 / (true ? 0.5 : -2.0)), (!(true ? false : false) ? 2.0 : (-1.0 - -2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec2 t = m.xy;
  float k = m.z;
  vec4 a = vec4(t , k , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
63.63636363636363
Mutations attempted: 220
Valid mutations:     140
Success rate:        63.64%
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvaryyvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 x = 2.0 * (color.ggg - 0.5);
	vec3 y = 2.0 * (color.bbb - 0.5);
	vec3 c;
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		if(x[0] < 0.0 ^^ y[0] < 0.0)
		{
			sign[0] = -1.0;
		}
		if(abs(y[0]) <= abs(x[0]))
		{
			c[0] = abs(y[0] / x[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[0] = abs(x[0] / y[0]);
			atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
			scale[0] *= -1.0;
			atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
			scale[0] *= -1.0;
			result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;
		}
		if(x[0] < 0.0)
			if(y[0] < 0.0) result[0] -= 0.5;
			else if(y[0] > 0.0) result[0] += 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		if(x[1] < 0.0 ^^ y[1] < 0.0)
		{
			sign[1] = -1.0;
		}
		if(abs(y[1]) <= abs(x[1]))
		{
			c[1] = abs(y[1] / x[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[1] = abs(x[1] / y[1]);
			atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
			scale[1] *= -1.0;
			atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
			scale[1] *= -1.0;
			result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;
		}
		if(x[1] < 0.0)
			if(y[1] < 0.0) result[1] -= 0.5;
			else if(y[1] > 0.0) result[1] += 0.5;
	}
	if(x[2] > epsilon || abs(y[2]) > epsilon)
	{
		if(x[2] < 0.0 ^^ y[2] < 0.0)
		{
			sign[2] = -1.0;
		}
		if(abs(y[2]) <= abs(x[2]))
		{
			c[2] = abs(y[2] / x[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;
		}
		else
		{
			c[2] = abs(x[2] / y[2]);
			atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
			scale[2] *= -1.0;
			atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
			scale[2] *= -1.0;
			result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;
		}
		if(x[2] < 0.0)
			if(y[2] < 0.0) result[2] -= 0.5;
			else if(y[2] > 0.0) result[2] += 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 x = 2.0 * (color.ggg - 0.5);\n\tvec3 y = 2.0 * (color.bbb - 0.5);\n\tvec3 c;\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tif(x[0] < 0.0 ^^ y[0] < 0.0)\n\t\t{\n\t\t\tsign[0] = -1.0;\n\t\t}\n\t\tif(abs(y[0]) <= abs(x[0]))\n\t\t{\n\t\t\tc[0] = abs(y[0] / x[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * atan_c[0] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[0] = abs(x[0] / y[0]);\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\t\tscale[0] *= -1.0;\n\t\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\t\tscale[0] *= -1.0;\n\t\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[0] < 0.0)\n\t\t\tif(y[0] < 0.0) result[0] -= 0.5;\n\t\t\telse if(y[0] > 0.0) result[0] += 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tif(x[1] < 0.0 ^^ y[1] < 0.0)\n\t\t{\n\t\t\tsign[1] = -1.0;\n\t\t}\n\t\tif(abs(y[1]) <= abs(x[1]))\n\t\t{\n\t\t\tc[1] = abs(y[1] / x[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * atan_c[1] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[1] = abs(x[1] / y[1]);\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\t\tscale[1] *= -1.0;\n\t\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\t\tscale[1] *= -1.0;\n\t\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[1] < 0.0)\n\t\t\tif(y[1] < 0.0) result[1] -= 0.5;\n\t\t\telse if(y[1] > 0.0) result[1] += 0.5;\n\t}\n\tif(x[2] > epsilon || abs(y[2]) > epsilon)\n\t{\n\t\tif(x[2] < 0.0 ^^ y[2] < 0.0)\n\t\t{\n\t\t\tsign[2] = -1.0;\n\t\t}\n\t\tif(abs(y[2]) <= abs(x[2]))\n\t\t{\n\t\t\tc[2] = abs(y[2] / x[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * atan_c[2] / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tc[2] = abs(x[2] / y[2]);\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\t\tscale[2] *= -1.0;\n\t\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\t\tscale[2] *= -1.0;\n\t\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / (2.0 * M_PI) + 0.5;\n\t\t}\n\t\tif(x[2] < 0.0)\n\t\t\tif(y[2] < 0.0) result[2] -= 0.5;\n\t\t\telse if(y[2] > 0.0) result[2] += 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 x = (2.0 * (color.ggg - 0.5));
  vec3 y = (2.0 * (color.bbb - 0.5));
  vec3 c;
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    if (((x[0] < 0.0) ^^ (y[0] < 0.0)))
    {
      sign[0] = -1.0;
    }
    if ((abs(y[0]) <= abs(x[0])))
    {
      c[0] = abs((y[0] / x[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * atan_c[0]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[0] = abs((x[0] / y[0]));
      (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
      (scale[0] *= -1.0);
      (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
      (scale[0] *= -1.0);
      result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[0] < 0.0))
      if ((y[0] < 0.0))
        (result[0] -= 0.5);
      else
        if ((y[0] > 0.0))
          (result[0] += 0.5);
  }
  if (((x[1] > epsilon) || (abs(y[1]) > epsilon)))
  {
    if (((x[1] < 0.0) ^^ (y[1] < 0.0)))
    {
      sign[1] = -1.0;
    }
    if ((abs(y[1]) <= abs(x[1])))
    {
      c[1] = abs((y[1] / x[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * atan_c[1]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[1] = abs((x[1] / y[1]));
      (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
      (scale[1] *= -1.0);
      (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
      (scale[1] *= -1.0);
      result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[1] < 0.0))
      if ((y[1] < 0.0))
        (result[1] -= 0.5);
      else
        if ((y[1] > 0.0))
          (result[1] += 0.5);
  }
  if (((x[2] > epsilon) || (abs(y[2]) > epsilon)))
  {
    if (((x[2] < 0.0) ^^ (y[2] < 0.0)))
    {
      sign[2] = -1.0;
    }
    if ((abs(y[2]) <= abs(x[2])))
    {
      c[2] = abs((y[2] / x[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * atan_c[2]) / (2.0 * M_PI)) + 0.5);
    }
    else
    {
      c[2] = abs((x[2] / y[2]));
      (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
      (scale[2] *= -1.0);
      (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
      (scale[2] *= -1.0);
      result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / (2.0 * M_PI)) + 0.5);
    }
    if ((x[2] < 0.0))
      if ((y[2] < 0.0))
        (result[2] -= 0.5);
      else
        if ((y[2] > 0.0))
          (result[2] += 0.5);
  }
  gl_FragColor = color;
}


As vertex? : False
SUCCESS!
63.80090497737556
Processing this: /home/oof/webgl_cleaned/simple.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute float gtf_Color;
varying vec4 tc;
void main ()
{
	tc = vec4(gtf_Color, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute float gtf_Color;\nvarying vec4 tc;\nvoid main ()\n{\n\ttc = vec4(gtf_Color, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

float gtf_Color;

vec4 tc = vec4(1.0, 2.0, (true ? (+1.0 / 2.0) : (!true ? 2.0 : -gtf_Color)), gtf_Color);

void main()
{
  tc = vec4(gtf_Color , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

float gtf_Color;

vec4 tc = vec4(1.0, 2.0, (true ? (+1.0 / 2.0) : (!true ? 2.0 : -gtf_Color)), gtf_Color);

void main()
{
  tc = vec4(gtf_Color , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
63.51351351351351
Processing this: /home/oof/webgl_cleaned/matrixMultComp_mat3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	mat3 m1 = mat3(color.rgb, color.rgb, color.rgb);
	mat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);
	mat3 m3 = mat3(0.0);
	vec3 result = vec3(0.0, 0.0, 0.0);
	m3 = matrixCompMult(m1, m2);
	result[0] += m3[0][0];
	result[0] += m3[0][1];
	result[0] += m3[0][2];
	result[1] += m3[1][0];
	result[1] += m3[1][1];
	result[1] += m3[1][2];
	result[2] += m3[2][0];
	result[2] += m3[2][1];
	result[2] += m3[2][2];
	gl_FragColor = vec4(result / 2.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tmat3 m1 = mat3(color.rgb, color.rgb, color.rgb);\n\tmat3 m2 = mat3(1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0);\n\tmat3 m3 = mat3(0.0);\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tm3 = matrixCompMult(m1, m2);\n\tresult[0] += m3[0][0];\n\tresult[0] += m3[0][1];\n\tresult[0] += m3[0][2];\n\tresult[1] += m3[1][0];\n\tresult[1] += m3[1][1];\n\tresult[1] += m3[1][2];\n\tresult[2] += m3[2][0];\n\tresult[2] += m3[2][1];\n\tresult[2] += m3[2][2];\n\tgl_FragColor = vec4(result / 2.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  mat3 m1 = mat3(color.rgb , color.rgb , color.rgb);
  mat3 m2 = mat3(1.0 , 0.5 , 0.5 , 0.5 , 1.0 , 0.5 , 0.5 , 0.5 , 1.0);
  mat3 m3 = mat3(0.0);
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  m3 = matrixCompMult(m1 , m2);
  (result[0] += m3[0][0]);
  (result[0] += m3[0][1]);
  (result[0] += m3[0][2]);
  (result[1] += m3[1][0]);
  (result[1] += m3[1][1]);
  (result[1] += m3[1][2]);
  (result[2] += m3[2][0]);
  (result[2] += m3[2][1]);
  (result[2] += m3[2][2]);
  gl_FragColor = vec4((result / 2.0) , 1.0);
}


As vertex? : False
SUCCESS!
63.67713004484305
Processing this: /home/oof/webgl_cleaned/step_vec3_frag_xvary_edgeconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 edge = vec3(0.5, 0.5, 0.5);
	gl_FragColor = vec4(step(edge, color.rgb), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge = vec3(0.5, 0.5, 0.5);\n\tgl_FragColor = vec4(step(edge, color.rgb), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, (true ? -1.0 : 0.5), 2.0, 2.0);

void main()
{
  const vec3 edge = vec3(0.5 , 0.5 , 0.5);
  gl_FragColor = vec4(step(edge , color.rgb) , 1.0);
}


As vertex? : False
SUCCESS!
63.83928571428571
Processing this: /home/oof/webgl_cleaned/fwidth_frag_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.0
Processing this: /home/oof/webgl_cleaned/notEqual_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(notEqual(c, vec3(0.0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(notEqual(c, vec3(0.0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, -0.5, 0.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(notEqual(c , vec3(0.0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
64.15929203539822
Processing this: /home/oof/webgl_cleaned/simple.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 tc;
void main ()
{
	gl_FragColor = tc;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 tc;\nvoid main ()\n{\n\tgl_FragColor = tc;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 tc = vec4(1.0, ((!true ? (true ? 1.0 : 1.0) : (true ? 0.0 : 2.0)) * -1.0), +--0.5, -2.0);

void main()
{
  gl_FragColor = tc;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 tc = vec4(1.0, ((!true ? (true ? 1.0 : 1.0) : (true ? 0.0 : 2.0)) * -1.0), +--0.5, -2.0);

void main()
{
  gl_FragColor = tc;
}


==============================
63.87665198237885
Processing this: /home/oof/webgl_cleaned/for_break_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count = 0;
        for(int i=0;i<5;i++)
	{
	  count++;
	  if(count == 3)
            break;
	}
	float gray;
	if( count == 3)
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint count = 0;\n        for(int i=0;i<5;i++)\n\t{\n\t  count++;\n\t  if(count == 3)\n            break;\n\t}\n\tfloat gray;\n\tif( count == 3)\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.5, 0.5, 0.0);

void main()
{
  int count = 0;
  for (int i = 0; (i < 5); i++)
  {
    count++;
    if ((count == 3))
      break;
  }
  float gray;
  if ((count == 3))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
64.03508771929825
Processing this: /home/oof/webgl_cleaned/exp2_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = color.rgb;
	gl_FragColor = vec4(exp2(5.0 * c) / 32.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(exp2(5.0 * c) / 32.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = color.rgb;
  gl_FragColor = vec4((exp2((5.0 * c)) / 32.0));
}


==============================
63.75545851528385
Processing this: /home/oof/webgl_cleaned/qualifiers_struct_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	float a;
	float b;
	float c;
	float d;
};
sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,
sabcd e)
{
        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
        b = a;
        c.a += d.a;
        c.b += d.b;
        c.c += d.c;
        c.d += d.d;
        a.a += one.a;
        a.b += one.b;
        a.c += one.c;
        a.d += one.d;
        return e;
}
void main ()
{
	sabcd a = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd b = sabcd(2.0, 2.0, 2.0, 2.0);
	sabcd c = sabcd(3.0, 3.0, 3.0, 3.0);
	sabcd d = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd e = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd f = sabcd(0.0, 0.0, 0.0, 0.0);
	sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);
	sabcd four = sabcd(4.0, 4.0, 4.0, 4.0);
	sabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);
	float q = 0.0;
	float q2 = 0.0;
	f = qualifiers(a, b, c, d, e);
	if(a == one) q += 1.0;
	if(b == one) q += 2.0;
	if(c == seven) q += 4.0;
	if(d == four) q2 += 1.0;
	if(e == one) q2 += 2.0;
	if(f == one) q2 += 4.0;
	gl_FragColor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tfloat a;\n\tfloat b;\n\tfloat c;\n\tfloat d;\n};\nsabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d,\nsabcd e)\n{\n        sabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n        b = a;\n        c.a += d.a;\n        c.b += d.b;\n        c.c += d.c;\n        c.d += d.d;\n        a.a += one.a;\n        a.b += one.b;\n        a.c += one.c;\n        a.d += one.d;\n        return e;\n}\nvoid main ()\n{\n\tsabcd a = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd b = sabcd(2.0, 2.0, 2.0, 2.0);\n\tsabcd c = sabcd(3.0, 3.0, 3.0, 3.0);\n\tsabcd d = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd e = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd f = sabcd(0.0, 0.0, 0.0, 0.0);\n\tsabcd one = sabcd(1.0, 1.0, 1.0, 1.0);\n\tsabcd four = sabcd(4.0, 4.0, 4.0, 4.0);\n\tsabcd seven = sabcd(7.0, 7.0, 7.0, 7.0);\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\tf = qualifiers(a, b, c, d, e);\n\tif(a == one) q += 1.0;\n\tif(b == one) q += 2.0;\n\tif(c == seven) q += 4.0;\n\tif(d == four) q2 += 1.0;\n\tif(e == one) q2 += 2.0;\n\tif(f == one) q2 += 4.0;\n\tgl_FragColor = vec4(vec2(q / 7.0, q2 / 7.0), 1.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  float a;
  float b;
  float c;
  float d;
};

sabcd qualifiers(in sabcd a, out sabcd b, inout sabcd c, const in sabcd d, sabcd e)
{
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  b = a;
  (c.a += d.a);
  (c.b += d.b);
  (c.c += d.c);
  (c.d += d.d);
  (a.a += one.a);
  (a.b += one.b);
  (a.c += one.c);
  (a.d += one.d);
  return e;
}

void main()
{
  sabcd a = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd b = sabcd(2.0 , 2.0 , 2.0 , 2.0);
  sabcd c = sabcd(3.0 , 3.0 , 3.0 , 3.0);
  sabcd d = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd e = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd f = sabcd(0.0 , 0.0 , 0.0 , 0.0);
  sabcd one = sabcd(1.0 , 1.0 , 1.0 , 1.0);
  sabcd four = sabcd(4.0 , 4.0 , 4.0 , 4.0);
  sabcd seven = sabcd(7.0 , 7.0 , 7.0 , 7.0);
  float q = 0.0;
  float q2 = 0.0;
  f = qualifiers(a , b , c , d , e);
  if ((a == one))
    (q += 1.0);
  if ((b == one))
    (q += 2.0);
  if ((c == seven))
    (q += 4.0);
  if ((d == four))
    (q2 += 1.0);
  if ((e == one))
    (q2 += 2.0);
  if ((f == one))
    (q2 += 4.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 7.0)) , 1.0 , 1.0);
}


As vertex? : False
SUCCESS!
63.91304347826087
Mutations attempted: 230
Valid mutations:     147
Success rate:        63.91%
Processing this: /home/oof/webgl_cleaned/default.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
	gl_PointSize = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n\tgl_PointSize = 1.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((0.0 + +-1.0), 2.0, (1.0 + 0.5), (-1.0 * 2.0));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  gl_PointSize = 1.0;
}


As vertex? : True
SUCCESS!
64.06926406926407
Processing this: /home/oof/webgl_cleaned/3m_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform mat3 color;
void main ()
{
	gl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2],
						 color[1][0] + color[1][1] + color[1][2],
						 color[2][0] + color[2][1] + color[2][2],
						 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform mat3 color;\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2],\n\t\t\t\t\t\t color[1][0] + color[1][1] + color[1][2],\n\t\t\t\t\t\t color[2][0] + color[2][1] + color[2][2],\n\t\t\t\t\t\t 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat3 color;

void main()
{
  color = vec4(((color[0][0] + color[0][1]) + color[0][2]) , ((color[1][0] + color[1][1]) + color[1][2]) , ((color[2][0] + color[2][1]) + color[2][2]));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
ERROR: 0:8: 'assign' : l-value required (can't modify a uniform "color")
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: 'assign' : cannot convert from 'const 4-component vector of float' to 'uniform mediump 3X3 matrix of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat3 color;

void main()
{
  color = vec4(((color[0][0] + color[0][1]) + color[0][2]) , ((color[1][0] + color[1][1]) + color[1][2]) , ((color[2][0] + color[2][1]) + color[2][2]));
}


==============================
63.793103448275865
Processing this: /home/oof/webgl_cleaned/notEqual_ivec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 ne(in ivec3 a, in ivec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(ne(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 ne(in ivec3 a, in ivec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(ne(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((-1.0 * (0.5 * -1.0)), 0.5, 0.0, 1.0);

bvec3 ne(in ivec3 a, in ivec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(ne(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
63.94849785407726
Processing this: /home/oof/webgl_cleaned/min_vec3_frag_xvary_yconsthalf.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec3 min_c = vec3(0.5, 0.5, 0.5);
	vec3 c = color.rgb;
	gl_FragColor = vec4(min(c, min_c), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 min_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = color.rgb;\n\tgl_FragColor = vec4(min(c, min_c), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5);
  vec3 c = color.rgb;
  gl_FragColor = vec4(min(c , min_c) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5);
  vec3 c = color.rgb;
  gl_FragColor = vec4(min(c , min_c) , 1.0);
}


==============================
63.67521367521367
Processing this: /home/oof/webgl_cleaned/atan_float_frag_xvaryyvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float x = 2.0 * (color.g - 0.5);
	float y = 2.0 * (color.b - 0.5);
	const float epsilon = 1.0e-4;
	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
	if(x > epsilon || abs(y) > epsilon)
	{
		gl_FragColor = vec4(atan(y, x) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
	}
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat x = 2.0 * (color.g - 0.5);\n\tfloat y = 2.0 * (color.b - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x > epsilon || abs(y) > epsilon)\n\t{\n\t\tgl_FragColor = vec4(atan(y, x) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t}\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? -(true ? 1.0 : 0.5) : -1.0), 0.5, 0.0, (true ? (2.0 * (true ? 0.0 : 0.0)) : 1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  float x = (2.0 * (color.g - 0.5));
  float y = (2.0 * (color.b - 0.5));
  const float epsilon = 0.0001;
  gl_FragColor = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    gl_FragColor = vec4(((atan(y , x) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
  }
}


As vertex? : False
SUCCESS!
63.829787234042556
Processing this: /home/oof/webgl_cleaned/step_vec3_vert_xvary_edgeconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge = vec3(0.5, 0.5, 0.5);
	color = vec4(step(edge, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge = vec3(0.5, 0.5, 0.5);\n\tcolor = vec4(step(edge, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge = vec3(0.5 , 0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rgb) , 1.0);
  (gtf_ModelViewProjectionMatrix * gtf_Vertex) = gl_Position;
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'assign' :  l-value required

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 edge = vec3(0.5 , 0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rgb) , 1.0);
  (gtf_ModelViewProjectionMatrix * gtf_Vertex) = gl_Position;
}


==============================
63.559322033898304
Processing this: /home/oof/webgl_cleaned/notEqual_bvec3_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec3 ne(in bvec3 a, in bvec3 b)
{
	bvec3 result;
	if(a[0] != b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] != b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] != b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	vec3 result = vec3(ne(bvec3(c), bvec3(true)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec3 ne(in bvec3 a, in bvec3 b)\n{\n\tbvec3 result;\n\tif(a[0] != b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] != b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] != b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tvec3 result = vec3(ne(bvec3(c), bvec3(true)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec3 ne(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = vec3(ne(bvec3(c)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:27: 'ne' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec3 ne(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] != b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] != b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] != b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec3 result = vec3(ne(bvec3(c)));
  gl_FragColor = vec4(result , 1.0);
}


==============================
63.29113924050633
Processing this: /home/oof/webgl_cleaned/array_const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat2 a = mat2(1.0, 2.0, 3.0, 4.0);
	const mat2 b = mat2(5.0, 6.0, 7.0, 8.0);
	mat2 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat2 a = mat2(1.0, 2.0, 3.0, 4.0);\n\tconst mat2 b = mat2(5.0, 6.0, 7.0, 8.0);\n\tmat2 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat2 a = mat2(1.0 , 2.0 , 3.0 , 4.0);
  const mat2 b = mat2(5.0 , 6.0 , 7.0 , 8.0);
  mat2 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[3] == b)))
    gray = 1.0;
  else
    ivec2((1 % 5), 2) = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: '[]' : array index out of range
ERROR: 0:19: '%' : integer modulus operator supported in GLSL ES 3.00 and above only
ERROR: 0:19: 'assign' : l-value required (can't modify a const)
ERROR: 0:19: 'assign' : cannot convert from 'const float' to 'const 2-component vector of int'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat2 a = mat2(1.0 , 2.0 , 3.0 , 4.0);
  const mat2 b = mat2(5.0 , 6.0 , 7.0 , 8.0);
  mat2 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[3] == b)))
    gray = 1.0;
  else
    ivec2((1 % 5), 2) = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


==============================
63.02521008403361
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 x = 31.0 * gtf_Color.rg + 1.0;
	vec2 y = vec2(0.0);
	vec2 z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	vec2 p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0;
	color = vec4(y / 3.466, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 x = 31.0 * gtf_Color.rg + 1.0;\n\tvec2 y = vec2(0.0);\n\tvec2 z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tvec2 p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0;\n\tcolor = vec4(y / 3.466, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+2.0, 1.0, 0.5, 0.0, (+0.0 / 0.0), -1.0, (((false && true) || false) ? (false ? 0.5 : 2.0) : (false ? -1.0 : (0.0 / -1.0))), 2.0, -1.0, -1.0, (false ? ((0.5 / 0.0) * (0.5 * 2.0)) : 2.0), (true ? (2.0 - 1.0) : (false ? 0.5 : (false ? -1.0 : 0.5))), 0.5, (2.0 + (+2.0 * (-1.0 / 2.0))), (true ? (-1.0 + (true ? 0.0 : 0.5)) : 0.0), 0.0);

vec4 color;

void main()
{
  vec2 x = ((31.0 * gtf_Color.rg) + 1.0);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Zero divided by zero during constant folding generated NaN
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(+2.0, 1.0, 0.5, 0.0, (+0.0 / 0.0), -1.0, (((false && true) || false) ? (false ? 0.5 : 2.0) : (false ? -1.0 : (0.0 / -1.0))), 2.0, -1.0, -1.0, (false ? ((0.5 / 0.0) * (0.5 * 2.0)) : 2.0), (true ? (2.0 - 1.0) : (false ? 0.5 : (false ? -1.0 : 0.5))), 0.5, (2.0 + (+2.0 * (-1.0 / 2.0))), (true ? (-1.0 + (true ? 0.0 : 0.5)) : 0.0), 0.0);

vec4 color;

void main()
{
  vec2 x = ((31.0 * gtf_Color.rg) + 1.0);
  vec2 y = vec2(0.0);
  vec2 z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  vec2 p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= 2.0);
  color = vec4((y / 3.466) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.76150627615063
Processing this: /home/oof/webgl_cleaned/compressed_paletted_texture.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 gtf_TexCoord[1];
attribute vec4 gtf_MultiTexCoord0;
varying vec4 color;
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 gtf_TexCoord[1];\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(0.0, +0.5, 2.0, ((0.5 + 0.5) - --1.0));

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: '--' : l-value required (can't modify a const)
ERROR: 0:12: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_TexCoord[1];

vec4 gtf_MultiTexCoord0 = vec4(0.0, +0.5, 2.0, ((0.5 + 0.5) - --1.0));

vec4 color;

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.5
Mutations attempted: 240
Valid mutations:     150
Success rate:        62.50%
Processing this: /home/oof/webgl_cleaned/sin_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rgb) + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * sin(2.0 * M_PI * color.rgb) + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = (!false ? vec4(-1.0, --1.0, +(1.0 * 0.5), 0.5) : vec4(2.0, (-+1.0 + -(0.0 * 0.5)), (true ? +(true ? 0.0 : 1.0) : ((true ? 2.0 : -1.0) / (true ? 0.5 : 1.0))), -1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.rgb))) + 0.5) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = (!false ? vec4(-1.0, --1.0, +(1.0 * 0.5), 0.5) : vec4(2.0, (-+1.0 + -(0.0 * 0.5)), (true ? +(true ? 0.0 : 1.0) : ((true ? 2.0 : -1.0) / (true ? 0.5 : 1.0))), -1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * sin(((2.0 * M_PI) * color.rgb))) + 0.5) , 1.0);
}


==============================
62.24066390041494
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_vec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec2 gte(in vec2 a, in vec2 b)
{
	bvec2 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(gte(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec2 gte(in vec2 a, in vec2 b)\n{\n\tbvec2 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(gte(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec2 gte(in vec2 a, in vec2 b)
{
  bvec2 result = bvec2(-1.0, 0.0);
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(gte(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.396694214876035
Processing this: /home/oof/webgl_cleaned/normalize_float_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 tmp_Color = gtf_Color + vec4(0.25);
	color = vec4(normalize(tmp_Color.r), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 tmp_Color = gtf_Color + vec4(0.25);\n\tcolor = vec4(normalize(tmp_Color.r), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, (!false ? (false ? -0.5 : 0.5) : (false ? -1.0 : 0.0)), (((2.0 - -1.0) / 0.0) * 1.0), -0.0);

void main()
{
  vec4 tmp_Color = (gtf_Color + vec4(0.25));
  color = vec4(normalize(tmp_Color.r) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.55144032921811
Processing this: /home/oof/webgl_cleaned/vec3_xyz_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.xyz;
	vec4 a = vec4(m.xyz,lightloc.w);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.xyz;\n\tvec4 a = vec4(m.xyz,lightloc.w);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((true ? ((2.0 - -1.0) * 2.0) : (true ? (-1.0 + 0.5) : (true ? 0.0 : -1.0))), 1.0, --2.0, --1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec4 a = vec4(m.xyz , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((true ? ((2.0 - -1.0) * 2.0) : (true ? (-1.0 + 0.5) : (true ? 0.0 : -1.0))), 1.0, --2.0, --1.0);

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec3 m = lightloc.xyz;
  vec4 a = vec4(m.xyz , lightloc.w);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


==============================
62.295081967213115
Processing this: /home/oof/webgl_cleaned/degrees_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);
	gl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 2.0 * M_PI * 2.0 * (color.rg - 0.5);\n\tgl_FragColor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = (((2.0 * M_PI) * 2.0) * (color.rg - 0.5));
  gl_FragColor = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
62.44897959183674
Processing this: /home/oof/webgl_cleaned/fract_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);
	c = abs(fract(c) - 0.5) * 2.0;
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 10.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tc = abs(fract(c) - 0.5) * 2.0;\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4((true ? 0.0 : +(false ? 1.0 : -1.0)), ((true ? true : (true ? true : false)) ? 2.0 : -+1.0), -1.0, 0.5);

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((10.0 * 2.0) * (gtf_Color.rg - 0.5));
  c = (abs((fract(c) - 0.5)) * 2.0);
  color = vec4(c , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.601626016260155
Processing this: /home/oof/webgl_cleaned/degrees_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(degrees(c) / (2.0 * 360.0) + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((2.0 * M_PI) * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((2.0 * M_PI) * 2.0) * (color.rgb - 0.5));
  gl_FragColor = vec4(((degrees(c) / (2.0 * 360.0)) + 0.5));
}


==============================
62.34817813765182
Processing this: /home/oof/webgl_cleaned/log2_float_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const float ln2 = 0.69314718055994530941723212145818;
void main ()
{
	float x = 31.0 * color.r + 1.0;
	float y = 0.0;
	float z;
	int n = 50;
	z = (x - 1.0) / (x + 1.0);
	float p = z;
	for(int i = 1; i <= 101; i += 2)
	{
		y += p / float(i);
		p *= z * z;
	}
	y *= 2.0 / ln2;
	gl_FragColor = vec4(y / 5.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst float ln2 = 0.69314718055994530941723212145818;\nvoid main ()\n{\n\tfloat x = 31.0 * color.r + 1.0;\n\tfloat y = 0.0;\n\tfloat z;\n\tint n = 50;\n\tz = (x - 1.0) / (x + 1.0);\n\tfloat p = z;\n\tfor(int i = 1; i <= 101; i += 2)\n\t{\n\t\ty += p / float(i);\n\t\tp *= z * z;\n\t}\n\ty *= 2.0 / ln2;\n\tgl_FragColor = vec4(y / 5.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? ((true && false) ? (true ? 0.0 : ln2) : ln2) : -1.0), (true ? ln2 : -1.0), 1.0, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  float x = ((31.0 * color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (2.0 / ln2));
  gl_FragColor = vec4((y / 5.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'ln2' : undeclared identifier
ERROR: 0:4: 'ln2' : undeclared identifier
ERROR: 0:4: 'ln2' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(((false && false) ? ((true && false) ? (true ? 0.0 : ln2) : ln2) : -1.0), (true ? ln2 : -1.0), 1.0, 0.0);

const float ln2 = 0.6931471805599453;

void main()
{
  float x = ((31.0 * color.r) + 1.0);
  float y = 0.0;
  float z;
  int n = 50;
  z = ((x - 1.0) / (x + 1.0));
  float p = z;
  for (int i = 1; (i <= 101); (i += 2))
  {
    (y += (p / float(i)));
    (p *= (z * z));
  }
  (y *= (2.0 / ln2));
  gl_FragColor = vec4((y / 5.0) , 0.0 , 0.0 , 1.0);
}


==============================
62.096774193548384
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 4.0 * (gtf_Color.r);
	color = vec4(c * c / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 4.0 * (gtf_Color.r);\n\tcolor = vec4(c * c / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (4.0 * gtf_Color.r);
  color = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
62.24899598393574
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	gl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tgl_FragColor =  vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  gl_FragColor = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
}


As vertex? : False
SUCCESS!
62.4
Mutations attempted: 250
Valid mutations:     156
Success rate:        62.40%
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
vec4 function(out vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
vec4 function(out vec4 par)
{
	set_all(par, 0.0);
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvec4 function(out vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvec4 function(out vec4 par)\n{\n\tset_all(par, 0.0);\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
62.4
Processing this: /home/oof/webgl_cleaned/const_mat4_copy_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	mat4 b = a;
	bool elms = true;
	if(b[0][0] !=  1.0) elms = false;
	if(b[0][1] !=  2.0) elms = false;
	if(b[0][2] !=  3.0) elms = false;
	if(b[0][3] !=  4.0) elms = false;
	if(b[1][0] !=  5.0) elms = false;
	if(b[1][1] !=  6.0) elms = false;
	if(b[1][2] !=  7.0) elms = false;
	if(b[1][3] !=  8.0) elms = false;
	if(b[2][0] !=  9.0) elms = false;
	if(b[2][1] != 10.0) elms = false;
	if(b[2][2] != 11.0) elms = false;
	if(b[2][3] != 12.0) elms = false;
	if(b[3][0] != 13.0) elms = false;
	if(b[3][1] != 14.0) elms = false;
	if(b[3][2] != 15.0) elms = false;
	if(b[3][3] != 16.0) elms = false;
	bool rows = true;
	x = b[0][0] + b[1][0] + b[2][0] + b[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = b[0][1] + b[1][1] + b[2][1] + b[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = b[0][2] + b[1][2] + b[2][2] + b[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = b[0][3] + b[1][3] + b[2][3] + b[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = b[0][0] + b[0][1] + b[0][2] + b[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = b[1][0] + b[1][1] + b[1][2] + b[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = b[2][0] + b[2][1] + b[2][2] + b[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = b[3][0] + b[3][1] + b[3][2] + b[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tmat4 b = a;\n\tbool elms = true;\n\tif(b[0][0] !=  1.0) elms = false;\n\tif(b[0][1] !=  2.0) elms = false;\n\tif(b[0][2] !=  3.0) elms = false;\n\tif(b[0][3] !=  4.0) elms = false;\n\tif(b[1][0] !=  5.0) elms = false;\n\tif(b[1][1] !=  6.0) elms = false;\n\tif(b[1][2] !=  7.0) elms = false;\n\tif(b[1][3] !=  8.0) elms = false;\n\tif(b[2][0] !=  9.0) elms = false;\n\tif(b[2][1] != 10.0) elms = false;\n\tif(b[2][2] != 11.0) elms = false;\n\tif(b[2][3] != 12.0) elms = false;\n\tif(b[3][0] != 13.0) elms = false;\n\tif(b[3][1] != 14.0) elms = false;\n\tif(b[3][2] != 15.0) elms = false;\n\tif(b[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = b[0][0] + b[1][0] + b[2][0] + b[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = b[0][1] + b[1][1] + b[2][1] + b[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = b[0][2] + b[1][2] + b[2][2] + b[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = b[0][3] + b[1][3] + b[2][3] + b[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = b[0][0] + b[0][1] + b[0][2] + b[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = b[1][0] + b[1][1] + b[1][2] + b[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = b[2][0] + b[2][1] + b[2][2] + b[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = b[3][0] + b[3][1] + b[3][2] + b[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  mat4 b = a;
  bool elms = true;
  if ((b[0][0] != 1.0))
    elms = false;
  if ((b[0][1] != 2.0))
    elms = false;
  if ((b[0][2] != 3.0))
    elms = false;
  if ((b[0][3] != 4.0))
    elms = false;
  if ((b[1][0] != 5.0))
    elms = false;
  if ((b[1][1] != 6.0))
    elms = false;
  if ((b[1][2] != 7.0))
    elms = false;
  if ((b[1][3] != 8.0))
    elms = false;
  if ((b[2][0] != 9.0))
    elms = false;
  if ((b[2][1] != 10.0))
    elms = false;
  if ((b[2][2] != 11.0))
    elms = false;
  if ((b[2][3] != 12.0))
    elms = false;
  if ((b[3][0] != 13.0))
    elms = false;
  if ((b[3][1] != 14.0))
    elms = false;
  if ((b[3][2] != 15.0))
    elms = false;
  if ((b[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((b[0][0] + b[1][0]) + b[2][0]) + b[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((b[0][1] + b[1][1]) + b[2][1]) + b[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((b[0][2] + b[1][2]) + b[2][2]) + b[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((b[0][3] + b[1][3]) + b[2][3]) + b[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  vec4(+0.0, -(0.5 / (false ? -1.0 : 1.0)), ((false && (false ? true : true)) ? -1.0 : 2.0), +2.0);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((b[1][0] + b[1][1]) + b[1][2]) + b[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((b[2][0] + b[2][1]) + b[2][2]) + b[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((b[3][0] + b[3][1]) + b[3][2]) + b[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.54980079681275
Processing this: /home/oof/webgl_cleaned/const_mat2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat2 a = mat2(1.0, 2.0,
	                    4.0, 8.0);
	bool elms = true;
	if(a[0][0] != 1.0) elms = false;
	if(a[0][1] != 2.0) elms = false;
	if(a[1][0] != 4.0) elms = false;
	if(a[1][1] != 8.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0];
	if(x < 5.0-0.1 || x > 5.0+0.1) rows = false;
	x = a[0][1] + a[1][1];
	if(x < 10.0-0.1 || x > 10.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1];
	if(x < 3.0-0.1 || x > 3.0+0.1) cols = false;
	x = a[1][0] + a[1][1];
	if(x < 12.0-0.1 || x > 12.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat2 a = mat2(1.0, 2.0,\n\t                    4.0, 8.0);\n\tbool elms = true;\n\tif(a[0][0] != 1.0) elms = false;\n\tif(a[0][1] != 2.0) elms = false;\n\tif(a[1][0] != 4.0) elms = false;\n\tif(a[1][1] != 8.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0];\n\tif(x < 5.0-0.1 || x > 5.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1];\n\tif(x < 3.0-0.1 || x > 3.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1];\n\tif(x < 12.0-0.1 || x > 12.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat2 a = mat2(1.0 , 2.0 , 4.0 , 8.0);
  bool elms = true;
  if ((a[0][0] != 0.5))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[1][0] != 4.0))
    elms = false;
  if ((a[1][1] != 8.0))
    elms = false;
  bool rows = true;
  x = (a[0][0] + a[1][0]);
  if (((x < (5.0 - 0.1)) || (x > (5.0 + 0.1))))
    rows = false;
  x = (a[0][1] + a[1][1]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (a[0][0] + a[0][1]);
  if (((x < (3.0 - 0.1)) || (x > (3.0 + 0.1))))
    cols = false;
  x = (a[1][0] + a[1][1]);
  if (((x < (12.0 - 0.1)) || (x > (12.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
62.698412698412696
Processing this: /home/oof/webgl_cleaned/notEqual_bvec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * gtf_Color.rg);
	vec2 result = vec2(notEqual(bvec2(c), bvec2(true)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * gtf_Color.rg);\n\tvec2 result = vec2(notEqual(bvec2(c), bvec2(true)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((false || (true && false)) ? 0.0 : (false ? +0.5 : +0.0)), (+2.0 + ((true && false) ? 1.0 : 1.0)), (((false ? false : true) ? false : true) ? -0.5 : 0.5), 0.5);

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  vec2 result = vec2(notEqual(bvec2(c) , bvec2(true)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex;

vec4 gtf_Color;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: 'gtf_Color' : undeclared identifier
ERROR: 0:10: 'rg' :  field selection requires structure or vector on left hand side
ERROR: 0:10: '=' : dimension mismatch
ERROR: 0:10: '=' : cannot convert from 'const highp float' to 'mediump 2-component vector of float'
ERROR: 0:13: 'gtf_Vertex' : undeclared identifier
ERROR: 0:13: '=' : dimension mismatch
ERROR: 0:13: 'assign' : cannot convert from 'highp 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(((false || (true && false)) ? 0.0 : (false ? +0.5 : +0.0)), (+2.0 + ((true && false) ? 1.0 : 1.0)), (((false ? false : true) ? false : true) ? -0.5 : 0.5), 0.5);

void main()
{
  vec2 c = floor((1.5 * gtf_Color.rg));
  vec2 result = vec2(notEqual(bvec2(c) , bvec2(true)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 gtf_Vertex;

vec4 gtf_Color;


==============================
62.450592885375485
Processing this: /home/oof/webgl_cleaned/clamp_vec2_vert_xvary_yconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float min_c = 0.25;
	const float max_c = 0.75;
	vec2 c = gtf_Color.rg;
	color = vec4(clamp(c, min_c, max_c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float min_c = 0.25;\n\tconst float max_c = 0.75;\n\tvec2 c = gtf_Color.rg;\n\tcolor = vec4(clamp(c, min_c, max_c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 2.0, (-(false ? -1.0 : 1.0) / (0.0 * 0.0)), -1.0, -1.0, (!false ? +(false ? 1.0 : 1.0) : (+2.0 + (0.5 / 0.5))), (1.0 * (-1.0 - (2.0 / 0.5))), ((!true ? (false ? false : true) : (true ? true : true)) ? 0.5 : (-0.0 / -2.0)), 1.0, 1.0, +(0.0 - (true ? 2.0 : 0.0)), (+0.5 - 2.0), ++0.0, 2.0, +0.0, 0.0);

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  color = vec4(clamp(c , min_c , max_c) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 2.0, (-(false ? -1.0 : 1.0) / (0.0 * 0.0)), -1.0, -1.0, (!false ? +(false ? 1.0 : 1.0) : (+2.0 + (0.5 / 0.5))), (1.0 * (-1.0 - (2.0 / 0.5))), ((!true ? (false ? false : true) : (true ? true : true)) ? 0.5 : (-0.0 / -2.0)), 1.0, 1.0, +(0.0 - (true ? 2.0 : 0.0)), (+0.5 - 2.0), ++0.0, 2.0, +0.0, 0.0);

vec4 color;

void main()
{
  const float min_c = 0.25;
  const float max_c = 0.75;
  vec2 c = gtf_Color.rg;
  color = vec4(clamp(c , min_c , max_c) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
62.20472440944882
Processing this: /home/oof/webgl_cleaned/CorrectExtension1_V100_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main()
{
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main()\n{\n}\n\x00')
62.20472440944882
Processing this: /home/oof/webgl_cleaned/24f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec4 color[2];
void main ()
{
	gl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2] + color[0][3],
						 color[1][0] + color[1][1] + color[1][2] + color[1][3],
						 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec4 color[2];\nvoid main ()\n{\n\tgl_FragColor = vec4 (color[0][0] + color[0][1] + color[0][2] + color[0][3],\n\t\t\t\t\t\t color[1][0] + color[1][1] + color[1][2] + color[1][3],\n\t\t\t\t\t\t 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec4 color[2];

void main()
{
  gl_FragColor = vec4((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]) , (((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec4 color[2];

void main()
{
  gl_FragColor = vec4((((color[0][0] + color[0][1]) + color[0][2]) + color[0][3]) , (((color[1][0] + color[1][1]) + color[1][2]) + color[1][3]) , 0.0);
}


==============================
61.96078431372549
Processing this: /home/oof/webgl_cleaned/CorrectParse2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;
const bool BoolConst1 = true && true || false;
const bool BoolConst2 = false || !false && false;
void main ()
{
    float float1 = 4.0, float2 = floatConst2;
    int int_1 = int(FloatConst1);
    vec4 vec4_1;
    vec3 vec3_1 = vec3(1, 1, 1);
	vec3 vec3_2 = vec3(0, 0, 0);
    bool bool4, bool5;
    bool4 = bool5;
    bool4 = 4 > 5;
    bool4 = !(3.2 != 0.0);
    bool4 = bool(float1);
    bool4 = bool(int_1);
    float1 = float(bool4);
    float1 = float(int_1);
    int_1 = int(float1);
    int_1 = int(bool4);
    {
        int a, b, c;
        a = b;
        b = c;
        {
            int b, c, d;
            b = c;
            c = d;
            {
                int a, d, e;
                a = d;
                d = e;
            }
            {
                int a, b, c;
                a = b;
                b = c;
            }
        }
        a = b;
        b = c;
    }
    {
        float f1, f2;
        vec3 v31, v32;
        max(f1, f2);
        max(v31, v32);
        vec4 v4 = vec4(3.0);
        vec3 v3 = -vec3(2.0, 1.0, 3.0);
        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);
    }
    if (BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst1 || BoolConst2)
        ++vec3_1;
    else
        --vec3_1;
    if (BoolConst2 && BoolConst1)
        ++vec3_1;
    else
        --vec3_1;
    if (FloatConst1 != 0.0)
        --int_1;
    else
        ++int_1;
    if (0 != 0)
        ++int_1;
    else
        --int_1;
    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);
    float1 = 5 != 0 ? float1 : float(int_1);
    float1 = BoolConst1 ? float1 : float(int_1);
    if (float1 != float1)
        ++int_1;
    else
        --int_1;
    float1 = float1 != float1 ? float1 : float(int_1);
    --int_1;
    ++float1;
    (vec4_1.x)--;
    vec3_1++;
    if (vec3_1.x > vec3_2.x)
        float1 = 4.0 + 6.0;
    if (bool4 ^^ bool5)
        float1 *= 2.4;
    if (false ^^ false)
        float1 *= 2.5;
    if (true ^^ false)
        float1 *= 2.6;
    {
        int i;
    }
    if (bool4) {
        int i;
    } else {
        int i;
        i = 5;
    }
    mat4 m1;
    m1[2][1] = 4.0;
    gl_Position = vec4(float1+float1, float1, float1, float(int_1));
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nconst float FloatConst1 = 3.0 * 8.0, floatConst2 = 4.0;\nconst bool BoolConst1 = true && true || false;\nconst bool BoolConst2 = false || !false && false;\nvoid main ()\n{\n    float float1 = 4.0, float2 = floatConst2;\n    int int_1 = int(FloatConst1);\n    vec4 vec4_1;\n    vec3 vec3_1 = vec3(1, 1, 1);\n\tvec3 vec3_2 = vec3(0, 0, 0);\n    bool bool4, bool5;\n    bool4 = bool5;\n    bool4 = 4 > 5;\n    bool4 = !(3.2 != 0.0);\n    bool4 = bool(float1);\n    bool4 = bool(int_1);\n    float1 = float(bool4);\n    float1 = float(int_1);\n    int_1 = int(float1);\n    int_1 = int(bool4);\n    {\n        int a, b, c;\n        a = b;\n        b = c;\n        {\n            int b, c, d;\n            b = c;\n            c = d;\n            {\n                int a, d, e;\n                a = d;\n                d = e;\n            }\n            {\n                int a, b, c;\n                a = b;\n                b = c;\n            }\n        }\n        a = b;\n        b = c;\n    }\n    {\n        float f1, f2;\n        vec3 v31, v32;\n        max(f1, f2);\n        max(v31, v32);\n        vec4 v4 = vec4(3.0);\n        vec3 v3 = -vec3(2.0, 1.0, 3.0);\n        mat2 m2 = mat2(3.0, 4.0, 6.0, 3.0);\n    }\n    if (BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst1 || BoolConst2)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (BoolConst2 && BoolConst1)\n        ++vec3_1;\n    else\n        --vec3_1;\n    if (FloatConst1 != 0.0)\n        --int_1;\n    else\n        ++int_1;\n    if (0 != 0)\n        ++int_1;\n    else\n        --int_1;\n    bool4 = BoolConst1 && ! (int_1 != 0) && ! BoolConst1  && ! (FloatConst1 != 0.0) && (FloatConst1 != 0.0) && (float1 != 0.0);\n    float1 = 5 != 0 ? float1 : float(int_1);\n    float1 = BoolConst1 ? float1 : float(int_1);\n    if (float1 != float1)\n        ++int_1;\n    else\n        --int_1;\n    float1 = float1 != float1 ? float1 : float(int_1);\n    --int_1;\n    ++float1;\n    (vec4_1.x)--;\n    vec3_1++;\n    if (vec3_1.x > vec3_2.x)\n        float1 = 4.0 + 6.0;\n    if (bool4 ^^ bool5)\n        float1 *= 2.4;\n    if (false ^^ false)\n        float1 *= 2.5;\n    if (true ^^ false)\n        float1 *= 2.6;\n    {\n        int i;\n    }\n    if (bool4) {\n        int i;\n    } else {\n        int i;\n        i = 5;\n    }\n    mat4 m1;\n    m1[2][1] = 4.0;\n    gl_Position = vec4(float1+float1, float1, float1, float(int_1));\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

const float FloatConst1 = (3.0 * 8.0);

const bool BoolConst1 = ((true && true) || false);

const bool BoolConst2 = (false || (!false && false));

void main()
{
  float float1 = 4.0 , float2 = floatConst2;
  int int_1 = int(FloatConst1);
  vec4 vec4_1;
  vec3 vec3_1 = vec3(1 , 1 , 1);
  vec3 vec3_2 = vec3(0 , 0 , 0);
  bool bool4, bool5;
  bool4 = bool5;
  bool4 = (4 > 5);
  bool4 = !(3.2 != 0.0);
  bool4 = bool(float1);
  bool4 = bool(int_1);
  float1 = float(bool4);
  float1 = float(int_1);
  int_1 = int(float1);
  int_1 = int(bool4);
  {
    int a, b, c;
    a = b;
    b = c;
    {
      int b, c, d;
      b = c;
      c = d;
      {
        int a, d, e;
        a = d;
        d = e;
      }
      {
        int a, b, c;
        a = b;
        b = c;
      }
    }
    a = b;
    b = c;
  }
  {
    float f1, f2;
    vec3 v31, v32;
    max(f1 , f2);
    max(v31 , v32);
    vec4 v4 = vec4(3.0);
    vec3 v3 = -vec3(2.0 , 1.0 , 3.0);
    mat2 m2 = mat2(3.0 , 4.0 , 6.0 , 3.0);
  }
  if (BoolConst1)
    ++vec3_1;
  else
    --vec3_1;
  if (BoolConst2)
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst1 || BoolConst2))
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst2 && BoolConst1))
    ++vec3_1;
  else
    --vec3_1;
  if ((FloatConst1 != 0.0))
    --int_1;
  else
    ++int_1;
  if ((0 != 0))
    ++int_1;
  else
    --int_1;
  bool4 = (((((BoolConst1 && !(int_1 != 0)) && !BoolConst1) && !(FloatConst1 != 0.0)) && (FloatConst1 != 0.0)) && (float1 != 0.0));
  (float1 = (5 != 0) ? float1 : float(int_1));
  (float1 = BoolConst1 ? float1 : float(int_1));
  if ((float1 != float1))
    ++int_1;
  else
    --int_1;
  (float1 = (float1 != float1) ? float1 : float(int_1));
  --int_1;
  ++float1;
  vec4_1.x--;
  vec3_1++;
  if ((vec3_1.x > vec3_2.x))
    float1 = (4.0 + 6.0);
  if ((bool4 ^^ bool5))
    (float1 *= 2.4);
  if ((false ^^ false))
    (float1 *= 2.5);
  if ((true ^^ false))
    (float1 *= 2.6);
  {
    int i;
  }
  if (bool4)
  {
    int i;
  }
  else
  {
    int i;
    i = 5;
  }
  mat4 m1;
  m1[2][1] = 4.0;
  gl_Position = vec4((float1 + float1) , float1 , float1 , float(int_1));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:12: 'floatConst2' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

const float FloatConst1 = (3.0 * 8.0);

const bool BoolConst1 = ((true && true) || false);

const bool BoolConst2 = (false || (!false && false));

void main()
{
  float float1 = 4.0 , float2 = floatConst2;
  int int_1 = int(FloatConst1);
  vec4 vec4_1;
  vec3 vec3_1 = vec3(1 , 1 , 1);
  vec3 vec3_2 = vec3(0 , 0 , 0);
  bool bool4, bool5;
  bool4 = bool5;
  bool4 = (4 > 5);
  bool4 = !(3.2 != 0.0);
  bool4 = bool(float1);
  bool4 = bool(int_1);
  float1 = float(bool4);
  float1 = float(int_1);
  int_1 = int(float1);
  int_1 = int(bool4);
  {
    int a, b, c;
    a = b;
    b = c;
    {
      int b, c, d;
      b = c;
      c = d;
      {
        int a, d, e;
        a = d;
        d = e;
      }
      {
        int a, b, c;
        a = b;
        b = c;
      }
    }
    a = b;
    b = c;
  }
  {
    float f1, f2;
    vec3 v31, v32;
    max(f1 , f2);
    max(v31 , v32);
    vec4 v4 = vec4(3.0);
    vec3 v3 = -vec3(2.0 , 1.0 , 3.0);
    mat2 m2 = mat2(3.0 , 4.0 , 6.0 , 3.0);
  }
  if (BoolConst1)
    ++vec3_1;
  else
    --vec3_1;
  if (BoolConst2)
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst1 || BoolConst2))
    ++vec3_1;
  else
    --vec3_1;
  if ((BoolConst2 && BoolConst1))
    ++vec3_1;
  else
    --vec3_1;
  if ((FloatConst1 != 0.0))
    --int_1;
  else
    ++int_1;
  if ((0 != 0))
    ++int_1;
  else
    --int_1;
  bool4 = (((((BoolConst1 && !(int_1 != 0)) && !BoolConst1) && !(FloatConst1 != 0.0)) && (FloatConst1 != 0.0)) && (float1 != 0.0));
  (float1 = (5 != 0) ? float1 : float(int_1));
  (float1 = BoolConst1 ? float1 : float(int_1));
  if ((float1 != float1))
    ++int_1;
  else
    --int_1;
  (float1 = (float1 != float1) ? float1 : float(int_1));
  --int_1;
  ++float1;
  vec4_1.x--;
  vec3_1++;
  if ((vec3_1.x > vec3_2.x))
    float1 = (4.0 + 6.0);
  if ((bool4 ^^ bool5))
    (float1 *= 2.4);
  if ((false ^^ false))
    (float1 *= 2.5);
  if ((true ^^ false))
    (float1 *= 2.6);
  {
    int i;
  }
  if (bool4)
  {
    int i;
  }
  else
  {
    int i;
    i = 5;
  }
  mat4 m1;
  m1[2][1] = 4.0;
  gl_Position = vec4((float1 + float1) , float1 , float1 , float(int_1));
}


==============================
61.71875
Processing this: /home/oof/webgl_cleaned/boolUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform bool bval;
uniform bvec2 bval2;
uniform bvec3 bval3;
uniform bvec4 bval4;
void main()
{
    bool allSet = bval
            && bval2[0] && bval2[1]
            && bval3[0] && bval3[1] && bval3[2]
            && bval4[0] && bval4[1] && bval4[2] && bval4[3];
    gl_Position = vec4((allSet ? 1.0 : -1.0), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform bool bval;\nuniform bvec2 bval2;\nuniform bvec3 bval3;\nuniform bvec4 bval4;\nvoid main()\n{\n    bool allSet = bval\n            && bval2[0] && bval2[1]\n            && bval3[0] && bval3[1] && bval3[2]\n            && bval4[0] && bval4[1] && bval4[2] && bval4[3];\n    gl_Position = vec4((allSet ? 1.0 : -1.0), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform bool bval;

uniform bvec2 bval2;

uniform bvec3 bval3 = bvec3((true ? ((true ? 1.0 : 2.0) * (true ? 0.5 : 1.0)) : -1.0), -1.0, -1.0);

uniform bvec4 bval4;

void main()
{
  bool allSet = (((((((((bval && bval2[0]) && bval2[1]) && bval3[0]) && bval3[1]) && bval3[2]) && bval4[0]) && bval4[1]) && bval4[2]) && bval4[3]);
  gl_Position = vec4((allSet ? 1.0 : -1.0) , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform bool bval;

uniform bvec2 bval2;

uniform bvec3 bval3 = bvec3((true ? ((true ? 1.0 : 2.0) * (true ? 0.5 : 1.0)) : -1.0), -1.0, -1.0);

uniform bvec4 bval4;

void main()
{
  bool allSet = (((((((((bval && bval2[0]) && bval2[1]) && bval3[0]) && bval3[1]) && bval3[2]) && bval4[0]) && bval4[1]) && bval4[2]) && bval4[3]);
  gl_Position = vec4((allSet ? 1.0 : -1.0) , 0.0 , 0.0 , 1.0);
}


==============================
61.478599221789885
Processing this: /home/oof/webgl_cleaned/structnest_mat4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	mat4 b;
};
struct nesta
{
	mat4 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat4(11, 13, 29, 33, 63, 13, 49, 57, 71, 47, 91, 101, 167, 21, 39, 41), nestb( mat4(12, 19, 79, 81, 35, 51, 73, 66, 23, 134, 121, 156, 76, 23, 24, 78) ) ) );
	float sum1=0.0,sum2=0.0;
	sum1 = sum1 + s.nest_a.a[0][0];
	sum2 = sum2 + s.nest_a.nest_b.b[0][0];
	sum1 = sum1 + s.nest_a.a[0][1];
	sum2 = sum2 + s.nest_a.nest_b.b[0][1];
	sum1 = sum1 + s.nest_a.a[0][2];
	sum2 = sum2 + s.nest_a.nest_b.b[0][2];
	sum1 = sum1 + s.nest_a.a[0][3];
	sum2 = sum2 + s.nest_a.nest_b.b[0][3];
	sum1 = sum1 + s.nest_a.a[1][0];
	sum2 = sum2 + s.nest_a.nest_b.b[1][0];
	sum1 = sum1 + s.nest_a.a[1][1];
	sum2 = sum2 + s.nest_a.nest_b.b[1][1];
	sum1 = sum1 + s.nest_a.a[1][2];
	sum2 = sum2 + s.nest_a.nest_b.b[1][2];
	sum1 = sum1 + s.nest_a.a[1][3];
	sum2 = sum2 + s.nest_a.nest_b.b[1][3];
	sum1 = sum1 + s.nest_a.a[2][0];
	sum2 = sum2 + s.nest_a.nest_b.b[2][0];
	sum1 = sum1 + s.nest_a.a[2][1];
	sum2 = sum2 + s.nest_a.nest_b.b[2][1];
	sum1 = sum1 + s.nest_a.a[2][2];
	sum2 = sum2 + s.nest_a.nest_b.b[2][2];
	sum1 = sum1 + s.nest_a.a[2][3];
	sum2 = sum2 + s.nest_a.nest_b.b[2][3];
	sum1 = sum1 + s.nest_a.a[3][0];
	sum2 = sum2 + s.nest_a.nest_b.b[3][0];
	sum1 = sum1 + s.nest_a.a[3][1];
	sum2 = sum2 + s.nest_a.nest_b.b[3][1];
	sum1 = sum1 + s.nest_a.a[3][2];
	sum2 = sum2 + s.nest_a.nest_b.b[3][2];
	sum1 = sum1 + s.nest_a.a[3][3];
	sum2 = sum2 + s.nest_a.nest_b.b[3][3];
	color = vec4( vec3( ( sum1 + sum2 )/ 1897.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tmat4 b;\n};\nstruct nesta\n{\n\tmat4 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat4(11, 13, 29, 33, 63, 13, 49, 57, 71, 47, 91, 101, 167, 21, 39, 41), nestb( mat4(12, 19, 79, 81, 35, 51, 73, 66, 23, 134, 121, 156, 76, 23, 24, 78) ) ) );\n\tfloat sum1=0.0,sum2=0.0;\n\tsum1 = sum1 + s.nest_a.a[0][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][0];\n\tsum1 = sum1 + s.nest_a.a[0][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][1];\n\tsum1 = sum1 + s.nest_a.a[0][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][2];\n\tsum1 = sum1 + s.nest_a.a[0][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[0][3];\n\tsum1 = sum1 + s.nest_a.a[1][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][0];\n\tsum1 = sum1 + s.nest_a.a[1][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][1];\n\tsum1 = sum1 + s.nest_a.a[1][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][2];\n\tsum1 = sum1 + s.nest_a.a[1][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[1][3];\n\tsum1 = sum1 + s.nest_a.a[2][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][0];\n\tsum1 = sum1 + s.nest_a.a[2][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][1];\n\tsum1 = sum1 + s.nest_a.a[2][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][2];\n\tsum1 = sum1 + s.nest_a.a[2][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[2][3];\n\tsum1 = sum1 + s.nest_a.a[3][0];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][0];\n\tsum1 = sum1 + s.nest_a.a[3][1];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][1];\n\tsum1 = sum1 + s.nest_a.a[3][2];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][2];\n\tsum1 = sum1 + s.nest_a.a[3][3];\n\tsum2 = sum2 + s.nest_a.nest_b.b[3][3];\n\tcolor = vec4( vec3( ( sum1 + sum2 )/ 1897.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  mat4 b;
};

struct nesta {
  mat4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat4(11 , 13 , 29 , 33 , 63 , 13 , 49 , 57 , 71 , 47 , 91 , 101 , 167 , 21 , 39 , 41) , nestb(mat4(12 , 19 , 79 , 81 , 35 , 51 , 73 , 66 , 23 , 134 , 121 , 156 , 76 , 23 , 24 , 78))));
  float sum1 = 0.0 , sum2 = 0.0;
  sum1 = (sum1 + s.nest_a.a[0][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][0]);
  sum1 = (sum1 + s.nest_a.a[0][1]);
  gtf_Vertex = (gtf_ModelViewProjectionMatrix + s.nest_a.nest_b.b[-4][1]);
  sum1 = (sum1 + s.nest_a.a[0][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][2]);
  sum1 = (sum1 + s.nest_a.a[0][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][3]);
  sum1 = (sum1 + s.nest_a.a[1][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][0]);
  sum1 = (sum1 + s.nest_a.a[1][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][1]);
  sum1 = (sum1 + s.nest_a.a[1][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][2]);
  sum1 = (sum1 + s.nest_a.a[1][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][3]);
  sum1 = (sum1 + s.nest_a.a[2][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][0]);
  sum1 = (sum1 + s.nest_a.a[2][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][1]);
  sum1 = (sum1 + s.nest_a.a[2][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][2]);
  sum1 = (sum1 + s.nest_a.a[2][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][3]);
  sum1 = (sum1 + s.nest_a.a[3][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][0]);
  sum1 = (sum1 + s.nest_a.a[3][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][1]);
  sum1 = (sum1 + s.nest_a.a[3][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][2]);
  sum1 = (sum1 + s.nest_a.a[3][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][3]);
  color = vec4(vec3(((sum1 + sum2) / 1897.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:30: '[]' : index expression is negative
ERROR: 0:30: '=' : dimension mismatch
ERROR: 0:30: 'assign' : cannot convert from 'mediump 4X4 matrix of float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  mat4 b;
};

struct nesta {
  mat4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat4(11 , 13 , 29 , 33 , 63 , 13 , 49 , 57 , 71 , 47 , 91 , 101 , 167 , 21 , 39 , 41) , nestb(mat4(12 , 19 , 79 , 81 , 35 , 51 , 73 , 66 , 23 , 134 , 121 , 156 , 76 , 23 , 24 , 78))));
  float sum1 = 0.0 , sum2 = 0.0;
  sum1 = (sum1 + s.nest_a.a[0][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][0]);
  sum1 = (sum1 + s.nest_a.a[0][1]);
  gtf_Vertex = (gtf_ModelViewProjectionMatrix + s.nest_a.nest_b.b[-4][1]);
  sum1 = (sum1 + s.nest_a.a[0][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][2]);
  sum1 = (sum1 + s.nest_a.a[0][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[0][3]);
  sum1 = (sum1 + s.nest_a.a[1][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][0]);
  sum1 = (sum1 + s.nest_a.a[1][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][1]);
  sum1 = (sum1 + s.nest_a.a[1][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][2]);
  sum1 = (sum1 + s.nest_a.a[1][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[1][3]);
  sum1 = (sum1 + s.nest_a.a[2][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][0]);
  sum1 = (sum1 + s.nest_a.a[2][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][1]);
  sum1 = (sum1 + s.nest_a.a[2][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][2]);
  sum1 = (sum1 + s.nest_a.a[2][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[2][3]);
  sum1 = (sum1 + s.nest_a.a[3][0]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][0]);
  sum1 = (sum1 + s.nest_a.a[3][1]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][1]);
  sum1 = (sum1 + s.nest_a.a[3][2]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][2]);
  sum1 = (sum1 + s.nest_a.a[3][3]);
  sum2 = (sum2 + s.nest_a.nest_b.b[3][3]);
  color = vec4(vec3(((sum1 + sum2) / 1897.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.240310077519375
Mutations attempted: 258
Valid mutations:     158
Success rate:        61.24%
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 4.0 * 2.0 * (color.rgb - 0.5);
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	if(c[0] < 0.0)
	{
		sign[0] = -1.0;
		c[0] *= -1.0;
	}
	if(c[0] <= 1.0)
	{
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * atan_c[0] / M_PI + 0.5;
	}
	else
	{
		c[0] = 1.0 / c[0];
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;
	}
	if(c[1] < 0.0)
	{
		sign[1] = -1.0;
		c[1] *= -1.0;
	}
	if(c[1] <= 1.0)
	{
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * atan_c[1] / M_PI + 0.5;
	}
	else
	{
		c[1] = 1.0 / c[1];
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;
	}
	if(c[2] < 0.0)
	{
		sign[2] = -1.0;
		c[2] *= -1.0;
	}
	if(c[2] <= 1.0)
	{
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * atan_c[2] / M_PI + 0.5;
	}
	else
	{
		c[2] = 1.0 / c[2];
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 4.0 * 2.0 * (color.rgb - 0.5);\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(c[0] < 0.0)\n\t{\n\t\tsign[0] = -1.0;\n\t\tc[0] *= -1.0;\n\t}\n\tif(c[0] <= 1.0)\n\t{\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * atan_c[0] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[0] = 1.0 / c[0];\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;\n\t}\n\tif(c[1] < 0.0)\n\t{\n\t\tsign[1] = -1.0;\n\t\tc[1] *= -1.0;\n\t}\n\tif(c[1] <= 1.0)\n\t{\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * atan_c[1] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[1] = 1.0 / c[1];\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;\n\t}\n\tif(c[2] < 0.0)\n\t{\n\t\tsign[2] = -1.0;\n\t\tc[2] *= -1.0;\n\t}\n\tif(c[2] <= 1.0)\n\t{\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * atan_c[2] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[2] = 1.0 / c[2];\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (--2.0 / ((true ? 2.0 : 0.5) * 0.0)), (1.0 * 0.5), +((false ? 1.0 : 2.0) + 0.5));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, (--2.0 / ((true ? 2.0 : 0.5) * 0.0)), (1.0 * 0.5), +((false ? 1.0 : 2.0) + 0.5));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


==============================
61.003861003861005
Processing this: /home/oof/webgl_cleaned/all_bvec2_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bool _all(in bvec2 a)
{
	bool temp = true;
	if(!a[0]) temp = false;
	if(!a[1]) temp = false;
	return temp;
}
void main ()
{
	vec2 c = floor(4.0 * gtf_Color.rg);
	color = vec4(vec3(_all(bvec2(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbool _all(in bvec2 a)\n{\n\tbool temp = true;\n\tif(!a[0]) temp = false;\n\tif(!a[1]) temp = false;\n\treturn temp;\n}\nvoid main ()\n{\n\tvec2 c = floor(4.0 * gtf_Color.rg);\n\tcolor = vec4(vec3(_all(bvec2(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bool _all(in bvec2 a)
{
  bool temp = true;
  if (!a[-1])
    temp = false;
  if (!a[1])
    temp = false;
  return temp;
}

void main()
{
  vec2 c = floor((4.0 * gtf_Color.rg));
  color = vec4(vec3(_all(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: '[]' : index expression is negative

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bool _all(in bvec2 a)
{
  bool temp = true;
  if (!a[-1])
    temp = false;
  if (!a[1])
    temp = false;
  return temp;
}

void main()
{
  vec2 c = floor((4.0 * gtf_Color.rg));
  color = vec4(vec3(_all(bvec2(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.76923076923077
Processing this: /home/oof/webgl_cleaned/brick.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec3 gtf_Normal;
attribute vec4 gtf_Vertex;
uniform mat3 gtf_NormalMatrix;
uniform mat4 gtf_ModelViewMatrix;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying float lightIntensity;
varying vec3  Position;
uniform vec3  LightPosition;
uniform vec3  NotActiveOne;
attribute float myAttribute1;
attribute vec3 myAttribute2;
const float specularContribution = 0.7;
const float diffuseContribution  = (1.0 - specularContribution);
void main() {
    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;
    Position        = vec3(gtf_Vertex);
    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);
    vec3 lightVec   = normalize(LightPosition - vec3(pos));
    vec3 reflectVec = reflect(lightVec, tnorm);
    vec3 viewVec    = normalize(vec3(pos));
	float spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    spec = spec * spec;
    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +
                     specularContribution * spec;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec3 gtf_Normal;\nattribute vec4 gtf_Vertex;\nuniform mat3 gtf_NormalMatrix;\nuniform mat4 gtf_ModelViewMatrix;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying float lightIntensity;\nvarying vec3  Position;\nuniform vec3  LightPosition;\nuniform vec3  NotActiveOne;\nattribute float myAttribute1;\nattribute vec3 myAttribute2;\nconst float specularContribution = 0.7;\nconst float diffuseContribution  = (1.0 - specularContribution);\nvoid main() {\n    vec4 pos        = gtf_ModelViewMatrix * gtf_Vertex;\n    Position        = vec3(gtf_Vertex);\n    vec3 tnorm      = normalize(gtf_NormalMatrix * gtf_Normal);\n    vec3 lightVec   = normalize(LightPosition - vec3(pos));\n    vec3 reflectVec = reflect(lightVec, tnorm);\n    vec3 viewVec    = normalize(vec3(pos));\n\tfloat spec = clamp(dot(reflectVec, viewVec), myAttribute1, myAttribute2[1]);\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    spec = spec * spec;\n    lightIntensity = diffuseContribution * dot(lightVec, tnorm) +\n                     specularContribution * spec;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity;

vec3 Position = vec3((true ? ((true || false) ? 2.0 : (diffuseContribution - 0.5)) : -myAttribute1), 2.0, 0.5);

uniform vec3 LightPosition;

uniform vec3 NotActiveOne;

float myAttribute1;

vec3 myAttribute2;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float spec = clamp(dot(reflectVec , viewVec) , myAttribute1 , myAttribute2[1]);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:16: 'diffuseContribution' : undeclared identifier
ERROR: 0:16: 'myAttribute1' : undeclared identifier

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec3 gtf_Normal;

vec4 gtf_Vertex;

uniform mat3 gtf_NormalMatrix;

uniform mat4 gtf_ModelViewMatrix;

uniform mat4 gtf_ModelViewProjectionMatrix;

float lightIntensity;

vec3 Position = vec3((true ? ((true || false) ? 2.0 : (diffuseContribution - 0.5)) : -myAttribute1), 2.0, 0.5);

uniform vec3 LightPosition;

uniform vec3 NotActiveOne;

float myAttribute1;

vec3 myAttribute2;

const float specularContribution = 0.7;

const float diffuseContribution = (1.0 - specularContribution);

void main()
{
  vec4 pos = (gtf_ModelViewMatrix * gtf_Vertex);
  Position = vec3(gtf_Vertex);
  vec3 tnorm = normalize((gtf_NormalMatrix * gtf_Normal));
  vec3 lightVec = normalize((LightPosition - vec3(pos)));
  vec3 reflectVec = reflect(lightVec , tnorm);
  vec3 viewVec = normalize(vec3(pos));
  float spec = clamp(dot(reflectVec , viewVec) , myAttribute1 , myAttribute2[1]);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  spec = (spec * spec);
  lightIntensity = ((diffuseContribution * dot(lightVec , tnorm)) + (specularContribution * spec));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.53639846743295
Processing this: /home/oof/webgl_cleaned/min_vec2_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = gtf_Color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	color = vec4(c, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = gtf_Color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tcolor = vec4(c, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = gtf_Color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  color = vec4(c , 0.0 , 1.0);
  gtf_Color = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.68702290076335
Processing this: /home/oof/webgl_cleaned/for_nested_break_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	int count1 = 0, count2 = 0;
        for(int i=0;i<4;i++)
	{
	  count1++;
	  count2 = 0;
	  for(int j=0;j<4;j++)
	  {
	     count2++;
	     if(count2 == 3)
		break;
	  }
	  if(count1 == 2)
            break;
	}
	float gray;
	if( (count1 == 2) && (count2 == 3))
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tint count1 = 0, count2 = 0;\n        for(int i=0;i<4;i++)\n\t{\n\t  count1++;\n\t  count2 = 0;\n\t  for(int j=0;j<4;j++)\n\t  {\n\t     count2++;\n\t     if(count2 == 3)\n\t\tbreak;\n\t  }\n\t  if(count1 == 2)\n            break;\n\t}\n\tfloat gray;\n\tif( (count1 == 2) && (count2 == 3))\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((false ? ((true ? false : false) ? (true ? 0.5 : -1.0) : (-1.0 - -1.0)) : 1.0), (false ? +(true ? 0.5 : 0.0) : (0.0 + -1.0)), -0.5, -1.0);

void main()
{
  int count1 = 0 , count2 = 0;
  for (int i = 0; (i < 4); i++)
  {
    count1++;
    count2 = 0;
    for (int j = 0; (j < 4); j++)
    {
      count2++;
      if ((count2 == 3))
        break;
    }
    if ((count1 == 2))
      break;
  }
  float gray;
  if (((count1 == 2) && (count2 == 3)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.836501901140686
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec2_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
bvec2 gte(in ivec2 a, in ivec2 b)
{
	bvec2 result;
	if(a[0] >= b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] >= b[1]) result[1] = true;
	else result[1] = false;
	return result;
}
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(gte(ivec2(c), ivec2(0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nbvec2 gte(in ivec2 a, in ivec2 b)\n{\n\tbvec2 result;\n\tif(a[0] >= b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] >= b[1]) result[1] = true;\n\telse result[1] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(gte(ivec2(c), ivec2(0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

bvec2 gte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(gte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:24: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

bvec2 gte(in ivec2 a, in ivec2 b)
{
  bvec2 result;
  if ((a[0] >= b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] >= b[1]))
    result[1] = true;
  else
    result[1] = false;
  return result;
}

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(gte(ivec2(c) , ivec2(0)));
  gl_FragColor = vec4(result , 0.0);
}


==============================
60.60606060606061
Processing this: /home/oof/webgl_cleaned/floatUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform float fval;
uniform vec2 fval2;
uniform vec3 fval3;
uniform vec4 fval4;
void main()
{
    float sum = fval
            + fval2[0] + fval2[1]
            + fval3[0] + fval3[1] + fval3[2]
            + fval4[0] + fval4[1] + fval4[2] + fval4[3];
    gl_Position = vec4(sum, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform float fval;\nuniform vec2 fval2;\nuniform vec3 fval3;\nuniform vec4 fval4;\nvoid main()\n{\n    float sum = fval\n            + fval2[0] + fval2[1]\n            + fval3[0] + fval3[1] + fval3[2]\n            + fval4[0] + fval4[1] + fval4[2] + fval4[3];\n    gl_Position = vec4(sum, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform float fval;

uniform vec2 fval2;

uniform vec3 fval3 = vec3(-(-1.0 / (false ? 0.0 : 0.5)), 0.5, 0.5);

uniform vec4 fval4;

void main()
{
  float sum = (((((((((fval + fval2[0]) + fval2[1]) + fval3[0]) + fval3[1]) + fval3[2]) + fval4[0]) + fval4[1]) + fval4[2]) + fval4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform float fval;

uniform vec2 fval2;

uniform vec3 fval3 = vec3(-(-1.0 / (false ? 0.0 : 0.5)), 0.5, 0.5);

uniform vec4 fval4;

void main()
{
  float sum = (((((((((fval + fval2[0]) + fval2[1]) + fval3[0]) + fval3[1]) + fval3[2]) + fval4[0]) + fval4[1]) + fval4[2]) + fval4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


==============================
60.37735849056604
Processing this: /home/oof/webgl_cleaned/bvec4_empty_in_bvec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(in bvec4 par[3]);
bool is_all(const in bvec4 par, const in bool value);
bool is_all(const in bvec4 array[3], const in bvec4 value);
void set_all(out bvec4 array[3], const in bvec4 value);
void main ()
{
	bvec4 par[3];
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	set_all(par, bvec4(true, true, true, true));
	ret = function(par);
	if(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(in bvec4 par[3])
{
	if(is_all(par, bvec4(true, true, true, true)))
	{
		set_all(par, bvec4(false, false, false, false));
		return bvec4(true, true, true, true);
	}
	else
		return bvec4(false, false, false, false);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in bvec4 array[3], const in bvec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 array[3], const in bvec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(in bvec4 par[3]);\nbool is_all(const in bvec4 par, const in bool value);\nbool is_all(const in bvec4 array[3], const in bvec4 value);\nvoid set_all(out bvec4 array[3], const in bvec4 value);\nvoid main ()\n{\n\tbvec4 par[3];\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tset_all(par, bvec4(true, true, true, true));\n\tret = function(par);\n\tif(is_all(par, bvec4(true, true, true, true)) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(in bvec4 par[3])\n{\n\tif(is_all(par, bvec4(true, true, true, true)))\n\t{\n\t\tset_all(par, bvec4(false, false, false, false));\n\t\treturn bvec4(true, true, true, true);\n\t}\n\telse\n\t\treturn bvec4(false, false, false, false);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in bvec4 array[3], const in bvec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 array[3], const in bvec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.37735849056604
Processing this: /home/oof/webgl_cleaned/step_vec2_vert_xvary_edgeconsthalf.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec2 edge = vec2(0.5, 0.5);
	color = vec4(step(edge, gtf_Color.rg), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 edge = vec2(0.5, 0.5);\n\tcolor = vec4(step(edge, gtf_Color.rg), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge = vec2(0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rg) , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec2 edge = vec2(0.5 , 0.5);
  color = vec4(step(edge , gtf_Color.rg) , 0.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.150375939849624
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
mat4 function(in mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(in mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nmat4 function(in mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(in mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.150375939849624
Mutations attempted: 266
Valid mutations:     160
Success rate:        60.15%
Processing this: /home/oof/webgl_cleaned/vec4_xy_zw_2vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec2 m = lightloc.xy;
	vec2 n = lightloc.zw;
	vec4 a = vec4(m,n);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec2 m = lightloc.xy;\n\tvec2 n = lightloc.zw;\n\tvec4 a = vec4(m,n);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(0.5, +0.0, 0.0, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec4 lightloc = gtf_Vertex;
  vec2 m = lightloc.xy;
  vec2 n = lightloc.zw;
  vec4 a = vec4(m , n);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
}


As vertex? : True
SUCCESS!
60.2996254681648
Processing this: /home/oof/webgl_cleaned/buffer_objects_multitexturing.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
attribute vec4 gtf_MultiTexCoord1;
varying vec4 color;
varying vec4 gtf_TexCoord[2];
void main ()
{
	color = gtf_Color;
	gtf_TexCoord[0] = gtf_MultiTexCoord0;
	gtf_TexCoord[1] = gtf_MultiTexCoord1;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nattribute vec4 gtf_MultiTexCoord1;\nvarying vec4 color;\nvarying vec4 gtf_TexCoord[2];\nvoid main ()\n{\n\tcolor = gtf_Color;\n\tgtf_TexCoord[0] = gtf_MultiTexCoord0;\n\tgtf_TexCoord[1] = gtf_MultiTexCoord1;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color = vec4(-1.0, 0.5, (+(true ? 2.0 : -1.0) + 2.0), (2.0 * -2.0));

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 gtf_MultiTexCoord1;

vec4 color;

vec4 gtf_TexCoord[2];

void main()
{
  color = gtf_Color;
  gtf_TexCoord[0] = gtf_MultiTexCoord0;
  gtf_TexCoord[1] = gtf_MultiTexCoord1;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.447761194029844
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = (false ? -1.0 : 1.0)(greaterThan(ivec2(c)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: '=' : dimension mismatch
ERROR: 0:15: '=' : cannot convert from 'const float' to 'mediump 2-component vector of float'
ERROR: 0:15: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = (false ? -1.0 : 1.0)(greaterThan(ivec2(c)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.223048327137555
Processing this: /home/oof/webgl_cleaned/equal_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 eq(in bvec3 a, in bvec3 b)
{
	bvec3 result;
	if(a[0] == b[0]) result[0] = true;
	else result[0] = false;
	if(a[1] == b[1]) result[1] = true;
	else result[1] = false;
	if(a[2] == b[2]) result[2] = true;
	else result[2] = false;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	vec3 result = vec3(eq(bvec3(c), bvec3(true)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 eq(in bvec3 a, in bvec3 b)\n{\n\tbvec3 result;\n\tif(a[0] == b[0]) result[0] = true;\n\telse result[0] = false;\n\tif(a[1] == b[1]) result[1] = true;\n\telse result[1] = false;\n\tif(a[2] == b[2]) result[2] = true;\n\telse result[2] = false;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tvec3 result = vec3(eq(bvec3(c), bvec3(true)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 eq(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  vec3 result = vec3(eq(bvec3(c)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:33: 'eq' : no matching overloaded function found

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 eq(in bvec3 a, in bvec3 b)
{
  bvec3 result;
  if ((a[0] == b[0]))
    result[0] = true;
  else
    result[0] = false;
  if ((a[1] == b[1]))
    result[1] = true;
  else
    result[1] = false;
  if ((a[2] == b[2]))
    result[2] = true;
  else
    result[2] = false;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  vec3 result = vec3(eq(bvec3(c)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/vec2_vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 b = vec3(13.0, 53.0, 139.0);
	vec2 a = vec2(b);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 b = vec3(13.0, 53.0, 139.0);\n\tvec2 a = vec2(b);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(-1.0, (!true ? ((true ? false : false) ? (2.0 + 0.0) : 0.5) : 1.0), 0.5, 0.0);

void main()
{
  vec3 b = vec3(13.0 , 53.0 , 139.0);
  vec2 a = vec2(b);
  float gray;
  if (((a[0] == 13.0) && (a[1] == 53.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.147601476014756
Processing this: /home/oof/webgl_cleaned/bvec4_empty_out_bvec4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec4 function(out bvec4 par);
bool is_all(const in bvec4 par, const in bool value);
void set_all(out bvec4 par, const in bool value);
void main ()
{
	bvec4 par = bvec4(true, true, true, true);
	bvec4 ret = bvec4(false, false, false, false);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, false) && is_all(ret, true))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
bvec4 function(out bvec4 par)
{
	set_all(par, false);
	return bvec4(true, true, true, true);
}
bool is_all(const in bvec4 par, const in bool value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out bvec4 par, const in bool value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec4 function(out bvec4 par);\nbool is_all(const in bvec4 par, const in bool value);\nvoid set_all(out bvec4 par, const in bool value);\nvoid main ()\n{\n\tbvec4 par = bvec4(true, true, true, true);\n\tbvec4 ret = bvec4(false, false, false, false);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, false) && is_all(ret, true))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nbvec4 function(out bvec4 par)\n{\n\tset_all(par, false);\n\treturn bvec4(true, true, true, true);\n}\nbool is_all(const in bvec4 par, const in bool value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out bvec4 par, const in bool value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
60.147601476014756
Processing this: /home/oof/webgl_cleaned/array_const_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
const int array_size = 2;
void main ()
{
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
		             5.0,  6.0,  7.0,  8.0,
			     9.0, 10.0, 11.0, 12.0,
			    13.0, 14.0, 15.0, 16.0);
	const mat4 b = mat4(17.0, 18.0, 19.0, 20.0,
		            21.0, 22.0, 23.0, 24.0,
			    25.0, 26.0, 27.0, 28.0,
			    29.0, 30.0, 31.0, 32.0);
	mat4 array[array_size];
	float gray;
	array[0] = a;
	array[1] = b;
	if((array[0] == a) && (array[1] == b))
		gray = 1.0;
	else
		gray = 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nconst int array_size = 2;\nvoid main ()\n{\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t\t             5.0,  6.0,  7.0,  8.0,\n\t\t\t     9.0, 10.0, 11.0, 12.0,\n\t\t\t    13.0, 14.0, 15.0, 16.0);\n\tconst mat4 b = mat4(17.0, 18.0, 19.0, 20.0,\n\t\t            21.0, 22.0, 23.0, 24.0,\n\t\t\t    25.0, 26.0, 27.0, 28.0,\n\t\t\t    29.0, 30.0, 31.0, 32.0);\n\tmat4 array[array_size];\n\tfloat gray;\n\tarray[0] = a;\n\tarray[1] = b;\n\tif((array[0] == a) && (array[1] == b))\n\t\tgray = 1.0;\n\telse\n\t\tgray = 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

const int array_size = 2;

void main()
{
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  const mat4 b = mat4(17.0 , 18.0 , 19.0 , 20.0 , 21.0 , 22.0 , 23.0 , 24.0 , 25.0 , 26.0 , 27.0 , 28.0 , 29.0 , 30.0 , 31.0 , 32.0);
  mat4 array[array_size];
  float gray;
  array[0] = a;
  array[1] = b;
  if (((array[0] == a) && (array[1] == b)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.29411764705882
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * gtf_Color.rg;
	color = vec4(c / 100.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * gtf_Color.rg;\n\tcolor = vec4(c / 100.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(2.0, 1.0, -0.5, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (100.0 * gtf_Color.rg);
  color = vec4((c / 100.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.43956043956044
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(lessThan(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(lessThan(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 0.5, ((0.5 - 0.0) + (true ? 0.0 : (2.0 / 1.0))), 1.0);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(lessThan(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.58394160583942
Processing this: /home/oof/webgl_cleaned/vec2_2float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 a = vec2(13.0,53.0);
	float gray;
	if( (a[0] == 13.0) && (a[1] == 53.0) )
	gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 a = vec2(13.0,53.0);\n\tfloat gray;\n\tif( (a[0] == 13.0) && (a[1] == 53.0) )\n\tgray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(((false ? (1.0 - 2.0) : -1.0) - (-0.5 - -1.0)), (!(true || true) ? 0.0 : (false ? (false ? 0.5 : 1.0) : (0.0 - 1.0))), ((+-1.0 * -2.0) - (0.0 + -1.0)), 0.0);

void main()
{
  vec2 a = vec2(13.0 , 53.0);
  float gray;
  if (((a[0] == 13.0) && (a[1] == 53.0)))
    gray = 1.0;
  else
    gray = 0.0;
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.72727272727273
Mutations attempted: 275
Valid mutations:     167
Success rate:        60.73%
Processing this: /home/oof/webgl_cleaned/cos_float_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	gl_FragColor = vec4(0.5 * cos(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tgl_FragColor = vec4(0.5 * cos(2.0 * M_PI * color.r) + 0.5, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((-1.0 - 0.5) * 0.5) + 1.0), 0.5, (((true && true) ? true : true) ? 0.0 : ((true && false) ? 0.5 : -0.5)), +0.0);

void main()
{
  const float M_PI = 3.141592653589793;
  gl_FragColor = vec4(((0.5 * cos(((2.0 * M_PI) * color.r))) + 0.5) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.86956521739131
Processing this: /home/oof/webgl_cleaned/float_empty_out_float_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(out float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(out float par[3])
{
	set_all(par, 0.0);
	return 1.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(out float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(out float par[3])\n{\n\tset_all(par, 0.0);\n\treturn 1.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.86956521739131
Processing this: /home/oof/webgl_cleaned/structnest_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct nestb
{
	vec4 b;
};
struct nesta
{
	vec4 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta(vec4(11, 13, 17, 31), nestb(vec4(12, 19, 29, 69) ) ) );
	gl_FragColor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.a[3] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2] + s.nest_a.nest_b.b[3]) / 201.0 ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct nestb\n{\n\tvec4 b;\n};\nstruct nesta\n{\n\tvec4 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta(vec4(11, 13, 17, 31), nestb(vec4(12, 19, 29, 69) ) ) );\n\tgl_FragColor = vec4( vec3(  (s.nest_a.a[0] + s.nest_a.a[1] + s.nest_a.a[2] + s.nest_a.a[3] + s.nest_a.nest_b.b[0] + s.nest_a.nest_b.b[1] + s.nest_a.nest_b.b[2] + s.nest_a.nest_b.b[3]) / 201.0 ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct nestb {
  vec4 b;
};

struct nesta {
  vec4 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(vec4(11 , 13 , 17 , 31) , nestb(vec4(12 , 19 , 29 , 69))));
  gl_FragColor = vec4(vec3(((((((((s.nest_a.a[0] + s.nest_a.a[1]) + s.nest_a.a[2]) + s.nest_a.a[3]) + s.nest_a.nest_b.b[0]) + s.nest_a.nest_b.b[1]) + s.nest_a.nest_b.b[2]) + s.nest_a.nest_b.b[3]) / 201.0)) , 1.0);
}


As vertex? : False
SUCCESS!
61.01083032490975
Processing this: /home/oof/webgl_cleaned/structcopy_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec2 a;
	vec2 b;
};
void main ()
{
	sabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );
	sabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );
	s2 = s1;
	color = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec2 a;\n\tvec2 b;\n};\nvoid main ()\n{\n\tsabcd s1 = sabcd(vec2(12.0, 29.0), vec2(13.0, 26.0) );\n\tsabcd s2 = sabcd(vec2(0.0, 0.0), vec2(0.0, 0.0) );\n\ts2 = s1;\n\tcolor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.b[0] + s2.b[1]) / 80.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:6: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  vec2 a;
  vec2 b;
};

void main()
{
  sabcd s1 = sabcd(vec2(12.0 , 29.0) , vec2(13.0 , 26.0));
  sabcd s2 = sabcd(vec2(0.0 , 0.0) , vec2(0.0 , 0.0));
  s2 = s1;
  color = vec4(vec3(((((s2.a[0] + s2.a[1]) + s2.b[0]) + s2.b[1]) / 80.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.79136690647482
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.93189964157706
Processing this: /home/oof/webgl_cleaned/pow_vec3_vert_xconsthalf_yvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = -2.0 * (gtf_Color.rgb - 0.5);
	color = vec4(exp2(2.0 * c) / 4.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = -2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4(exp2(2.0 * c) / 4.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (gtf_Color.rgb - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = (-2.0 * (gtf_Color.rgb - 0.5));
  color = vec4((exp2((2.0 * c)) / 4.0));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.71428571428571
Processing this: /home/oof/webgl_cleaned/float_empty_inout_float_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(inout float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(inout float par[3])
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return 1.0;
	}
	else
		return 0.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(inout float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(inout float par[3])\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.71428571428571
Processing this: /home/oof/webgl_cleaned/exp2_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = gtf_Color.rgb;
	color = vec4(pow(vec3(2.0), 5.0 * c) / 32.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = gtf_Color.rgb;\n\tcolor = vec4(pow(vec3(2.0), 5.0 * c) / 32.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.5, -1.0, 0.5, -0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = gtf_Color.rgb;
  color = vec4((pow(vec3(2.0) , (5.0 * c)) / 32.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.854092526690394
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_array_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(out vec4 par[3]);
bool is_all(const in vec4 par, const in float value);
bool is_all(const in vec4 array[3], const in vec4 value);
void set_all(out vec4 array[3], const in vec4 value);
void main ()
{
	vec4 par[3];
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	set_all(par, vec4(1.0, 1.0, 1.0, 1.0));
	ret = function(par);
	if(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(out vec4 par[3])
{
	set_all(par, vec4(0.0, 0.0, 0.0, 0.0));
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in vec4 array[3], const in vec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 array[3], const in vec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(out vec4 par[3]);\nbool is_all(const in vec4 par, const in float value);\nbool is_all(const in vec4 array[3], const in vec4 value);\nvoid set_all(out vec4 array[3], const in vec4 value);\nvoid main ()\n{\n\tvec4 par[3];\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tset_all(par, vec4(1.0, 1.0, 1.0, 1.0));\n\tret = function(par);\n\tif(is_all(par, vec4(0.0, 0.0, 0.0, 0.0)) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(out vec4 par[3])\n{\n\tset_all(par, vec4(0.0, 0.0, 0.0, 0.0));\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in vec4 array[3], const in vec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 array[3], const in vec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.854092526690394
Processing this: /home/oof/webgl_cleaned/tan_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 0.5 * M_PI * 2.0 * (color.rgb - 0.5);
	vec3 o;
	if(abs(c.r) < 0.5)
		o.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;
	else
		o.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;
	if(abs(c.g) < 0.5)
		o.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;
	else
		o.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;
	if(abs(c.b) < 0.5)
		o.b = 0.5 * (sin(c.b) / cos(c.b)) + 0.5;
	else
		o.b = 0.5 * (cos(c.b) / sin(c.b)) + 0.5;
	gl_FragColor = vec4(o, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 0.5 * M_PI * 2.0 * (color.rgb - 0.5);\n\tvec3 o;\n\tif(abs(c.r) < 0.5)\n\t\to.r = 0.5 * (sin(c.r) / cos(c.r)) + 0.5;\n\telse\n\t\to.r = 0.5 * (cos(c.r) / sin(c.r)) + 0.5;\n\tif(abs(c.g) < 0.5)\n\t\to.g = 0.5 * (sin(c.g) / cos(c.g)) + 0.5;\n\telse\n\t\to.g = 0.5 * (cos(c.g) / sin(c.g)) + 0.5;\n\tif(abs(c.b) < 0.5)\n\t\to.b = 0.5 * (sin(c.b) / cos(c.b)) + 0.5;\n\telse\n\t\to.b = 0.5 * (cos(c.b) / sin(c.b)) + 0.5;\n\tgl_FragColor = vec4(o, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * (sin(c.r) / cos(c.r))) + 0.5);
  else
    o.r = ((0.5 * (cos(c.r) / sin(c.r))) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * (sin(c.g) / cos(c.g))) + 0.5);
  else
    o.g = ((0.5 * (cos(c.g) / sin(c.g))) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * (sin(c.b) / cos(c.b))) + 0.5);
  else
    o.b = ((0.5 * (cos(c.b) / sin(c.b))) + 0.5);
  gl_FragColor = vec4(o);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:23: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (((0.5 * M_PI) * 2.0) * (color.rgb - 0.5));
  vec3 o;
  if ((abs(c.r) < 0.5))
    o.r = ((0.5 * (sin(c.r) / cos(c.r))) + 0.5);
  else
    o.r = ((0.5 * (cos(c.r) / sin(c.r))) + 0.5);
  if ((abs(c.g) < 0.5))
    o.g = ((0.5 * (sin(c.g) / cos(c.g))) + 0.5);
  else
    o.g = ((0.5 * (cos(c.g) / sin(c.g))) + 0.5);
  if ((abs(c.b) < 0.5))
    o.b = ((0.5 * (sin(c.b) / cos(c.b))) + 0.5);
  else
    o.b = ((0.5 * (cos(c.b) / sin(c.b))) + 0.5);
  gl_FragColor = vec4(o);
}


==============================
60.63829787234043
Mutations attempted: 282
Valid mutations:     171
Success rate:        60.64%
Processing this: /home/oof/webgl_cleaned/all_bvec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(4.0 * color.rgb);
	gl_FragColor = vec4(vec3(all(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(4.0 * color.rgb);\n\tgl_FragColor = vec4(vec3(all(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((+2.0 / (+1.0 - 2.0)), 1.0, (!true ? 2.0 : (1.0 - -0.0)), -1.0);

void main()
{
  vec3 c = floor((4.0 * color.rgb));
  gl_FragColor = vec4(vec3(all(bvec3(c))) , 1.0);
}


As vertex? : False
SUCCESS!
60.7773851590106
Processing this: /home/oof/webgl_cleaned/const_mat4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void main ()
{
	float x;
	const mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,
	                     5.0,  6.0,  7.0,  8.0,
	                     9.0, 10.0, 11.0, 12.0,
	                    13.0, 14.0, 15.0, 16.0);
	bool elms = true;
	if(a[0][0] !=  1.0) elms = false;
	if(a[0][1] !=  2.0) elms = false;
	if(a[0][2] !=  3.0) elms = false;
	if(a[0][3] !=  4.0) elms = false;
	if(a[1][0] !=  5.0) elms = false;
	if(a[1][1] !=  6.0) elms = false;
	if(a[1][2] !=  7.0) elms = false;
	if(a[1][3] !=  8.0) elms = false;
	if(a[2][0] !=  9.0) elms = false;
	if(a[2][1] != 10.0) elms = false;
	if(a[2][2] != 11.0) elms = false;
	if(a[2][3] != 12.0) elms = false;
	if(a[3][0] != 13.0) elms = false;
	if(a[3][1] != 14.0) elms = false;
	if(a[3][2] != 15.0) elms = false;
	if(a[3][3] != 16.0) elms = false;
	bool rows = true;
	x = a[0][0] + a[1][0] + a[2][0] + a[3][0];
	if(x < 28.0-0.1 || x > 28.0+0.1) rows = false;
	x = a[0][1] + a[1][1] + a[2][1] + a[3][1];
	if(x < 32.0-0.1 || x > 32.0+0.1) rows = false;
	x = a[0][2] + a[1][2] + a[2][2] + a[3][2];
	if(x < 36.0-0.1 || x > 36.0+0.1) rows = false;
	x = a[0][3] + a[1][3] + a[2][3] + a[3][3];
	if(x < 40.0-0.1 || x > 40.0+0.1) rows = false;
	bool cols = true;
	x = a[0][0] + a[0][1] + a[0][2] + a[0][3];
	if(x < 10.0-0.1 || x > 10.0+0.1) cols = false;
	x = a[1][0] + a[1][1] + a[1][2] + a[1][3];
	if(x < 26.0-0.1 || x > 26.0+0.1) cols = false;
	x = a[2][0] + a[2][1] + a[2][2] + a[2][3];
	if(x < 42.0-0.1 || x > 42.0+0.1) cols = false;
	x = a[3][0] + a[3][1] + a[3][2] + a[3][3];
	if(x < 58.0-0.1 || x > 58.0+0.1) cols = false;
	float gray = elms && rows && cols ? 1.0 : 0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid main ()\n{\n\tfloat x;\n\tconst mat4 a = mat4( 1.0,  2.0,  3.0,  4.0,\n\t                     5.0,  6.0,  7.0,  8.0,\n\t                     9.0, 10.0, 11.0, 12.0,\n\t                    13.0, 14.0, 15.0, 16.0);\n\tbool elms = true;\n\tif(a[0][0] !=  1.0) elms = false;\n\tif(a[0][1] !=  2.0) elms = false;\n\tif(a[0][2] !=  3.0) elms = false;\n\tif(a[0][3] !=  4.0) elms = false;\n\tif(a[1][0] !=  5.0) elms = false;\n\tif(a[1][1] !=  6.0) elms = false;\n\tif(a[1][2] !=  7.0) elms = false;\n\tif(a[1][3] !=  8.0) elms = false;\n\tif(a[2][0] !=  9.0) elms = false;\n\tif(a[2][1] != 10.0) elms = false;\n\tif(a[2][2] != 11.0) elms = false;\n\tif(a[2][3] != 12.0) elms = false;\n\tif(a[3][0] != 13.0) elms = false;\n\tif(a[3][1] != 14.0) elms = false;\n\tif(a[3][2] != 15.0) elms = false;\n\tif(a[3][3] != 16.0) elms = false;\n\tbool rows = true;\n\tx = a[0][0] + a[1][0] + a[2][0] + a[3][0];\n\tif(x < 28.0-0.1 || x > 28.0+0.1) rows = false;\n\tx = a[0][1] + a[1][1] + a[2][1] + a[3][1];\n\tif(x < 32.0-0.1 || x > 32.0+0.1) rows = false;\n\tx = a[0][2] + a[1][2] + a[2][2] + a[3][2];\n\tif(x < 36.0-0.1 || x > 36.0+0.1) rows = false;\n\tx = a[0][3] + a[1][3] + a[2][3] + a[3][3];\n\tif(x < 40.0-0.1 || x > 40.0+0.1) rows = false;\n\tbool cols = true;\n\tx = a[0][0] + a[0][1] + a[0][2] + a[0][3];\n\tif(x < 10.0-0.1 || x > 10.0+0.1) cols = false;\n\tx = a[1][0] + a[1][1] + a[1][2] + a[1][3];\n\tif(x < 26.0-0.1 || x > 26.0+0.1) cols = false;\n\tx = a[2][0] + a[2][1] + a[2][2] + a[2][3];\n\tif(x < 42.0-0.1 || x > 42.0+0.1) cols = false;\n\tx = a[3][0] + a[3][1] + a[3][2] + a[3][3];\n\tif(x < 58.0-0.1 || x > 58.0+0.1) cols = false;\n\tfloat gray = elms && rows && cols ? 1.0 : 0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  float x;
  const mat4 a = mat4(1.0 , 2.0 , 3.0 , 4.0 , 5.0 , 6.0 , 7.0 , 8.0 , 9.0 , 10.0 , 11.0 , 12.0 , 13.0 , 14.0 , 15.0 , 16.0);
  bool elms = true;
  if ((a[0][0] != 1.0))
    elms = false;
  if ((a[0][1] != 2.0))
    elms = false;
  if ((a[0][2] != 3.0))
    elms = false;
  if ((a[0][3] != 4.0))
    elms = false;
  if ((a[1][0] != 5.0))
    elms = false;
  if ((a[1][1] != 6.0))
    elms = false;
  if ((a[1][2] != 7.0))
    elms = false;
  if ((a[1][3] != 8.0))
    elms = false;
  if ((a[2][0] != 9.0))
    elms = false;
  if ((a[2][1] != 10.0))
    elms = false;
  if ((a[2][2] != 11.0))
    elms = false;
  if ((a[2][3] != 12.0))
    elms = false;
  if ((a[3][0] != 13.0))
    elms = false;
  if ((a[3][1] != 14.0))
    elms = false;
  if ((a[3][2] != 15.0))
    elms = false;
  if ((a[3][3] != 16.0))
    elms = false;
  bool rows = true;
  x = (((a[0][0] + a[1][0]) + a[2][0]) + a[3][0]);
  if (((x < (28.0 - 0.1)) || (x > (28.0 + 0.1))))
    rows = false;
  x = (((a[0][1] + a[1][1]) + a[2][1]) + a[3][1]);
  if (((x < (32.0 - 0.1)) || (x > (32.0 + 0.1))))
    rows = false;
  x = (((a[0][2] + a[1][2]) + a[2][2]) + a[3][2]);
  if (((x < (36.0 - 0.1)) || (x > (36.0 + 0.1))))
    rows = false;
  x = (((a[0][3] + a[1][3]) + a[2][3]) + a[3][3]);
  if (((x < (40.0 - 0.1)) || (x > (40.0 + 0.1))))
    rows = false;
  bool cols = true;
  x = (((a[0][0] + a[0][1]) + a[0][2]) + a[0][3]);
  if (((x < (10.0 - 0.1)) || (x > (10.0 + 0.1))))
    cols = false;
  x = (((a[1][0] + a[1][1]) + a[1][2]) + a[1][3]);
  if (((x < (26.0 - 0.1)) || (x > (26.0 + 0.1))))
    cols = false;
  x = (((a[2][0] + a[2][1]) + a[2][2]) + a[2][3]);
  if (((x < (42.0 - 0.1)) || (x > (42.0 + 0.1))))
    cols = false;
  x = (((a[3][0] + a[3][1]) + a[3][2]) + a[3][3]);
  if (((x < (58.0 - 0.1)) || (x > (58.0 + 0.1))))
    cols = false;
  float gray = (((elms && rows) && cols) ? 1.0 : 0.0);
  gl_FragColor = vec4(gray , gray , gray , 1.0);
}


As vertex? : False
SUCCESS!
60.91549295774647
Processing this: /home/oof/webgl_cleaned/ivec4_empty_out_ivec4_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
ivec4 function(out ivec4 par[3]);
bool is_all(const in ivec4 par, const in int value);
bool is_all(const in ivec4 array[3], const in ivec4 value);
void set_all(out ivec4 array[3], const in ivec4 value);
void main ()
{
	ivec4 par[3];
	ivec4 ret = ivec4(0, 0, 0, 0);
	float gray = 0.0;
	set_all(par, ivec4(1, 1, 1, 1));
	ret = function(par);
	if(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
ivec4 function(out ivec4 par[3])
{
	set_all(par, ivec4(0, 0, 0, 0));
	return ivec4(1, 1, 1, 1);
}
bool is_all(const in ivec4 par, const in int value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
bool is_all(const in ivec4 array[3], const in ivec4 value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out ivec4 array[3], const in ivec4 value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nivec4 function(out ivec4 par[3]);\nbool is_all(const in ivec4 par, const in int value);\nbool is_all(const in ivec4 array[3], const in ivec4 value);\nvoid set_all(out ivec4 array[3], const in ivec4 value);\nvoid main ()\n{\n\tivec4 par[3];\n\tivec4 ret = ivec4(0, 0, 0, 0);\n\tfloat gray = 0.0;\n\tset_all(par, ivec4(1, 1, 1, 1));\n\tret = function(par);\n\tif(is_all(par, ivec4(0, 0, 0, 0)) && is_all(ret, 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nivec4 function(out ivec4 par[3])\n{\n\tset_all(par, ivec4(0, 0, 0, 0));\n\treturn ivec4(1, 1, 1, 1);\n}\nbool is_all(const in ivec4 par, const in int value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nbool is_all(const in ivec4 array[3], const in ivec4 value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out ivec4 array[3], const in ivec4 value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.91549295774647
Processing this: /home/oof/webgl_cleaned/gl_MaxFragmentUniformVectors_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(float(gl_MaxFragmentUniformVectors) / 16.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(float(gl_MaxFragmentUniformVectors) / 16.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4((float(gl_MaxFragmentUniformVectors) / 16.5));
}


As vertex? : False
SUCCESS!
61.05263157894737
Processing this: /home/oof/webgl_cleaned/notEqual_vec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * color.rg - 4.5);
	vec2 result = vec2(notEqual(c, vec2(0.0)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * color.rg - 4.5);\n\tvec2 result = vec2(notEqual(c, vec2(0.0)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 2.0, -1.0, 0.5);

void main()
{
  vec2 c = floor(((10.0 * color.rg) - 4.5));
  vec2 result = vec2(notEqual(c , vec2(0.0)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.18881118881119
Processing this: /home/oof/webgl_cleaned/int_empty_out_int_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
int function(out int par[3]);
bool is_all(const in int array[3], const in int value);
void set_all(out int array[3], const in int value);
void main ()
{
	int par[3];
	int ret = 0;
	float gray = 0.0;
	set_all(par, 1);
	ret = function(par);
	if(is_all(par, 0) && (ret == 1))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
int function(out int par[3])
{
	set_all(par, 0);
	return 1;
}
bool is_all(const in int array[3], const in int value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out int array[3], const in int value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nint function(out int par[3]);\nbool is_all(const in int array[3], const in int value);\nvoid set_all(out int array[3], const in int value);\nvoid main ()\n{\n\tint par[3];\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tset_all(par, 1);\n\tret = function(par);\n\tif(is_all(par, 0) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nint function(out int par[3])\n{\n\tset_all(par, 0);\n\treturn 1;\n}\nbool is_all(const in int array[3], const in int value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out int array[3], const in int value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
61.18881118881119
Processing this: /home/oof/webgl_cleaned/initfunc_empty_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void initialise_array(out float array[2], float init_val);
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	initialise_array(new_mad,25.0);
	if( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
void initialise_array(out float array[2], float init_val)
{
	array[0] = init_val;
	array[1] = init_val;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid initialise_array(out float array[2], float init_val);\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tinitialise_array(new_mad,25.0);\n\tif( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvoid initialise_array(out float array[2], float init_val)\n{\n\tarray[0] = init_val;\n\tarray[1] = init_val;\n}\n\x00')
61.18881118881119
Processing this: /home/oof/webgl_cleaned/int_empty_empty_int_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
int function(int par);
void main ()
{
	int par = 1;
	int ret = 0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1) && (ret == 1))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
int function(int par)
{
	if(par == 1)
	{
		par = 0;
		return 1;
	}
	else
		return 0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nint function(int par);\nvoid main ()\n{\n\tint par = 1;\n\tint ret = 0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1) && (ret == 1))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nint function(int par)\n{\n\tif(par == 1)\n\t{\n\t\tpar = 0;\n\t\treturn 1;\n\t}\n\telse\n\t\treturn 0;\n}\n\x00')
61.18881118881119
Processing this: /home/oof/webgl_cleaned/log_vec2_vert_xvary01.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = (gtf_Color.rg + 0.01) / 1.01;
	color = vec4(log(c) / -4.61, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (gtf_Color.rg + 0.01) / 1.01;\n\tcolor = vec4(log(c) / -4.61, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((true ? 1.0 : (0.0 / 2.0)) - (-1.0 + 0.0)), ((-0.5 * --1.0) + 0.0), 1.0, (!true ? -(0.0 - 0.0) : (0.0 + 2.0)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((gtf_Color.rg + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color = vec4(((true ? 1.0 : (0.0 / 2.0)) - (-1.0 + 0.0)), ((-0.5 * --1.0) + 0.0), 1.0, (!true ? -(0.0 - 0.0) : (0.0 + 2.0)));

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = ((gtf_Color.rg + 0.01) / 1.01);
  color = vec4((log(c) / -4.61) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.97560975609756
Processing this: /home/oof/webgl_cleaned/vec4_yxwz_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.yxwz;
	vec4 a = vec4(m.y, m.x, m.w, m.z);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.yxwz;\n\tvec4 a = vec4(m.y, m.x, m.w, m.z);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.yxwz;
  vec4 a = vec4(m.y , m.x , m.w , m.z);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
61.111111111111114
Mutations attempted: 288
Valid mutations:     176
Success rate:        61.11%
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvaryyvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float x = 2.0 * (gtf_Color.g - 0.5);
	float y = 2.0 * (gtf_Color.b - 0.5);
	float atan_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	const float epsilon = 1.0e-4;
	if(x > epsilon || abs(y) > epsilon)
	{
		if(x < 0.0 ^^ y < 0.0)
		{
			sign = -1.0;
		}
		if(abs(y) <= abs(x))
		{
			float c = abs(y / x);
			for(int i = 1; i < 12; i += 2)
			{
				atan_c += scale * pow(c, float(i)) / float(i);
				scale *= -1.0;
			}
			result = vec4(sign * atan_c / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
		}
		else
		{
			float c = abs(x / y);
			for(int i = 1; i < 12; i += 2)
			{
				atan_c += scale * pow(c, float(i)) / float(i);
				scale *= -1.0;
			}
			result = vec4(sign * (M_PI / 2.0 - atan_c) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);
		}
		if(x < 0.0)
			if(y < 0.0) result.r -= 0.5;
			else if(y > 0.0) result.r += 0.5;
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat x = 2.0 * (gtf_Color.g - 0.5);\n\tfloat y = 2.0 * (gtf_Color.b - 0.5);\n\tfloat atan_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tconst float epsilon = 1.0e-4;\n\tif(x > epsilon || abs(y) > epsilon)\n\t{\n\t\tif(x < 0.0 ^^ y < 0.0)\n\t\t{\n\t\t\tsign = -1.0;\n\t\t}\n\t\tif(abs(y) <= abs(x))\n\t\t{\n\t\t\tfloat c = abs(y / x);\n\t\t\tfor(int i = 1; i < 12; i += 2)\n\t\t\t{\n\t\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\t\tscale *= -1.0;\n\t\t\t}\n\t\t\tresult = vec4(sign * atan_c / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfloat c = abs(x / y);\n\t\t\tfor(int i = 1; i < 12; i += 2)\n\t\t\t{\n\t\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\t\tscale *= -1.0;\n\t\t\t}\n\t\t\tresult = vec4(sign * (M_PI / 2.0 - atan_c) / (2.0 * M_PI) + 0.5, 0.0, 0.0, 1.0);\n\t\t}\n\t\tif(x < 0.0)\n\t\t\tif(y < 0.0) result.r -= 0.5;\n\t\t\telse if(y > 0.0) result.r += 0.5;\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color = vec4((false ? 2.0 : 0.5), +1.0, 1.0, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float x = (2.0 * (gtf_Color.g - 0.5));
  float y = (2.0 * (gtf_Color.b - 0.5));
  float atan_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x > epsilon) || (abs(y) > epsilon)))
  {
    if (((x < 0.0) ^^ (y < 0.0)))
    {
      sign = -1.0;
    }
    if ((abs(y) <= abs(x)))
    {
      float c = abs((y / x));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * atan_c) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    else
    {
      float c = abs((x / y));
      for (int i = 1; (i < 12); (i += 2))
      {
        (atan_c += ((scale * pow(c , float(i))) / float(i)));
        (scale *= -1.0);
      }
      result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / (2.0 * M_PI)) + 0.5) , 0.0 , 0.0 , 1.0);
    }
    if ((x < 0.0))
      if ((y < 0.0))
        (result.r -= 0.5);
      else
        if ((y > 0.0))
          (result.r += 0.5);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.245674740484425
Processing this: /home/oof/webgl_cleaned/radians_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 c = 360.0 * 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 c = 360.0 * 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(radians(c) / (4.0 * M_PI) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(+0.5, -1.0, -1.0, -1.0);

void main()
{
  const float M_PI = 3.141592653589793;
  vec2 c = ((360.0 * 2.0) * (gtf_Color.rg - 0.5));
  color = vec4(((radians(c) / (4.0 * M_PI)) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
61.37931034482759
Processing this: /home/oof/webgl_cleaned/log_vec2_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = 31.0 * color.rg + 1.0;
	gl_FragColor = vec4(log(c) / 3.466, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 31.0 * color.rg + 1.0;\n\tgl_FragColor = vec4(log(c) / 3.466, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, (((true ? true : true) && !false) ? 2.0 : -1.0), 2.0, ++(true ? 1.0 : 2.0));

void main()
{
  vec2 c = ((31.0 * color.rg) + 1.0);
  gl_FragColor = vec4((log(c) / 3.466) , 0.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '++' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, (((true ? true : true) && !false) ? 2.0 : -1.0), 2.0, ++(true ? 1.0 : 2.0));

void main()
{
  vec2 c = ((31.0 * color.rg) + 1.0);
  gl_FragColor = vec4((log(c) / 3.466) , 0.0 , 1.0);
}


==============================
61.16838487972509
Processing this: /home/oof/webgl_cleaned/bvec4_2int_2float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	bvec4 a = bvec4(0, 23, 0.0, 23.0);
	float gray;
	if( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tbvec4 a = bvec4(0, 23, 0.0, 23.0);\n\tfloat gray;\n\tif( (a[0] == false) && (a[1] == true) && (a[2] == false) && (a[3] == true) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, (-1.0 * (true ? 0.0 : -1.0)), (-(-1.0 - -1.0) - 1.0), (2.0 - (-1.0 / 0.5)), (((false && false) ? true : true) ? ((true && false) ? 0.0 : -1.0) : -1.0), -0.0, -1.0, 1.0, 0.0, 2.0, 0.5, 0.0, (((true ? 1.0 : 1.0) - -1.0) - --2.0), -1.0, -1.0, -1.0);

vec4 color;

void main()
{
  bvec4 a = bvec4(0 , 23 , 0.0 , 23.0);
  float gray;
  if (((((a[0] == false) && (a[1] == true)) && (a[2] == false)) && (a[3] == true)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '--' : l-value required (can't modify a const)
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, (-1.0 * (true ? 0.0 : -1.0)), (-(-1.0 - -1.0) - 1.0), (2.0 - (-1.0 / 0.5)), (((false && false) ? true : true) ? ((true && false) ? 0.0 : -1.0) : -1.0), -0.0, -1.0, 1.0, 0.0, 2.0, 0.5, 0.0, (((true ? 1.0 : 1.0) - -1.0) - --2.0), -1.0, -1.0, -1.0);

vec4 color;

void main()
{
  bvec4 a = bvec4(0 , 23 , 0.0 , 23.0);
  float gray;
  if (((((a[0] == false) && (a[1] == true)) && (a[2] == false)) && (a[3] == true)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.95890410958904
Processing this: /home/oof/webgl_cleaned/array_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
	b[0] = a[0];
	c[0] += d[0];
	a[0] += 1.0;
	e[0] += 1.0;
	b[1] = a[1];
	c[1] += d[1];
	a[1] += 1.0;
	e[1] += 1.0;
	b[2] = a[2];
	c[2] += d[2];
	a[2] += 1.0;
	e[2] += 1.0;
	b[3] = a[3];
	c[3] += d[3];
	a[3] += 1.0;
	e[3] += 1.0;
}
void main ()
{
	float a[4];
	float b[4];
	float c[4];
	float d[4];
	float e[4];
	float q = 0.0;
	float q2 = 0.0;
	a[0] = 1.0;
	b[0] = 2.0;
	c[0] = 3.0;
	d[0] = 4.0;
	e[0] = 1.0;
	a[1] = 1.0;
	b[1] = 2.0;
	c[1] = 3.0;
	d[1] = 4.0;
	e[1] = 1.0;
	a[2] = 1.0;
	b[2] = 2.0;
	c[2] = 3.0;
	d[2] = 4.0;
	e[2] = 1.0;
	a[3] = 1.0;
	b[3] = 2.0;
	c[3] = 3.0;
	d[3] = 4.0;
	e[3] = 1.0;
	qualifiers(a, b, c, d, e);
	if(a[0] == 1.0) q += 1.0;
	if(b[1] == 1.0) q += 2.0;
	if(c[2] == 7.0) q += 4.0;
	if(d[3] == 4.0) q2 += 1.0;
	if(e[0] == 1.0) q2 += 2.0;
	gl_FragColor = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])\n{\n\tb[0] = a[0];\n\tc[0] += d[0];\n\ta[0] += 1.0;\n\te[0] += 1.0;\n\tb[1] = a[1];\n\tc[1] += d[1];\n\ta[1] += 1.0;\n\te[1] += 1.0;\n\tb[2] = a[2];\n\tc[2] += d[2];\n\ta[2] += 1.0;\n\te[2] += 1.0;\n\tb[3] = a[3];\n\tc[3] += d[3];\n\ta[3] += 1.0;\n\te[3] += 1.0;\n}\nvoid main ()\n{\n\tfloat a[4];\n\tfloat b[4];\n\tfloat c[4];\n\tfloat d[4];\n\tfloat e[4];\n\tfloat q = 0.0;\n\tfloat q2 = 0.0;\n\ta[0] = 1.0;\n\tb[0] = 2.0;\n\tc[0] = 3.0;\n\td[0] = 4.0;\n\te[0] = 1.0;\n\ta[1] = 1.0;\n\tb[1] = 2.0;\n\tc[1] = 3.0;\n\td[1] = 4.0;\n\te[1] = 1.0;\n\ta[2] = 1.0;\n\tb[2] = 2.0;\n\tc[2] = 3.0;\n\td[2] = 4.0;\n\te[2] = 1.0;\n\ta[3] = 1.0;\n\tb[3] = 2.0;\n\tc[3] = 3.0;\n\td[3] = 4.0;\n\te[3] = 1.0;\n\tqualifiers(a, b, c, d, e);\n\tif(a[0] == 1.0) q += 1.0;\n\tif(b[1] == 1.0) q += 2.0;\n\tif(c[2] == 7.0) q += 4.0;\n\tif(d[3] == 4.0) q2 += 1.0;\n\tif(e[0] == 1.0) q2 += 2.0;\n\tgl_FragColor = vec4(vec2(q / 7.0, q2 / 3.0), 1.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4];
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  4.0 = color[0];
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:48: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void qualifiers(in float a[4], out float b[4], inout float c[4], const in float d[4], float e[4])
{
  b[0] = a[0];
  (c[0] += d[0]);
  (a[0] += 1.0);
  (e[0] += 1.0);
  b[1] = a[1];
  (c[1] += d[1]);
  (a[1] += 1.0);
  (e[1] += 1.0);
  b[2] = a[2];
  (c[2] += d[2]);
  (a[2] += 1.0);
  (e[2] += 1.0);
  b[3] = a[3];
  (c[3] += d[3]);
  (a[3] += 1.0);
  (e[3] += 1.0);
}

void main()
{
  float a[4];
  float b[4];
  float c[4];
  float d[4];
  float e[4];
  float q = 0.0;
  float q2 = 0.0;
  a[0] = 1.0;
  b[0] = 2.0;
  c[0] = 3.0;
  d[0] = 4.0;
  e[0] = 1.0;
  a[1] = 1.0;
  b[1] = 2.0;
  c[1] = 3.0;
  d[1] = 4.0;
  e[1] = 1.0;
  a[2] = 1.0;
  b[2] = 2.0;
  c[2] = 3.0;
  4.0 = color[0];
  e[2] = 1.0;
  a[3] = 1.0;
  b[3] = 2.0;
  c[3] = 3.0;
  d[3] = 4.0;
  e[3] = 1.0;
  qualifiers(a , b , c , d , e);
  if ((a[0] == 1.0))
    (q += 1.0);
  if ((b[1] == 1.0))
    (q += 2.0);
  if ((c[2] == 7.0))
    (q += 4.0);
  if ((d[3] == 4.0))
    (q2 += 1.0);
  if ((e[0] == 1.0))
    (q2 += 2.0);
  gl_FragColor = vec4(vec2((q / 7.0) , (q2 / 3.0)) , 1.0 , 1.0);
}


==============================
60.75085324232082
Processing this: /home/oof/webgl_cleaned/pow_vec2_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 16.0 * gtf_Color.rg;
	color = vec4(sqrt(c) / 4.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 16.0 * gtf_Color.rg;\n\tcolor = vec4(sqrt(c) / 4.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(2.0, 2.0, +(false ? (2.0 + -1.0) : 0.5), +0.5);

void main()
{
  vec2 c = (16.0 * gtf_Color.rg);
  color = vec4((sqrt(c) / 4.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.8843537414966
Processing this: /home/oof/webgl_cleaned/atan_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 4.0 * 2.0 * (gtf_Color.r - 0.5);
	float atan_c = 0.0;
	float scale = 1.0;
	float sign = 1.0;
	vec4 result;
	if(c < 0.0)
	{
		sign = -1.0;
		c *= -1.0;
	}
	if(c <= 1.0)
	{
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	else
	{
		c = 1.0 / c;
		for(int i = 1; i < 12; i += 2)
		{
			atan_c += scale * pow(c, float(i)) / float(i);
			scale *= -1.0;
		}
		result = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);
	}
	color = result;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 4.0 * 2.0 * (gtf_Color.r - 0.5);\n\tfloat atan_c = 0.0;\n\tfloat scale = 1.0;\n\tfloat sign = 1.0;\n\tvec4 result;\n\tif(c < 0.0)\n\t{\n\t\tsign = -1.0;\n\t\tc *= -1.0;\n\t}\n\tif(c <= 1.0)\n\t{\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * atan_c / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\telse\n\t{\n\t\tc = 1.0 / c;\n\t\tfor(int i = 1; i < 12; i += 2)\n\t\t{\n\t\t\tatan_c += scale * pow(c, float(i)) / float(i);\n\t\t\tscale *= -1.0;\n\t\t}\n\t\tresult = vec4(sign * (M_PI / 2.0 - atan_c) / M_PI + 0.5, 0.0, 0.0, 1.0);\n\t}\n\tcolor = result;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 1.0, -1.0, (0.0 - -1.0), 2.0, --1.0, -1.0, 0.0, 0.0, -0.5, -(!false ? +0.0 : +0.0), 0.5, +2.0, (((true ? true : true) ? (true || true) : false) ? +1.0 : (0.5 + 1.0)), (0.0 * -1.0), -1.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  float atan_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  vec4 result;
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  if ((c <= 1.0))
  {
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * atan_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  else
  {
    c = (1.0 / c);
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '--' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(1.0, 1.0, -1.0, (0.0 - -1.0), 2.0, --1.0, -1.0, 0.0, 0.0, -0.5, -(!false ? +0.0 : +0.0), 0.5, +2.0, (((true ? true : true) ? (true || true) : false) ? +1.0 : (0.5 + 1.0)), (0.0 * -1.0), -1.0);

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = ((4.0 * 2.0) * (gtf_Color.r - 0.5));
  float atan_c = 0.0;
  float scale = 1.0;
  float sign = 1.0;
  vec4 result;
  if ((c < 0.0))
  {
    sign = -1.0;
    (c *= -1.0);
  }
  if ((c <= 1.0))
  {
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * atan_c) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  else
  {
    c = (1.0 / c);
    for (int i = 1; (i < 12); (i += 2))
    {
      (atan_c += ((scale * pow(c , float(i))) / float(i)));
      (scale *= -1.0);
    }
    result = vec4((((sign * ((M_PI / 2.0) - atan_c)) / M_PI) + 0.5) , 0.0 , 0.0 , 1.0);
  }
  color = result;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.67796610169491
Processing this: /home/oof/webgl_cleaned/lessThan_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(lessThan(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(lessThan(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(-0.5, (false ? -1.0 : -1.0), -1.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(lessThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.810810810810814
Processing this: /home/oof/webgl_cleaned/varying1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying float foo;
void main()
{
    foo = 5.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying float foo;\nvoid main()\n{\n    foo = 5.0;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct FuzzStruct48685 {
  uint f_9066;
  int f_8071;
  bool f_7592;
};

float foo = 2.0;

void main()
{
  foo = 5.0;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:5: 'uint' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

struct FuzzStruct48685 {
  uint f_9066;
  int f_8071;
  bool f_7592;
};

float foo = 2.0;

void main()
{
  foo = 5.0;
}


==============================
60.60606060606061
Processing this: /home/oof/webgl_cleaned/greaterThan_vec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(c, vec2(0.0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(c, vec2(0.0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, -1.0, (((-1.0 + 0.5) - (true ? -1.0 : 0.0)) * (0.0 - 0.0)), 0.0, ((true ? true : (true && true)) ? (true ? +-1.0 : -1.0) : 0.0), 0.0, +1.0, (false ? 0.5 : 2.0), -(+-1.0 + 1.0), -0.5, ((true ? 0.0 : +0.5) + 2.0), (!(false ? true : false) ? -(1.0 / 1.0) : ((false ? true : false) ? (0.0 * 1.0) : (true ? -1.0 : -1.0))), (0.5 / 1.0), -1.0, 2.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(-1.0, 0.0, -1.0, (((-1.0 + 0.5) - (true ? -1.0 : 0.0)) * (0.0 - 0.0)), 0.0, ((true ? true : (true && true)) ? (true ? +-1.0 : -1.0) : 0.0), 0.0, +1.0, (false ? 0.5 : 2.0), -(+-1.0 + 1.0), -0.5, ((true ? 0.0 : +0.5) + 2.0), (!(false ? true : false) ? -(1.0 / 1.0) : ((false ? true : false) ? (0.0 * 1.0) : (true ? -1.0 : -1.0))), (0.5 / 1.0), -1.0, 2.0);

vec4 color;

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(c , vec2(0.0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.40268456375839
Mutations attempted: 298
Valid mutations:     180
Success rate:        60.40%
Processing this: /home/oof/webgl_cleaned/exp_float_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	float c = color.r;
	gl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tfloat c = color.r;\n\tgl_FragColor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  const float exp1 = 2.7183;
  float c = color.r;
  gl_FragColor = vec4(0.5);
}


As vertex? : False
SUCCESS!
60.535117056856194
Processing this: /home/oof/webgl_cleaned/2f_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
attribute vec4 gtf_Color;
uniform vec2 color;
varying vec2 col;
void main ()
{
	col = color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nattribute vec4 gtf_Color;\nuniform vec2 color;\nvarying vec2 col;\nvoid main ()\n{\n\tcol = color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Color;

uniform vec2 color;

vec2 col = vec2(0.5, (((true ? true : true) ? true : (false ? false : false)) ? 0.0 : (false ? (0.5 * 1.0) : -1.0)));

void main()
{
  col = color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.66666666666667
Processing this: /home/oof/webgl_cleaned/min_vec3_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 min_c = vec3(0.5, 0.5, 0.5);
	vec3 c = gtf_Color.rgb;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	if(c[2] > min_c[2]) c[2] = min_c[2];
	color = vec4(c, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 min_c = vec3(0.5, 0.5, 0.5);\n\tvec3 c = gtf_Color.rgb;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tif(c[2] > min_c[2]) c[2] = min_c[2];\n\tcolor = vec4(c, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(((2.0 / 2.0) / 0.5), 0.0, (false ? 0.0 : 0.5), (-0.0 + 0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const vec3 min_c = vec3(0.5 , 0.5 , 0.5);
  vec3 c = gtf_Color.rgb;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  if ((c[2] > min_c[2]))
    c[2] = min_c[2];
  color = vec4(c , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.797342192691026
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = floor(10.0 * gtf_Color.rg - 4.5);
	vec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));
	color = vec4(result, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(10.0 * gtf_Color.rg - 4.5);\n\tvec2 result = vec2(greaterThan(ivec2(c), ivec2(0)));\n\tcolor = vec4(result, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, -0.5, 2.0, -1.0);

void main()
{
  vec2 c = floor(((10.0 * gtf_Color.rg) - 4.5));
  vec2 result = vec2(greaterThan(ivec2(c) , ivec2(0)));
  color = vec4(result , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.9271523178808
Processing this: /home/oof/webgl_cleaned/intUniformShader.vert
Original source code: 
precision mediump float;
precision mediump int;

uniform int ival;
uniform ivec2 ival2;
uniform ivec3 ival3;
uniform ivec4 ival4;
void main()
{
    int sum = ival
            + ival2[0] + ival2[1]
            + ival3[0] + ival3[1] + ival3[2]
            + ival4[0] + ival4[1] + ival4[2] + ival4[3];
    gl_Position = vec4(sum, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform int ival;\nuniform ivec2 ival2;\nuniform ivec3 ival3;\nuniform ivec4 ival4;\nvoid main()\n{\n    int sum = ival\n            + ival2[0] + ival2[1]\n            + ival3[0] + ival3[1] + ival3[2]\n            + ival4[0] + ival4[1] + ival4[2] + ival4[3];\n    gl_Position = vec4(sum, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2 = ivec2(7, +ival);

uniform ivec3 ival3;

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform int ival;

uniform ivec2 ival2 = ivec2(7, +ival);

uniform ivec3 ival3;

uniform ivec4 ival4;

void main()
{
  int sum = (((((((((ival + ival2[0]) + ival2[1]) + ival3[0]) + ival3[1]) + ival3[2]) + ival4[0]) + ival4[1]) + ival4[2]) + ival4[3]);
  gl_Position = vec4(sum , 0.0 , 0.0 , 1.0);
}


==============================
60.726072607260726
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvaryneg.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = -color.rg;
	gl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = -color.rg;\n\tgl_FragColor = vec4(exp2(5.0 * c), 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = -color.rg;
  gl_FragColor = vec4(exp2((5.0 * c)) , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = -color.rg;
  gl_FragColor = vec4(exp2((5.0 * c)) , 0.0);
}


==============================
60.526315789473685
Processing this: /home/oof/webgl_cleaned/void_empty_empty_void_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float gray = 0.0;
void function();
void main ()
{
	gray = 0.0;
	function();
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
void function()
{
	gray = 1.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat gray = 0.0;\nvoid function();\nvoid main ()\n{\n\tgray = 0.0;\n\tfunction();\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nvoid function()\n{\n\tgray = 1.0;\n}\n\x00')
60.526315789473685
Processing this: /home/oof/webgl_cleaned/vec4_pqs_t_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.pqs;
	float t = al.t;
	vec4 a = vec4(m.p, t, m.s, m.t);
	gl_FragColor = a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.pqs;\n\tfloat t = al.t;\n\tvec4 a = vec4(m.p, t, m.s, m.t);\n\tgl_FragColor = a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(-1.0, 0.5, -1.0, (0.0 * 1.0));

void main()
{
  vec4 al = color;
  vec3 m = al.pqs;
  float t = al.t;
  vec4 a = vec4(m.p , t , m.s , m.t);
  gl_FragColor = a;
}


As vertex? : False
SUCCESS!
60.65573770491803
Processing this: /home/oof/webgl_cleaned/fwidth_frag_ref_dx.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec2 vertXY;
void main ()
{
	vertXY = gtf_Vertex.xy;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec2 vertXY;\nvoid main ()\n{\n\tvertXY = gtf_Vertex.xy;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec2 vertXY;

void main()
{
  vertXY = gtf_Vertex.xy;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.78431372549019
Processing this: /home/oof/webgl_cleaned/dot_float_frag_xvaryyone_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	gl_FragColor = vec4(vec3(color.r), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tgl_FragColor = vec4(vec3(color.r), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, 2.0, 0.0, +(false ? 0.5 : (2.0 - 2.0)))(vec3(color.r));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '(' : syntax error

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4(-1.0, 2.0, 0.0, +(false ? 0.5 : (2.0 - 2.0)))(vec3(color.r));
}


==============================
60.586319218241044
Mutations attempted: 307
Valid mutations:     186
Success rate:        60.59%
Processing this: /home/oof/webgl_cleaned/struct_vec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	color = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tcolor = vec4( vec3(  (s.a[0] + s.a[1] + s.a[2] + s.a[3] + s.b[0] + s.b[1] + s.b[2] + s.b[3]) / 250.0  ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  color = vec4(vec3(((((((((s.a[0] + s.a[1]) + s.a[2]) + s.a[3]) + s.b[0]) + s.b[1]) + s.b[2]) + s.b[3]) / 250.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.71428571428571
Processing this: /home/oof/webgl_cleaned/mod_vec3_frag_xvary_yconst1_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (color.rgb - 0.5);
	c = c - 1.0 * floor(c / 1.0);
	gl_FragColor = vec4(c, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (color.rgb - 0.5);\n\tc = c - 1.0 * floor(c / 1.0);\n\tgl_FragColor = vec4(c, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, 0.0, (!!false ? (-1.0 * 0.0) : 2.0), ((true ? true : (true ? true : true)) ? (-1.0 / 1.0) : 0.0));

void main()
{
  vec3 c = ((10.0 * 2.0) * (color.rgb - 0.5));
  c = (c - (1.0 * floor((c / 1.0))));
  gl_FragColor = vec4(c , 1.0);
}


As vertex? : False
SUCCESS!
60.84142394822006
Processing this: /home/oof/webgl_cleaned/exp2_vec2_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = color.rg;
	gl_FragColor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(pow(vec2(2.0), 5.0 * c) / 32.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = color.rg;
  gl_FragColor = vec4((pow(vec2(2.0) , (5.0 * c)) / 32.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.967741935483865
Processing this: /home/oof/webgl_cleaned/CorrectFuncOverload_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
void testVoid (vec4 v, vec4 v1)
{
}
void testVoid (ivec4 v, ivec4 v1)
{
}
void main()
{
    vec4 v;
    ivec4 i;
    testVoid(i, i);
    testVoid(v, v);
    gl_FragColor = v;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvoid testVoid (vec4 v, vec4 v1)\n{\n}\nvoid testVoid (ivec4 v, ivec4 v1)\n{\n}\nvoid main()\n{\n    vec4 v;\n    ivec4 i;\n    testVoid(i, i);\n    testVoid(v, v);\n    gl_FragColor = v;\n}\n\x00')
60.967741935483865
Processing this: /home/oof/webgl_cleaned/mix_vec2_frag_xvary_yconsthalf_aconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 y = vec2(0.5, 0.5);
	const vec2 a = vec2(0.5, 0.5);
	vec2 c = color.rg;
	gl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 y = vec2(0.5, 0.5);\n\tconst vec2 a = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tgl_FragColor = vec4(c * (1.0 - a) + y * a, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.0, (2.0 * ((0.0 - 2.0) + (true ? 1.0 : 1.0))), -0.5, 1.0);

void main()
{
  const vec2 y = vec2(0.5 , 0.5);
  const vec2 a = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  gl_FragColor = vec4(((c * (1.0 - a)) + (y * a)) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.09324758842444
Processing this: /home/oof/webgl_cleaned/mat3arrayindirect1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform mat3 testmat3[2];
varying vec4  color;
void main()
{
	vec3 result = vec3(0.0, 0.0, 0.0);
	result += testmat3[1][0];
	result += testmat3[1][1];
	result += testmat3[1][2];
	gl_FragColor = vec4(result/2.0, 0.5);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform mat3 testmat3[2];\nvarying vec4  color;\nvoid main()\n{\n\tvec3 result = vec3(0.0, 0.0, 0.0);\n\tresult += testmat3[1][0];\n\tresult += testmat3[1][1];\n\tresult += testmat3[1][2];\n\tgl_FragColor = vec4(result/2.0, 0.5);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform mat3 testmat3[2];

vec4 color = vec4(0.0, -0.0, ((false ? (true && false) : !true) ? 0.5 : 0.0), (2.0 - -1.0));

void main()
{
  vec3 result = vec3(0.0 , 0.0 , 0.0);
  (result += testmat3[1][0]);
  (result += testmat3[1][1]);
  (result += testmat3[1][2]);
  gl_FragColor = vec4((result / 2.0) , 0.5);
}


As vertex? : False
SUCCESS!
61.21794871794872
Processing this: /home/oof/webgl_cleaned/vec4_empty_out_vec4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
vec4 function(out vec4 par);
bool is_all(const in vec4 par, const in float value);
void set_all(out vec4 par, const in float value);
void main ()
{
	vec4 par = vec4(1.0, 1.0, 1.0, 1.0);
	vec4 ret = vec4(0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
vec4 function(out vec4 par)
{
	set_all(par, 0.0);
	return vec4(1.0, 1.0, 1.0, 1.0);
}
bool is_all(const in vec4 par, const in float value)
{
	bool ret = true;
	if(par[0] != value)
		ret = false;
	if(par[1] != value)
		ret = false;
	if(par[2] != value)
		ret = false;
	if(par[3] != value)
		ret = false;
	return ret;
}
void set_all(out vec4 par, const in float value)
{
	par[0] = value;
	par[1] = value;
	par[2] = value;
	par[3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvec4 function(out vec4 par);\nbool is_all(const in vec4 par, const in float value);\nvoid set_all(out vec4 par, const in float value);\nvoid main ()\n{\n\tvec4 par = vec4(1.0, 1.0, 1.0, 1.0);\n\tvec4 ret = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvec4 function(out vec4 par)\n{\n\tset_all(par, 0.0);\n\treturn vec4(1.0, 1.0, 1.0, 1.0);\n}\nbool is_all(const in vec4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0] != value)\n\t\tret = false;\n\tif(par[1] != value)\n\t\tret = false;\n\tif(par[2] != value)\n\t\tret = false;\n\tif(par[3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out vec4 par, const in float value)\n{\n\tpar[0] = value;\n\tpar[1] = value;\n\tpar[2] = value;\n\tpar[3] = value;\n}\n\x00')
61.21794871794872
Processing this: /home/oof/webgl_cleaned/log_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 31.0 * gtf_Color.rgb + 1.0;
	color = vec4(log(c) / 3.466, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 31.0 * gtf_Color.rgb + 1.0;\n\tcolor = vec4(log(c) / 3.466, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((true || false) ? 0.5 : (0.5 - -1.0));
  color = vec4((log(c) / 3.466) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: '=' : dimension mismatch
ERROR: 0:14: '=' : cannot convert from 'const float' to 'mediump 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = ((true || false) ? 0.5 : (0.5 - -1.0));
  color = vec4((log(c) / 3.466) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
61.0223642172524
Processing this: /home/oof/webgl_cleaned/CorrectParseTest1_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
struct s {
    vec4 v;
} s2;
void main()
{
    s s1 = s(vec4(ivec4(4.0, vec2(5,6), 7.0)));
    vec4 v = vec4(2,ivec2(3.0, 4.0), 5.0);
    vec4 v4 = vec4(ivec4(8.0));
    gl_FragColor = v4 + v + s1.v;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nstruct s {\n    vec4 v;\n} s2;\nvoid main()\n{\n    s s1 = s(vec4(ivec4(4.0, vec2(5,6), 7.0)));\n    vec4 v = vec4(2,ivec2(3.0, 4.0), 5.0);\n    vec4 v4 = vec4(ivec4(8.0));\n    gl_FragColor = v4 + v + s1.v;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

struct s {
  vec4 v;
} s2;

void main()
{
  s s1 = s(vec4(ivec4(4.0 , vec2(5 , 6) , 7.0)));
  vec4 v = vec4(2 , ivec2(3.0 , 4.0) , 5.0);
  vec4 v4 = vec4(ivec4(8.0));
  gl_FragColor = ((v4 + v) + s1.v);
}


As vertex? : False
SUCCESS!
61.146496815286625
Processing this: /home/oof/webgl_cleaned/float_empty_empty_float_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
float function(float par);
void main ()
{
	float par = 1.0;
	float ret = 0.0;
	float gray = 0.0;
	ret = function(par);
	if((par == 1.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
float function(float par)
{
	if(par == 1.0)
	{
		par = 0.0;
		return 1.0;
	}
	else
		return 0.0;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nfloat function(float par);\nvoid main ()\n{\n\tfloat par = 1.0;\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif((par == 1.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nfloat function(float par)\n{\n\tif(par == 1.0)\n\t{\n\t\tpar = 0.0;\n\t\treturn 1.0;\n\t}\n\telse\n\t\treturn 0.0;\n}\n\x00')
61.146496815286625
Mutations attempted: 314
Valid mutations:     192
Success rate:        61.15%
Processing this: /home/oof/webgl_cleaned/vec4_s_t_p_q_4float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	float s = al.s;
	float t = al.t;
	float p = al.p;
	float q = al.q;
	vec4 m = vec4(s,t,p,q);
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tfloat s = al.s;\n\tfloat t = al.t;\n\tfloat p = al.p;\n\tfloat q = al.q;\n\tvec4 m = vec4(s,t,p,q);\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  float s = al.s;
  float t = al.t;
  float p = al.p;
  float q = al.q;
  vec4 m = vec4(s , t , p , q);
  gl_FragColor = m;
  vec4(-1.0, (false ? 2.0 : (!true ? -1.0 : (false ? 1.0 : -1.0))), 0.5, +0.0);
}


As vertex? : False
SUCCESS!
61.26984126984127
Processing this: /home/oof/webgl_cleaned/gl_MaxVertexTextureImageUnits_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	if(gl_MaxVertexTextureImageUnits >= 0)
		gl_FragColor = vec4(1.0);
	else
		gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tif(gl_MaxVertexTextureImageUnits >= 0)\n\t\tgl_FragColor = vec4(1.0);\n\telse\n\t\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((gl_MaxVertexTextureImageUnits >= 1))
    gl_FragColor = vec4(1.0);
  else
    gl_FragColor = vec4(0.0 , 0.0 , 0.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:11: 'constructor' : not enough data provided for construction

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  if ((gl_MaxVertexTextureImageUnits >= 1))
    gl_FragColor = vec4(1.0);
  else
    gl_FragColor = vec4(0.0 , 0.0 , 0.0);
}


==============================
61.07594936708861
Processing this: /home/oof/webgl_cleaned/vec4_rgb_a_1vec3_1float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec3 m = al.rgb;
	float a = al.a;
	vec4 b = vec4(m, a);
	gl_FragColor = b;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec3 m = al.rgb;\n\tfloat a = al.a;\n\tvec4 b = vec4(m, a);\n\tgl_FragColor = b;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(0.5, 2.0, (0.5 + 2.0), 0.5);

void main()
{
  vec4 al = color;
  vec3 m = al.rgb;
  float a = al.a;
  vec4 b = vec4(m , a);
  gl_FragColor = b;
}


As vertex? : False
SUCCESS!
61.198738170347
Processing this: /home/oof/webgl_cleaned/asin_vec3_frag_xvary.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * (color.rgb - 0.5);
	gl_FragColor = vec4(asin(c) / M_PI + 0.5, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * (color.rgb - 0.5);\n\tgl_FragColor = vec4(asin(c) / M_PI + 0.5, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((((false ? false : true) || false) ? 0.5 : 0.5), --0.5, -((true && true) ? (2.0 + 0.5) : -1.0), (1.0 - ---1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4(((asin(c) / M_PI) + 0.5) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '--' : l-value required (can't modify a const)
ERROR: 0:4: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = vec4((((false ? false : true) || false) ? 0.5 : 0.5), --0.5, -((true && true) ? (2.0 + 0.5) : -1.0), (1.0 - ---1.0));

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = (2.0 * (color.rgb - 0.5));
  gl_FragColor = vec4(((asin(c) / M_PI) + 0.5) , 1.0);
}


==============================
61.0062893081761
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconst2_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 4.0 * (gtf_Color.r);
	color = vec4(c * c / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 4.0 * (gtf_Color.r);\n\tcolor = vec4(c * c / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[3] = vec4(-1.0, -1.0, -0.5, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (4.0 * gtf_Color.r);
  color = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[3] of 4-component vector of float'
ERROR: 0:16: '*' : array / non-array mismatch
ERROR: 0:16: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[3] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[3] = vec4(-1.0, -1.0, -0.5, -1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (4.0 * gtf_Color.r);
  color = vec4(((c * c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.81504702194357
Processing this: /home/oof/webgl_cleaned/structcopy_bvec2bvec3bvec4_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct sabcd
{
	bvec2 a;
	bvec3 b;
	bvec4 c;
};
void main ()
{
	sabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );
	sabcd s2 = sabcd( bvec2(0, 0), bvec3(0.0, 0.0, 0.0), bvec4(0.0, 0.0, 0.0, 0.0 ) );
	s2 = s;
	float gray = 0.0;
	if( (s2.a[0]) && (s2.a[1]) && (s2.b[0]) && (!s2.b[1]) && (s2.b[2]) && (s2.c[0]) && (s2.c[1]) && (s2.c[2]) && (s2.c[3]) )
	  gray=1.0;
	else
          gray =0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct sabcd\n{\n\tbvec2 a;\n\tbvec3 b;\n\tbvec4 c;\n};\nvoid main ()\n{\n\tsabcd s = sabcd( bvec2(12, 13), bvec3(14.0, 0.0, 139.0), bvec4(25.5, 17.0, 145, 163 ) );\n\tsabcd s2 = sabcd( bvec2(0, 0), bvec3(0.0, 0.0, 0.0), bvec4(0.0, 0.0, 0.0, 0.0 ) );\n\ts2 = s;\n\tfloat gray = 0.0;\n\tif( (s2.a[0]) && (s2.a[1]) && (s2.b[0]) && (!s2.b[1]) && (s2.b[2]) && (s2.c[0]) && (s2.c[1]) && (s2.c[2]) && (s2.c[3]) )\n\t  gray=1.0;\n\telse\n          gray =0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bvec2 a;
  bvec3 b;
  bvec4 c0;
};

void main()
{
  sabcd s = sabcd(bvec2(12 , 13) , bvec3(14.0 , 0.0 , 139.0) , bvec4(25.5 , 17.0 , 145 , 163));
  sabcd s2 = sabcd(bvec2(0 , 0) , bvec3(0.0 , 0.0 , 0.0) , bvec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  float gray = 0.0;
  if (((((((((s2.a[0] && s2.a[1]) && s2.b[0]) && !s2.b[1]) && s2.b[2]) && s2.c[0]) && s2.c[1]) && s2.c[2]) && s2.c[3]))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)
ERROR: 0:22: 'c' :  no such field in structure
ERROR: 0:22: 's2' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:22: '&&' : wrong operand types - no operation '&&' exists that takes a left-hand operand of type 'const bool' and a right operand of type 'const highp float' (or there is no acceptable conversion)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct sabcd {
  bvec2 a;
  bvec3 b;
  bvec4 c0;
};

void main()
{
  sabcd s = sabcd(bvec2(12 , 13) , bvec3(14.0 , 0.0 , 139.0) , bvec4(25.5 , 17.0 , 145 , 163));
  sabcd s2 = sabcd(bvec2(0 , 0) , bvec3(0.0 , 0.0 , 0.0) , bvec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  float gray = 0.0;
  if (((((((((s2.a[0] && s2.a[1]) && s2.b[0]) && !s2.b[1]) && s2.b[2]) && s2.c[0]) && s2.c[1]) && s2.c[2]) && s2.c[3]))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.62499999999999
Processing this: /home/oof/webgl_cleaned/empty_empty_array_float_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	new_mad[0]=float(1);
	new_mad[1]=float(2);
	if( (new_mad[0] == 1.0) && (new_mad[1] == 2.0) )
	  gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tnew_mad[0]=float(1);\n\tnew_mad[1]=float(2);\n\tif( (new_mad[0] == 1.0) && (new_mad[1] == 2.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

void main()
{
  int i = 0;
  float new_mad[2];
  float gray = 0.0;
  new_mad[0] = float(1);
  new_mad[1] = float(2);
  if (((new_mad[0] == 1.0) && (new_mad[1] == 2.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color = vec4(1.0, 2.0, 2.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'color' : undeclared identifier
ERROR: 0:15: 'assign' : l-value required (can't modify a const)
ERROR: 0:15: '=' : dimension mismatch
ERROR: 0:15: 'assign' : cannot convert from 'mediump 4-component vector of float' to 'const highp float'
ERROR: 0:16: 'gtf_ModelViewProjectionMatrix' : undeclared identifier
ERROR: 0:16: 'gtf_Vertex' : undeclared identifier
ERROR: 0:16: '=' : dimension mismatch
ERROR: 0:16: 'assign' : cannot convert from 'const highp float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

void main()
{
  int i = 0;
  float new_mad[2];
  float gray = 0.0;
  new_mad[0] = float(1);
  new_mad[1] = float(2);
  if (((new_mad[0] == 1.0) && (new_mad[1] == 2.0)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}

vec4 color = vec4(1.0, 2.0, 2.0, 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 gtf_Vertex;


==============================
60.43613707165109
Processing this: /home/oof/webgl_cleaned/sin_vec3_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float lerp(float a, float b, float s)
{
	return a + (b - a) * s;
}
void main ()
{
	float sinValues[17];
	sinValues[0] = 0.0;
	sinValues[1] = 0.382683;
	sinValues[2] = 0.707107;
	sinValues[3] = 0.92388;
	sinValues[4] = 1.0;
	sinValues[5] = 0.92388;
	sinValues[6] = 0.707107;
	sinValues[7] = 0.382683;
	sinValues[8] = 0.0;
	sinValues[9] = -0.382683;
	sinValues[10] = -0.707107;
	sinValues[11] = -0.92388;
	sinValues[12] = -1.0;
	sinValues[13] = -0.923879;
	sinValues[14] = -0.707107;
	sinValues[15] = -0.382683;
	sinValues[16] = 0.0;
	const float M_PI = 3.14159265358979323846;
	vec3 c = 2.0 * M_PI * gtf_Color.rgb;
	float sign = 1.0;
	vec3 sin_c = vec3(0.0);
	float fact;
	float fact_of;
	for(int i = 0; i < 12; i++)
	{
		fact = 1.0;
		for(int j = 2; j <= 23; j++)
			if (j <= 2 * i + 1)
				fact *= float(j);
		sin_c += sign * pow(c, vec3(2.0 * float(i) + 1.0)) / fact;
		sign *= -1.0;
	}
	color = vec4(0.5 * sin_c + 0.5, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat lerp(float a, float b, float s)\n{\n\treturn a + (b - a) * s;\n}\nvoid main ()\n{\n\tfloat sinValues[17];\n\tsinValues[0] = 0.0;\n\tsinValues[1] = 0.382683;\n\tsinValues[2] = 0.707107;\n\tsinValues[3] = 0.92388;\n\tsinValues[4] = 1.0;\n\tsinValues[5] = 0.92388;\n\tsinValues[6] = 0.707107;\n\tsinValues[7] = 0.382683;\n\tsinValues[8] = 0.0;\n\tsinValues[9] = -0.382683;\n\tsinValues[10] = -0.707107;\n\tsinValues[11] = -0.92388;\n\tsinValues[12] = -1.0;\n\tsinValues[13] = -0.923879;\n\tsinValues[14] = -0.707107;\n\tsinValues[15] = -0.382683;\n\tsinValues[16] = 0.0;\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 2.0 * M_PI * gtf_Color.rgb;\n\tfloat sign = 1.0;\n\tvec3 sin_c = vec3(0.0);\n\tfloat fact;\n\tfloat fact_of;\n\tfor(int i = 0; i < 12; i++)\n\t{\n\t\tfact = 1.0;\n\t\tfor(int j = 2; j <= 23; j++)\n\t\t\tif (j <= 2 * i + 1)\n\t\t\t\tfact *= float(j);\n\t\tsin_c += sign * pow(c, vec3(2.0 * float(i) + 1.0)) / fact;\n\t\tsign *= -1.0;\n\t}\n\tcolor = vec4(0.5 * sin_c + 0.5, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

float lerp(float a, float b, float s)
{
  return (a + ((b - a) * s));
}

void main()
{
  float sinValues[17];
  sinValues[0] = 0.0;
  sinValues[1] = 0.382683;
  sinValues[2] = 0.707107;
  sinValues[3] = 0.92388;
  sinValues[4] = 1.0;
  sinValues[5] = 0.92388;
  sinValues[6] = 0.707107;
  sinValues[7] = 0.382683;
  sinValues[8] = 0.0;
  sinValues[9] = -0.382683;
  sinValues[10] = -0.707107;
  sinValues[11] = -0.92388;
  sinValues[12] = -1.0;
  sinValues[13] = -0.923879;
  sinValues[14] = -0.707107;
  sinValues[15] = -0.382683;
  vec4(-0.5, 0.5, 0.0, 0.0);
  const float M_PI = 3.141592653589793;
  vec3 c = ((2.0 * M_PI) * gtf_Color.rgb);
  float sign = 1.0;
  vec3 sin_c = vec3(0.0);
  float fact;
  float fact_of;
  for (int i = 0; (i < 12); i++)
  {
    fact = 1.0;
    for (int j = 2; (j <= 23); j++)
    if ((j <= ((2 * i) + 1)))
      (fact *= float(j));
    (sin_c += ((sign * pow(c , vec3(((2.0 * float(i)) + 1.0)))) / fact));
    (sign *= -1.0);
  }
  color = vec4(((0.5 * sin_c) + 0.5) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  ivec2(0.0, -0.5);
}


As vertex? : True
SUCCESS!
60.55900621118012
Processing this: /home/oof/webgl_cleaned/vec3_stp_1vec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec4 lightloc = gtf_Vertex;
	vec3 m = lightloc.stp;
	vec4 a = vec4(m.stp,lightloc.q);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * a;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 lightloc = gtf_Vertex;\n\tvec3 m = lightloc.stp;\n\tvec4 a = vec4(m.stp,lightloc.q);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * a;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 m = lightloc.stp;
  ivec2(7, 1);
  color = gtf_Color;
  vec4 lightloc = gtf_Vertex;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
  vec4 a = vec4(m.stp , lightloc.q);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'lightloc' : undeclared identifier
ERROR: 0:14: 'stp' :  field selection requires structure or vector on left hand side
ERROR: 0:14: '=' : dimension mismatch
ERROR: 0:14: '=' : cannot convert from 'const highp float' to 'mediump 3-component vector of float'
ERROR: 0:18: 'a' : undeclared identifier
ERROR: 0:18: '=' : dimension mismatch
ERROR: 0:18: 'assign' : cannot convert from 'highp 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 m = lightloc.stp;
  ivec2(7, 1);
  color = gtf_Color;
  vec4 lightloc = gtf_Vertex;
  gl_Position = (gtf_ModelViewProjectionMatrix * a);
  vec4 a = vec4(m.stp , lightloc.q);
}


==============================
60.371517027863774
Processing this: /home/oof/webgl_cleaned/ivec3_3int_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	ivec3 a = ivec3(20, 13, 17);
	float gray;
	if( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )
	gray=1.0;
	else gray=0.0;
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tivec3 a = ivec3(20, 13, 17);\n\tfloat gray;\n\tif( (a[0] == 20) && (a[1] == 13) && (a[2] == 17) )\n\tgray=1.0;\n\telse gray=0.0;\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(0.0, 0.5, -1.0, 0.0);

void main()
{
  ivec3 a = ivec3(20 , 13 , 17);
  float gray;
  if ((((a[0] == 20) && (a[1] == 13)) && (a[2] == 17)))
    gray = 1.0;
  else
    gray = 0.0;
  color = vec4(gray , gray , gray , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.49382716049383
Mutations attempted: 324
Valid mutations:     196
Success rate:        60.49%
Processing this: /home/oof/webgl_cleaned/pow_float_vert_xvary_yconsthalf_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float c = 16.0 * gtf_Color.r;
	color = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = 16.0 * gtf_Color.r;\n\tcolor = vec4(sqrt(c) / 4.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  float c = (16.0 * gtf_Color.r);
  color = vec4((sqrt(c) / 4.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.61538461538461
Processing this: /home/oof/webgl_cleaned/cos_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	color = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.rg) + 0.5, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tcolor = vec4(0.5 * cos(2.0 * M_PI * gtf_Color.rg) + 0.5, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, -1.0, 2.0, (false ? +0.0 : 2.0));

void main()
{
  const float M_PI = 3.141592653589793;
  color = vec4(((0.5 * cos(((2.0 * M_PI) * gtf_Color.rg))) + 0.5) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.73619631901841
Processing this: /home/oof/webgl_cleaned/atan_vec2_vert_xvaryyvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
attribute vec4 gtf_Color;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec2 x = 2.0 * (gtf_Color.gg - 0.5);
	vec2 y = 2.0 * (gtf_Color.bb - 0.5);
	const float epsilon = 1.0e-4;
	color = vec4(0.0, 0.0, 0.0, 1.0);
	if(x[0] > epsilon || abs(y[0]) > epsilon)
	{
		color[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;
	}
	if(x[1] > epsilon || abs(y[1]) > epsilon)
	{
		color[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;
	}
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_Color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec2 x = 2.0 * (gtf_Color.gg - 0.5);\n\tvec2 y = 2.0 * (gtf_Color.bb - 0.5);\n\tconst float epsilon = 1.0e-4;\n\tcolor = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(x[0] > epsilon || abs(y[0]) > epsilon)\n\t{\n\t\tcolor[0] = atan(y[0], x[0]) / (2.0 * M_PI) + 0.5;\n\t}\n\tif(x[1] > epsilon || abs(y[1]) > epsilon)\n\t{\n\t\tcolor[1] = atan(y[1], x[1]) / (2.0 * M_PI) + 0.5;\n\t}\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 x = (2.0 * (gtf_Color.gg - 0.5));
  if (((x[1] > epsilon) ^^ (abs(y[1]) > epsilon)))
  {
    color[1] = (vec4(0.5, (true ? --0.0 : 1.0), 2.0, (((false ? false : false) ? -1.0 : 0.0) * 0.0)) + 0.5);
  }
  const float M_PI = 3.141592653589793;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    color[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  vec2 y = (2.0 * (gtf_Color.bb - 0.5));
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:15: 'epsilon' : undeclared identifier
ERROR: 0:15: 'y' : undeclared identifier
ERROR: 0:15: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:15: 'epsilon' : undeclared identifier
ERROR: 0:17: '--' : l-value required (can't modify a const)
ERROR: 0:17: '=' : dimension mismatch
ERROR: 0:17: 'assign' : cannot convert from 'const 4-component vector of float' to 'mediump float'
ERROR: 0:23: 'y' : undeclared identifier
ERROR: 0:23: 'expression' :  left of '[' is not of type array, matrix, or vector 
ERROR: 0:25: 'y' : undeclared identifier
ERROR: 0:25: 'expression' :  left of '[' is not of type array, matrix, or vector 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

vec4 gtf_Color;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 x = (2.0 * (gtf_Color.gg - 0.5));
  if (((x[1] > epsilon) ^^ (abs(y[1]) > epsilon)))
  {
    color[1] = (vec4(0.5, (true ? --0.0 : 1.0), 2.0, (((false ? false : false) ? -1.0 : 0.0) * 0.0)) + 0.5);
  }
  const float M_PI = 3.141592653589793;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
  color = vec4(0.0 , 0.0 , 0.0 , 1.0);
  const float epsilon = 0.0001;
  if (((x[0] > epsilon) || (abs(y[0]) > epsilon)))
  {
    color[0] = ((atan(y[0] , x[0]) / (2.0 * M_PI)) + 0.5);
  }
  vec2 y = (2.0 * (gtf_Color.bb - 0.5));
}


==============================
60.550458715596335
Processing this: /home/oof/webgl_cleaned/greaterThanEqual_ivec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * color.rgb - 4.5);
	vec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));
	gl_FragColor = vec4(result, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * color.rgb - 4.5);\n\tvec3 result = vec3(greaterThanEqual(ivec3(c), ivec3(0)));\n\tgl_FragColor = vec4(result, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((true ? 0.5 : ((true ? true : true) ? (1.0 - 0.0) : +0.0)), (false ? 0.5 : 1.0), 0.5, 0.0);

void main()
{
  vec3 c = floor(((10.0 * color.rgb) - 4.5));
  vec3 result = vec3(greaterThanEqual(ivec3(c) , ivec3(0)));
  gl_FragColor = vec4(result , 1.0);
}


As vertex? : False
SUCCESS!
60.670731707317074
Processing this: /home/oof/webgl_cleaned/any_bvec3_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = floor(1.5 * color.rgb);
	gl_FragColor = vec4(vec3(any(bvec3(c))), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(1.5 * color.rgb);\n\tgl_FragColor = vec4(vec3(any(bvec3(c))), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec4(vec3(any(bvec3(c)))) = gl_FragColor;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:9: 'constructor' : not enough data provided for construction
ERROR: 0:9: 'assign' : l-value required (can't modify a const)

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec3 c = floor((1.5 * color.rgb));
  vec4(vec3(any(bvec3(c)))) = gl_FragColor;
}


==============================
60.48632218844985
Processing this: /home/oof/webgl_cleaned/mat4_empty_in_mat4_empty_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
mat4 function(in mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 1.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
mat4 function(in mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nmat4 function(in mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 1.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nmat4 function(in mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.48632218844985
Processing this: /home/oof/webgl_cleaned/sqrt_vec2_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 100.0 * gtf_Color.rg;
	color = vec4(c / 100.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 100.0 * gtf_Color.rg;\n\tcolor = vec4(c / 100.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, 2.0, -1.0, (false ? -0.0 : ((false && true) ? (-1.0 / -1.0) : +2.0)));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec2 c = (100.0 * gtf_Color.rg);
  color = vec4((c / 100.0) , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.60606060606061
Processing this: /home/oof/webgl_cleaned/exp_float_vert_xvaryneg_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float exp1 = 2.7183;
	float c = gtf_Color.r;
	color = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float exp1 = 2.7183;\n\tfloat c = gtf_Color.r;\n\tcolor = vec4(1.0 / pow(exp1, 3.0 * c), 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((!(false ? true : false) ? (--1.0 - -1.0) : +-1.0), 2.0, ((true ? 0.0 : 0.5) * ((true || true) ? +0.0 : 0.0)), 2.0);

void main()
{
  const float exp1 = 2.7183;
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(exp1 , (3.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '--' : l-value required (can't modify a const)
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4((!(false ? true : false) ? (--1.0 - -1.0) : +-1.0), 2.0, ((true ? 0.0 : 0.5) * ((true || true) ? +0.0 : 0.0)), 2.0);

void main()
{
  const float exp1 = 2.7183;
  float c = gtf_Color.r;
  color = vec4((1.0 / pow(exp1 , (3.0 * c))) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.42296072507553
Processing this: /home/oof/webgl_cleaned/structnest_mat2_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
struct nestb
{
	mat2 b;
};
struct nesta
{
	mat2 a;
	nestb nest_b;
};
struct nest
{
	nesta nest_a;
};
void main ()
{
	nest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );
	color = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nstruct nestb\n{\n\tmat2 b;\n};\nstruct nesta\n{\n\tmat2 a;\n\tnestb nest_b;\n};\nstruct nest\n{\n\tnesta nest_a;\n};\nvoid main ()\n{\n\tnest s = nest(nesta( mat2(11, 13, 29, 33), nestb( mat2(12, 19, 79, 81) ) ) );\n\tcolor = vec4( vec3(  (s.nest_a.a[0][0] + s.nest_a.a[0][1] + s.nest_a.a[1][0] + s.nest_a.a[1][1] + s.nest_a.nest_b.b[0][0] + s.nest_a.nest_b.b[0][1] + s.nest_a.nest_b.b[1][0] + s.nest_a.nest_b.b[1][1] ) / 277.0 ), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex = vec4((0.0 * 1.0), (((true && true) && false) ? (true ? 0.5 : 2.0) : +2.0), 0.5, (((false || false) ? -1.0 : 1.0) - 0.0));

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

struct nestb {
  mat2 b;
};

struct nesta {
  mat2 a;
  nestb nest_b;
};

struct nest {
  nesta nest_a;
};

void main()
{
  nest s = nest(nesta(mat2(11 , 13 , 29 , 33) , nestb(mat2(12 , 19 , 79 , 81))));
  color = vec4(vec3(((((((((s.nest_a.a[0][0] + s.nest_a.a[0][1]) + s.nest_a.a[1][0]) + s.nest_a.a[1][1]) + s.nest_a.nest_b.b[0][0]) + s.nest_a.nest_b.b[0][1]) + s.nest_a.nest_b.b[1][0]) + s.nest_a.nest_b.b[1][1]) / 277.0)) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.54216867469879
Processing this: /home/oof/webgl_cleaned/vec4_xyzw_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.xyzw;
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.xyzw;\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 al = color;
  vec4 m = al.xyzw;
  gl_FragColor = m;
}


As vertex? : False
SUCCESS!
60.66066066066066
Mutations attempted: 333
Valid mutations:     202
Success rate:        60.66%
Processing this: /home/oof/webgl_cleaned/log2_vec2_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = (color.rg + 0.01) / 1.01;
	gl_FragColor = vec4(log2(c) / -8.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = (color.rg + 0.01) / 1.01;\n\tgl_FragColor = vec4(log2(c) / -8.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4(1.0, 0.5, 1.0, -0.5);

void main()
{
  vec2 c = ((color.rg + 0.01) / 1.01);
  gl_FragColor = vec4((log2(c) / -8.0) , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.778443113772454
Processing this: /home/oof/webgl_cleaned/not_bvec3_vert_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
bvec3 _not(in bvec3 a)
{
	bvec3 result;
	if(a[0]) result[0] = false;
	else result[0] = true;
	if(a[1]) result[1] = false;
	else result[1] = true;
	if(a[2]) result[2] = false;
	else result[2] = true;
	return result;
}
void main ()
{
	vec3 c = floor(1.5 * gtf_Color.rgb);
	color = vec4(vec3(_not(bvec3(c))), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nbvec3 _not(in bvec3 a)\n{\n\tbvec3 result;\n\tif(a[0]) result[0] = false;\n\telse result[0] = true;\n\tif(a[1]) result[1] = false;\n\telse result[1] = true;\n\tif(a[2]) result[2] = false;\n\telse result[2] = true;\n\treturn result;\n}\nvoid main ()\n{\n\tvec3 c = floor(1.5 * gtf_Color.rgb);\n\tcolor = vec4(vec3(_not(bvec3(c))), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

bvec3 _not(in bvec3 a)
{
  bvec3 result;
  if (a[0])
    result[0] = false;
  else
    result[0] = true;
  if (a[1])
    result[1] = false;
  else
    result[1] = true;
  if (a[2])
    ivec2(3, (!!true ? (true ? (false ? 0 : 0) : 2) : 5));
  else
    result[2] = true;
  return result;
}

void main()
{
  vec3 c = floor((1.5 * gtf_Color.rgb));
  color = vec4(vec3(_not(bvec3(c))) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.895522388059696
Processing this: /home/oof/webgl_cleaned/float_empty_out_float_array_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
float function(out float par[3]);
bool is_all(const in float array[3], const in float value);
void set_all(out float array[3], const in float value);
void main ()
{
	float par[3];
	float ret = 0.0;
	float gray = 0.0;
	set_all(par, 1.0);
	ret = function(par);
	if(is_all(par, 0.0) && (ret == 1.0))
	{
		gray = 1.0;
	}
	color = vec4(gray, gray, gray, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}
float function(out float par[3])
{
	set_all(par, 0.0);
	return 1.0;
}
bool is_all(const in float array[3], const in float value)
{
	bool ret = true;
	if(array[0] != value)
		ret = false;
	if(array[1] != value)
		ret = false;
	if(array[2] != value)
		ret = false;
	return ret;
}
void set_all(out float array[3], const in float value)
{
	array[0] = value;
	array[1] = value;
	array[2] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nfloat function(out float par[3]);\nbool is_all(const in float array[3], const in float value);\nvoid set_all(out float array[3], const in float value);\nvoid main ()\n{\n\tfloat par[3];\n\tfloat ret = 0.0;\n\tfloat gray = 0.0;\n\tset_all(par, 1.0);\n\tret = function(par);\n\tif(is_all(par, 0.0) && (ret == 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tcolor = vec4(gray, gray, gray, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\nfloat function(out float par[3])\n{\n\tset_all(par, 0.0);\n\treturn 1.0;\n}\nbool is_all(const in float array[3], const in float value)\n{\n\tbool ret = true;\n\tif(array[0] != value)\n\t\tret = false;\n\tif(array[1] != value)\n\t\tret = false;\n\tif(array[2] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out float array[3], const in float value)\n{\n\tarray[0] = value;\n\tarray[1] = value;\n\tarray[2] = value;\n}\n\x00')
60.895522388059696
Processing this: /home/oof/webgl_cleaned/refract_float_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	float v1 = (gtf_Color.g + 1.0) / 2.0;
	float v2 = (gtf_Color.b + 1.0) / 2.0;
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat v1 = (gtf_Color.g + 1.0) / 2.0;\n\tfloat v2 = (gtf_Color.b + 1.0) / 2.0;\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 + 0.5), +2.0, +-1.0, 1.0, 1.0, +2.0, 2.0, ((false && false) ? +(2.0 / 0.0) : 2.0), -1.0, (false ? 0.0 : 0.0), (true ? (false ? 0.0 : (false ? -1.0 : -1.0)) : 2.0), ((false && true) ? -(1.0 - -1.0) : 0.0), -2.0, 2.0, ((1.0 - -1.0) - 2.0), 2.0);

vec4 color;

void main()
{
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
WARNING: 0:8: '/' : Divide by zero during constant folding
ERROR: 0:8: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((2.0 + 0.5), +2.0, +-1.0, 1.0, 1.0, +2.0, 2.0, ((false && false) ? +(2.0 / 0.0) : 2.0), -1.0, (false ? 0.0 : 0.0), (true ? (false ? 0.0 : (false ? -1.0 : -1.0)) : 2.0), ((false && true) ? -(1.0 - -1.0) : 0.0), -2.0, 2.0, ((1.0 - -1.0) - 2.0), 2.0);

vec4 color;

void main()
{
  float v1 = ((gtf_Color.g + 1.0) / 2.0);
  float v2 = ((gtf_Color.b + 1.0) / 2.0);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.71428571428571
Processing this: /home/oof/webgl_cleaned/equal_bvec2_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
precision mediump float;
varying vec4 color;
void main ()
{
	vec2 c = floor(1.5 * color.rg);
	vec2 result = vec2(equal(bvec2(c), bvec2(true)));
	gl_FragColor = vec4(result, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = floor(1.5 * color.rg);\n\tvec2 result = vec2(equal(bvec2(c), bvec2(true)));\n\tgl_FragColor = vec4(result, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec2 c = floor((1.5 * color.rg));
  vec2 result = vec2(equal(bvec2(c) , bvec2(true)));
  gl_FragColor = vec4(result , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.83086053412463
Processing this: /home/oof/webgl_cleaned/4f_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
uniform vec4 color;
uniform ivec4 icolor;
uniform bool flag;
void main ()
{
	if(flag)
		gl_FragColor = vec4 (icolor[0], icolor[1], icolor[2], icolor[3]);
	else
		gl_FragColor = vec4 (color[0], color[1], color[2], color[3]);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nuniform vec4 color;\nuniform ivec4 icolor;\nuniform bool flag;\nvoid main ()\n{\n\tif(flag)\n\t\tgl_FragColor = vec4 (icolor[0], icolor[1], icolor[2], icolor[3]);\n\telse\n\t\tgl_FragColor = vec4 (color[0], color[1], color[2], color[3]);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

uniform vec4 color = vec4(2.0, 1.0, 1.0, 0.0);

uniform ivec4 icolor;

uniform bool flag;

void main()
{
  if (flag)
    gl_FragColor = vec4(icolor[0] , icolor[1] , icolor[2] , icolor[3]);
  else
    gl_FragColor = vec4(color[0] , color[1] , color[2] , color[3]);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'uniform' :  cannot initialize this type of qualifier 

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

uniform vec4 color = vec4(2.0, 1.0, 1.0, 0.0);

uniform ivec4 icolor;

uniform bool flag;

void main()
{
  if (flag)
    gl_FragColor = vec4(icolor[0] , icolor[1] , icolor[2] , icolor[3]);
  else
    gl_FragColor = vec4(color[0] , color[1] , color[2] , color[3]);
}


==============================
60.650887573964496
Processing this: /home/oof/webgl_cleaned/floor_vec3_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);
	color = vec4((floor(c) + 10.0) / 20.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = 10.0 * 2.0 * (gtf_Color.rgb - 0.5);\n\tcolor = vec4((floor(c) + 10.0) / 20.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color = vec4(1.0, 0.0, -1.0, (!!false ? -(0.0 / -1.0) : 2.0));

void main()
{
  vec3 c = ((10.0 * 2.0) * (gtf_Color.rgb - 0.5));
  color = vec4(((floor(c) + 10.0) / 20.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.766961651917406
Processing this: /home/oof/webgl_cleaned/precision_specifiers.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute mediump vec4 gtf_Color;
attribute mediump vec4 gtf_Vertex;
uniform mediump mat4 gtf_ModelViewProjectionMatrix;
varying mediump vec4 color;
void main ()
{
	mediump int x = 5;
	lowp int y = 3;
	mediump float x2 = 5.0;
	lowp float y2 = 1.0;
	color = vec4(x + y, x2 * y2, x, 1.0);
	color = gtf_Color;
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute mediump vec4 gtf_Color;\nattribute mediump vec4 gtf_Vertex;\nuniform mediump mat4 gtf_ModelViewProjectionMatrix;\nvarying mediump vec4 color;\nvoid main ()\n{\n\tmediump int x = 5;\n\tlowp int y = 3;\n\tmediump float x2 = 5.0;\n\tlowp float y2 = 1.0;\n\tcolor = vec4(x + y, x2 * y2, x, 1.0);\n\tcolor = gtf_Color;\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

mediump vec4 gtf_Color;

mediump vec4 gtf_Vertex;

uniform mediump mat4 gtf_ModelViewProjectionMatrix;

mediump vec4 color;

void main()
{
  mediump int x = 5;
  lowp int y = 3;
  mediump float x2 = 5.0;
  lowp float y2 = 1.0;
  color = vec4((x + y) , (x2 * y2) , x , 1.0);
  color = gtf_Color;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.882352941176464
Processing this: /home/oof/webgl_cleaned/degrees_float_vert_xvary_ref.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	float c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);
	color = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tfloat c = 2.0 * M_PI * 2.0 * (gtf_Color.r - 0.5);\n\tcolor = vec4((c * 180.0 / M_PI) / (2.0 * 360.0) + 0.5, 0.0, 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4(1.0, -1.0, +(-1.0 / 0.0), 0.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  float c = (((2.0 * M_PI) * 2.0) * (gtf_Color.r - 0.5));
  color = vec4(((((c * 180.0) / M_PI) / (2.0 * 360.0)) + 0.5) , 0.0 , 0.0 , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.997067448680355
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
mat4 function(inout mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(inout mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nmat4 function(inout mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(inout mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.997067448680355
Mutations attempted: 341
Valid mutations:     208
Success rate:        61.00%
Processing this: /home/oof/webgl_cleaned/mat4_empty_inout_mat4_empty_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
mat4 function(inout mat4 par);
bool is_all(const in mat4 par, const in float value);
void set_all(out mat4 par, const in float value);
void main ()
{
	mat4 par = mat4(1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0,
			1.0, 1.0, 1.0, 1.0);
	mat4 ret = mat4(0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0,
			0.0, 0.0, 0.0, 0.0);
	float gray = 0.0;
	ret = function(par);
	if(is_all(par, 0.0) && is_all(ret, 1.0))
	{
		gray = 1.0;
	}
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
mat4 function(inout mat4 par)
{
	if(is_all(par, 1.0))
	{
		set_all(par, 0.0);
		return mat4(1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0,
			    1.0, 1.0, 1.0, 1.0);
	}
	else
		return mat4(0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0,
			    0.0, 0.0, 0.0, 0.0);
}
bool is_all(const in mat4 par, const in float value)
{
	bool ret = true;
	if(par[0][0] != value)
		ret = false;
	if(par[0][1] != value)
		ret = false;
	if(par[0][2] != value)
		ret = false;
	if(par[0][3] != value)
		ret = false;
	if(par[1][0] != value)
		ret = false;
	if(par[1][1] != value)
		ret = false;
	if(par[1][2] != value)
		ret = false;
	if(par[1][3] != value)
		ret = false;
	if(par[2][0] != value)
		ret = false;
	if(par[2][1] != value)
		ret = false;
	if(par[2][2] != value)
		ret = false;
	if(par[2][3] != value)
		ret = false;
	if(par[3][0] != value)
		ret = false;
	if(par[3][1] != value)
		ret = false;
	if(par[3][2] != value)
		ret = false;
	if(par[3][3] != value)
		ret = false;
	return ret;
}
void set_all(out mat4 par, const in float value)
{
	par[0][0] = value;
	par[0][1] = value;
	par[0][2] = value;
	par[0][3] = value;
	par[1][0] = value;
	par[1][1] = value;
	par[1][2] = value;
	par[1][3] = value;
	par[2][0] = value;
	par[2][1] = value;
	par[2][2] = value;
	par[2][3] = value;
	par[3][0] = value;
	par[3][1] = value;
	par[3][2] = value;
	par[3][3] = value;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nmat4 function(inout mat4 par);\nbool is_all(const in mat4 par, const in float value);\nvoid set_all(out mat4 par, const in float value);\nvoid main ()\n{\n\tmat4 par = mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0,\n\t\t\t1.0, 1.0, 1.0, 1.0);\n\tmat4 ret = mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0,\n\t\t\t0.0, 0.0, 0.0, 0.0);\n\tfloat gray = 0.0;\n\tret = function(par);\n\tif(is_all(par, 0.0) && is_all(ret, 1.0))\n\t{\n\t\tgray = 1.0;\n\t}\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nmat4 function(inout mat4 par)\n{\n\tif(is_all(par, 1.0))\n\t{\n\t\tset_all(par, 0.0);\n\t\treturn mat4(1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0,\n\t\t\t    1.0, 1.0, 1.0, 1.0);\n\t}\n\telse\n\t\treturn mat4(0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0,\n\t\t\t    0.0, 0.0, 0.0, 0.0);\n}\nbool is_all(const in mat4 par, const in float value)\n{\n\tbool ret = true;\n\tif(par[0][0] != value)\n\t\tret = false;\n\tif(par[0][1] != value)\n\t\tret = false;\n\tif(par[0][2] != value)\n\t\tret = false;\n\tif(par[0][3] != value)\n\t\tret = false;\n\tif(par[1][0] != value)\n\t\tret = false;\n\tif(par[1][1] != value)\n\t\tret = false;\n\tif(par[1][2] != value)\n\t\tret = false;\n\tif(par[1][3] != value)\n\t\tret = false;\n\tif(par[2][0] != value)\n\t\tret = false;\n\tif(par[2][1] != value)\n\t\tret = false;\n\tif(par[2][2] != value)\n\t\tret = false;\n\tif(par[2][3] != value)\n\t\tret = false;\n\tif(par[3][0] != value)\n\t\tret = false;\n\tif(par[3][1] != value)\n\t\tret = false;\n\tif(par[3][2] != value)\n\t\tret = false;\n\tif(par[3][3] != value)\n\t\tret = false;\n\treturn ret;\n}\nvoid set_all(out mat4 par, const in float value)\n{\n\tpar[0][0] = value;\n\tpar[0][1] = value;\n\tpar[0][2] = value;\n\tpar[0][3] = value;\n\tpar[1][0] = value;\n\tpar[1][1] = value;\n\tpar[1][2] = value;\n\tpar[1][3] = value;\n\tpar[2][0] = value;\n\tpar[2][1] = value;\n\tpar[2][2] = value;\n\tpar[2][3] = value;\n\tpar[3][0] = value;\n\tpar[3][1] = value;\n\tpar[3][2] = value;\n\tpar[3][3] = value;\n}\n\x00')
60.997067448680355
Processing this: /home/oof/webgl_cleaned/initfunc_empty_array_float_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void initialise_array(out float array[2], float init_val);
void main ()
{
	int i=0;
	float new_mad[2];
	float gray = 0.0;
	initialise_array(new_mad,25.0);
	if( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )
	  gray=1.0;
	else gray=0.0;
	gl_FragColor = vec4(gray, gray, gray, 1.0);
}
void initialise_array(out float array[2], float init_val)
{
	int i=0;
	array[0] = init_val;
	array[1] = init_val;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid initialise_array(out float array[2], float init_val);\nvoid main ()\n{\n\tint i=0;\n\tfloat new_mad[2];\n\tfloat gray = 0.0;\n\tinitialise_array(new_mad,25.0);\n\tif( (new_mad[0] == 25.0) && (new_mad[1] == 25.0) )\n\t  gray=1.0;\n\telse gray=0.0;\n\tgl_FragColor = vec4(gray, gray, gray, 1.0);\n}\nvoid initialise_array(out float array[2], float init_val)\n{\n\tint i=0;\n\tarray[0] = init_val;\n\tarray[1] = init_val;\n}\n\x00')
60.997067448680355
Processing this: /home/oof/webgl_cleaned/min_vec2_frag_xvary_yconsthalf_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const vec2 min_c = vec2(0.5, 0.5);
	vec2 c = color.rg;
	if(c[0] > min_c[0]) c[0] = min_c[0];
	if(c[1] > min_c[1]) c[1] = min_c[1];
	gl_FragColor = vec4(c, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec2 min_c = vec2(0.5, 0.5);\n\tvec2 c = color.rg;\n\tif(c[0] > min_c[0]) c[0] = min_c[0];\n\tif(c[1] > min_c[1]) c[1] = min_c[1];\n\tgl_FragColor = vec4(c, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = vec4((0.5 * 1.0), (true ? (2.0 / 0.5) : (1.0 - (1.0 - -1.0))), 0.0, (-1.0 * ((true ? true : true) ? (false ? 0.5 : 2.0) : 0.5)));

void main()
{
  const vec2 min_c = vec2(0.5 , 0.5);
  vec2 c = color.rg;
  if ((c[0] > min_c[0]))
    c[0] = min_c[0];
  if ((c[1] > min_c[1]))
    c[1] = min_c[1];
  gl_FragColor = vec4(c , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
61.111111111111114
Processing this: /home/oof/webgl_cleaned/atan_vec3_frag_xvary_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 c = 4.0 * 2.0 * (color.rgb - 0.5);
	vec3 atan_c = vec3(0.0);
	vec3 scale = vec3(1.0);
	vec3 sign = vec3(1.0);
	vec4 result = vec4(0.0, 0.0, 0.0, 1.0);
	if(c[0] < 0.0)
	{
		sign[0] = -1.0;
		c[0] *= -1.0;
	}
	if(c[0] <= 1.0)
	{
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * atan_c[0] / M_PI + 0.5;
	}
	else
	{
		c[0] = 1.0 / c[0];
		atan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);
		scale[0] *= -1.0;
		atan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);
		scale[0] *= -1.0;
		result[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;
	}
	if(c[1] < 0.0)
	{
		sign[1] = -1.0;
		c[1] *= -1.0;
	}
	if(c[1] <= 1.0)
	{
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * atan_c[1] / M_PI + 0.5;
	}
	else
	{
		c[1] = 1.0 / c[1];
		atan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);
		scale[1] *= -1.0;
		atan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);
		scale[1] *= -1.0;
		result[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;
	}
	if(c[2] < 0.0)
	{
		sign[2] = -1.0;
		c[2] *= -1.0;
	}
	if(c[2] <= 1.0)
	{
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * atan_c[2] / M_PI + 0.5;
	}
	else
	{
		c[2] = 1.0 / c[2];
		atan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);
		scale[2] *= -1.0;
		atan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);
		scale[2] *= -1.0;
		result[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;
	}
	gl_FragColor = result;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 c = 4.0 * 2.0 * (color.rgb - 0.5);\n\tvec3 atan_c = vec3(0.0);\n\tvec3 scale = vec3(1.0);\n\tvec3 sign = vec3(1.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 1.0);\n\tif(c[0] < 0.0)\n\t{\n\t\tsign[0] = -1.0;\n\t\tc[0] *= -1.0;\n\t}\n\tif(c[0] <= 1.0)\n\t{\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * atan_c[0] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[0] = 1.0 / c[0];\n\t\tatan_c[0] += scale[0] * pow(c[0], float(1)) / float(1);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(3)) / float(3);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(5)) / float(5);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(7)) / float(7);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(9)) / float(9);\n\t\tscale[0] *= -1.0;\n\t\tatan_c[0] += scale[0] * pow(c[0], float(11)) / float(11);\n\t\tscale[0] *= -1.0;\n\t\tresult[0] = sign[0] * (M_PI / 2.0 - atan_c[0]) / M_PI + 0.5;\n\t}\n\tif(c[1] < 0.0)\n\t{\n\t\tsign[1] = -1.0;\n\t\tc[1] *= -1.0;\n\t}\n\tif(c[1] <= 1.0)\n\t{\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * atan_c[1] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[1] = 1.0 / c[1];\n\t\tatan_c[1] += scale[1] * pow(c[1], float(1)) / float(1);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(3)) / float(3);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(5)) / float(5);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(7)) / float(7);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(9)) / float(9);\n\t\tscale[1] *= -1.0;\n\t\tatan_c[1] += scale[1] * pow(c[1], float(11)) / float(11);\n\t\tscale[1] *= -1.0;\n\t\tresult[1] = sign[1] * (M_PI / 2.0 - atan_c[1]) / M_PI + 0.5;\n\t}\n\tif(c[2] < 0.0)\n\t{\n\t\tsign[2] = -1.0;\n\t\tc[2] *= -1.0;\n\t}\n\tif(c[2] <= 1.0)\n\t{\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * atan_c[2] / M_PI + 0.5;\n\t}\n\telse\n\t{\n\t\tc[2] = 1.0 / c[2];\n\t\tatan_c[2] += scale[2] * pow(c[2], float(1)) / float(1);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(3)) / float(3);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(5)) / float(5);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(7)) / float(7);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(9)) / float(9);\n\t\tscale[2] *= -1.0;\n\t\tatan_c[2] += scale[2] * pow(c[2], float(11)) / float(11);\n\t\tscale[2] *= -1.0;\n\t\tresult[2] = sign[2] * (M_PI / 2.0 - atan_c[2]) / M_PI + 0.5;\n\t}\n\tgl_FragColor = result;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: 'color' : undeclared identifier
ERROR: 0:4: '=' : dimension mismatch
ERROR: 0:4: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color = color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 c = ((4.0 * 2.0) * (color.rgb - 0.5));
  vec3 atan_c = vec3(0.0);
  vec3 scale = vec3(1.0);
  vec3 sign = vec3(1.0);
  vec4 result = vec4(0.0 , 0.0 , 0.0 , 1.0);
  if ((c[0] < 0.0))
  {
    sign[0] = -1.0;
    (c[0] *= -1.0);
  }
  if ((c[0] <= 1.0))
  {
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * atan_c[0]) / M_PI) + 0.5);
  }
  else
  {
    c[0] = (1.0 / c[0]);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(1))) / float(1)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(3))) / float(3)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(5))) / float(5)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(7))) / float(7)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(9))) / float(9)));
    (scale[0] *= -1.0);
    (atan_c[0] += ((scale[0] * pow(c[0] , float(11))) / float(11)));
    (scale[0] *= -1.0);
    result[0] = (((sign[0] * ((M_PI / 2.0) - atan_c[0])) / M_PI) + 0.5);
  }
  if ((c[1] < 0.0))
  {
    sign[1] = -1.0;
    (c[1] *= -1.0);
  }
  if ((c[1] <= 1.0))
  {
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * atan_c[1]) / M_PI) + 0.5);
  }
  else
  {
    c[1] = (1.0 / c[1]);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(1))) / float(1)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(3))) / float(3)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(5))) / float(5)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(7))) / float(7)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(9))) / float(9)));
    (scale[1] *= -1.0);
    (atan_c[1] += ((scale[1] * pow(c[1] , float(11))) / float(11)));
    (scale[1] *= -1.0);
    result[1] = (((sign[1] * ((M_PI / 2.0) - atan_c[1])) / M_PI) + 0.5);
  }
  if ((c[2] < 0.0))
  {
    sign[2] = -1.0;
    (c[2] *= -1.0);
  }
  if ((c[2] <= 1.0))
  {
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * atan_c[2]) / M_PI) + 0.5);
  }
  else
  {
    c[2] = (1.0 / c[2]);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(1))) / float(1)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(3))) / float(3)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(5))) / float(5)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(7))) / float(7)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(9))) / float(9)));
    (scale[2] *= -1.0);
    (atan_c[2] += ((scale[2] * pow(c[2] , float(11))) / float(11)));
    (scale[2] *= -1.0);
    result[2] = (((sign[2] * ((M_PI / 2.0) - atan_c[2])) / M_PI) + 0.5);
  }
  gl_FragColor = result;
}


==============================
60.932944606414
Processing this: /home/oof/webgl_cleaned/log2_vec3_frag_xvary01.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec3 c = (color.rgb + 0.01) / 1.01;
	gl_FragColor = vec4(log2(c) / -8.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = (color.rgb + 0.01) / 1.01;\n\tgl_FragColor = vec4(log2(c) / -8.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color[8] = vec4(2.0, 0.5, (((false || false) && true) ? -1.0 : +2.0), 1.0);

void main()
{
  vec3 c = ((color.rgb + 0.01) / 1.01);
  gl_FragColor = vec4((log2(c) / -8.0) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:4: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:4: '=' : array / non-array mismatch
ERROR: 0:4: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[8] of 4-component vector of float'
ERROR: 0:8: '.' : cannot apply dot operator to an array
ERROR: 0:8: '+' : array / non-array mismatch
ERROR: 0:8: '+' : wrong operand types - no operation '+' exists that takes a left-hand operand of type 'mediump array[8] of 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:8: '/' : array / non-array mismatch
ERROR: 0:8: '/' : wrong operand types - no operation '/' exists that takes a left-hand operand of type 'mediump array[8] of 4-component vector of float' and a right operand of type 'const float' (or there is no acceptable conversion)
ERROR: 0:8: '=' : array / non-array mismatch
ERROR: 0:8: '=' : cannot convert from 'mediump array[8] of 4-component vector of float' to 'mediump 3-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color[8] = vec4(2.0, 0.5, (((false || false) && true) ? -1.0 : +2.0), 1.0);

void main()
{
  vec3 c = ((color.rgb + 0.01) / 1.01);
  gl_FragColor = vec4((log2(c) / -8.0) , 1.0);
}


==============================
60.75581395348837
Processing this: /home/oof/webgl_cleaned/refract_vec3_vert_ivarynconst.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const float M_PI = 3.14159265358979323846;
	vec3 v1;
	vec3 v2 = normalize(vec3(1.0, 1.0, 1.0));
	float theta = gtf_Color.g * 2.0 * M_PI;
	float phi = gtf_Color.b * 2.0 * M_PI;
	v1.x = cos(theta) * sin(phi);
	v1.y = sin(theta) * sin(phi);
	v1.z = cos(phi);
	color = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst float M_PI = 3.14159265358979323846;\n\tvec3 v1;\n\tvec3 v2 = normalize(vec3(1.0, 1.0, 1.0));\n\tfloat theta = gtf_Color.g * 2.0 * M_PI;\n\tfloat phi = gtf_Color.b * 2.0 * M_PI;\n\tv1.x = cos(theta) * sin(phi);\n\tv1.y = sin(theta) * sin(phi);\n\tv1.z = cos(phi);\n\tcolor = vec4((refract(v1, v2, 0.5) + 1.0) / 2.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex = vec4((!true ? 0.5 : 0.0), -0.5, 0.5, 1.0);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  const float M_PI = 3.141592653589793;
  vec3 v1;
  vec3 v2 = normalize(vec3(1.0 , 1.0 , 1.0));
  float theta = ((gtf_Color.g * 2.0) * M_PI);
  float phi = ((gtf_Color.b * 2.0) * M_PI);
  v1.x = (cos(theta) * sin(phi));
  v1.y = (sin(theta) * sin(phi));
  v1.z = cos(phi);
  color = vec4(((refract(v1 , v2 , 0.5) + 1.0) / 2.0) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
SUCCESS!
60.86956521739131
Processing this: /home/oof/webgl_cleaned/smoothstep_vec3_vert_xvary_edgeconstquarter.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	const vec3 edge0 = vec3(0.25, 0.25, 0.25);
	const vec3 edge1 = vec3(0.75, 0.75, 0.75);
	color = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tconst vec3 edge0 = vec3(0.25, 0.25, 0.25);\n\tconst vec3 edge1 = vec3(0.75, 0.75, 0.75);\n\tcolor = vec4(smoothstep(edge0, edge1, gtf_Color.rgb), 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -1.0, (false ? 2.0 : -1.0), +2.0, (((false ? false : false) ? false : false) ? 0.5 : (true ? 0.0 : (0.0 * 1.0))), 2.0, 0.5, -1.0, (1.0 + -1.0), ((true && (false ? true : true)) ? (2.0 * (1.0 / -1.0)) : 0.0), ++0.5, (false ? (0.5 + -1.0) : 1.0), -1.0, 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: '++' : l-value required (can't modify a const)
ERROR: 0:8: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4(0.0, -1.0, (false ? 2.0 : -1.0), +2.0, (((false ? false : false) ? false : false) ? 0.5 : (true ? 0.0 : (0.0 * 1.0))), 2.0, 0.5, -1.0, (1.0 + -1.0), ((true && (false ? true : true)) ? (2.0 * (1.0 / -1.0)) : 0.0), ++0.5, (false ? (0.5 + -1.0) : 1.0), -1.0, 1.0, 0.5, 0.5);

vec4 color;

void main()
{
  const vec3 edge0 = vec3(0.25 , 0.25 , 0.25);
  const vec3 edge1 = vec3(0.75 , 0.75 , 0.75);
  color = vec4(smoothstep(edge0 , edge1 , gtf_Color.rgb) , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.69364161849711
Processing this: /home/oof/webgl_cleaned/structcopy_vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
struct sabcd
{
	vec4 a;
	vec4 b;
};
void main ()
{
	sabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );
	sabcd s2 = sabcd(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0 ) );
	s2 = s;
	gl_FragColor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.a[3] + s2.b[0] + s2.b[1] + s2.b[2] + s2.b[3]) / 250.0  ), 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nstruct sabcd\n{\n\tvec4 a;\n\tvec4 b;\n};\nvoid main ()\n{\n\tsabcd s = sabcd(vec4(12.0, 29.0, 32.0, 47.0), vec4(13.0, 26.0, 38.0, 53.0 ) );\n\tsabcd s2 = sabcd(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.0, 0.0, 0.0, 0.0 ) );\n\ts2 = s;\n\tgl_FragColor = vec4( vec3(  (s2.a[0] + s2.a[1] + s2.a[2] + s2.a[3] + s2.b[0] + s2.b[1] + s2.b[2] + s2.b[3]) / 250.0  ), 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  sabcd s2 = color(vec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  gl_FragColor = vec4(vec3(((((((((s2.a[0] + s2.a[1]) + s2.a[2]) + s2.a[3]) + s2.b[0]) + s2.b[1]) + s2.b[2]) + s2.b[3]) / 250.0)) , 1.0);
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: 'color' : function name expected
ERROR: 0:14: '=' : cannot convert from 'const mediump float' to 'structure 'sabcd' (symbol id 3002)'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

struct sabcd {
  vec4 a;
  vec4 b;
};

void main()
{
  sabcd s = sabcd(vec4(12.0 , 29.0 , 32.0 , 47.0) , vec4(13.0 , 26.0 , 38.0 , 53.0));
  sabcd s2 = color(vec4(0.0 , 0.0 , 0.0 , 0.0));
  s2 = s;
  gl_FragColor = vec4(vec3(((((((((s2.a[0] + s2.a[1]) + s2.a[2]) + s2.a[3]) + s2.b[0]) + s2.b[1]) + s2.b[2]) + s2.b[3]) / 250.0)) , 1.0);
}


==============================
60.51873198847262
Processing this: /home/oof/webgl_cleaned/ivec_tests.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
uniform int vuni1;
uniform ivec2 vuni2;
uniform ivec3 vuni3;
uniform ivec4 vuni4;
varying vec4 color;
void main ()
{
	color = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nuniform int vuni1;\nuniform ivec2 vuni2;\nuniform ivec3 vuni3;\nuniform ivec4 vuni4;\nvarying vec4 color;\nvoid main ()\n{\n\tcolor = vec4(float(vuni1), float(vuni2[0] + vuni2[1]), float(vuni3[0] + vuni3[1] + vuni3[2]), float(vuni4[0] + vuni4[1] + vuni4[2] + vuni4[3]) );\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform int vuni1;

uniform ivec2 vuni2 = ivec2(2, +vuni1);

uniform ivec3 vuni3;

uniform ivec4 vuni4;

vec4 color;

void main()
{
  color = vec4(float(vuni1) , float((vuni2[0] + vuni2[1])) , float(((vuni3[0] + vuni3[1]) + vuni3[2])) , float((((vuni4[0] + vuni4[1]) + vuni4[2]) + vuni4[3])));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:10: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Vertex;

uniform mat4 gtf_ModelViewProjectionMatrix;

uniform int vuni1;

uniform ivec2 vuni2 = ivec2(2, +vuni1);

uniform ivec3 vuni3;

uniform ivec4 vuni4;

vec4 color;

void main()
{
  color = vec4(float(vuni1) , float((vuni2[0] + vuni2[1])) , float(((vuni3[0] + vuni3[1]) + vuni3[2])) , float((((vuni4[0] + vuni4[1]) + vuni4[2]) + vuni4[3])));
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.3448275862069
Processing this: /home/oof/webgl_cleaned/gl_FragCoord_xy_frag_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main()
{
	gl_FragColor = vec4((434.0 / 500.0) * (color.gb - 0.5) + 0.5, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main()\n{\n\tgl_FragColor = vec4((434.0 / 500.0) * (color.gb - 0.5) + 0.5, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4((((434.0 / 500.0) * (color.gb - 0.5)) + 0.5) , 0.0);
  vec4(0.0, ((true && (true || false)) ? -1.0 : 0.0), 0.0, (false ? (false ? 0.5 : (true ? 0.0 : 0.5)) : ((2.0 / 1.0) / (2.0 - 2.0))));
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'constructor' : not enough data provided for construction
WARNING: 0:9: '/' : Divide by zero during constant folding

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  gl_FragColor = vec4((((434.0 / 500.0) * (color.gb - 0.5)) + 0.5) , 0.0);
  vec4(0.0, ((true && (true || false)) ? -1.0 : 0.0), 0.0, (false ? (false ? 0.5 : (true ? 0.0 : 0.5)) : ((2.0 / 1.0) / (2.0 - 2.0))));
}


==============================
60.17191977077364
Mutations attempted: 349
Valid mutations:     210
Success rate:        60.17%
Processing this: /home/oof/webgl_cleaned/fboShader0.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
attribute vec4 gtf_MultiTexCoord0;
varying vec4 texCoord[1];
varying vec4 color;
uniform mat4 gtf_ModelViewProjectionMatrix;
void main ()
{
    color = gtf_Color;
    texCoord[0] = gtf_MultiTexCoord0;
    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nattribute vec4 gtf_MultiTexCoord0;\nvarying vec4 texCoord[1];\nvarying vec4 color;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvoid main ()\n{\n    color = gtf_Color;\n    texCoord[0] = gtf_MultiTexCoord0;\n    gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 + (true ? 0.0 : (true ? 0.5 : -1.0))), -((false ? 1.0 : 0.5) * +-1.0), 0.0, --1.0, +1.0, 2.0, (+0.0 + 0.0), 0.0, (((0.0 / 0.0) / 2.0) - -1.0), 2.0, (false ? +(0.5 - 0.0) : 2.0), ((1.0 - -0.5) - 0.0), -1.0, -1.0, (true ? -1.0 : (0.5 / 1.0)), ((1.0 / -1.0) / (0.0 / (false ? 2.0 : 0.0))));

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:14: '--' : l-value required (can't modify a const)
WARNING: 0:14: '/' : Zero divided by zero during constant folding generated NaN
WARNING: 0:14: '/' : Zero divided by zero during constant folding generated NaN
ERROR: 0:14: '=' : global variable initializers must be constant expressions

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex;

vec4 gtf_MultiTexCoord0;

vec4 texCoord[1];

vec4 color;

uniform mat4 gtf_ModelViewProjectionMatrix = mat4((1.0 + (true ? 0.0 : (true ? 0.5 : -1.0))), -((false ? 1.0 : 0.5) * +-1.0), 0.0, --1.0, +1.0, 2.0, (+0.0 + 0.0), 0.0, (((0.0 / 0.0) / 2.0) - -1.0), 2.0, (false ? +(0.5 - 0.0) : 2.0), ((1.0 - -0.5) - 0.0), -1.0, -1.0, (true ? -1.0 : (0.5 / 1.0)), ((1.0 / -1.0) / (0.0 / (false ? 2.0 : 0.0))));

void main()
{
  color = gtf_Color;
  texCoord[0] = gtf_MultiTexCoord0;
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
60.0
Processing this: /home/oof/webgl_cleaned/exp2_float_frag_xvaryneg_ref.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	float c = color.r;
	gl_FragColor = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tfloat c = color.r;\n\tgl_FragColor = vec4(1.0 / pow(2.0, 5.0 * c), 0.0, 0.0, 1.0);\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  float c = color.r;
  gl_FragColor = vec4((1.0 / pow(2.0 , (5.0 * c))) , 0.0 , 0.0 , 1.0);
}


As vertex? : False
SUCCESS!
60.11396011396012
Processing this: /home/oof/webgl_cleaned/greaterThan_ivec3_vert.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec3 c = floor(10.0 * gtf_Color.rgb - 4.5);
	vec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));
	color = vec4(result, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec3 c = floor(10.0 * gtf_Color.rgb - 4.5);\n\tvec3 result = vec3(greaterThan(ivec3(c), ivec3(0)));\n\tcolor = vec4(result, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.0, 0.0, 2.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


As vertex? : True
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:6: '[]' : first-class arrays (array initializer) supported in GLSL ES 3.00 and above only
ERROR: 0:6: '=' : array / non-array mismatch
ERROR: 0:6: '=' : cannot convert from 'const 4-component vector of float' to 'mediump array[2] of 4-component vector of float'
ERROR: 0:17: '*' : array / non-array mismatch
ERROR: 0:17: '*' : wrong operand types - no operation '*' exists that takes a left-hand operand of type 'uniform mediump 4X4 matrix of float' and a right operand of type 'mediump array[2] of 4-component vector of float' (or there is no acceptable conversion)
ERROR: 0:17: '=' : dimension mismatch
ERROR: 0:17: 'assign' : cannot convert from 'uniform mediump 4X4 matrix of float' to 'Position highp 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 gtf_Color;

vec4 gtf_Vertex[2] = vec4(0.0, 0.0, 2.0, 0.5);

uniform mat4 gtf_ModelViewProjectionMatrix;

vec4 color;

void main()
{
  vec3 c = floor(((10.0 * gtf_Color.rgb) - 4.5));
  vec3 result = vec3(greaterThan(ivec3(c) , ivec3(0)));
  color = vec4(result , 1.0);
  gl_Position = (gtf_ModelViewProjectionMatrix * gtf_Vertex);
}


==============================
59.94318181818182
Processing this: /home/oof/webgl_cleaned/vec4_rgba_1vec4_frag.frag
Original source code: 
precision mediump float;
precision mediump int;

precision mediump float;
varying vec4 color;
void main ()
{
	vec4 al = color;
	vec4 m = al.rgba;
	gl_FragColor = m;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nprecision mediump float;\nvarying vec4 color;\nvoid main ()\n{\n\tvec4 al = color;\n\tvec4 m = al.rgba;\n\tgl_FragColor = m;\n}\n\x00')
Mutated source code: 
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 m = al.rgba;
  gl_FragColor = m;
  vec4 al = color;
}


As vertex? : False
Errored with this here: #### BEGIN COMPILER 0 INFO LOG ####
ERROR: 0:8: 'al' : undeclared identifier
ERROR: 0:8: 'rgba' :  field selection requires structure or vector on left hand side
ERROR: 0:8: '=' : dimension mismatch
ERROR: 0:8: '=' : cannot convert from 'const highp float' to 'mediump 4-component vector of float'

#### END COMPILER 0 INFO LOG ####



==============================
precision mediump float;
precision mediump int;

vec4 color;

void main()
{
  vec4 m = al.rgba;
  gl_FragColor = m;
  vec4 al = color;
}


==============================
59.773371104815865
Processing this: /home/oof/webgl_cleaned/point_sprites.frag
Original source code: 
precision mediump float;
precision mediump int;

uniform sampler2D gtf_Texture0;
void main ()
{
	gl_FragColor = texture2D(gtf_Texture0, gl_PointCoord.st);
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nuniform sampler2D gtf_Texture0;\nvoid main ()\n{\n\tgl_FragColor = texture2D(gtf_Texture0, gl_PointCoord.st);\n}\n\x00')
59.773371104815865
Processing this: /home/oof/webgl_cleaned/sign_vec2_vert_xvary.vert
Original source code: 
precision mediump float;
precision mediump int;

attribute vec4 gtf_Color;
attribute vec4 gtf_Vertex;
uniform mat4 gtf_ModelViewProjectionMatrix;
varying vec4 color;
void main ()
{
	vec2 c = 2.0 * (gtf_Color.rg - 0.5);
	color = vec4(c * sign(c), 0.0, 1.0);
	gl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;
}

Passing this here: bytearray(b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00precision mediump float;\nprecision mediump int;\n\nattribute vec4 gtf_Color;\nattribute vec4 gtf_Vertex;\nuniform mat4 gtf_ModelViewProjectionMatrix;\nvarying vec4 color;\nvoid main ()\n{\n\tvec2 c = 2.0 * (gtf_Color.rg - 0.5);\n\tcolor = vec4(c * sign(c), 0.0, 1.0);\n\tgl_Position = gtf_ModelViewProjectionMatrix * gtf_Vertex;\n}\n\x00')
